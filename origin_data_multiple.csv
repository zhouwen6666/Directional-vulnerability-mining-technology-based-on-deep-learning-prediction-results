functionSource,count,typecwe
"""vfp_vep_callback(const struct sess *sp, ssize_t l, enum vgz_flag flg){tstruct vef_priv *vef;tsize_t dl, px;tconst void *dp;tint i;tCHECK_OBJ_NOTNULL(sp, SESS_MAGIC);tvef = sp->wrk->vef_priv;tCHECK_OBJ_NOTNULL(vef, VEF_MAGIC);tassert(l >= 0);tif (vef->error) {ttvef->tot += l;ttreturn (vef->tot);t}t/*t * l == 0 is valid when 'flg' calls for action, but in thet * normal case we can just ignore a l==0 request.t * (It would cause Z_BUF_ERROR anyway)t */tif (l == 0 && flg == VGZ_NORMAL)ttreturn (vef->tot);tdo {ttpx = vef->npend;ttif (l < px)tttpx = l;ttif (px != 0) {tttVGZ_Ibuf(vef->vgz, vef->pending, px);tttl -= px;tt} else {tttVGZ_Ibuf(vef->vgz, vef->bufp, l);tttvef->bufp += l;tttl = 0;tt}ttdo {tttif (VGZ_ObufStorage(sp, vef->vgz)) {ttttvef->error = errno;ttttvef->tot += l;ttttreturn (vef->tot);ttt}ttti = VGZ_Gzip(vef->vgz, &dp, &dl, flg);tttvef->tot += dl;tttsp->obj->len += dl;tt} while (!VGZ_IbufEmpty(vef->vgz) ||tt    (flg != VGZ_NORMAL && VGZ_ObufFull(vef->vgz)));ttif (px != 0) {tttmemmove(vef->pending, vef->pending + px,ttt    vef->npend - px);tttvef->npend -= px;tt}t} while (l > 0);tif (flg == VGZ_FINISH)ttassert(i == 1);ttt/* XXX */telsettassert(i == 0);ttt/* XXX */treturn (vef->tot);}""",2,"cwe119,cwe120"
"get_nth_ancestor(const char *name, int len,ttt    unsigned char *result, int generation){tunsigned char sha1[20];tint ret = get_sha1_1(name, len, sha1);tif (ret)ttreturn ret;twhile (generation--) {ttstruct commit *commit = lookup_commit_reference(sha1);ttif (!commit || parse_commit(commit) || !commit->parents)tttreturn -1;tthashcpy(sha1, commit->parents->item->object.sha1);t}thashcpy(result, sha1);treturn 0;}",2,"cwe119,cwe120"
"static_start_scope (gamgi_window *window){GtkWidget *dialog = window->dialog0;GtkWidget *combo;GtkWidget *entry;GtkWidget *button_cell;GtkWidget *button_range;GtkWidget *button_node;char token[GAMGI_ENGINE_TOKEN];gamgi_bool active; combo = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""combo_structure"");gtk_combo_box_set_active (GTK_COMBO_BOX (combo), GAMGI_CHEM_STRUCTURE - 1);combo = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""combo_filter"");gtk_combo_box_set_active (GTK_COMBO_BOX (combo), GAMGI_CHEM_FILTER - 1);entry = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""entry_thickness"");sprintf (token, ""%.*f"", gamgi->gamgi->length, GAMGI_CHEM_DIRECTION_THICKNESS);gtk_entry_set_text (GTK_ENTRY (entry), token); button_cell = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""button_cell"");button_range = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""button_range"");button_node = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""button_node"");if (gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (button_node)) == FALSE)  gtk_button_clicked (GTK_BUTTON (button_node));active = gtk_toggle_button_get_active (GTK_TOGGLE_BUTTON (button_cell));if (active == TRUE)  {  gtk_widget_set_sensitive (button_range, TRUE);  gtk_widget_set_sensitive (button_node, TRUE);  }else  {  gtk_widget_set_sensitive (button_range, FALSE);  gtk_widget_set_sensitive (button_node, FALSE);  }gamgi_gtk_direction_create_node (active, window); static_instance (NULL, window);}",2,"cwe119,cwe120"
"eb_jabber_read_prefs_config(LList *values){tchar *c;tc = value_pair_get_value(values, ""server"");tif (c) {ttstrcpy(jabber_server, c);ttfree(c);t}tc = value_pair_get_value(values, ""do_jabber_debug"");tif (c) {ttdo_jabber_debug = atoi(c);ttfree(c);t}}",3,"cwe119,cwe120,cweother"
"connect_cb(GIOChannel *io, GError *err, gpointer user_data){tstruct io_data *data = user_data;tGIOCondition cond;tchar addr[18];tuint16_t handle;tuint8_t cls[3];tif (err) {ttprintf(""Connecting failed: %s"", err->message);ttreturn;t}tif (!bt_io_get(io, data->type, &err,tttBT_IO_OPT_DEST, addr,tttBT_IO_OPT_HANDLE, &handle,tttBT_IO_OPT_CLASS, cls,tttBT_IO_OPT_INVALID)) {ttprintf(""Unable to get destination address: %s"",tttttttterr->message);ttg_clear_error(&err);ttstrcpy(addr, ""(unknown)"");t}tprintf(""Successfully connected to %s. handle=%u, class=%02x%02x%02x"",tttaddr, handle, cls[0], cls[1], cls[2]);tif (data->type == BT_IO_L2CAP || data->type == BT_IO_SCO) {ttuint16_t omtu, imtu;ttif (!bt_io_get(io, data->type, &err,tttttBT_IO_OPT_OMTU, &omtu,tttttBT_IO_OPT_IMTU, &imtu,tttttBT_IO_OPT_INVALID)) {tttprintf(""Unable to get L2CAP MTU sizes: %s"",tttttttterr->message);tttg_clear_error(&err);tt} elsetttprintf(""imtu=%u, omtu=%u"", imtu, omtu);t}tif (data->type == BT_IO_L2CAP) {ttuint8_t key_size;ttif (!bt_io_get(io, data->type, &err,tttttBT_IO_OPT_KEY_SIZE, &key_size,tttttBT_IO_OPT_INVALID)) {tttprintf(""Unable to get L2CAP Key size: %s"",tttttttterr->message);tttg_clear_error(&err);tt} elsetttprintf(""key_size=%u"", key_size);t}tif (data->disconn == 0) {ttg_io_channel_shutdown(io, TRUE, NULL);ttprintf(""Disconnected"");ttreturn;t}tif (data->io == NULL)ttdata->io = g_io_channel_ref(io);tif (data->disconn > 0) {ttio_data_ref(data);ttg_timeout_add_seconds_full(G_PRIORITY_DEFAULT, data->disconn,tttttdisconn_timeout, data,ttttt(GDestroyNotify) io_data_unref);t}tio_data_ref(data);tif (opt_update_sec > 0)ttupdate_sec_level(data);tcond = G_IO_NVAL | G_IO_HUP | G_IO_ERR;tg_io_add_watch_full(io, G_PRIORITY_DEFAULT, cond, io_watch, data,ttttt(GDestroyNotify) io_data_unref);}",2,"cwe119,cwe120"
"readinterfaces(int fd, section* CSec, section *PSec){tchar name[10];tFILE *iflst;tchar s[BUFSIZ];tchar *p;tif ((iflst = fopen(FILE_PROC, ""r"")) == NULL)t{ttperror(FILE_PROC);ttreturn -1;t}twhile (!feof(iflst))t{ttfgets(s, sizeof(s), iflst);ttif ((p = strchr(s, ':')))tt{ttt*p = 0;tttsscanf(s, ""%s"", name);tttp = readoptions(fd, name, 1, CSec, PSec);tttwhile (p != NULL && *p != '0')ttt{ttttstrcpy(name, p);ttttp = readoptions(fd, name, 0, CSec, PSec);ttt}tt}t}tfclose(iflst);treturn 0;}",4,"cwe119,cwe120,cwe476,cweother"
"pop_get_command(POP *p, char *mp){    state_table     *   s;    char                buf[MAXMSGLINELEN];     #ifdef DEBUG    if(p->debug) strlcpy (buf, mp, sizeof(buf));#endif           if ((p->parm_count = pop_parse(p,mp)) < 0) return(NULL);     #ifdef DEBUG    if(p->debug){        if(strcmp(p->pop_command,""pass"") == 0)            pop_log(p,POP_DEBUG,""Received: ""%s xxxxxxxxx"""",p->pop_command);        else {                         buf[strlen(buf)-2] = '0';            pop_log(p,POP_DEBUG,""Received: ""%s"""",buf);        }    }#endif           for (s = states; s->command; s++) {                 if (strcmp(s->command,p->pop_command) == 0             && s->ValidCurrentState == p->CurrentState) {                         if (p->parm_count < s->min_parms) {                pop_msg(p,POP_FAILURE,ttt""Too few arguments for the %s command."",tttp->pop_command);ttreturn NULL;t    }                         if (p->parm_count > s->max_parms) {                pop_msg(p,POP_FAILURE,ttt""Too many arguments for the %s command."",tttp->pop_command);ttreturn NULL;t   }                         return (s);        }    }         pop_msg(p,POP_FAILURE,t    ""Unknown command: ""%s""."",p->pop_command);    return NULL;}",2,"cwe469,cweother"
"sigar_boot_time_get(sigar_t *sigar){    FILE *fp;    char buffer[BUFSIZ], *ptr;    int found = 0;    if (!(fp = fopen(PROC_STAT, ""r""))) {        return errno;    }    while ((ptr = fgets(buffer, sizeof(buffer), fp))) {        if (strnEQ(ptr, ""btime"", 5)) {            if ((ptr = sigar_skip_token(ptr))) {                sigar->boot_time = sigar_strtoul(ptr);                found = 1;            }            break;        }    }    fclose(fp);    if (!found) {                 sigar->boot_time = time(NULL);    }    return SIGAR_OK;}",3,"cwe119,cwe120,cweother"
"LoadPersistentContext(){ CF_DB *dbp;  CF_DBC *dbcp;  int ksize,vsize;  char *key;  void *value;  time_t now = time(NULL);  struct CfState q;  char filename[CF_BUFSIZE];if (LOOKUP)  {  return;  }Banner(""Loading persistent classes"");  snprintf(filename,CF_BUFSIZE,""%s/state/%s"",CFWORKDIR,CF_STATEDB_FILE);MapName(filename);if (!OpenDB(filename,&dbp))   {   return;   } if (!NewDBCursor(dbp,&dbcp))   {   CfOut(cf_inform,"""","" !! Unable to scan persistence cache"");   return;   }while(NextDB(dbp,dbcp,&key,&ksize,&value,&vsize))   {   memcpy((void *)&q,value,sizeof(struct CfState));   Debug("" - Found key %s..."",key);   if (now > q.expires)      {      CfOut(cf_verbose,"""","" Persistent class %s expired"",key);      DeleteDB(dbp,key);      }   else      {      CfOut(cf_verbose,"""","" Persistent class %s for %d more minutes"",key,(q.expires-now)/60);      CfOut(cf_verbose,"""","" Adding persistent class %s to heap"",key);      NewClass(key);      }   }DeleteDBCursor(dbp,dbcp);CloseDB(dbp);Banner(""Loaded persistent memory"");}",2,"cwe119,cwe120"
"smk_bu_current(char *note, struct smack_known *oskp,ttt  int mode, int rc){tstruct task_smack *tsp = current_security();tchar acc[SMK_NUM_ACCESS_TYPE + 1];tif (rc <= 0)ttreturn rc;tif (rc > SMACK_UNCONFINED_OBJECT)ttrc = 0;tsmk_bu_mode(mode, acc);tpr_info(""Smack %s: (%s %s %s) %s %s"", smk_bu_mess[rc],tttsp->smk_task->smk_known, oskp->smk_known,ttacc, current->comm, note);treturn 0;}",2,"cwe119,cwe120"
"main(void){    gint count = 0;    register FSM *f = FSM_create(""abcdefghijklmnopqrstuvwxyz"",                      test_merge_Func, test_merge_Func, NULL);#define TESTSETSIZE 32    char *testset[TESTSETSIZE] = {          ""auto"",     ""break"",    ""case"",     ""char"",        ""const"",    ""continue"", ""default"",  ""do"",        ""double"",   ""else"",     ""enum"",     ""extern"",        ""float"",    ""for"",      ""goto"",     ""if"",        ""int"",      ""long"",     ""register"", ""return"",        ""short"",    ""signed"",   ""sizeof"",   ""static"",        ""struct"",   ""switch"",   ""typedef"",  ""union"",        ""unsigned"", ""void"",     ""volatile"", ""while""  };    char *testsen = ""-unSIGNed--switCHAR---DOUBLElse--sizeoFOR"";     register gint i;    register guchar *tolower_filter = (guchar*)    ""----------------------------------------------------------------""    ""-abcdefghijklmnopqrstuvwxyz------abcdefghijklmnopqrstuvwxyz-----""    ""----------------------------------------------------------------""    ""----------------------------------------------------------------"";    for(i = 0; i < TESTSETSIZE; i++)        FSM_add(f, testset[i], strlen(testset[i]), GINT_TO_POINTER(1));    FSM_compile(f);    FSM_add_traversal_filter(f, tolower_filter);    FSM_traverse(f, testsen, test_traverse_Func, &count);    g_print(""FSM count is [%d]"", count);    g_assert(count == 9);    FSM_destroy(f);    return 0;    }",2,"cwe119,cwe120"
"quetzal_stack_restore(strid_t stream, glui32 qsize){  glui32 i = 0;  int num_frames = 0;  kill_stack();  init_stack(1024, 128);    while(i < qsize) {    unsigned n;    unsigned num_locals;    zword locals[16];    int num_args;    int var;    glui32 qframe[5];    i += fillstruct(stream, qstackframe, qframe, NULL);    if(qframe[qreturnPC] > total_size) {      n_show_error(E_SAVE, ""function return PC past end of memory"",tt qframe[qreturnPC]);      return FALSE;    }    if((qframe[qflags] & b11100000) != 0) {      n_show_error(E_SAVE, ""expected top bits of flag to be zero"", qframe[qflags]);      return FALSE;    }        var = qframe[qvar];    if(qframe[qflags] & b00010000)         var = -1;        num_locals = qframe[qflags] & b00001111;    if(num_locals > 15) {      n_show_error(E_SAVE, ""too many locals"", num_locals);      return FALSE;    }        num_args = 0;    switch(qframe[qargs]) {    default:      n_show_error(E_SAVE, ""invalid argument count"", qframe[qargs]);      return FALSE;    case b01111111: num_args++;    case b00111111: num_args++;    case b00011111: num_args++;    case b00001111: num_args++;    case b00000111: num_args++;    case b00000011: num_args++;    case b00000001: num_args++;    case b00000000: ;    }        for(n = 0; n < num_locals; n++) {      unsigned char v[ZWORD_SIZE];      glk_get_buffer_stream(stream, (char *) v, ZWORD_SIZE);      locals[n] = MSBdecodeZ(v);      i+=ZWORD_SIZE;    }        if(zversion != 6 && num_frames == 0)      ;                    else      add_stack_frame(qframe[qreturnPC],tt      num_locals, locals,tt      num_args, var);        for(n = 0; n < qframe[qeval]; n++) {      unsigned char v[ZWORD_SIZE];      glk_get_buffer_stream(stream, (char *) v, ZWORD_SIZE);      stack_push(MSBdecodeZ(v));      i += ZWORD_SIZE;    }        num_frames++;  }  if(!verify_stack()) {    n_show_error(E_SAVE, ""restored stack fails verification"", 0);    return FALSE;  }  return TRUE;}",2,"cwe119,cwe120"
"fl_exe_command( const char * cmd,                int          block ){    pid_t pid;    static int p_err[ 2 ] = { -1, -1 },               p_inout[ 2 ];    char buf[ 256 ];    create_logger( );    if ( pipe( p_err ) < 0 || pipe( p_inout ) < 0 )    {        fl_snprintf( buf, sizeof buf,                     ""Can't create pipe - %s"", fli_get_syserror_msg( ) );        fprintf(stderr, ""%s"", buf);        fl_addto_browser( logger->browser, buf );        if ( p_err[ 0 ] > 0 )        {            close( p_err[ 0 ] );            close( p_err[ 1 ] );        }        return -1;    }    if ( ( pid = fork( ) ) < 0 )    {        fl_snprintf( buf, sizeof buf, ""fork failed: %s"",                     fli_get_syserror_msg( ) );        fl_addto_browser( logger->browser, buf );        perror( ""fork"" );        close( p_inout[ 0 ] );        close( p_inout[ 1 ] );        close( p_err[ 0 ] );        close( p_err[ 1 ] );        return -1;    }    if ( pid == 0 )    {        dup2( p_inout[ 1 ], fileno( stdout ) );        close( p_inout[ 1 ] );        close( p_inout[ 0 ] );        dup2( p_err[ 1 ], fileno( stderr ) );        close( p_err[ 1 ] );        close( p_err[ 0 ] );        fl_execl( ""/bin/sh"", ""sh"", ""-c"", cmd, ( char * ) 0 );        perror( ""execle"" );        _exit( 127 );    }    else    {        PIDList *cur = fl_malloc( sizeof *cur );        cur->next    = pidlist;        cur->pid     = pid;        cur->fd_user = -1;        pidlist = cur;                 close( p_inout[ 1 ] );        close( p_err[ 1 ] );        cur->fd_out = p_inout[ 0 ];        cur->fd_err = p_err[ 0 ];                 fl_add_io_callback( cur->fd_err,                            FL_READ,                            io_cb,                            ( void * ) ( long ) cur->pid );        fl_add_io_callback( cur->fd_out,                            FL_READ,                            io_cb,                            ( void * ) ( long ) cur->pid );    }    return block ? ( FL_PID_T ) fl_end_command( pid ) : pid;}",3,"cwe119,cwe120,cweother"
"clear_help_hash(void){trb_dlink_node *ptr;trb_dlink_node *next_ptr;tint i;tHASH_WALK_SAFE(i, HELP_MAX, ptr, next_ptr, helpTable)t{ttfree_cachefile(ptr->data);ttrb_dlinkDestroy(ptr, &helpTable[i]);t}HASH_WALK_END}",2,"cwe119,cwe120"
"chirp_audit_recursive(const char *path, struct hash_table *table){tstruct chirp_dir *dir;tstruct chirp_dirent *d;tchar subpath[CHIRP_PATH_MAX];tchar owner[CHIRP_PATH_MAX];tstruct chirp_audit *entry;tint result;tresult = get_directory_owner(path, owner);tif(result < 0)ttstrcpy(owner, ""unknown"");tentry = hash_table_lookup(table, owner);tif(!entry) {ttentry = malloc(sizeof(*entry));ttmemset(entry, 0, sizeof(*entry));ttstrcpy(entry->name, owner);tthash_table_insert(table, owner, entry);t}tentry->ndirs++;tdir = cfs->opendir(path);tif(!dir) {ttdebug(D_LOCAL, ""audit: couldn't enter %s: %s"", path, strerror(errno));ttreturn -1;t}twhile((d = cfs->readdir(dir))) {ttif(!strcmp(d->name, "".""))tttcontinue;ttif(!strcmp(d->name, ""..""))tttcontinue;ttif(!strncmp(d->name, "".__"", 3))tttcontinue;ttif(!strncmp(d->name, "".__"", 3))tttcontinue;ttaudit_count++;ttif((audit_count % 10000) == 0)tttdebug(D_LOCAL, ""audit: %d items"", audit_count);ttsprintf(subpath, ""%s/%s"", path, d->name);ttif(S_ISDIR(d->info.cst_mode)) {tttchirp_audit_recursive(subpath, table);tt} else {tttentry->nfiles++;tttentry->nbytes += d->info.cst_size;tt}t}tcfs->closedir(dir);treturn 0;}",3,"cwe119,cwe120,cwe469"
"lips4v_output_page(gx_device * dev, int num_copies, int flush){    gx_device_vector *const vdev = (gx_device_vector *) dev;    gx_device_lips4v *const pdev = (gx_device_lips4v *) dev;    stream *s = gdev_vector_stream(vdev);    char str[6];    if (pdev->TextMode) {        sputc(s, LIPS_CSI);        lputs(s, ""&}"");        pdev->TextMode = FALSE;    }    lputs(s, ""%"");    sputc(s, LIPS_IS2);    lputs(s, ""}p"");    sputc(s, LIPS_IS2);    if (num_copies > 255)        num_copies = 255;    if (pdev->prev_num_copies != num_copies) {        gs_sprintf(str, ""%c%dv"", LIPS_CSI, num_copies);        lputs(s, str);        pdev->prev_num_copies = num_copies;    }    sputc(s, LIPS_FF);    sflush(s);    vdev->in_page = false;    pdev->first_page = false;    gdev_vector_reset(vdev);    return 0;}",2,"cwe119,cwe120"
"main(int argc,char **argv){    int opt;    int i;    int fflag = 0;    int r, code = 0;    char *alt_config = NULL, *domain = NULL;    if ((geteuid()) == 0 && (become_cyrus() != 0)) {tfatal(""must run as the Cyrus user"", EC_USAGE);    }    while ((opt = getopt(argc, argv, ""C:d:f"")) != EOF) {tswitch (opt) {tcase 'C':  t    alt_config = optarg;t    break;tcase 'd':t    domain = optarg;t    break;tcase 'f':t    fflag = 1;t    break;tdefault:t    usage();t}    }    cyrus_init(alt_config, ""quota"", 0);         if ((r = mboxname_init_namespace(&quota_namespace, 1)) != 0) {tsyslog(LOG_ERR, ""%s"", error_message(r));tfatal(error_message(r), EC_CONFIG);    }    if (config_getswitch(IMAPOPT_IMPROVED_MBOXLIST_SORT))tcompar = bsearch_compare;    elsetcompar = strcmp;         mboxlist_init(0);    mboxlist_open(NULL);    quotadb_init(0);    quotadb_open(NULL);    r = buildquotalist(domain, argv+optind, argc-optind);    if (!r && fflag)tr = fixquotas(domain, argv+optind, argc-optind);    quotadb_close();    quotadb_done();    mboxlist_close();    mboxlist_done();    if (r) code = convert_code(r);    else reportquota();         for (i = 0; i < quota_num; i++)tfree(quota[i].allocname);    free(quota);    cyrus_done();    return code;}",2,"cwe120,cweother"
"main(int argc, char *argv[]){tchar dummy[256];tchar *device = ""/dev/video0"";tint tab = 1;tint fd;tif (argc > 1)ttdevice = argv[1];tfd = open(device,O_RDONLY);tif (-1 == fd) {ttfprintf(stderr,""open %s: %s"",device,strerror(errno));ttexit(1);t};tif (-1 != ioctl(fd,VIDIOC_QUERYCAP,dummy)) {ttprintf(""### v4l2 device info [%s] ###"",device);ttdump_v4l2(fd,tab);t} else {ttfprintf(stderr,""%s: not an video4linux device"",device);ttexit(1);t}treturn 0;}",3,"cwe119,cwe120,cweother"
"spif_linked_list_to_array(spif_linked_list_t self){    spif_obj_t *tmp;    spif_linked_list_item_t current;    spif_listidx_t i;    ASSERT_RVAL(!SPIF_LIST_ISNULL(self), SPIF_NULL_TYPE_PTR(obj));    tmp = SPIF_CAST_C(spif_obj_t *) MALLOC(SPIF_SIZEOF_TYPE(obj) * self->len);    for (i = 0, current = self->head; i < self->len; current = current->next, i++) {        tmp[i] = SPIF_CAST(obj) SPIF_OBJ(spif_linked_list_item_get_data(current));    }    return tmp;}",2,"cwe120,cweother"
"""icalrecur_add_byrules(struct icalrecur_parser *parser, short *array,ttt   int size, char* vals){    char *t, *n;    int i=0;    int sign = 1;    short v;    n = vals;    while(n != 0){tif(i == size){t    return;t}ttt = n;tn = strchr(t,',');tif(n != 0){t    *n = 0;t    n++;t}tt/* Get optional sign. HACK. sign is not allowed for all BYxxx           rule parts */tif( *t == '-'){t    sign = -1;t    t++;t} else if (*t == '+'){t    sign = 1;t    t++;t}tv = atoi(t) * sign ;tarray[i++] = v;tarray[i] =  ICAL_RECURRENCE_ARRAY_MAX;    }}""",2,"cwe469,cweother"
"getConstraints(TableInfo tblinfo[], int numTables){tintttti,ttttj;tConstraintInfo *constrinfo;tPQExpBuffer query;tPGresult   *res;tintttti_condef,tttti_contableoid,tttti_conoid,tttti_conname;tinttttntups;t tif (g_fout->remoteVersion < 70300)ttreturn;tquery = createPQExpBuffer();tfor (i = 0; i < numTables; i++)t{ttTableInfo  *tbinfo = &tblinfo[i];ttif (tbinfo->ntrig == 0 || !tbinfo->dobj.dump)tttcontinue;ttif (g_verbose)tttwrite_msg(NULL, ""reading foreign key constraints for table ""%s"""",ttttt  tbinfo->dobj.name);tt ttselectSourceSchema(tbinfo->dobj.namespace->dobj.name);ttresetPQExpBuffer(query);ttappendPQExpBuffer(query,tttttt  ""SELECT tableoid, oid, conname, ""tttttt  ""pg_catalog.pg_get_constraintdef(oid) as condef ""tttttt  ""FROM pg_catalog.pg_constraint ""tttttt  ""WHERE conrelid = '%u'::pg_catalog.oid ""tttttt  ""AND contype = 'f'"",tttttt  tbinfo->dobj.catId.oid);ttres = PQexec(g_conn, query->data);ttcheck_sql_result(res, g_conn, query->data, PGRES_TUPLES_OK);ttntups = PQntuples(res);tti_contableoid = PQfnumber(res, ""tableoid"");tti_conoid = PQfnumber(res, ""oid"");tti_conname = PQfnumber(res, ""conname"");tti_condef = PQfnumber(res, ""condef"");ttconstrinfo = (ConstraintInfo *) malloc(ntups * sizeof(ConstraintInfo));ttfor (j = 0; j < ntups; j++)tt{tttconstrinfo[j].dobj.objType = DO_FK_CONSTRAINT;tttconstrinfo[j].dobj.catId.tableoid = atooid(PQgetvalue(res, j, i_contableoid));tttconstrinfo[j].dobj.catId.oid = atooid(PQgetvalue(res, j, i_conoid));tttAssignDumpId(&constrinfo[j].dobj);tttconstrinfo[j].dobj.name = strdup(PQgetvalue(res, j, i_conname));tttconstrinfo[j].dobj.namespace = tbinfo->dobj.namespace;tttconstrinfo[j].contable = tbinfo;tttconstrinfo[j].condomain = NULL;tttconstrinfo[j].contype = 'f';tttconstrinfo[j].condef = strdup(PQgetvalue(res, j, i_condef));tttconstrinfo[j].conindex = 0;tttconstrinfo[j].coninherited = false;tttconstrinfo[j].separate = true;tt}ttPQclear(res);t}tdestroyPQExpBuffer(query);}",2,"cwe120,cweother"
"string_heap_insert (MonoDynamicStream *sh, const char *str){tguint32 idx;tguint32 len;tgpointer oldkey, oldval;tif (g_hash_table_lookup_extended (sh->hash, str, &oldkey, &oldval))ttreturn GPOINTER_TO_UINT (oldval);tlen = strlen (str) + 1;tidx = sh->index;ttmake_room_in_stream (sh, idx + len);t tg_hash_table_insert (sh->hash, g_strdup (str), GUINT_TO_POINTER (idx));tmemcpy (sh->data + idx, str, len);tsh->index += len;treturn idx;}",2,"cwe120,cwe469"
"prc_parse_file (const char *pathname, const flag securecheck) {    prc_errflag = 0;    querylist = hosttail = (struct query *)NULL;    errno = 0;         if ( (prc_errflag = prc_filecheck(pathname, securecheck)) != 0 )treturn(prc_errflag);         if (errno == ENOTDIR)treturn(PS_IOERR);    else if (errno == ENOENT)treturn(PS_SUCCESS);         if (strcmp(pathname, ""-"") == 0)tyyin = stdin;    else if ((yyin = fopen(pathname,""r"")) == (FILE *)NULL) {treport(stderr, ""open: %s: %s"", pathname, strerror(errno));treturn(PS_IOERR);    }    yyparse();tt     if (yyin != stdin)       fclose(yyin);t     if (prc_errflag) treturn(PS_SYNTAX);    elsetreturn(PS_SUCCESS);}",2,"cwe469,cweother"
"getinclude(void *sc, const char *script, int isglobal,tt      char *fname, size_t size){    script_data_t *sdata = (script_data_t *) sc;    char userbuf[MAX_MAILBOX_BUFFER], *user, *domain = NULL;    struct stat sbuf;    int r;    if (strstr(script, ""../"")) {tsyslog(LOG_NOTICE, ""Illegal script name '%s' for user '%s'"",t       script, sdata->username);treturn SIEVE_FAIL;    }    user = (char *) sdata->username;    if (config_virtdomains && strchr(user, '@')) {t tstrlcpy(userbuf, sdata->username, sizeof(userbuf));tuser = userbuf;tif ((domain = strrchr(user, '@'))) *domain++ = '0';    }    r = sieve_find_script(isglobal ? NULL : user, domain, script,ttt  fname, size);    if (!r && isglobal && domain && stat(fname, &sbuf) != 0) {t tr = sieve_find_script(NULL, NULL, script, fname, size);    }    return r;}",2,"cwe119,cwe120"
"""find_host_for_network (struct subnet **sp, struct host_decl **host,ttt   struct iaddr *addr, struct shared_network *share){tint i;tstruct iaddr ip_address;tstruct host_decl *hp;tstruct data_string fixed_addr;tmemset (&fixed_addr, 0, sizeof fixed_addr);tfor (hp = *host; hp; hp = hp -> n_ipaddr) {ttif (!hp -> fixed_addr)tttcontinue;ttif (!evaluate_option_cache (&fixed_addr, (struct packet *)0,ttttt    (struct lease *)0,ttttt    (struct client_state *)0,ttttt    (struct option_state *)0,ttttt    (struct option_state *)0,ttttt    &global_scope,ttttt    hp -> fixed_addr, MDL))tttcontinue;ttfor (i = 0; i < fixed_addr.len; i += 4) {tttip_address.len = 4;tttmemcpy (ip_address.iabuf,ttttfixed_addr.data + i, 4);tttif (find_grouped_subnet (sp, share, ip_address, MDL)) {ttttstruct host_decl *tmp = (struct host_decl *)0;tttt*addr = ip_address;tttt/* This is probably not necessary, buttttt   just in case *host is the only referencetttt   to that host declaration, make a temporarytttt   reference so that dereferencing it doesn'ttttt   dereference hp out from under us. */tttthost_reference (&tmp, *host, MDL);tttthost_dereference (host, MDL);tttthost_reference (host, hp, MDL);tttthost_dereference (&tmp, MDL);ttttdata_string_forget (&fixed_addr, MDL);ttttreturn 1;ttt}tt}ttdata_string_forget (&fixed_addr, MDL);t}treturn 0;}""",2,"cwe119,cwe120"
"tax_table_entries_refresh (TaxTableWindow *ttw){    GList *list, *node;    GtkTreeView *view;    GtkListStore *store;    GtkTreeIter iter;    GtkTreePath *path;    GtkTreeSelection *selection;    GtkTreeRowReference *reference = NULL;    GncTaxTableEntry *selected_entry;    g_return_if_fail (ttw);    view = GTK_TREE_VIEW (ttw->entries_view);    store = GTK_LIST_STORE(gtk_tree_view_get_model(view));         selected_entry = ttw->current_entry;    gtk_list_store_clear (store);    if (ttw->current_table == NULL)        return;         list = gncTaxTableGetEntries (ttw->current_table);    if (list)        list = g_list_reverse (g_list_copy (list));    for (node = list ; node; node = node->next)    {        char *row_text[3];        GncTaxTableEntry *entry = node->data;        Account *acc = gncTaxTableEntryGetAccount (entry);        gnc_numeric amount = gncTaxTableEntryGetAmount (entry);        row_text[0] = gnc_account_get_full_name (acc);        switch (gncTaxTableEntryGetType (entry))        {        case GNC_AMT_TYPE_PERCENT:            row_text[1] =                g_strdup_printf (""%s%%"",                                 xaccPrintAmount (amount,                                                  gnc_default_print_info (FALSE)));            break;        default:            row_text[1] =                g_strdup_printf (""%s"",                                 xaccPrintAmount (amount,                                                  gnc_default_print_info (TRUE)));            break;        }        gtk_list_store_prepend(store, &iter);        gtk_list_store_set(store, &iter,                           TAX_ENTRY_COL_NAME, row_text[0],                           TAX_ENTRY_COL_POINTER, entry,                           TAX_ENTRY_COL_AMOUNT, row_text[1],                           -1);        if (entry == selected_entry)        {            path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &iter);            reference = gtk_tree_row_reference_new(GTK_TREE_MODEL(store), path);            gtk_tree_path_free(path);        }        g_free (row_text[0]);        g_free (row_text[1]);    }    if (reference)    {        path = gtk_tree_row_reference_get_path(reference);        gtk_tree_row_reference_free(reference);        if (path)        {            selection = gtk_tree_view_get_selection(view);            gtk_tree_selection_select_path(selection, path);            gtk_tree_view_scroll_to_cell(view, path, NULL, TRUE, 0.5, 0.0);            gtk_tree_path_free(path);        }    }}",2,"cwe119,cwe120"
"ast_cdr_data_add_structure(struct ast_data *tree, struct ast_cdr *cdr, int recur){tstruct ast_cdr *tmpcdr;tstruct ast_data *level;tstruct ast_var_t *variables;tconst char *var, *val;tint x = 1, i;tchar workspace[256];tchar *tmp;tif (!cdr) {ttreturn -1;t}tfor (tmpcdr = cdr; tmpcdr; tmpcdr = (recur ? tmpcdr->next : NULL)) {ttlevel = ast_data_add_node(tree, ""level"");ttif (!level) {tttcontinue;tt}ttast_data_add_int(level, ""level_number"", x);ttAST_LIST_TRAVERSE(&tmpcdr->varshead, variables, entries) {tttif (variables && (var = ast_var_name(variables)) &&ttttt(val = ast_var_value(variables)) && !ast_strlen_zero(var)ttttt&& !ast_strlen_zero(val)) {ttttast_data_add_str(level, var, val);ttt} else {ttttbreak;ttt}tt}ttfor (i = 0; cdr_readonly_vars[i]; i++) {tttworkspace[0] = 0;  tttast_cdr_getvar(tmpcdr, cdr_readonly_vars[i], &tmp, workspace, sizeof(workspace), 0, 0);tttif (!tmp) {ttttcontinue;ttt}tttast_data_add_str(level, cdr_readonly_vars[i], tmp);tt}ttx++;t}treturn 0;}",2,"cwe119,cwe120"
"__ecereMethod___ecereNameSpace__ecere__net__Socket_Sendf(struct __ecereNameSpace__ecere__com__Instance * this, char * format, ...){struct __ecereNameSpace__ecere__net__Socket * __ecerePointer___ecereNameSpace__ecere__net__Socket = (struct __ecereNameSpace__ecere__net__Socket *)(this ? (((char *)this) + __ecereClass___ecereNameSpace__ecere__net__Socket->offset) : 0);unsigned int result;va_list args;char string[1025];__builtin_va_start(args, format);vsnprintf(string, sizeof string, format, args);string[sizeof string - 1] = (char)0;result = __ecereMethod___ecereNameSpace__ecere__net__Socket_Send(this, string, (int)strlen(string));__builtin_va_end(args);return result;}",3,"cwe119,cwe120,cweother"
"usnic_transport_put_socket(struct socket *sock){tchar buf[100];tusnic_transport_sock_to_str(buf, sizeof(buf), sock);tusnic_dbg(""Put sock %s"", buf);tsockfd_put(sock);}",2,"cwe119,cwe120"
"do_cmd_pref_file_hack(long row){tchar ftmp[80];tscreen_save();t tprt(""Command: Load a user pref file"", row, 0);t tprt(""File: "", row + 2, 0);t tstrnfmt(ftmp, sizeof ftmp, ""%s.prf"", op_ptr->base_name);t tif (askfor_aux(ftmp, sizeof ftmp, NULL))t{tt ttif (process_pref_file(ftmp, FALSE, TRUE) == FALSE)tt{ttt tttprt("""", 0, 0);tttmsg(""Failed to load '%s'!"", ftmp);tt}ttelsett{ttt tttprt("""", 0, 0);tttmsg(""Loaded '%s'."", ftmp);tt}t}tscreen_load();}",2,"cwe119,cwe120"
"ecs_mem_init(const char *log_file_name){  size_t alloc_size;  if (_ecs_mem_global_initialized == 1) {    _ecs_mem_summary(stderr);    ecs_error(__FILE__, __LINE__, 0,              _(""ecs_mem_init() has already been called""));  }  _ecs_mem_global_initialized = 1;  alloc_size = sizeof(struct _ecs_mem_block_t) * _ecs_mem_global_block_max;  _ecs_mem_global_block_array    = malloc(sizeof(struct _ecs_mem_block_t) * _ecs_mem_global_block_max);  if (_ecs_mem_global_block_array == NULL) {    _ecs_mem_summary(stderr);    ecs_error(__FILE__, __LINE__, errno,              _(""Failure to allocate ""%s"" (%lu bytes)""),              ""_ecs_mem_global_block_array"", (unsigned long)alloc_size);    return;  }  if (log_file_name != NULL) {    _ecs_mem_global_file = fopen(log_file_name, ""w"");         if (_ecs_mem_global_file == NULL)      fprintf(stderr,              _(""Failure to open memory log file ""%s""""),              log_file_name);  }     if (_ecs_mem_global_file != NULL) {    fprintf(_ecs_mem_global_file,            ""       :     FILE NAME              : LINE  :""            ""  POINTER NAME                          : N BYTES   :""            "" (+- N BYTES) : TOTAL BYTES  : [    ADRESS]""            ""-------:----------------------------:-------:""            ""----------------------------------------:-----------:""            ""-----------------------------:--------------"");  }}",2,"cwe120,cweother"
"extra_decode_xrpn(snd_midi_event_t *dev, unsigned char *buf, int count, const snd_seq_event_t *ev){tunsigned char cmd;tconst char *cbytes;tstatic const char cbytes_nrpn[4] = { MIDI_CTL_NONREG_PARM_NUM_MSB,tttt       MIDI_CTL_NONREG_PARM_NUM_LSB,tttt       MIDI_CTL_MSB_DATA_ENTRY,tttt       MIDI_CTL_LSB_DATA_ENTRY };tstatic const char cbytes_rpn[4] =  { MIDI_CTL_REGIST_PARM_NUM_MSB,tttt       MIDI_CTL_REGIST_PARM_NUM_LSB,tttt       MIDI_CTL_MSB_DATA_ENTRY,tttt       MIDI_CTL_LSB_DATA_ENTRY };tunsigned char bytes[4];tint idx = 0, i;tif (count < 8)ttreturn -ENOMEM;tif (dev->nostat && count < 12)ttreturn -ENOMEM;tcmd = MIDI_CMD_CONTROL|(ev->data.control.channel & 0x0f);tbytes[0] = (ev->data.control.param & 0x3f80) >> 7;tbytes[1] = ev->data.control.param & 0x007f;tbytes[2] = (ev->data.control.value & 0x3f80) >> 7;tbytes[3] = ev->data.control.value & 0x007f;tif (cmd != dev->lastcmd && !dev->nostat) {ttif (count < 9)tttreturn -ENOMEM;ttbuf[idx++] = dev->lastcmd = cmd;t}tcbytes = ev->type == SND_SEQ_EVENT_NONREGPARAM ? cbytes_nrpn : cbytes_rpn;tfor (i = 0; i < 4; i++) {ttif (dev->nostat)tttbuf[idx++] = dev->lastcmd = cmd;ttbuf[idx++] = cbytes[i];ttbuf[idx++] = bytes[i];t}treturn idx;}",2,"cwe119,cwe120"
"initLogFile(const unsigned int logLevel, const char* fileName, const char* fileMode){   finishLogging();   if(fileName != NULL) {      *gStdLog = fopen(fileName,fileMode);      if(*gStdLog != NULL) {         gCloseStdLog = true;         gLogLevel   = min(logLevel,MAX_LOGLEVEL);         return(true);      }   }   *gStdLog     = stderr;   gCloseStdLog = false;   return(false);}",2,"cwe469,cweother"
"emit_unwind_info (MonoAotCompile *acfg){tint i;tchar symbol [128];tif (acfg->aot_opts.llvm_only) {ttg_assert (acfg->unwind_ops->len == 0);ttreturn;t}t tsprintf (symbol, ""unwind_info"");temit_section_change (acfg, RODATA_SECT, 1);temit_alignment (acfg, 8);temit_info_symbol (acfg, symbol);tfor (i = 0; i < acfg->unwind_ops->len; ++i) {ttguint32 index = GPOINTER_TO_UINT (g_ptr_array_index (acfg->unwind_ops, i));ttguint8 *unwind_info;ttguint32 unwind_info_len;ttguint8 buf [16];ttguint8 *p;ttunwind_info = mono_get_cached_unwind_info (index, &unwind_info_len);ttp = buf;ttencode_value (unwind_info_len, p, &p);ttemit_bytes (acfg, buf, p - buf);ttemit_bytes (acfg, unwind_info, unwind_info_len);ttacfg->stats.unwind_info_size += (p - buf) + unwind_info_len;t}}",2,"cwe119,cwe120"
"get_dev_random(u_char *output, unsigned size){#ifdef HAVE_DEV_RANDOMtstruct stat st;tint n = 0, fd = -1, s;ts = stat(""/dev/random"", &st);tif (s == 0 && S_ISCHR(st.st_mode)) {ttif ((fd = open(""/dev/random"", O_RDONLY | O_NONBLOCK)) != -1) {tttif ((n = read(fd, output, size)) < 0)ttttn = 0;tttclose(fd);tt}ttreturn (n);t}#endiftreturn (0);}",2,"cwe120,cweother"
"read_data(char *fname){    FILE *fp;    CARD *card = 0;    char buffer[BUFSIZ];    if ((fp = fopen(fname, ""r"")) != 0) {twhile (fgets(buffer, sizeof(buffer), fp)) {t    trim(buffer);t    if (isspace(UChar(*buffer))) {ttif (card == 0)tt    card = add_title("""");ttadd_content(card, buffer);t    } else if ((card = find_card(buffer)) == 0) {ttcard = add_title(buffer);t    }t}tfclose(fp);    }}",3,"cwe119,cwe120,cweother"
"element_getattro(ElementObject* self, PyObject* nameobj){    PyObject* res;    char *name = """";    if (PyUnicode_Check(nameobj))        name = _PyUnicode_AsString(nameobj);    if (name == NULL)        return NULL;         if (strcmp(name, ""tag"") == 0) {        res = self->tag;        Py_INCREF(res);        return res;    } else if (strcmp(name, ""text"") == 0) {        res = element_get_text(self);        Py_INCREF(res);        return res;    }         res = PyObject_GenericGetAttr((PyObject*) self, nameobj);    if (res)        return res;         if (strcmp(name, ""tail"") == 0) {        PyErr_Clear();        res = element_get_tail(self);    } else if (strcmp(name, ""attrib"") == 0) {        PyErr_Clear();        if (!self->extra)            create_extra(self, NULL);        res = element_get_attrib(self);    }    if (!res)        return NULL;    Py_INCREF(res);    return res;}",2,"cwe469,cweother"
"send_fprtime_if_not_null (ctrl_t ctrl, const char *keyword,                          int number, const unsigned char *stamp){                        char numbuf1[50], numbuf2[50];  unsigned long value;  value = buf32_to_ulong (stamp);  if (!value)    return;  sprintf (numbuf1, ""%d"", number);  sprintf (numbuf2, ""%lu"", value);  send_status_info (ctrl, keyword,                    numbuf1, (size_t)strlen(numbuf1),                    numbuf2, (size_t)strlen(numbuf2), NULL, 0);}",2,"cwe119,cwe120"
"detail_parse(CONF_SECTION *cs, rad_listen_t *this){tintttrcode;tlisten_detail_t *data;tRADCLIENTt*client;tchar buffer[2048];tif (check_config) return 0;tif (!this->data) {ttthis->data = rad_malloc(sizeof(*data));ttmemset(this->data, 0, sizeof(*data));t}tdata = this->data;trcode = cf_section_parse(cs, data, detail_config);tif (rcode < 0) {ttcf_log_err(cf_sectiontoitem(cs), ""Failed parsing listen section"");ttreturn -1;t}tif (!data->filename) {ttcf_log_err(cf_sectiontoitem(cs), ""No detail file specified in listen section"");ttreturn -1;t}tif ((data->load_factor < 1) || (data->load_factor > 100)) {ttcf_log_err(cf_sectiontoitem(cs), ""Load factor must be between 1 and 100"");ttreturn -1;t}tif ((data->poll_interval < 1) || (data->poll_interval > 20)) {ttcf_log_err(cf_sectiontoitem(cs), ""poll_interval must be between 1 and 20"");ttreturn -1;t}t tif ((strchr(data->filename, '*') != NULL) ||t    (strchr(data->filename, '[') != NULL)) {ttchar *p;#ifndef HAVE_GLOB_Httradlog(L_INFO, ""WARNING: Detail file ""%s"" appears to use file globbing, but it is not supported on this system."", data->filename);#endifttstrlcpy(buffer, data->filename, sizeof(buffer));ttp = strrchr(buffer, FR_DIR_SEP);ttif (p) {tttp[1] = '0';tt} else {tttbuffer[0] = '0';tt}ttstrlcat(buffer, ""detail.work"",tttsizeof(buffer) - strlen(buffer));tttt} else {ttsnprintf(buffer, sizeof(buffer), ""%s.work"", data->filename);t}tfree(data->filename_work);tdata->filename_work = strdup(buffer);  tdata->vps = NULL;tdata->fp = NULL;tdata->state = STATE_UNOPENED;tdata->delay_time = data->poll_interval * USEC;tdata->signal = 1;t tclient = &data->detail_client;tmemset(client, 0, sizeof(*client));tclient->ipaddr.af = AF_INET;tclient->ipaddr.ipaddr.ip4addr.s_addr = INADDR_NONE;tclient->prefix = 0;tclient->longname = client->shortname = data->filename;tclient->secret = client->shortname;tclient->nastype = strdup(""none"");treturn 0;}",3,"cwe119,cwe120,cwe469"
"snd_hdmi_write_eld_info(struct hdmi_eld *eld,ttt     struct snd_info_buffer *buffer){tstruct parsed_hdmi_eld *e = &eld->info;tchar line[64];tchar name[64];tchar *sname;tlong long val;tunsigned int n;twhile (!snd_info_get_line(buffer, line, sizeof(line))) {ttif (sscanf(line, ""%s %llx"", name, &val) != 2)tttcontinue;tt ttif (!strcmp(name, ""monitor_present""))ttteld->monitor_present = val;ttelse if (!strcmp(name, ""eld_valid""))ttteld->eld_valid = val;ttelse if (!strcmp(name, ""connection_type""))ttte->conn_type = val;ttelse if (!strcmp(name, ""port_id""))ttte->port_id = val;ttelse if (!strcmp(name, ""support_hdcp""))ttte->support_hdcp = val;ttelse if (!strcmp(name, ""support_ai""))ttte->support_ai = val;ttelse if (!strcmp(name, ""audio_sync_delay""))ttte->aud_synch_delay = val;ttelse if (!strcmp(name, ""speakers""))ttte->spk_alloc = val;ttelse if (!strcmp(name, ""sad_count""))ttte->sad_count = val;ttelse if (!strncmp(name, ""sad"", 3)) {tttsname = name + 4;tttn = name[3] - '0';tttif (name[4] >= '0' && name[4] <= '9') {ttttsname++;ttttn = 10 * n + name[4] - '0';ttt}tttif (n >= ELD_MAX_SAD)ttttcontinue;tttif (!strcmp(sname, ""_coding_type""))tttte->sad[n].format = val;tttelse if (!strcmp(sname, ""_channels""))tttte->sad[n].channels = val;tttelse if (!strcmp(sname, ""_rates""))tttte->sad[n].rates = val;tttelse if (!strcmp(sname, ""_bits""))tttte->sad[n].sample_bits = val;tttelse if (!strcmp(sname, ""_max_bitrate""))tttte->sad[n].max_bitrate = val;tttelse if (!strcmp(sname, ""_profile""))tttte->sad[n].profile = val;tttif (n >= e->sad_count)tttte->sad_count = n + 1;tt}t}}",3,"cwe119,cwe120,cweother"
"__ecereMethod_Project_MatchProjectAndConfigPlatformOptions(struct Project * this, struct ProjectConfig * config, int platform, struct __ecereNameSpace__ecere__com__Instance ** projectPlatformOptions, struct __ecereNameSpace__ecere__com__Instance ** configPlatformOptions){*projectPlatformOptions = (((void *)0));*configPlatformOptions = (((void *)0));if(this->platforms){{struct __ecereNameSpace__ecere__com__Instance ** p;struct __ecereNameSpace__ecere__com__Instance * __internalArray = this->platforms;for(p = (struct __ecereNameSpace__ecere__com__Instance **)((struct __ecereNameSpace__ecere__com__Array *)(((char *)__internalArray + 24)))->array; p < (struct __ecereNameSpace__ecere__com__Instance **)((struct __ecereNameSpace__ecere__com__Array *)(((char *)__internalArray + 24)))->array + ((struct __ecereNameSpace__ecere__com__Array *)(((char *)__internalArray + 24)))->count; p++){if(!(strcasecmp)(__extension__ ({char * __ecTemp1 = ((*p));((struct PlatformOptions *)(__ecTemp1 + __ecereClass_PlatformOptions->offset));})->name, __ecereProp___ecereNameSpace__ecere__com__Platform_Get_char__PTR_(platform))){*projectPlatformOptions = (*p);break;}}}}if(config && __ecereProp_ProjectConfig_Get_platforms(config)){{struct __ecereNameSpace__ecere__com__Instance ** p;struct __ecereNameSpace__ecere__com__Instance * __internalArray = __ecereProp_ProjectConfig_Get_platforms(config);for(p = (struct __ecereNameSpace__ecere__com__Instance **)((struct __ecereNameSpace__ecere__com__Array *)(((char *)__internalArray + 24)))->array; p < (struct __ecereNameSpace__ecere__com__Instance **)((struct __ecereNameSpace__ecere__com__Array *)(((char *)__internalArray + 24)))->array + ((struct __ecereNameSpace__ecere__com__Array *)(((char *)__internalArray + 24)))->count; p++){if(!(strcasecmp)(__extension__ ({char * __ecTemp1 = ((*p));((struct PlatformOptions *)(__ecTemp1 + __ecereClass_PlatformOptions->offset));})->name, __ecereProp___ecereNameSpace__ecere__com__Platform_Get_char__PTR_(platform))){*configPlatformOptions = (*p);break;}}}}}",2,"cwe119,cwe120"
"sha_eq(const unsigned char *a, const unsigned char *b){tif (!a && !b)ttreturn 2;treturn a && b && hashcmp(a, b) == 0;}",2,"cwe119,cwe120"
"writeGroup(OFile *fp, VObject *o){    char buf1[256];    char buf2[256];    strncpy(buf1,NAME_OF(o), 256);    while ((o=isAPropertyOf(o,VCGroupingProp)) != 0) {tstrncpy(buf2,STRINGZ_VALUE_OF(o),sizeof(buf2));tbuf2[sizeof(buf2)-1] = '0';tstrncat(buf2,""."",sizeof(buf2)-strlen(buf2)-1);tstrncat(buf2,buf1,sizeof(buf2)-strlen(buf2)-1);tstrcpy(buf1,buf2);t}    appendsOFile(fp,buf1);}",2,"cwe119,cwe120"
"tas5086_probe(struct snd_soc_codec *codec){tstruct tas5086_private *priv = snd_soc_codec_get_drvdata(codec);tint i, ret;tret = regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);tif (ret < 0) {ttdev_err(codec->dev, ""Failed to enable regulators: %d"", ret);ttreturn ret;t}tpriv->pwm_start_mid_z = 0;tpriv->charge_period = 1300000;  tif (of_match_device(of_match_ptr(tas5086_dt_ids), codec->dev)) {ttstruct device_node *of_node = codec->dev->of_node;ttof_property_read_u32(of_node, ""ti,charge-period"",tttt     &priv->charge_period);ttfor (i = 0; i < 6; i++) {tttchar name[25];tttsnprintf(name, sizeof(name),tttt ""ti,mid-z-channel-%d"", i + 1);tttif (of_get_property(of_node, name, NULL) != NULL)ttttpriv->pwm_start_mid_z |= 1 << i;tt}t}ttas5086_reset(priv);tret = tas5086_init(codec->dev, priv);tif (ret < 0)ttgoto exit_disable_regulators;t tret = regmap_write(priv->regmap, TAS5086_MASTER_VOL, 0x30);tif (ret < 0)ttgoto exit_disable_regulators;treturn 0;exit_disable_regulators:tregulator_bulk_disable(ARRAY_SIZE(priv->supplies), priv->supplies);treturn ret;}",2,"cwe119,cwe120"
"decrypt_iso_header(FILE *psar, int header_offset, int header_size, unsigned char *pgd_key, int disc_num)r{rtif (psar == NULL)rt{rttprintf(""ERROR: Can't open input file for ISO header!"");rttreturn -1;rt}rrt tfseek(psar, header_offset, SEEK_SET);rrt tunsigned char *iso_header = (unsigned char *) malloc (header_size);rtfread(iso_header, header_size, 1, psar);rrtprintf(""Decrypting ISO header..."");rrt tint pgd_size = decrypt_pgd(iso_header, header_size, 2, pgd_key);rrtif (pgd_size > 0)rttprintf(""ISO header successfully decrypted! Saving as ISO_HEADER.BIN..."");rtelsert{rttprintf(""ERROR: ISO header decryption failed!"");rttreturn -1;rt}rtrt tchar iso_header_filename[0x12];rtif (disc_num > 0)rttsprintf(iso_header_filename, ""ISO_HEADER_%d.BIN"", disc_num);rtelserttsprintf(iso_header_filename, ""ISO_HEADER.BIN"");rrt tFILE* dec_iso_header = fopen(iso_header_filename, ""wb"");rtfwrite(iso_header + 0x90, pgd_size, 1, dec_iso_header);rtfclose(dec_iso_header);rtrtfree(iso_header);rrtreturn 0;r}",3,"cwe119,cwe120,cweother"
_hidden_job(struct job_record *job_ptr){tint i;tfor (i=0; i<HIDE_PART_CNT; i++) {ttif (hide_part_ptr[i] == NULL)tttbreak;ttif (hide_part_ptr[i] == job_ptr->part_ptr)tttreturn 1;t}treturn 0;},2,"cwe119,cwe120"
"read_datalog_info(unsigned int* seg1_addr, unsigned int* seg1_len,                  unsigned int* seg2_addr, unsigned int* seg2_len){  unsigned char  info[16];  unsigned int   flash_start_addr;  unsigned int   flash_length;  unsigned int   data_start_addr;  unsigned int   next_blank_addr;  write_packet(PID_INFO_DATALOG, NULL, 0);  read_packet(PID_DATA, info, sizeof(info), sizeof(info), FALSE);  flash_start_addr = le_read32(info);  flash_length = le_read32(info + 4);  data_start_addr = le_read32(info + 8);  next_blank_addr = le_read32(info + 12);  if (data_start_addr > next_blank_addr) {         *seg1_addr = data_start_addr;    *seg1_len = flash_start_addr + flash_length - *seg1_addr;    *seg2_addr = flash_start_addr;    *seg2_len = next_blank_addr - flash_start_addr;  } else {         *seg1_addr = data_start_addr;    *seg1_len = next_blank_addr - data_start_addr;    *seg2_addr = 0;    *seg2_len = 0;  }  if (*seg1_len & 0x1F || *seg2_len & 0x1F) {    fatal(MYNAME "": Protocol error: datalog lengths %u, %u ""          ""not aligned to 32 bytes"", *seg1_len, *seg2_len);  }}",2,"cwe119,cwe120"
"particulate_field_read (GtsObject ** o, GtsFile * fp){  (* GTS_OBJECT_CLASS (gfs_particulate_field_class ())->parent_class->read) (o, fp);   if (fp->type == GTS_ERROR)    return;  if (fp->type != GTS_STRING) {    gts_file_error (fp, ""expecting a string (object name)"");    return;  }  GfsParticulateField * pfield = GFS_PARTICULATE_FIELD (*o);  GtsObject * object = gfs_object_from_name (GFS_DOMAIN (gfs_object_simulation (*o)), ttttt     fp->token->str);  if (object == NULL) {    gts_file_error (fp, ""unknown object '%s'"", fp->token->str);    return;  }  if (!GFS_IS_PARTICLE_LIST (object)) {    gts_file_error (fp, ""object '%s' is not a GfsParticleList"", fp->token->str);    return;    }  gts_file_next_token (fp);    pfield->plist = GFS_PARTICLE_LIST (object);}",2,"cwe120,cweother"
"searchttl (char *str){  char buf[strlen (str) + 1];  char *cptr, *dptr;  uint32_t time;  int i;  dptr = strstr (str, ""ttl="");  if (dptr == NULL)tt     return DEFAULT_TTL;;  dptr += 4;ttt   i = 0;  while (dptr[i] != '0' && dptr[i] != ':')    i++;  if (i == 0)ttt     return DEFAULT_TTL;  strncpy (buf, dptr, i);  buf[i] = '0';  time = 0;  dptr = buf;  cptr = strchr (dptr, 'd');  if (cptr != NULL)    {      *cptr = '0';      cptr++;      time += atoi (dptr) * 60 * 60 * 24;      dptr = cptr;    }  cptr = strchr (dptr, 'h');  if (cptr != NULL)    {      *cptr = '0';      cptr++;      time += atoi (dptr) * 60 * 60;      dptr = cptr;    }  cptr = strchr (dptr, 'm');  if (cptr != NULL)    {      *cptr = '0';      cptr++;      time += atoi (dptr) * 60;      dptr = cptr;    }  cptr = strchr (dptr, 's');  if (cptr != NULL)    *cptr = '0';  time += atoi (dptr);  return time;}",3,"cwe119,cwe120,cweother"
"uptime_screen(int rep, int display, int *flags_ptr){tint xoffs;tint days, hour, min, sec;tdouble uptime, idle;tstatic int heartbeat = 0;tchar tmp[257];t tif ((*flags_ptr & INITIALIZED) == 0) {tt*flags_ptr |= INITIALIZED;ttsock_send_string(sock, ""screen_add U"");ttsock_printf(sock, ""screen_set U -name {Uptime Screen: %s}"", get_hostname());ttsock_send_string(sock, ""widget_add U title title"");ttif (lcd_hgt >= 4) {tttsock_send_string(sock, ""widget_add U one string"");tttsock_send_string(sock, ""widget_add U two string"");tttsock_send_string(sock, ""widget_add U three string"");tttsock_send_string(sock, ""widget_set U title {SYSTEM UPTIME}"");tttsprintf(tmp, ""%s"", get_hostname());tttxoffs = (lcd_wid > strlen(tmp)) ? (((lcd_wid - strlen(tmp)) / 2) + 1) : 1;tttsock_printf(sock, ""widget_set U one %i 2 {%s}"", xoffs, tmp);tttsprintf(tmp, ""%s %s"", get_sysname(), get_sysrelease());tttxoffs = (lcd_wid > strlen(tmp)) ? (((lcd_wid - strlen(tmp)) / 2) + 1) : 1;tttsock_printf(sock, ""widget_set U three %i 4 {%s}"", xoffs, tmp);tt} else {tttsock_send_string(sock, ""widget_add U one string"");tttsock_printf(sock, ""widget_set U title {%s %s: %s}"",tttttget_sysname(), get_sysrelease(), get_hostname());tt}t}t theartbeat ^= 1;tmachine_get_uptime(&uptime, &idle);tdays = (int) uptime / 86400;thour = ((int) uptime % 86400) / 3600;tmin =  ((int) uptime % 3600) / 60;tsec =  ((int) uptime % 60);tif (lcd_wid >= 20)ttsprintf(tmp, ""%d day%s %02d:%02d:%02d"",tttdays, ((days != 1) ? ""s"" : """"), hour, min, sec);telsettsprintf(tmp, ""%dd %02d:%02d:%02d"", days, hour, min, sec);tif (display) {ttxoffs = (lcd_wid > strlen(tmp)) ? (((lcd_wid - strlen(tmp)) / 2) + 1) : 1;ttif (lcd_hgt >= 4)tttsock_printf(sock, ""widget_set U two %d 3 {%s}"", xoffs, tmp);ttelsetttsock_printf(sock, ""widget_set U one %d 2 {%s}"", xoffs, tmp);t}treturn 0;}",2,"cwe119,cwe120"
"ipmi_sel_add_entries_fromfile(struct ipmi_intf * intf, const char * filename){tFILE * fp;tchar buf[1024];tchar * ptr, * tok;tint i, j;tint rc = 0;tuint8_t rqdata[8];tstruct sel_event_record sel_event;ttif (filename == NULL)ttreturn -1;tfp = ipmi_open_file_read(filename);tif (fp == NULL)ttreturn -1;twhile (feof(fp) == 0) {ttif (fgets(buf, 1024, fp) == NULL)tttcontinue;tt ttptr = strchr(buf, '#');ttif (ptr)ttt*ptr = '0';ttelsetttptr = buf + strlen(buf);tt ttptr--;ttwhile (isspace((int)*ptr) && ptr >= buf)ttt*ptr-- = '0';ttptr = buf;ttwhile (isspace((int)*ptr))tttptr++;ttif (strlen(ptr) == 0)tttcontinue;tt tt tti = 0;tttok = strtok(ptr, "" "");ttwhile (tok) {tttif (i == 7)ttttbreak;tttj = i++;tttif (str2uchar(tok, &rqdata[j]) != 0) {ttttbreak;ttt}ttttok = strtok(NULL, "" "");tt}ttif (i < 7) {tttlprintf(LOG_ERR, ""Invalid Event: %s"",ttt       buf2str(rqdata, sizeof(rqdata)));tttcontinue;tt}ttmemset(&sel_event, 0, sizeof(struct sel_event_record));ttsel_event.record_id = 0x0000;ttsel_event.record_type = 0x02;ttsel_event.sel_type.standard_type.gen_id = 0x00;ttsel_event.sel_type.standard_type.evm_rev = rqdata[0];ttsel_event.sel_type.standard_type.sensor_type = rqdata[1];ttsel_event.sel_type.standard_type.sensor_num = rqdata[2];ttsel_event.sel_type.standard_type.event_type = rqdata[3] & 0x7f;ttsel_event.sel_type.standard_type.event_dir = (rqdata[3] & 0x80) >> 7;ttsel_event.sel_type.standard_type.event_data[0] = rqdata[4];ttsel_event.sel_type.standard_type.event_data[1] = rqdata[5];ttsel_event.sel_type.standard_type.event_data[2] = rqdata[6];ttrc = ipmi_sel_add_entry(intf, &sel_event);ttif (rc < 0)tttbreak;t}tfclose(fp);treturn rc;}",2,"cwe119,cwe120"
"dopost(const char *s){    if (sys_printhook)        (*sys_printhook)(s);    else if (sys_printtostderr)        fprintf(stderr, ""%s"", s);    else    {        char upbuf[MAXPDSTRING];        sys_vgui(""::pdwindow::post {%s}"", strnescape(upbuf, s, MAXPDSTRING));    }}",2,"cwe119,cwe120"
"""relay_send_end_cell_from_edge(streamid_t stream_id, circuit_t *circ,                              uint8_t reason, crypt_path_t *cpath_layer){  char payload[1];  if (CIRCUIT_PURPOSE_IS_CLIENT(circ->purpose)) {    /* Never send the server an informative reason code; it doesn't need to     * know why the client stream is failing. */    reason = END_STREAM_REASON_MISC;  }  payload[0] = (char) reason;  return relay_send_command_from_edge(stream_id, circ, RELAY_COMMAND_END,                                      payload, 1, cpath_layer);}""",2,"cwe119,cwe120"
"krb5_def_store_mkey_list(krb5_context       context,                         char               *keyfile,                         krb5_principal     mname,                         krb5_keylist_node  *keylist,                         char               *master_pwd){    krb5_error_code retval = 0;    char defkeyfile[MAXPATHLEN+1];    char *tmp_ktname = NULL, *tmp_ktpath;    krb5_data *realm = krb5_princ_realm(context, mname);    krb5_keytab kt = NULL;    krb5_keytab_entry new_entry;    struct stat stb;    int statrc;    if (!keyfile) {        (void) snprintf(defkeyfile, sizeof(defkeyfile), ""%s%s"",                        DEFAULT_KEYFILE_STUB, realm->data);        keyfile = defkeyfile;    }         if ((statrc = stat(keyfile, &stb)) >= 0) {                 if (!S_ISREG(stb.st_mode)) {            retval = EINVAL;            krb5_set_error_message(context, retval,                                   _(""keyfile (%s) is not a regular file: %s""),                                   keyfile, error_message(retval));            goto out;        }    }              if ((retval = asprintf(&tmp_ktname, ""WRFILE:%s_XXXXXX"", keyfile)) < 0) {        krb5_set_error_message(context, retval,                               _(""Could not create temp keytab file name.""));        goto out;    }         tmp_ktpath = tmp_ktname + (sizeof(""WRFILE:"") - 1);    if (mktemp(tmp_ktpath) == NULL) {        retval = errno;        krb5_set_error_message(context, retval,                               _(""Could not create temp stash file: %s""),                               error_message(errno));        goto out;    }         retval = krb5_kt_resolve(context, tmp_ktname, &kt);    if (retval != 0)        goto out;    while (keylist && !retval) {        memset(&new_entry, 0, sizeof(new_entry));        new_entry.principal = mname;        new_entry.key = keylist->keyblock;        new_entry.vno = keylist->kvno;        retval = krb5_kt_add_entry(context, kt, &new_entry);        keylist = keylist->next;    }    krb5_kt_close(context, kt);    if (retval != 0) {                 if (stat(keyfile, &stb) >= 0)            (void) unlink(tmp_ktpath);    } else {                 if (rename(tmp_ktpath, keyfile) < 0) {            retval = errno;            krb5_set_error_message(context, retval,                                   _(""rename of temporary keyfile (%s) to ""                                     ""(%s) failed: %s""), tmp_ktpath, keyfile,                                   error_message(errno));        }    }out:    if (tmp_ktname != NULL)        free(tmp_ktname);    return retval;}",3,"cwe119,cwe120,cweother"
"init_obj_classes(){tint i, class, prev_class;tprev_class = -1;tfor (i = 0; i < NUM_OBJECTS; i++) {t    class = objects[i].oc_class;t    if (class != prev_class) {ttbases[class] = i;ttprev_class = class;t    }t}}",2,"cwe119,cwe120"
"""secfile_hash_delete(struct section_file *secfile,                                struct entry *pentry){  char buf[256];  if (NULL == secfile->hash.entries) {    /* Consider as success if this secfile doesn't have built the entries     * hash table. */    return TRUE;  }  entry_path(pentry, buf, sizeof(buf));  return entry_hash_remove(secfile->hash.entries, buf);}""",2,"cwe119,cwe120"
"""theme_format_append_variable(GString *str, const char **format){tconst char *orig;tchar *value, *args[1] = { NULL };tint free_ret;torig = *format;t(*format)++;tvalue = parse_special((char **) format, NULL, NULL,ttt      args, &free_ret, NULL, PARSE_FLAG_ONLY_ARGS);tif (free_ret) g_free(value);tif (**format != '0')tt(*format)++;t/* append the variable name */tvalue = g_strndup(orig, (int) (*format-orig));tg_string_append(str, value);tg_free(value);}""",2,"cwe119,cwe120"
"ecore_con_url_ftp_upload(Ecore_Con_Url *url_con, const char *filename, const char *user, const char *pass, const char *upload_dir){#ifdef HAVE_CURL   char url[4096];   char userpwd[4096];   FILE *fd;   struct stat file_info;   CURLcode ret;   if (!ECORE_MAGIC_CHECK(url_con, ECORE_MAGIC_CON_URL))     {        ECORE_MAGIC_FAIL(url_con,                         ECORE_MAGIC_CON_URL,                         ""ecore_con_url_ftp_upload"");        return EINA_FALSE;     }   if (url_con->dead) return EINA_FALSE;   if (!url_con->url) return EINA_FALSE;   if ((!filename) || (!filename[0])) return EINA_FALSE;   if (stat(filename, &file_info))     return EINA_FALSE;   snprintf(userpwd, sizeof(userpwd), ""%s:%s"", user, pass);   ret = curl_easy_setopt(url_con->curl_easy, CURLOPT_USERPWD, userpwd);   if (ret != CURLE_OK)     {        ERR(""Could not set username and password for FTP upload: %s"",            curl_easy_strerror(ret));        return EINA_FALSE;     }   char tmp[PATH_MAX];   snprintf(tmp, PATH_MAX, ""%s"", filename);   if (upload_dir)     snprintf(url, sizeof(url), ""ftp://%s/%s/%s"", url_con->url,              upload_dir, basename(tmp));   else     snprintf(url, sizeof(url), ""ftp://%s/%s"", url_con->url,              basename(tmp));   if (!ecore_con_url_url_set(url_con, url))     return EINA_FALSE;   curl_easy_setopt(url_con->curl_easy, CURLOPT_INFILESIZE_LARGE,                    (curl_off_t)file_info.st_size);   curl_easy_setopt(url_con->curl_easy, CURLOPT_UPLOAD, 1);   curl_easy_setopt(url_con->curl_easy, CURLOPT_READFUNCTION,                    _ecore_con_url_read_cb);   fd = fopen(filename, ""rb"");   if (!fd)     {        ERR(""Could not open ""%s"" for FTP upload"", filename);        return EINA_FALSE;     }   curl_easy_setopt(url_con->curl_easy, CURLOPT_READDATA, fd);   return _ecore_con_url_perform(url_con);#else   return EINA_FALSE;   (void)url_con;   (void)filename;   (void)user;   (void)pass;   (void)upload_dir;#endif}",3,"cwe119,cwe120,cweother"
flimage_set_fits_bits( int bits ){    int old = fits_bit;    if ( bits > 0 && bits < 16 )    {        fits_bit = bits;        return old;    }treturn - old;},2,"cwe119,cwe120"
"verify_callback(int ok, X509_STORE_CTX * ctx){    char    buf[256];    X509   *err_cert;    int     err;    int     depth;    err_cert = X509_STORE_CTX_get_current_cert(ctx);    err = X509_STORE_CTX_get_error(ctx);    depth = X509_STORE_CTX_get_error_depth(ctx);    X509_NAME_oneline(X509_get_subject_name(err_cert), buf, sizeof(buf));         if (!ok) {      printf(""verify error:num=%d:%s"", err,t     X509_verify_cert_error_string(err));tif (verify_depth >= depth) {t    ok = 1;t    verify_error = X509_V_OK;t} else {t    ok = 0;t    verify_error = X509_V_ERR_CERT_CHAIN_TOO_LONG;t}    }    switch (ctx->error) {    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:tX509_NAME_oneline(X509_get_issuer_name(ctx->current_cert),ttt  buf, sizeof(buf));tprintf(""issuer= %s"", buf);tbreak;    case X509_V_ERR_CERT_NOT_YET_VALID:    case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:      printf(""cert not yet valid"");      break;    case X509_V_ERR_CERT_HAS_EXPIRED:    case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:      printf(""cert has expired"");      break;    }         return (ok);}",2,"cwe119,cwe120"
"help_update_improvement(const struct help_item *pitem,tttt    char *title){  char buf[8192];  struct impr_type *imp = improvement_by_translated_name(title);  create_help_page(HELP_IMPROVEMENT);  if (imp  &&  !is_great_wonder(imp)) {    const char *req = REQ_LABEL_NONE;    char req_buf[512];    sprintf(buf, ""%d"", impr_build_shield_cost(imp));    gtk_label_set_text(GTK_LABEL(help_ilabel[1]), buf);    sprintf(buf, ""%d"", imp->upkeep);    gtk_label_set_text(GTK_LABEL(help_ilabel[3]), buf);         requirement_vector_iterate(&imp->reqs, preq) {      if (preq->negated) {        continue;      }      req = universal_name_translation(&preq->source, req_buf, sizeof(req_buf));      break;    } requirement_vector_iterate_end;    gtk_label_set_text(GTK_LABEL(help_ilabel[5]), req);   }  else {    gtk_label_set_text(GTK_LABEL(help_ilabel[1]), ""0"");    gtk_label_set_text(GTK_LABEL(help_ilabel[3]), ""0"");    gtk_label_set_text(GTK_LABEL(help_ilabel[5]), REQ_LABEL_NEVER);   }    if (get_building_sprite(tileset, imp)) {      struct sprite *sprite = get_building_sprite(tileset, imp);      gtk_pixcomm_set_from_sprite(GTK_PIXCOMM(help_tile), sprite);      gtk_widget_show(help_tile);    }  gtk_widget_show(help_itable);  helptext_building(buf, sizeof(buf), client.conn.playing, pitem->text, imp);  gtk_text_buffer_set_text(help_text, buf, -1);  gtk_widget_show(help_text_sw);}",2,"cwe119,cwe120"
"defout(int last){tint i, c;tchar sar[NAMESIZE+10];tfor(i=ndefout; i<=ntokens; i++) {tt ttc = tokset[i].name[0];ttif(c != ' ' && c != '$') {tttBprint(ftable, ""#definet%st%d"",tttttokset[i].name, tokset[i].value);tttif(fdefine)ttttBprint(fdefine, ""#definet%st%d"",ttttttokset[i].name, tokset[i].value);tt}t}tndefout = ntokens+1;tif(last && fdebug) {ttBprint(fdebug, ""statictchar*tyytoknames[] ={"");ttTLOOP(i) {tttif(tokset[i].name) {ttttchcopy(sar, tokset[i].name);ttttBprint(fdebug, ""t""%s"","", sar);ttttcontinue;ttt}tttBprint(fdebug, ""t0,"");tt}ttBprint(fdebug, ""};"");t}}",2,"cwe119,cwe120"
"ReadBytesSwapped(FILE * fp, char *p, int n){    register char *q = p;         while (!feof(fp) & (n-- > 0))        *q++ = getc(fp);         for (q--; p < q; p++, q--) {        n = *p;        *p = *q;        *q = n;    }}",2,"cwe120,cweother"
"srvWrite(int fileID, srvrec_t *srvp){  size_t datasize;  size_t blocklen;  size_t i;  int dprec, hprec;  char tempheader[64];  int *header;  void *buffer;  int byteswap = srvp->byteswap;  dprec  = srvp->dprec;  hprec  = srvp->hprec;  header = srvp->header;     blocklen = SRV_HEADER_LEN * hprec;  binWriteF77Block(fileID, byteswap, blocklen);  switch ( hprec )    {    case SINGLE_PRECISION:      {tfor (i = 0; i < SRV_HEADER_LEN; i++)          ((INT32 *) tempheader)[i] = (INT32) header[i];tbinWriteInt32(fileID, byteswap, SRV_HEADER_LEN, (INT32 *) tempheader);tbreak;      }    case DOUBLE_PRECISION:      {tfor (i = 0; i < SRV_HEADER_LEN; i++)          ((INT64 *) tempheader)[i] = (INT64) header[i];tbinWriteInt64(fileID, byteswap, SRV_HEADER_LEN, (INT64 *) tempheader);tbreak;      }    default:      {tError(""unexpected header precision %d"", hprec);        break;      }    }    binWriteF77Block(fileID, byteswap, blocklen);  datasize = header[4]*header[5];  blocklen = datasize * dprec;  binWriteF77Block(fileID, byteswap, blocklen);  srvp->datasize = datasize;  buffer = srvp->buffer;  switch ( dprec )    {    case SINGLE_PRECISION:      {tbinWriteFlt32(fileID, byteswap, datasize, (FLT32 *) buffer);tbreak;      }    case DOUBLE_PRECISION:      {tbinWriteFlt64(fileID, byteswap, datasize, (FLT64 *) buffer);tbreak;      }    default:      {tError(""unexpected data precision %d"", dprec);        break;      }    }  binWriteF77Block(fileID, byteswap, blocklen);  return (0);}",2,"cwe119,cwe120"
"addall_hfs(Volume* volume, const char* dirToMerge, const char* dest) {tHFSPlusCatalogRecord* record;tchar* name;tchar cwd[1024];tchar initPath[1024];tint lastCharOfPath;ttASSERT(getcwd(cwd, 1024) != NULL, ""cannot get current working directory"");ttif(chdir(dirToMerge) != 0) {ttprintf(""Cannot open that directory: %s"", dirToMerge);ttexit(0);t}ttrecord = getRecordFromPath(dest, volume, &name, NULL);tstrcpy(initPath, dest);tlastCharOfPath = strlen(dest) - 1;tif(dest[lastCharOfPath] != '/') {ttinitPath[lastCharOfPath + 1] = '/';ttinitPath[lastCharOfPath + 2] = '0';t}ttif(record != NULL) {ttif(record->recordType == kHFSPlusFolderRecord)tttaddAllInFolder(((HFSPlusCatalogFolder*)record)->folderID, volume, initPath);  ttelse {tttprintf(""Not a folder"");tttexit(0);tt}t} else {ttprintf(""No such file or directory"");ttexit(0);t}ttASSERT(chdir(cwd) == 0, ""chdir"");tfree(record);t}",2,"cwe119,cwe120"
"__ecereProp___ecereNameSpace__eda__Row_Get_rowsCount(struct __ecereNameSpace__ecere__com__Instance * this){struct __ecereNameSpace__eda__Row * __ecerePointer___ecereNameSpace__eda__Row = (struct __ecereNameSpace__eda__Row *)(this ? (((char *)this) + __ecereClass___ecereNameSpace__eda__Row->offset) : 0);if(__ecerePointer___ecereNameSpace__eda__Row->query){char * from = __ecereFunction___ecereNameSpace__ecere__sys__SearchString(__ecerePointer___ecereNameSpace__eda__Row->query, 0, ""FROM"", 0x0, 0x1);if(from){unsigned int len = strlen(__ecerePointer___ecereNameSpace__eda__Row->query);char * countQuery = __ecereNameSpace__ecere__com__eSystem_New(sizeof(char) * (len + 40));unsigned int count;char * result;struct __ecereNameSpace__ecere__com__Instance * r = (r = __ecereNameSpace__ecere__com__eInstance_New(__ecereClass___ecereNameSpace__eda__Row), __ecereProp___ecereNameSpace__eda__Row_Set_tbl(r, __ecerePointer___ecereNameSpace__eda__Row->tbl), r);strcpy(countQuery, ""SELECT COUNT(*) "");strcat(countQuery, from);__ecereProp___ecereNameSpace__eda__Row_Set_query(r, countQuery);result = __ecereMethod___ecereNameSpace__eda__Row_GetColumn(r, 0);count = result ? strtol(result, (((void *)0)), 0) : 0;(__ecereNameSpace__ecere__com__eInstance_DecRef(r), r = 0);return count;}}else if(__ecerePointer___ecereNameSpace__eda__Row->tbl)return __ecereProp___ecereNameSpace__eda__Table_Get_rowsCount(__ecerePointer___ecereNameSpace__eda__Row->tbl);return 0;}",2,"cwe120,cwe476"
"isl_map_coalesce(struct isl_map *map){tint i;tunsigned n;tstruct isl_tab **tabs = NULL;tmap = isl_map_remove_empty_parts(map);tif (!map)ttreturn NULL;tif (map->n <= 1)ttreturn map;tmap = isl_map_sort_divs(map);tmap = isl_map_cow(map);ttabs = isl_calloc_array(map->ctx, struct isl_tab *, map->n);tif (!tabs)ttgoto error;tn = map->n;tfor (i = 0; i < map->n; ++i) {tttabs[i] = isl_tab_from_basic_map(map->p[i], 0);ttif (!tabs[i])tttgoto error;ttif (!ISL_F_ISSET(map->p[i], ISL_BASIC_MAP_NO_IMPLICIT))tttif (isl_tab_detect_implicit_equalities(tabs[i]) < 0)ttttgoto error;ttif (!ISL_F_ISSET(map->p[i], ISL_BASIC_MAP_NO_REDUNDANT))tttif (isl_tab_detect_redundant(tabs[i]) < 0)ttttgoto error;t}tfor (i = map->n - 1; i >= 0; --i)ttif (tabs[i]->empty)tttdrop(map, i, tabs);tmap = coalesce(map, tabs);tif (map)ttfor (i = 0; i < map->n; ++i) {tttmap->p[i] = isl_basic_map_update_from_tab(map->p[i],tttttttt    tabs[i]);tttmap->p[i] = isl_basic_map_finalize(map->p[i]);tttif (!map->p[i])ttttgoto error;tttISL_F_SET(map->p[i], ISL_BASIC_MAP_NO_IMPLICIT);tttISL_F_SET(map->p[i], ISL_BASIC_MAP_NO_REDUNDANT);tt}tfor (i = 0; i < n; ++i)ttisl_tab_free(tabs[i]);tfree(tabs);treturn map;error:tif (tabs)ttfor (i = 0; i < n; ++i)tttisl_tab_free(tabs[i]);tfree(tabs);tisl_map_free(map);treturn NULL;}",2,"cwe476,cweother"
"do_fmt_merge_msg(int merge_title, struct strbuf *in,tstruct strbuf *out, int shortlog_len) {tint i = 0, pos = 0;tunsigned char head_sha1[20];tconst char *current_branch;t tcurrent_branch = resolve_ref(""HEAD"", head_sha1, 1, NULL);tif (!current_branch)ttdie(""No current branch"");tif (!prefixcmp(current_branch, ""refs/heads/""))ttcurrent_branch += 11;t twhile (pos < in->len) {ttint len;ttchar *newline, *p = in->buf + pos;ttnewline = strchr(p, '');ttlen = newline ? newline - p : strlen(p);ttpos += len + !!newline;tti++;ttp[len] = 0;ttif (handle_line(p))tttdie (""Error in line %d: %.*s"", i, len, p);t}tif (!srcs.nr)ttreturn 0;tif (merge_title)ttdo_fmt_merge_msg_title(out, current_branch);tif (shortlog_len) {ttstruct commit *head;ttstruct rev_info rev;tthead = lookup_commit(head_sha1);ttinit_revisions(&rev, NULL);ttrev.commit_format = CMIT_FMT_ONELINE;ttrev.ignore_merges = 1;ttrev.limited = 1;ttif (suffixcmp(out->buf, """"))tttstrbuf_addch(out, '');ttfor (i = 0; i < origins.nr; i++)tttshortlog(origins.items[i].string, origins.items[i].util,ttttthead, &rev, shortlog_len, out);t}treturn 0;}",2,"cwe119,cwe120"
"""key_get_type_from_user(char *type,tttt  const char __user *_type,tttt  unsigned len){tint ret;tret = strncpy_from_user(type, _type, len);tif (ret < 0)ttreturn ret;tif (ret == 0 || ret >= len)ttreturn -EINVAL;tif (type[0] == '.')ttreturn -EPERM;ttype[len - 1] = '0';treturn 0;}""",2,"cwe119,cwe120"
"pitch2key(int note){static char name[5];char* s = name;  switch(note % 12)  {  case 0: *s++ = 'c'; break;  case 1: *s++ = 'c'; *s++ = '#'; break;  case 2: *s++ = 'd'; break;  case 3: *s++ = 'd'; *s++ = '#'; break;  case 4: *s++ = 'e'; break;  case 5: *s++ = 'f'; break;  case 6: *s++ = 'f'; *s++ = '#'; break;  case 7: *s++ = 'g'; break;  case 8: *s++ = 'g'; *s++ = '#'; break;  case 9: *s++ = 'a'; break;  case 10: *s++ = 'a'; *s++ = '#'; break;  case 11: *s++ = 'b'; break;  }  sprintf(s, ""%d"", (note / 12)-1);     return  name;}",2,"cwe119,cwe120"
"ast_expr_init(struct ast_node *expr, ast_node_t type, const char *str){tint ret = 0;tswitch (type) {tcase AST_EX_OFFSET:ttstr++;  tcase AST_EX_NUMBER:ttret = sscanf(str, ""%""SCNi64, &expr->ast_num);ttif (ret != 1) {tttreturn 1;tt}ttbreak;tcase AST_EX_ID:tcase AST_EX_PATH:tcase AST_EX_STRING:ttexpr->ast_str = strdup(str);ttif (expr->ast_str == NULL) {tttreturn 1;tt}ttbreak;tcase AST_EX_ADDRESS:tcase AST_EX_SUBSCRIPT:tcase AST_EX_BLOCKSPEC:tcase AST_EX_STRUCTSPEC:tcase AST_EX_FIELDSPEC:tcase AST_EX_TYPESPEC:tcase AST_KW_STATE:ttbreak;tdefault:tterrno = EINVAL;ttreturn 1;t}treturn 0;}",2,"cwe120,cweother"
"wi_string_write_to_file(wi_string_t *string, wi_string_t *path) {tFILEt*fp;tchartfullpath[WI_PATH_SIZE];ttsnprintf(fullpath, sizeof(fullpath), ""%s~"", path->string);tfp = fopen(fullpath, ""w"");tif(!fp) {ttwi_error_set_errno(errno);ttreturn false;t}ttfprintf(fp, ""%s"", string->string);tfclose(fp);ttif(rename(fullpath, path->string) < 0) {ttwi_error_set_errno(errno);tt(void) unlink(fullpath);ttttreturn false;t}ttreturn true;}",3,"cwe119,cwe120,cweother"
"read_heading(FILE *fp){  char line[BUF_MAX], *s;     String_buf sb = get_string_buf();  int i = 0;  s = fgets(line, BUF_MAX, fp);  while (s && !substring(""= end of head ="", s)) {    if (i != 0) {      sb_append(sb, s);    }    i++;    s = fgets(line, BUF_MAX, fp);  }  if (!s)    fatal_error(""read_heading, ""= end of head ="" not found"");  return sb;}",2,"cwe119,cwe120"
"__ecereMethod___ecereNameSpace__ecere__sys__File_OnGetDataFromString(struct __ecereNameSpace__ecere__com__Class * class, struct __ecereNameSpace__ecere__com__Instance ** this, char * string){struct __ecereNameSpace__ecere__sys__File * __ecerePointer___ecereNameSpace__ecere__sys__File = (struct __ecereNameSpace__ecere__sys__File *)(this ? (((char *)this) + __ecereClass___ecereNameSpace__ecere__sys__File->offset) : 0);if(!string[0]){(*this) = (((void *)0));return 0x1;}else{struct __ecereNameSpace__ecere__com__Instance * f = __ecereNameSpace__ecere__sys__FileOpen(string, 1);if(f){(*this) = __ecereNameSpace__ecere__com__eInstance_New(__ecereClass___ecereNameSpace__ecere__sys__TempFile);while(!((unsigned int (*)(struct __ecereNameSpace__ecere__com__Instance *))__extension__ ({struct __ecereNameSpace__ecere__com__Instance * __internal_ClassInst = f;__internal_ClassInst ? __internal_ClassInst->_vTbl : __ecereClass___ecereNameSpace__ecere__sys__File->_vTbl;})[__ecereVMethodID___ecereNameSpace__ecere__sys__File_Eof])(f)){unsigned char buffer[4096];unsigned int read = ((int (*)(struct __ecereNameSpace__ecere__com__Instance *, void *  buffer, unsigned int size, unsigned int count))__extension__ ({struct __ecereNameSpace__ecere__com__Instance * __internal_ClassInst = f;__internal_ClassInst ? __internal_ClassInst->_vTbl : __ecereClass___ecereNameSpace__ecere__sys__File->_vTbl;})[__ecereVMethodID___ecereNameSpace__ecere__sys__File_Read])(f, buffer, 1, sizeof buffer);((int (*)(struct __ecereNameSpace__ecere__com__Instance *, void *  buffer, unsigned int size, unsigned int count))__extension__ ({struct __ecereNameSpace__ecere__com__Instance * __internal_ClassInst = (*this);__internal_ClassInst ? __internal_ClassInst->_vTbl : class->_vTbl;})[__ecereVMethodID___ecereNameSpace__ecere__sys__File_Write])((*this), buffer, 1, read);}(__ecereNameSpace__ecere__com__eInstance_DecRef(f), f = 0);return 0x1;}}return 0x0;}",4,"cwe119,cwe120,cwe469,cweother"
"ipr_ioafp_page0_inquiry(struct ipr_cmnd *ipr_cmd){tstruct ipr_ioa_cfg *ioa_cfg = ipr_cmd->ioa_cfg;tchar type[5];tENTER;t tmemcpy(type, ioa_cfg->vpd_cbs->ioa_vpd.std_inq_data.vpids.product_id, 4);ttype[4] = '0';tioa_cfg->type = simple_strtoul((char *)type, NULL, 16);tif (ipr_invalid_adapter(ioa_cfg)) {ttdev_err(&ioa_cfg->pdev->dev,ttt""Adapter not supported in this hardware configuration."");ttif (!ipr_testmode) {tttioa_cfg->reset_retries += IPR_NUM_RESET_RELOAD_RETRIES;tttipr_initiate_ioa_reset(ioa_cfg, IPR_SHUTDOWN_NONE);tttlist_add_tail(&ipr_cmd->queue,ttttt&ioa_cfg->hrrq->hrrq_free_q);tttreturn IPR_RC_JOB_RETURN;tt}t}tipr_cmd->job_step = ipr_ioafp_page3_inquiry;tipr_ioafp_inquiry(ipr_cmd, 1, 0,ttt  ioa_cfg->vpd_cbs_dma + offsetof(struct ipr_misc_cbs, page0_data),ttt  sizeof(struct ipr_inquiry_page0));tLEAVE;treturn IPR_RC_JOB_RETURN;}",2,"cwe119,cwe120"
"converter_type_move_on(ob_methods *context, object *trap, object *victim, object *originator) {    if (common_pre_ob_move_on(trap, victim, originator) == METHOD_ERROR)        return METHOD_OK;    if (convert_item(victim, trap) < 0) {        object *op;        char name[MAX_BUF];        query_name(trap, name, MAX_BUF);        draw_ext_info_format(NDI_UNIQUE, 0, originator, MSG_TYPE_APPLY, MSG_TYPE_APPLY_FAILURE,            ""The %s seems to be broken!"", name);        op = create_archetype(""burnout"");        if (op != NULL)            object_insert_in_map_at(op, trap->map, trap, 0, trap->x, trap->y);    }    common_post_ob_move_on(trap, victim, originator);    return METHOD_OK;}",2,"cwe119,cwe120"
"ipoe_nl_add_vlan_mon_vid(int ifindex, int vid){tstruct rtnl_handle rth;tstruct nlmsghdr *nlh;tstruct genlmsghdr *ghdr;tstruct {ttstruct nlmsghdr n;ttchar buf[1024];t} req;tint r = 0;ttif (rtnl_open_byproto(&rth, 0, NETLINK_GENERIC)) {ttlog_error(""ipoe: cannot open generic netlink socket"");ttreturn -1;t}ttnlh = &req.n;tnlh->nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);tnlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;tnlh->nlmsg_type = ipoe_genl_id;tghdr = NLMSG_DATA(&req.n);tghdr->cmd = IPOE_CMD_ADD_VLAN_MON_VID;taddattr32(nlh, 1024, IPOE_ATTR_IFINDEX, ifindex);taddattr32(nlh, 1024, IPOE_ATTR_ADDR, vid);tif (rtnl_talk(&rth, nlh, 0, 0, nlh, NULL, NULL, 0) < 0 ) {ttlog_error(""ipoe: nl_add_vlan_mon_vid: error talking to kernel"");ttr = -1;t}ttrtnl_close(&rth);treturn r;}",2,"cwe119,cwe120"
"__rd_ialine(void){ int32 len, totlen, osize, intr_num; char *chp; FILE *f;rd_again: __iahwrkline[0] = '0'; if (__cmd_s != NULL) { f = __cmd_s; __lin_cnt++; } else f = stdin; if (feof(f)) return(TEOF); for (totlen = 0;;)  {       chp = &(__iahwrkline[totlen]);           intr_num = 0;again2:     clearerr(f);   if (fgets(chp, IDLEN + 1, f) == NULL)    {     if (++intr_num >= 512)      {       __ia_err(1450,        ""interactive input call interrupted %d consecutive times - assuming EOF"",        intr_num);        break;      }     if (!feof(f) && errno == EINTR) goto again2;     if (feof(f) && errno == EINTR)      {       __ia_warn(1603,        ""interactive input call interrupted (but EOF also seen?) - trying again"");       goto again2;      }     if (ferror(f))      {       __ia_err(1460,        ""interactive input call failed because: [%s] - assuming EOF"",         strerror(errno));      }     break;    }   if (__pending_enter_iact && __iact_reason == IAER_CTRLC)    {     __pending_enter_iact = FALSE;     __iact_reason = IAER_UNKN;          if (__cmd_s == NULL) goto rd_again;            __ia_err(1457,      ""interactive $input file processing terminated by interrupt (^c)"");     totlen = 0;     __iahwrkline[0] = '0';     return(TEOF);    }   len = strlen(chp);   if (len >= IDLEN)     {     __ia_err(1402, ""interactive line too long (%d) - truncated"", IDLEN - 1);     chp[IDLEN - 1] = '0';       break;    }   totlen += len;       if (chp[len - 2] != '') break;       if (totlen >= __iahwrklen - IDLEN - 4)      {     osize = __iahwrklen;     __iahwrklen += IDLEN + 4;     __iahwrkline = __my_realloc(__iahwrkline, osize, __iahwrklen);    }      } if (totlen == 0) return(TEOF);   if (__echo_iactcmds_tolog && __log_s != NULL)  __my_fprintf(__log_s, ""%s"", __iahwrkline);      __iahwrkline[totlen - 1] = ' ';  return(TOK_NONE);}",2,"cwe119,cwe120"
"Credit(int fd, unsigned char socketID, int credit){   int rd;   unsigned char buf[100];   unsigned char rBuf[100];   cmdHeader_t *cmd = (cmdHeader_t*)buf;   cmd->psid     = 0;   cmd->ssid     = 0;   cmd->lengthH  = 0;   cmd->lengthL  = 0x0b;   cmd->credit   = 1;   cmd->control  = 0;   cmd->command  = 0x03;   buf[sizeof(cmdHeader_t)+0] = socketID;   buf[sizeof(cmdHeader_t)+1] = socketID;   buf[sizeof(cmdHeader_t)+2] = credit >> 8;   buf[sizeof(cmdHeader_t)+3] = credit & 0xff;   rd = sendReceiveCmd(fd, buf, 11, rBuf, 10, 0);   if ( rd == 10 )   {      return 1;   }   else   {      return 0;   }}",2,"cwe119,cwe120"
"pg_fe_getauthname(PQExpBuffer errorMessage){tchart   *result = NULL;tconst char *name = NULL;#ifdef WIN32t tcharttusername[256 + 1];tDWORDttnamesize = sizeof(username);#elsetuid_tttuser_id = geteuid();tcharttpwdbuf[BUFSIZ];tstruct passwd pwdstr;tstruct passwd *pw = NULL;tinttttpwerr;#endift tpglock_thread();#ifdef WIN32tif (GetUserName(username, &namesize))ttname = username;telse if (errorMessage)ttprintfPQExpBuffer(errorMessage,tttt libpq_gettext(""user name lookup failure: error code %lu""),tttttt  GetLastError());#elsetpwerr = pqGetpwuid(user_id, &pwdstr, pwdbuf, sizeof(pwdbuf), &pw);tif (pw != NULL)ttname = pw->pw_name;telse if (errorMessage)t{ttif (pwerr != 0)tttprintfPQExpBuffer(errorMessage,tttt   libpq_gettext(""could not look up local user ID %d: %s""),ttttttt  (int) user_id,ttttttt  pqStrerror(pwerr, pwdbuf, sizeof(pwdbuf)));ttelsetttprintfPQExpBuffer(errorMessage,ttttt libpq_gettext(""local user with ID %d does not exist""),ttttttt  (int) user_id);t}#endiftif (name)t{ttresult = strdup(name);ttif (result == NULL && errorMessage)tttprintfPQExpBuffer(errorMessage,ttttttt  libpq_gettext(""out of memory""));t}tpgunlock_thread();treturn result;}",2,"cwe119,cwe120"
cpp_token_len (const cpp_token *token){  unsigned int len;  switch (TOKEN_SPELL (token))    {    default:ttlen = 4;ttttbreak;    case SPELL_LITERAL:tlen = token->val.str.len;ttbreak;    case SPELL_IDENT:tlen = NODE_LEN (token->val.node);tbreak;    }  return len;},2,"cwe119,cwe120"
"storeUfsDirCreateSwapSubDirs(SwapDir * sd){    ufsinfo_t *ufsinfo = (ufsinfo_t *) sd->fsdata;    int i, k;    int should_exist;    LOCAL_ARRAY(char, name, MAXPATHLEN);    for (i = 0; i < ufsinfo->l1; i++) {tsnprintf(name, MAXPATHLEN, ""%s/%02X"", sd->path, i);tif (storeUfsDirCreateDirectory(name, 0))t    should_exist = 0;telset    should_exist = 1;tdebug(47, 1) (""Making directories in %s"", name);tfor (k = 0; k < ufsinfo->l2; k++) {t    snprintf(name, MAXPATHLEN, ""%s/%02X/%02X"", sd->path, i, k);t    storeUfsDirCreateDirectory(name, should_exist);t}    }}",2,"cwe120,cweother"
"generate_rsa_key(char** keyfile){  int key_length, home_length;  RSA* rsa_key;  FILE* rsa_file;  struct stat buf;  assert(keyfile != NULL);  assert((*keyfile) != NULL);     if (stat(*keyfile, &buf) == 0) {    return 0;  }     key_length = strlen(*keyfile);  home_length = strlen(home_dir);  if (home_dir_key) {    free(home_dir_key);    home_dir_key = NULL;  }  home_dir_key = calloc(1, home_length + key_length + 2);  if (home_dir_key == NULL) {    return 1;    }  strcpy(home_dir_key, home_dir);  home_dir_key[home_length] = '/';  strcpy(&home_dir_key[home_length+1], *keyfile);  *keyfile = home_dir_key;  if (stat(home_dir_key, &buf) == 0) {    return 0;  }     printf(""generating rsa key: 2048 bits"");  rsa_key = RSA_generate_key(2048, 65537, callback, NULL);  if (RSA_check_key(rsa_key)==1) {    printf(""   OK!"");  }  else {    printf(""   FAILED!"");    return 1;  }  rsa_file = fopen(home_dir_key, ""a"");  PEM_write_RSAPrivateKey(rsa_file, rsa_key, NULL, NULL, 0, NULL, NULL);  fclose(rsa_file);  return 0;}",2,"cwe120,cweother"
"fscheck_volume_read(volume * vol, hfsp_vh* vh, UInt32 block){    char buf[vol->blksize];    if (volume_readinbuf(vol, buf, block))treturn -1;    return fscheck_volume_readbuf(vol, vh, buf);}",2,"cwe119,cwe120"
"process_file (const char *file_name){  FILE * file;  char armag[SARMAG];  int ret;  if (check_file (file_name, NULL))    return 1;  file = fopen (file_name, ""r+b"");  if (file == NULL)    {      error (_(""Input file '%s' is not readable""), file_name);      return 1;    }  if (fread (armag, SARMAG, 1, file) != 1)    {      error (_(""%s: Failed to read file's magic number""),tt file_name);      fclose (file);      return 1;    }  if (memcmp (armag, ARMAG, SARMAG) == 0)    ret = process_archive (file_name, file, FALSE);  else if (memcmp (armag, ARMAGT, SARMAG) == 0)    ret = process_archive (file_name, file, TRUE);  else    {      rewind (file);      archive_file_size = archive_file_offset = 0;      ret = process_object (file_name, file);    }  fclose (file);  return ret;}",3,"cwe119,cwe120,cweother"
"iax2_exec(struct ast_channel *chan, const char *context, const char *exten, int priority, const char *callerid, const char *data){tchar odata[256];tchar req[256];tchar *ncontext;tstruct iax2_dpcache *dp = NULL;tstruct ast_app *dial = NULL;#if 0tast_log(LOG_NOTICE, ""iax2_exec: con: %s, exten: %s, pri: %d, cid: %s, data: %s, newstack: %d"", context, exten, priority, callerid ? callerid : ""<unknown>"", data, newstack);#endiftif (priority == 2) {tt ttconst char *dialstatus = pbx_builtin_getvar_helper(chan, ""DIALSTATUS"");ttif (dialstatus) {tttdial = pbx_findapp(dialstatus);tttif (dial) ttttpbx_exec(chan, dial, """");tt}ttreturn -1;t} else if (priority != 1)ttreturn -1;tAST_LIST_LOCK(&dpcache);tif ((dp = find_cache(chan, data, context, exten, priority))) {ttif (dp->flags & CACHE_FLAG_EXISTS) {tttast_copy_string(odata, data, sizeof(odata));tttncontext = strchr(odata, '/');tttif (ncontext) {tttt*ncontext = '0';ttttncontext++;ttttsnprintf(req, sizeof(req), ""IAX2/%s/%s@%s"", odata, exten, ncontext);ttt} else {ttttsnprintf(req, sizeof(req), ""IAX2/%s/%s"", odata, exten);ttt}tttast_verb(3, ""Executing Dial('%s')"", req);tt} else {tttAST_LIST_UNLOCK(&dpcache);tttast_log(LOG_WARNING, ""Can't execute nonexistent extension '%s[@%s]' in data '%s'"", exten, context, data);tttreturn -1;tt}t}tAST_LIST_UNLOCK(&dpcache);tif ((dial = pbx_findapp(""Dial"")))ttreturn pbx_exec(chan, dial, req);telsettast_log(LOG_WARNING, ""No dial application registered"");treturn -1;}",2,"cwe119,cwe120"
"dump_config_info(void){ char typ[RECLEN]; struct cfg_t *cfgp; struct cfgdes_t *desp; struct cfgrule_t *rulp; struct cfgnamlst_t *cnlp; __cv_msg(""  DUMPING CONFIG INFORMAION:""); dump_lib_expand(); for (cfgp = __cfg_hd; cfgp != NULL; cfgp = cfgp->cfgnxt)  {   __cv_msg(""    Config %s in %s lineno %d "", cfgp->cfgnam, cfgp->cfg_fnam,     cfgp->cfg_lno);       for (desp = cfgp->cfgdeslist; desp != NULL; desp = desp->desnxt)    {     __cv_msg(""      Design %s "", desp->deslbnam);     }       if (cfgp->cfgdflt != NULL) __cv_msg(""    Default rule:"");    rulp = cfgp->cfgdflt;   for (cnlp = rulp->rul_libs; cnlp != NULL; cnlp = cnlp->cnlnxt)    {     __cv_msg(""      %s "", cnlp->nam);     }       for (rulp = cfgp->cfgrules; rulp != NULL; rulp = rulp->rulnxt)    {     __cv_msg(""    Rule "");      if (rulp->rultyp == CFG_INSTANCE)        strcpy(typ, ""Instance"");     else        strcpy(typ, ""Cell"");     if (rulp->use_rule_cfg)       __cv_msg(""      %s %s using hierarchical config : %s"",          typ, rulp->objnam, rulp->rul_use_celnam);      else if (rulp->is_use)        __cv_msg(""      %s %s use %s.%s"", rulp->objnam,           typ, rulp->rul_use_libnam, rulp->rul_use_celnam);      else      {       __cv_msg(""      %s %s liblist:"", typ, rulp->objnam);        for (cnlp = rulp->rul_libs; cnlp != NULL; cnlp = cnlp->cnlnxt)        {         __cv_msg(""       %s "", cnlp->nam);         }      }    }  } __cv_msg(""  END CONFIG DUMP"");}",2,"cwe119,cwe120"
"_printXDot(xdot * x, pf print, void *info, print_op ofn){    int i;    xdot_op *op;    char *base = (char *) (x->ops);    for (i = 0; i < x->cnt; i++) {top = (xdot_op *) (base + i * x->sz);tofn(op, print, info, (i < x->cnt - 1));    }}",2,"cwe119,cwe120"
"skipf(FILE *fp, long count, const char *filename){    int             c;    while (count > 0)    {        c = getc(fp);        if (c == EOF)        {            if (ferror(fp))            {                sub_context_ty  *scp;                scp = sub_context_new();                sub_errno_set(scp);                sub_var_set_charstar(scp, ""File_Name"", filename);                fatal_intl(scp, i18n(""read ""$filename"": $errno""));            }            return -1;        }        if (c == '')            --count;    }    return 0;}",2,"cwe120,cweother"
"start_file(MainInfo *min, const gchar *cmd){tgchart*argv[] = { ""file"", ""file"", ""-n"", ""-f"", ""-"", NULL };tGPidtchild;tGErrort*err = NULL;tif(g_spawn_async_with_pipes(NULL, argv, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, &child, &file_info.file_in, &file_info.file_out, NULL, &err))t{ttchd_register(""file"", child, CGF_RUNINBG, 0);t}telset{ttgchartbuf[1024];ttg_snprintf(buf, sizeof buf, ""Couldn't run the 'file' command:%s"", err->message);ttdlg_dialog_async_new_error(buf);ttg_error_free(err);t}}",2,"cwe120,cweother"
"savec(int utf8,unsigned char **pieces, int n, int c){tunsigned char buf[16];tint len;tunsigned char *s = NULL;tif (utf8)ttlen = utf8_encode(buf,c);telse {ttbuf[0] = c;ttlen = 1;t}tif (pieces[n])ttvsrm(pieces[n]);ts = vsncpy(s, 0, buf, len);tpieces[n] = s;}",2,"cwe119,cwe120"
"GMT_load_user_media (void) {t tGMT_LONG n = 0, n_alloc = 0;tdouble w, h;tchar line[BUFSIZ], file[BUFSIZ], media[GMT_TEXT_LEN];tFILE *fp = NULL;tGMT_getsharepath (""conf"", ""gmt_custom_media"", "".conf"", file);tif ((fp = fopen (file, ""r"")) == NULL) return (0);tGMT_set_meminc (GMT_TINY_CHUNK);t twhile (fgets (line, BUFSIZ, fp)) {ttif (line[0] == '#' || line[0] == '') continue;t ttif (sscanf (line, ""%s %lg %lg"", media, &w, &h) != 3) {tttfprintf (stderr, ""%s: Error decoding file %s.  Bad format? [%s]"", GMT_program, file, line);tttGMT_exit (EXIT_FAILURE);tt}ttGMT_str_tolower (media);t ttif (n == n_alloc) {ttt(void)GMT_alloc_memory ((void **)&GMT_user_media, n, n_alloc, sizeof (struct GMT_MEDIA), GMT_program);tttn_alloc = GMT_alloc_memory ((void **)&GMT_user_media_name, n, n_alloc, sizeof (char *), GMT_program);tt}ttGMT_user_media_name[n] = strdup (media);ttGMT_user_media[n].width  = w;ttGMT_user_media[n].height = h;ttn++;t}tfclose (fp);tt(void)GMT_alloc_memory ((void **)&GMT_user_media, 0, n, sizeof (struct GMT_MEDIA), GMT_program);t(void)GMT_alloc_memory ((void **)&GMT_user_media_name, 0, n, sizeof (char *), GMT_program);tGMT_reset_meminc ();treturn (n);}",2,"cwe469,cweother"
"test_man_incr_insert_remove(hid_t fapl, H5HF_create_t *cparam, fheap_test_param_t *tparam){    hid_ttfile = -1;                   hid_t       dxpl = H5P_DATASET_XFER_DEFAULT;          chartfilename[FHEAP_FILENAME_LEN];              H5F_tt*f = NULL;                   H5HF_t      *fh = NULL;                  haddr_t     fh_addr;                     unsigned char heap_id[100][MAX_HEAP_ID_LEN];      struct a_type_t1 {        char a[10];        char b[29];    } obj1, obj2;                            size_t      id_len;                      fheap_heap_state_t state;                int i, j;         h5_fixname(FILENAME[0], fapl, filename, sizeof(filename));         if((file = H5Fcreate(filename, H5F_ACC_TRUNC, H5P_DEFAULT, fapl)) < 0)        FAIL_STACK_ERROR         if(NULL == (f = (H5F_t *)H5I_object(file)))        STACK_ERROR         if(NULL == (fh = H5HF_create(f, dxpl, cparam)))        FAIL_STACK_ERROR    if(H5HF_get_id_len(fh, &id_len) < 0)        FAIL_STACK_ERROR    if(id_len > HEAP_ID_LEN)        FAIL_STACK_ERROR    if(H5HF_get_heap_addr(fh, &fh_addr) < 0)        FAIL_STACK_ERROR    if(!H5F_addr_defined(fh_addr))        FAIL_STACK_ERROR    HDmemset(&state, 0, sizeof(fheap_heap_state_t));    if(check_stats(fh, &state))        FAIL_STACK_ERROR         TESTING(""incremental object insertion and removal"")    for(i = 0; i < 100; i++) {        sprintf(obj1.b, ""%s%d"", ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"", i);        for(j = 0; j < i; j++) {            sprintf(obj2.b, ""%s%d"", ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"", j);            if(H5HF_remove(fh, dxpl, heap_id[j]) < 0)                FAIL_STACK_ERROR            if(H5HF_insert(fh, dxpl, (sizeof(obj2)), &obj2, heap_id[j]) < 0)                FAIL_STACK_ERROR        }                   if(reopen_heap(f, dxpl, &fh, fh_addr, tparam) < 0)            TEST_ERROR                 HDmemset(heap_id[i], 0, id_len);        if(H5HF_insert(fh, dxpl, (sizeof(obj1)), &obj1, heap_id[i]) < 0)            FAIL_STACK_ERROR    }                if(H5HF_close(fh, dxpl) < 0)        TEST_ERROR         if(H5Fclose(file) < 0)        TEST_ERROR         PASSED()    return(0);error:    H5E_BEGIN_TRY {        if(fh)            H5HF_close(fh, dxpl);tH5Fclose(file);    } H5E_END_TRY;    return(1);}",2,"cwe119,cwe120"
"sendForm(_WebClientConnection* cc, string_t* content, boolean_t cookie){    string_t* header = stringNew(""HTTP/1.1 200 OKr"");    if (cc->runMode == SERVER_CMXML) {        stringAppend(header, ""Content-type: text/xml; charset=UTF-8rConnection: closer"");    } else {        stringAppend(header, ""Content-type: text/htmlrCache-Control: no-cache, must-revalidater"");    }    if (cc->conn->refreshPage > 0) {        stringAppend(header, ""Refresh: "");        char num[16];        sprintf(num,""%d"", cc->conn->refreshPage);        stringAppend(header, num);        stringAppend(header, ""; url="");        addLink(cc->conn->serverIP, header, cc->serverPort, BOOL_YES);        stringAppend(header, ""r"");    } else {        if (cc->runMode == SERVER_CMXML) {            stringAppend(header, ""Expires: -1r"");        }    }    sendData(cc, header->str);         stringFree(header, BOOL_YES);    if (cookie) {        sendCookie(cc);    }    sendData(cc, ""r"");    sendData(cc, content->str);     }",2,"cwe119,cwe120"
"ParseFile(const char * name, BOOL isOptional){tFILE *ttfp;tchar *ttcp;tchar *ttcmd;tBOOLttstatus;tMACRO_TYPEtmacroType;tstatus = TRUE;t tif (isOptional && (access(name, F_OK) != 0) && (errno == ENOENT))ttreturn TRUE;t tif (access(name, R_OK) != 0)t{ttfprintf(stderr, ""Cannot access ""%s"" for reading: %s"",tttname, strerror(errno));ttreturn FALSE;t}tfp = fopen(name, ""r"");tif (fp == NULL)t{ttfprintf(stderr, ""Cannot open ""%s"" for reading: %s"",tttname, strerror(errno));ttreturn FALSE;t}t tcmd = ReadLine(fp);tif ((cmd == NULL) || (strcmp(cmd, FIRST_LINE) != 0))t{ttfclose(fp);ttfprintf(stderr,ttt""The file ""%s"" does not begin with ""%s""."",tttname, FIRST_LINE);ttreturn FALSE;t}t twhile (TRUE)t{ttcmd = ReadLine(fp);ttif (cmd == NULL)tttbreak;ttwhile (isBlank(*cmd))tttcmd++;tt ttif ((*cmd == '#') || (*cmd == '0'))tttcontinue;ttcp = cmd;ttwhile ((*cp != '0') && !isBlank(*cp))tttcp++;ttif (*cp)ttt*cp++ = '0';ttwhile (isBlank(*cp))tttcp++;tt ttmacroType = MACRO_TYPE_NONE;ttif (strcmp(cmd, ""option"") == 0)tttmacroType = MACRO_TYPE_OPTION;ttelse if (strcmp(cmd, ""column"") == 0)tttmacroType = MACRO_TYPE_COLUMN;ttelse if (strcmp(cmd, ""expr"") == 0)tttmacroType = MACRO_TYPE_EXPRESSION;ttif (macroType != MACRO_TYPE_NONE)tt{tttcmd = cp;tttwhile ((*cp != '0') && !isBlank(*cp))ttttcp++;tttif (*cp)tttt*cp++ = '0';tttwhile (isBlank(*cp))ttttcp++;tttif (!DefineMacro(macroType, cmd, cp))ttttstatus = FALSE;tttcontinue;tt}tt ttfprintf(stderr, ""%s: Unknown command ""%s"""", name, cmd);ttstatus = FALSE;ttbreak;t}tif (ferror(fp))t{ttfprintf(stderr, ""Error reading ""%s"": %s"", name,tttstrerror(errno));ttfclose(fp);ttreturn FALSE;t}t(void) fclose(fp);treturn status;}",2,"cwe469,cweother"
"get_privs(void *opt, int argc, char **argv){    uint32_t privs;    char str[128];    kadm5_ret_t ret;    ret = kadm5_get_privs(kadm_handle, &privs);    if(ret)tkrb5_warn(context, ret, ""kadm5_get_privs"");    else{tret =_kadm5_privs_to_string(privs, str, sizeof(str));tif (ret == 0)t    printf(""%s"", str);telset    printf(""privs: 0x%x"", (unsigned int)privs);    }    return 0;}",2,"cwe119,cwe120"
"""AddDefinitions(ImageInfo *image_info,const char *definitions,  ExceptionInfo *exception){  char    key[MaxTextExtent],    value[MaxTextExtent];  MagickPassFail    status;  unsigned int    i,    j;  size_t    length;  status=MagickPass;  if (image_info->definitions == 0)    image_info->definitions=MagickMapAllocateMap(MagickMapCopyString,      MagickMapDeallocateString);  if (image_info->definitions == 0)    return MagickFail;  length=strlen(definitions);  i=0;  while (i < length)  {    unsigned int      has_value;    for (j=0; (i < length) && (definitions[i] != '=') && (definitions[i] != ','); i++,j++)      key[j]=definitions[i];    key[j]='0';    has_value=(i < length) && (definitions[i] == '='); /* Could be 0-length value */    i++;    j=0;    if (has_value)      {        for (; (i < length) && (definitions[i] != ','); i++,j++)          value[j]=definitions[i];        i++;      }    value[j]='0';    if (strlen(key) != 0)      {        status &= MagickMapAddEntry((MagickMap) image_info->definitions,key,value,0,exception);      }    else      {        status=MagickFail;        break;      }  }  return(status);}""",2,"cwe119,cwe120"
"g_mime_stream_write_to_stream (GMimeStream *src, GMimeStream *dest){tssize_t nread, nwritten, total = 0;tchar buf[4096];ttg_return_val_if_fail (GMIME_IS_STREAM (src), -1);tg_return_val_if_fail (GMIME_IS_STREAM (dest), -1);ttwhile (!g_mime_stream_eos (src)) {ttif ((nread = g_mime_stream_read (src, buf, sizeof (buf))) < 0)tttreturn -1;ttttif (nread > 0) {tttnwritten = 0;tttwhile (nwritten < nread) {ttttssize_t len;ttttttttif ((len = g_mime_stream_write (dest, buf + nwritten, nread - nwritten)) < 0)tttttreturn -1;ttttttttnwritten += len;ttt}tttttttotal += nwritten;tt}t}ttreturn total;}",2,"cwe119,cwe120"
"cli_uuencode(const char *dir, fmap_t *map){tmessage *m;tchar buffer[RFC2821LENGTH + 1];tsize_t at = 0;tif(!fmap_gets(map, buffer, &at, sizeof(buffer) - 1)) {tt ttreturn CL_CLEAN;t}tif(!isuuencodebegin(buffer)) {ttcli_dbgmsg(""Message is not in uuencoded format"");ttreturn CL_EFORMAT;t}tm = messageCreate();tif(m == NULL) {ttreturn CL_EMEM;t}tcli_dbgmsg(""found uuencode file"");tif(uudecodeFile(m, buffer, dir, map, &at) < 0) {ttmessageDestroy(m);ttcli_dbgmsg(""Message is not in uuencoded format"");ttreturn CL_EFORMAT;t}tmessageDestroy(m);treturn CL_CLEAN;t }",2,"cwe119,cwe120"
"read_config (void){  char config_line[PATH_MAX];  const char *optval;  char *endval;  long val;  FILE *fp;  int len;  DBG (DBG_INFO, ""read_config: searching for config file"");  fp = sanei_config_open (SANED_CONFIG_FILE);  if (fp)    {      while (sanei_config_read (config_line, sizeof (config_line), fp))        {          if (config_line[0] == '#')            continue;            t  optval = strchr (config_line, '=');t  if (optval == NULL)t    continue;                      len = strlen (config_line);          if (!len)            continue;                                 if (strstr(config_line, ""data_portrange"") != NULL)            {              optval = sanei_config_skip_whitespace (++optval);              if ((optval != NULL) && (*optval != '0'))                {tt  val = strtol (optval, &endval, 10);tt  if (optval == endval)tt    {tt      DBG (DBG_ERR, ""read_config: invalid value for data_portrange"");tt      continue;tt    }tt  else if ((val < 0) || (val > 65535))tt    {tt      DBG (DBG_ERR, ""read_config: data_portrange start port is invalid"");tt      continue;tt    }tt  optval = strchr (endval, '-');tt  if (optval == NULL)tt    {tt      DBG (DBG_ERR, ""read_config: no end port value for data_portrange"");tt      continue;tt    }tt  optval = sanei_config_skip_whitespace (++optval);tt  data_port_lo = val;tt  val = strtol (optval, &endval, 10);tt  if (optval == endval)tt    {tt      DBG (DBG_ERR, ""read_config: invalid value for data_portrange"");tt      data_port_lo = 0;tt      continue;tt    }tt  else if ((val < 0) || (val > 65535))tt    {tt      DBG (DBG_ERR, ""read_config: data_portrange end port is invalid"");tt      data_port_lo = 0;tt      continue;tt    }tt  else if (val < data_port_lo)tt    {tt      DBG (DBG_ERR, ""read_config: data_portrange end port is less than start port"");tt      data_port_lo = 0;tt      continue;tt    }tt  data_port_hi = val;                  DBG (DBG_INFO, ""read_config: data port range: %d - %d"", data_port_lo, data_port_hi);                }            }        }      fclose (fp);      DBG (DBG_INFO, ""read_config: done reading config"");    }  else    DBG (DBG_ERR, ""read_config: could not open config file (%s): %s"",t SANED_CONFIG_FILE, strerror (errno));}",2,"cwe119,cwe120"
"cli_xml_output_vol_status_clients (xmlTextWriterPtr writer, dict_t *dict,                                   int brick_index){        int             ret = -1;        int             client_count = 0;        char            *hostname = NULL;        uint64_t        bytes_read = 0;        uint64_t        bytes_write = 0;        char            key[1024] = {0,};        int             i = 0;                 ret = xmlTextWriterStartElement (writer, (xmlChar *)""clientsStatus"");        XML_RET_CHECK_AND_GOTO (ret, out);        snprintf (key, sizeof (key), ""brick%d.clientcount"", brick_index);        ret = dict_get_int32 (dict, key, &client_count);        if (ret)                goto out;        ret = xmlTextWriterWriteFormatElement (writer,                                               (xmlChar *)""clientCount"",                                               ""%d"", client_count);        XML_RET_CHECK_AND_GOTO (ret, out);        for (i = 0; i < client_count; i++) {                                 ret = xmlTextWriterStartElement (writer, (xmlChar *)""client"");                XML_RET_CHECK_AND_GOTO (ret, out);                memset (key, 0, sizeof (key));                snprintf (key, sizeof (key), ""brick%d.client%d.hostname"",                          brick_index, i);                ret = dict_get_str (dict, key, &hostname);                if (ret)                        goto out;                ret = xmlTextWriterWriteFormatElement (writer,                                                       (xmlChar *)""hostname"",                                                       ""%s"", hostname);                XML_RET_CHECK_AND_GOTO (ret, out);                memset (key, 0, sizeof (key));                snprintf (key, sizeof (key), ""brick%d.client%d.bytesread"",                          brick_index, i);                ret = dict_get_uint64 (dict, key, &bytes_read);                if (ret)                        goto out;                ret = xmlTextWriterWriteFormatElement (writer,                                                       (xmlChar *)""bytesRead"",                                                       ""%""PRIu64, bytes_read);                XML_RET_CHECK_AND_GOTO (ret, out);                memset (key, 0, sizeof (key));                snprintf (key, sizeof (key), ""brick%d.client%d.byteswrite"",                          brick_index, i);                ret = dict_get_uint64 (dict, key, &bytes_write);                if (ret)                        goto out;                ret = xmlTextWriterWriteFormatElement (writer,                                                       (xmlChar *)""bytesWrite"",                                                       ""%""PRIu64, bytes_write);                XML_RET_CHECK_AND_GOTO (ret, out);                                 ret = xmlTextWriterEndElement (writer);                XML_RET_CHECK_AND_GOTO (ret, out);        }                 ret = xmlTextWriterEndElement (writer);        XML_RET_CHECK_AND_GOTO (ret, out);out:        gf_log (""cli"", GF_LOG_DEBUG, ""Returning %d"", ret);        return ret;}",2,"cwe119,cwe120"
"vendor_mac_passthru_addr_read(struct r8152 *tp, struct sockaddr *sa){tacpi_status status;tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };tunion acpi_object *obj;tint ret = -EINVAL;tu32 ocp_data;tunsigned char buf[6];t tocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0);tif ((ocp_data & AD_MASK) != 0x1000)ttreturn -ENODEV;t tocp_data = ocp_read_byte(tp, MCU_TYPE_USB, EFUSE);tif ((ocp_data & PASS_THRU_MASK) != 1)ttreturn -ENODEV;t tstatus = acpi_evaluate_object(NULL, ""_SB.AMAC"", NULL, &buffer);tobj = (union acpi_object *)buffer.pointer;tif (!ACPI_SUCCESS(status))ttreturn -ENODEV;tif (obj->type != ACPI_TYPE_BUFFER || obj->string.length != 0x17) {ttnetif_warn(tp, probe, tp->netdev,ttt   ""Invalid buffer when reading pass-thru MAC addr: ""ttt   ""(%d, %d)"",ttt   obj->type, obj->string.length);ttgoto amacout;t}tif (strncmp(obj->string.pointer, ""_AUXMAC_#"", 9) != 0 ||t    strncmp(obj->string.pointer + 0x15, ""#"", 1) != 0) {ttnetif_warn(tp, probe, tp->netdev,ttt   ""Invalid header when reading pass-thru MAC addr"");ttgoto amacout;t}tret = hex2bin(buf, obj->string.pointer + 9, 6);tif (!(ret == 0 && is_valid_ether_addr(buf))) {ttnetif_warn(tp, probe, tp->netdev,ttt   ""Invalid MAC when reading pass-thru MAC addr: ""ttt   ""%d, %pM"", ret, buf);ttret = -EINVAL;ttgoto amacout;t}tmemcpy(sa->sa_data, buf, 6);tether_addr_copy(tp->netdev->dev_addr, sa->sa_data);tnetif_info(tp, probe, tp->netdev,tt   ""Using pass-thru MAC addr %pM"", sa->sa_data);amacout:tkfree(obj);treturn ret;}",2,"cwe119,cwe120"
"pcd_ready_wait(struct pcd_unit *cd, int tmo){tchar tr_cmd[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };tint k, p;tk = 0;twhile (k < tmo) {ttcd->last_sense = 0;ttpcd_atapi(cd, tr_cmd, 0, NULL, DBMSG(""test unit ready""));ttp = cd->last_sense;ttif (!p)tttreturn 0;ttif (!(((p & 0xffff) == 0x0402) || ((p & 0xff) == 6)))tttreturn p;ttk++;ttpcd_sleep(HZ);t}treturn 0x000020;t }",2,"cwe119,cwe120"
"decode_addr(const char *asc, struct in_addr *addr){    int a1 = 0, a2 = 0, a3 = 0, a4 = 0;    switch (sscanf(asc, ""%d.%d.%d.%d"", &a1, &a2, &a3, &a4)) {    case 4:ttt tif (!safe_inet_addr(asc, addr)) {t    debug(28, 0) (""decode_addr: unsafe IP address: '%s'"", asc);t    self_destruct();t}tbreak;    case 1:ttt tif (a1 >= 0 && a1 < 33) {t    addr->s_addr = a1 ? htonl(0xfffffffful << (32 - a1)) : 0;t    break;t}    default:tdebug(28, 0) (""decode_addr: Invalid IP address '%s'"", asc);treturn 0;tt     }    return 1;}",2,"cwe120,cweother"
"put_func_declarator(FILE *outf, Declarator * declarator, int commented){    char *s, *t, *decl_text;    int f;    int saveNest = nestedParams;         if ((s = strstr(declarator->text, ""%s"")) == NULL)treturn;    *s = '0';    put_string(outf, declarator->text);         if (declarator->func_stack->func_def == FUNC_NONE) {tdecl_text = declarator->func_stack->text;tif (declarator->name[0] == '0') {t    put_string(outf, decl_text);t} else {t    int star;t     t    if ((t = strstr(decl_text, declarator->name)) == NULL)ttreturn;t    *t = '0';t    star = ((t != decl_text) && (t[-1] == '*'));t    put_string(outf, decl_text);t    *t = declarator->name[0];t     t    f = (declarator == func_declarator) ? format : FMT_OTHER;t    if (strcmp(fmt[f].declarator_prefix, "" "") != 0)ttput_string(outf, fmt[f].declarator_prefix);t     t    if (where == FUNC_PROTO && proto_style == PROTO_ABSTRACT &&ttdeclarator != func_declarator) {ttif (proto_comments) {tt    if (star)tttput_char(outf, ' ');tt    put_string(outf, COMMENT_BEGIN);tt    put_string(outf, declarator->name);tt    put_string(outf, COMMENT_END);tt}t    } else {ttput_string(outf, declarator->name);t    }t     t    put_string(outf, t + strlen(declarator->name));t     t    put_string(outf, fmt[f].declarator_suffix);t}    } else {tput_func_declarator(outf, declarator->func_stack, commented);tnestedParams = 2;t     }    *s = '%';    s += 2;         if ((t = strstr(s, ""()"")) == NULL)treturn;    *t = '0';    put_string(outf, s);    if (where == FUNC_PROTOt&& (func_declarator == declaratort    || func_declarator == declarator->head)t&& proto_macro) {tfprintf(outf, "" %s("", macro_name);    }         put_char(outf, *t++ = PAREN_L);    put_parameters(outf, declarator, commented);    put_string(outf, t);    if (where == FUNC_PROTOt&& (func_declarator == declaratort    || func_declarator == declarator->head)t&& proto_macro) {tput_char(outf, PAREN_R);    }    nestedParams = saveNest;}",2,"cwe469,cweother"
"hawki_images_save(        cpl_frameset                *   allframes,        const cpl_parameterlist     *   parlist,        const cpl_frameset          *   usedframes,        const cpl_image             **  images,        const char                  *   recipe,        const char                  *   procat,        const char                  *   protype,        const cpl_propertylist      *   applist,        const cpl_propertylist      **  applists,        const char                  *   filename){    const char          *   fname ;    cpl_propertylist    *   pro_list ;    cpl_type_bpp            pixeltype ;    cpl_propertylist    *   qc_ext_list ;    char                    sval[16] ;    int                     chip_nb ;    int                     iext;         if (allframes == NULL) return -1 ;         if((fname = hawki_get_extref_file(allframes)) == NULL)    {        cpl_msg_error(__func__, ""Could not find a suitable reference frame"");        return -1;    }         if (applist != NULL) pro_list = cpl_propertylist_duplicate(applist) ;    else pro_list = cpl_propertylist_new() ;    if (protype != NULL)        cpl_propertylist_append_string(pro_list, CPL_DFS_PRO_TYPE, protype) ;    if (procat != NULL)        cpl_propertylist_append_string(pro_list, CPL_DFS_PRO_CATG, procat) ;         if (cpl_dfs_save_image(allframes, NULL, parlist, usedframes, NULL, NULL,                CPL_BPP_IEEE_FLOAT, recipe, pro_list, NULL,                 PACKAGE ""/"" PACKAGE_VERSION,                filename) != CPL_ERROR_NONE) {        cpl_msg_error(__func__, ""Cannot save the empty primary HDU of file %s"",                filename);        cpl_propertylist_delete(pro_list) ;        return -1 ;    }         cpl_propertylist_delete(pro_list) ;         if (cpl_image_get_type(images[0]) == CPL_TYPE_INT)        pixeltype = CPL_BPP_32_SIGNED ;    else        pixeltype = CPL_BPP_IEEE_FLOAT ;         for (iext=0 ; iext<HAWKI_NB_DETECTORS ; iext++) {                 if ((chip_nb = hawki_get_detector_from_ext(fname, iext+1)) == -1) {            cpl_msg_error(__func__, ""Cannot get the chip for extension %d ""                    ""when saving file %s"", iext+1, filename);            return -1 ;        }                 if ((applists != NULL) && (applists[chip_nb-1] != NULL))            qc_ext_list = cpl_propertylist_duplicate(applists[chip_nb-1]) ;        else            qc_ext_list = cpl_propertylist_new() ;        snprintf(sval, 16, ""CHIP%d.INT1"", chip_nb) ;        cpl_propertylist_prepend_string(qc_ext_list, ""EXTNAME"", sval) ;        if(cpl_image_save(images[chip_nb-1], filename,                pixeltype, qc_ext_list, CPL_IO_EXTEND) != CPL_ERROR_NONE)        {            cpl_msg_error(__func__,""Cannot save extension %d of file %s"",                    iext+1, filename);            cpl_propertylist_delete(qc_ext_list);            return -1;        }        cpl_propertylist_delete(qc_ext_list) ;    }    return 0 ;}",2,"cwe119,cwe120"
"has_fstab_option(const char *opt){tstruct mntent *mnt;tstruct mntent mnt_wrk;tchar buf[PATH_MAX * 3];tFILE *tab;tint ret = 0;tif (!opt)ttreturn 0;ttab = open_setmntent_r(_PATH_MNTTAB);tif (!tab) {ttchar *estr = strerror_r(errno, buf, PATH_MAX - 1);ttlogerr(""setmntent: %s"", estr);ttreturn 0;t}twhile ((mnt = getmntent_r(tab, &mnt_wrk, buf, PATH_MAX * 3))) {ttif (hasmntopt(mnt, opt)) {tttret = 1;tttbreak;tt}t}tendmntent(tab);treturn ret;}",3,"cwe119,cwe120,cweother"
"var_defines( const char **e )r{rtfor( ; *e; e++ )rt{rt    const char *val;rrt     rt     rrt    if( !strcmp( *e, ""OS=Windows_NT"" ) )rttcontinue;rrt    rt    if( ( val = strchr( *e, '=' ) ) && val[1] == '(' && val[2] == ')' )rttcontinue;rr# ifdef OS_MACrt     rt     rtrt    if( ( val = strchr( *e, '=' ) ) || ( val = *e + strlen( *e ) ) )r# elsert    if( val = strchr( *e, '=' ) )r# endifrt    {rttLIST *l = L0;rttconst char *pp, *p;r# ifdef OS_MACrttchar split = ',';r# elserttchar split = ' ';tr# endifrttchar buf[ MAXSYM ];rrtt rrttif( val - 4 >= *e )rtt{rtt    if( !strncmp( val - 4, ""PATH"", 4 ) ||rtt        !strncmp( val - 4, ""Path"", 4 ) ||rtt        !strncmp( val - 4, ""path"", 4 ) )rttt    split = SPLITPATH;rtt}rrtt rrttfor( pp = val + 1; p = strchr( pp, split ); pp = p + 1 )rtt{rtt    int  len = p - pp;rrtt    if ( len >= sizeof(buf) )rtt      len = sizeof(buf)-1;rrtt    strncpy( buf, pp, len );rtt    buf[ len ] = '0';rtt    l = list_new( l, buf, 0 );rtt}rrttl = list_new( l, pp, 0 );rrtt rrttstrncpy( buf, *e, val - *e );rttbuf[ val - *e ] = '0';rrttvar_set( buf, l, VAR_SET );rt    }rt}r}",2,"cwe119,cwe120"
"ars_update(){    size_t i;    feeder_iterator_t it;    char buffer[256];    i = curses_list_get();    snprintf(buffer, 256, ""%lu"", i + 1);    strformat_set(_bars_symbs, 'i', buffer);    it = feeder_end();    snprintf(buffer, 256, ""%lu"", it.id);    strformat_set(_bars_symbs, 'I', buffer);    it = feeder_begin();    feeder_next(&it, i);    strformat_set(_bars_symbs, 'n', feeder_get_it_name(it));    strformat_set(_bars_symbs, 't', feeder_get_it_text(it));    if(_bars_top)        curses_top_set(strformat_get(_bars_top));    else        curses_top_set(NULL);    if(_bars_bot)        curses_bot_set(strformat_get(_bars_bot));    else        curses_top_set(NULL);}",2,"cwe119,cwe120"
"get_cifs_nr(void){tFILE *fp;tchar line[128];tint cifs = 0;tif ((fp = fopen(CIFSSTATS, ""r"")) == NULL)tt ttreturn 0;twhile (fgets(line, 128, fp) != NULL) {ttttif (!strncmp(line, ""Share (unique mount targets): "", 30)) {tttsscanf(line + 30, ""%d"", &cifs);tttbreak;tt}t}t tfclose(fp);treturn cifs;}",3,"cwe119,cwe120,cweother"
"init_parser(char *FilenameBuff){tif((pInfile = fopen(FilenameBuff, ""rb"")) == NULL)ttexit_error(3, ""Cannot Open Input (Source) File"");tk = -1;twhile(!feof(pInfile) && k < MAXINBUFF)t{ttInBuff[++k] = fgetc(pInfile);t}tInBuff[k] = '0';tif(k < MAXINBUFF)t{tt t} else {ttexit_error(4, ""Input Too Large for Input Buffer"");t}}",2,"cwe120,cweother"
"rs_sta_dbgfs_rate_scale_data_read(struct file *file,tttchar __user *user_buf, size_t count, loff_t *ppos){tstruct iwl_lq_sta *lq_sta = file->private_data;tstruct iwl_scale_tbl_info *tbl = &lq_sta->lq_info[lq_sta->active_tbl];tchar buff[120];tint desc = 0;tif (is_Ht(tbl->lq_type))ttdesc += sprintf(buff+desc,tttt""Bit Rate= %d Mb/s"",tttttbl->expected_tpt[lq_sta->last_txrate_idx]);telsettdesc += sprintf(buff+desc,tttt""Bit Rate= %d Mb/s"",ttttiwl_rates[lq_sta->last_txrate_idx].ieee >> 1);treturn simple_read_from_buffer(user_buf, count, ppos, buff, desc);}",2,"cwe119,cwe120"
"generateUncompressedPS(char      *hexdata,                       l_int32    w,                       l_int32    h,                       l_int32    d,                       l_int32    psbpl,                       l_int32    bps,                       l_float32  xpt,                       l_float32  ypt,                       l_float32  wpt,                       l_float32  hpt,                       l_int32    boxflag){char    *outstr;char     bigbuf[L_BUF_SIZE];SARRAY  *sa;    PROCNAME(""generateUncompressedPS"");    if (!hexdata)        return (char *)ERROR_PTR(""hexdata not defined"", procName, NULL);    if ((sa = sarrayCreate(0)) == NULL)        return (char *)ERROR_PTR(""sa not made"", procName, NULL);    sarrayAddString(sa, (char *)""%!Adobe-PS"", L_COPY);    if (boxflag == 0) {        sprintf(bigbuf,            ""%%%%BoundingBox: %7.2f %7.2f %7.2f %7.2f"",            xpt, ypt, xpt + wpt, ypt + hpt);        sarrayAddString(sa, bigbuf, L_COPY);    }    else             sarrayAddString(sa, (char *)""gsave"", L_COPY);    if (d == 1)        sarrayAddString(sa,              (char *)""{1 exch sub} settransfer    %invert binary"", L_COPY);    sprintf(bigbuf, ""/bpl %d string def         %%bpl as a string"", psbpl);    sarrayAddString(sa, bigbuf, L_COPY);    sprintf(bigbuf,           ""%7.2f %7.2f translate         %%set image origin in pts"", xpt, ypt);    sarrayAddString(sa, bigbuf, L_COPY);    sprintf(bigbuf,            ""%7.2f %7.2f scale             %%set image size in pts"", wpt, hpt);    sarrayAddString(sa, bigbuf, L_COPY);    sprintf(bigbuf,            ""%d %d %d                 %%image dimensions in pixels"", w, h, bps);    sarrayAddString(sa, bigbuf, L_COPY);    sprintf(bigbuf,            ""[%d %d %d %d %d %d]     %%mapping matrix: [w 0 0 -h 0 h]"",            w, 0, 0, -h, 0, h);    sarrayAddString(sa, bigbuf, L_COPY);    if (boxflag == 0) {        if (d == 1 || d == 8)            sarrayAddString(sa,                (char *)""{currentfile bpl readhexstring pop} image"", L_COPY);        else               sarrayAddString(sa,              (char *)""{currentfile bpl readhexstring pop} false 3 colorimage"",              L_COPY);    }    else {           if (d == 1 || d == 8)            sarrayAddString(sa,              (char *)""{currentfile bpl readhexstring pop} bind image"", L_COPY);        else               sarrayAddString(sa,          (char *)""{currentfile bpl readhexstring pop} bind false 3 colorimage"",                 L_COPY);    }    sarrayAddString(sa, hexdata, L_INSERT);    if (boxflag == 0)        sarrayAddString(sa, (char *)""showpage"", L_COPY);    else           sarrayAddString(sa, (char *)""grestore"", L_COPY);    if ((outstr = sarrayToString(sa, 1)) == NULL)        return (char *)ERROR_PTR(""outstr not made"", procName, NULL);    sarrayDestroy(&sa);    return outstr;}",2,"cwe119,cwe120"
"check_password(request_rec *r, const char *user,                                   const char *password){         apr_status_t rv;    const char *key;    authn_cache_dircfg *dcfg;    unsigned char val[MAX_VAL_LEN];    unsigned int vallen = MAX_VAL_LEN - 1;    dcfg = ap_get_module_config(r->per_dir_config, &authn_socache_module);    if (!configured || !dcfg->providers) {        return AUTH_USER_NOT_FOUND;    }    key = construct_key(r, dcfg->context, user, NULL);    rv = socache_provider->retrieve(socache_instance, r->server,                                    (unsigned char*)key, strlen(key),                                    val, &vallen, r->pool);    if (APR_STATUS_IS_NOTFOUND(rv)) {                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01684)                      ""Authn cache: no credentials found for %s"", user);        return AUTH_USER_NOT_FOUND;    }    else if (rv == APR_SUCCESS) {                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01685)                      ""Authn cache: found credentials for %s"", user);        val[vallen] = 0;    }    else {                          ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01686)                      ""Error accessing authentication cache"");        return AUTH_USER_NOT_FOUND;    }    rv = apr_password_validate(password, (char*) val);    if (rv != APR_SUCCESS) {        return AUTH_DENIED;    }    return AUTH_GRANTED;}",2,"cwe119,cwe120"
"edit1(int *msgvec, int type){tint c;tint i;tFILE *fp = NULL;tstruct message *mp;toff_t size;tchar *line = NULL;tsize_t linesize;tinttwb;t twb = value(""writebackedited"") != NULL;tfor (i = 0; msgvec[i] && i < msgCount; i++) {ttsighandler_type sigint;ttif (i > 0) {tttchar *p;tttprintf(catgets(catd, CATSET, 72,ttttt""Edit message %d [ynq]? ""), msgvec[i]);tttfflush(stdout);tttif (readline(stdin, &line, &linesize) < 0)ttttbreak;tttfor (p = line; blankchar(*p & 0377); p++);tttif (*p == 'q')ttttbreak;tttif (*p == 'n')ttttcontinue;tt}ttsetdot(mp = &message[msgvec[i] - 1]);ttdid_print_dot = 1;tttouch(mp);ttsigint = safe_signal(SIGINT, SIG_IGN);ttfp = run_editor(fp, mp->m_size, type,tttt(mb.mb_perm & MB_EDIT) == 0 || !wb,ttttNULL, mp, wb ? SEND_MBOX : SEND_TODISP_ALL,ttttsigint);ttif (fp != NULL) {tttfseek(mb.mb_otf, 0L, SEEK_END);tttsize = ftell(mb.mb_otf);tttmp->m_block = mailx_blockof(size);tttmp->m_offset = mailx_offsetof(size);tttmp->m_size = fsize(fp);tttmp->m_lines = 0;tttmp->m_flag |= MODIFY;tttrewind(fp);tttwhile ((c = getc(fp)) != EOF) {ttttif (c == '')tttttmp->m_lines++;ttttif (putc(c, mb.mb_otf) == EOF)tttttbreak;ttt}tttif (ferror(mb.mb_otf))ttttperror(""/tmp"");tttFclose(fp);tt}ttsafe_signal(SIGINT, sigint);t}tif (line)ttfree(line);treturn 0;}",2,"cwe120,cweother"
"write_alias(nssov_alias_cbp *cbp,Entry *entry){tint32_t tmpint32,tmp2int32,tmp3int32;tstruct berval tmparr[2], empty;tstruct berval *names, *members;tAttribute *a;tint i;t tif (BER_BVISNULL(&cbp->name))t{tta = attr_find(entry->e_attrs, cbp->mi->mi_attrs[0].an_desc);ttif ( !a )tt{tttDebug(LDAP_DEBUG_ANY,""alias entry %s does not contain %s value"",ttttentry->e_name.bv_val,cbp->mi->mi_attrs[0].an_desc->ad_cname.bv_val,0 );tttreturn 0;tt}ttnames = a->a_vals;t}telset{ttnames=tmparr;ttnames[0]=cbp->name;ttBER_BVZERO(&names[1]);t}t  ta = attr_find(entry->e_attrs, cbp->mi->mi_attrs[1].an_desc);tif ( !a ) {ttBER_BVZERO( &empty );ttmembers = &empty;t} else {ttmembers = a->a_vals;t}t tfor (i=0;!BER_BVISNULL(&names[i]);i++)t{ttWRITE_INT32(cbp->fp,NSLCD_RESULT_BEGIN);ttWRITE_BERVAL(cbp->fp,&names[i]);ttWRITE_BVARRAY(cbp->fp,members);t}treturn 0;}",2,"cwe119,cwe120"
"set_rx_mode(void){tunsigned char mc_filter[8];tint i;tmemset(mc_filter, 0xff, sizeof(mc_filter));toutl(0x0C, rxcon);tfor(i = 0; i < 4; i++)ttoutw(((unsigned short *)mc_filter)[i], mc0 + i*4);treturn;}",2,"cwe119,cwe120"
"file_count_line(struct ast_channel *chan, const char *cmd, char *data, struct ast_str **buf, ssize_t len){tenum file_format newline_format = FF_UNKNOWN;tint64_t count;tAST_DECLARE_APP_ARGS(args,ttAST_APP_ARG(filename);ttAST_APP_ARG(format);t);tAST_STANDARD_APP_ARGS(args, data);tif (args.argc > 1) {ttif (tolower(args.format[0]) == 'd') {tttnewline_format = FF_DOS;tt} else if (tolower(args.format[0]) == 'm') {tttnewline_format = FF_MAC;tt} else if (tolower(args.format[0]) == 'u') {tttnewline_format = FF_UNIX;tt}t}tcount = count_lines(args.filename, newline_format);tast_str_set(buf, len, ""%"" PRId64, count);treturn 0;}",3,"cwe119,cwe120,cweother"
"dhcp_rx_offer ( struct dhcp_session *dhcp,ttt    struct dhcp_packet *dhcppkt,ttt    struct sockaddr_in *peer, uint8_t msgtype,ttt    struct in_addr server_id ) {tchar vci[9];  tint vci_len;tint has_pxeclient;tint pxeopts_len;tint has_pxeopts;tstruct dhcp_offer *offer;tint i;tDBGC ( dhcp, ""DHCP %p %s from %s:%d"", dhcp,t       dhcp_msgtype_name ( msgtype ), inet_ntoa ( peer->sin_addr ),t       ntohs ( peer->sin_port ) );tif ( server_id.s_addr != peer->sin_addr.s_addr )ttDBGC ( dhcp, "" (%s)"", inet_ntoa ( server_id ) );t tif ( dhcppkt->dhcphdr->yiaddr.s_addr )ttDBGC ( dhcp, "" for %s"", inet_ntoa ( dhcppkt->dhcphdr->yiaddr ));t tfor ( i = 0 ; i < DHCP_MAX_OFFERS ; i++ ) {ttif ( dhcp->offers[i].server.s_addr == server_id.s_addr ) {tttDBGC ( dhcp, "" dup"" );tttreturn;tt}ttif ( ! dhcp->offers[i].valid )tttbreak;t}tif ( i == DHCP_MAX_OFFERS ) {ttDBGC ( dhcp, "" dropped"" );ttreturn;t}toffer = &dhcp->offers[i];toffer->server = server_id;toffer->ip = dhcppkt->dhcphdr->yiaddr;t tvci_len = dhcppkt_fetch ( dhcppkt, DHCP_VENDOR_CLASS_ID,tttt  vci, sizeof ( vci ) );thas_pxeclient = ( ( vci_len >= ( int ) sizeof ( vci ) ) &&ttt  ( strncmp ( ""PXEClient"", vci, sizeof (vci) ) == 0 ));t tpxeopts_len = dhcppkt_fetch ( dhcppkt, DHCP_PXE_BOOT_MENU, NULL, 0 );thas_pxeopts = ( pxeopts_len >= 0 );tif ( has_pxeclient )ttDBGC ( dhcp, ""%s"", ( has_pxeopts ? "" pxe"" : "" proxy"" ) );tif ( has_pxeclient && has_pxeopts ) {tt ttif ( offer->pxe )tttdhcppkt_put ( offer->pxe );ttoffer->pxe = dhcppkt_get ( dhcppkt );t}t tdhcppkt_fetch ( dhcppkt, DHCP_EB_PRIORITY, &offer->priority,tttsizeof ( offer->priority ) );tif ( offer->priority )ttDBGC ( dhcp, "" pri %d"", offer->priority );t tdhcppkt_fetch ( dhcppkt, DHCP_EB_NO_PXEDHCP, &offer->no_pxedhcp,tttsizeof ( offer->no_pxedhcp ) );tif ( offer->no_pxedhcp )ttDBGC ( dhcp, "" nopxe"" );tDBGC ( dhcp, """" );t tif ( offer->ip.s_addr &&t     ( peer->sin_port == htons ( BOOTPS_PORT ) ) &&t     ( ( msgtype == DHCPOFFER ) || ( ! msgtype   ) ) )ttoffer->valid |= DHCP_OFFER_IP;tif ( has_pxeclient && ( msgtype == DHCPOFFER ) )ttoffer->valid |= DHCP_OFFER_PXE;}",2,"cwe119,cwe120"
"drac3PowerCycle (CURL *curl, tt const char *host){    char url[BUFLEN];    char cmd[]=CMD_POWERCYCLE;    char rc[SBUFLEN];    int status;    struct Chunk chunk;        chunk.memory = NULL;    chunk.size = 0;    if (curl_easy_setopt(curl, CURLOPT_FILE, (void *)&chunk)) return(1);        snprintf(url, BUFLEN, ""https://%s/cgi/bin"",tt    host);    url[BUFLEN-1] = 0x00;        if (curl_easy_setopt(curl, CURLOPT_URL, url)) return(1);    if (curl_easy_setopt(curl, CURLOPT_POSTFIELDS, cmd)) return(1);    if (curl_easy_perform(curl)) return(1);        if (DEBUG) printf(""R: %s"", chunk.memory);    status = xmlGetXPathString(chunk.memory, ""//RC"", rc, SBUFLEN);    if (status) {t    free(chunk.memory);t    return(1);    } if (DEBUG) printf(""RC: %s"", rc);    status = (strcmp(rc, RC_OK) == 0) ? 0 : 1;    free(chunk.memory);    return(status);}",2,"cwe119,cwe120"
"dc1394_log_debug(const char *format,...){    char string[1024];    if (system_debuglog_handler != NULL) {        va_list args;        va_start(args, format);        vsnprintf(string, sizeof(string), format, args);        system_debuglog_handler(DC1394_LOG_DEBUG, string, debuglog_data);    }}",3,"cwe119,cwe120,cweother"
"pdfmark_make_dest(char dstr[MAX_DEST_STRING], gx_device_pdf * pdev,                  const char *Page_key, const char *View_key,                  const gs_param_string * pairs, uint count, uint RequirePage){    gs_param_string page_string, view_string;    int present =        pdfmark_find_key(Page_key, pairs, count, &page_string) +        pdfmark_find_key(View_key, pairs, count, &view_string);    int page=0;    gs_param_string action;    int len;    if (present || RequirePage)        page = pdfmark_page_number(pdev, &page_string);    if (page < pdev->FirstPage || (pdev->LastPage != 0 && page > pdev->LastPage)) {        emprintf1(pdev->memory, ""Destination page %d lies outside the valid page range."", page);        return -1;    }    else        if (pdev->FirstPage != 0)            page = (page - pdev->FirstPage) + 1;    if (view_string.size == 0)        param_string_from_string(view_string, ""[/XYZ null null null]"");    if (page == 0)        strcpy(dstr, ""[null "");    else if (pdfmark_find_key(""/Action"", pairs, count, &action) &&             pdf_key_eq(&action, ""/GoToR"")        )        gs_sprintf(dstr, ""[%d "", page - 1);    else        gs_sprintf(dstr, ""[%ld 0 R "", pdf_page_id(pdev, page));    len = strlen(dstr);    if (len + view_string.size > MAX_DEST_STRING)        return_error(gs_error_limitcheck);    if (view_string.data[0] != '[' ||        view_string.data[view_string.size - 1] != ']'        )        return_error(gs_error_rangecheck);    memcpy(dstr + len, view_string.data + 1, view_string.size - 1);    dstr[len + view_string.size - 1] = 0;    return present;}",2,"cwe119,cwe120"
"__ecereDestructor_HTMLFile(struct __ecereNameSpace__ecere__com__Instance * this){struct HTMLFile * __ecerePointer_HTMLFile = (struct HTMLFile *)(this ? (((char *)this) + __ecereClass_HTMLFile->offset) : 0);{(__ecereNameSpace__ecere__com__eSystem_Delete(__ecerePointer_HTMLFile->baseHRef), __ecerePointer_HTMLFile->baseHRef = 0);}((__ecerePointer_HTMLFile->block ? (__ecereClass_Block->Destructor ? __ecereClass_Block->Destructor(__ecerePointer_HTMLFile->block) : 0, __ecereNameSpace__ecere__com__eSystem_Delete(__ecerePointer_HTMLFile->block)) : 0), __ecerePointer_HTMLFile->block = 0);((__ecerePointer_HTMLFile->defaultFont ? (__ecereClass_Block->Destructor ? __ecereClass_Block->Destructor(__ecerePointer_HTMLFile->defaultFont) : 0, __ecereNameSpace__ecere__com__eSystem_Delete(__ecerePointer_HTMLFile->defaultFont)) : 0), __ecerePointer_HTMLFile->defaultFont = 0);}",2,"cwe476,cweother"
"list_user_groups(int rid, int check){  char s[200];  char g[200];  char groupname[128];  int nk = 0;  struct keyval *m = NULL, *c = NULL;  struct group_C *cd;  unsigned int *grps;  int count = 0, isadmin = 0;  int i, size, grp, grpnamoffs, grpnamlen;  if (!rid || (H_SAM < 0)) return(0);         snprintf(s,180,""SAMDomainsBuiltinAliasesMembersS-1-5-21-%08X"",rid);        nk = trav_path(hive[H_SAM], 0, s, 0);  if (!nk) {         if (gverbose) printf(""list_user_groups(): Cannot find RID under computer SID <%s>"",s);    return(0);  }  nk += 4;  count = get_val_type(hive[H_SAM],nk,""@"",TPF_VK_EXACT);  if (count == -1) {    printf(""list_user_groups(): Cannot find value <%s@>"",s);    return(0);  }  if (!check) printf(""User is member of %d groups:"",count);       size = get_val_len(hive[H_SAM],nk,""@"",TPF_VK_EXACT);       if (gverbose) printf(""Data size %d bytes."",size);  if (size != count * 4) {    printf(""list_user_groups(): DEBUG: Size is not 4 * count! May not matter anyway. Continuing.."");  }    m = get_val2buf(hive[H_SAM], NULL, nk, ""@"", 0, TPF_VK_EXACT);  if (!m) {    printf(""list_user_groups(): Could not get value data! Giving up."");    return(0);  }    grps = (unsigned int *)&m->data;  for (i = 0; i < count; i++) {    grp = grps[i];    if (!check) printf(""%08x "",grp);    if (grp == 0x220) isadmin = 1;    if (!check) {      snprintf(g,180,""SAMDomainsBuiltinAliases%08XC"",grp);      c = get_val2buf(hive[H_SAM], NULL, 0, g, 0, TPF_VK_EXACT);      if (c) {tcd = (struct group_C *)&c->data;tgrpnamoffs = cd->grpname_ofs + 0x34;tgrpnamlen  = cd->grpname_len;ttcheap_uni2ascii((char *)cd + grpnamoffs, groupname, grpnamlen);ttprintf(""= %s (which has %d members)"",groupname,cd->grp_members);t      } else {tprintf(""Group info for %x not found!"",grp);      }    }  }  return(isadmin);}",3,"cwe119,cwe120,cweother"
"gf_bt_report(GF_BTParser *parser, GF_Err e, char *format, ...){#ifndef GPAC_DISABLE_LOGtif (gf_log_tool_level_on(GF_LOG_PARSER, e ? GF_LOG_ERROR : GF_LOG_WARNING)) {ttchar szMsg[2048];ttva_list args;ttva_start(args, format);ttvsprintf(szMsg, format, args);ttva_end(args);ttGF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_PARSER, (""[BT/WRL Parsing] %s (line %d)"", szMsg, parser->line));t}#endiftif (e) parser->last_error = e;treturn e;}",3,"cwe119,cwe120,cweother"
"ast_say_date_pt(struct ast_channel *chan, time_t t, const char *ints, const char *lang){tstruct timeval when = { t, 0 };tstruct ast_tm tm;tchar fn[256];tint res = 0;tast_localtime(&when, &tm, NULL);tsnprintf(fn, sizeof(fn), ""digits/day-%d"", tm.tm_wday);tif (!res)ttres = wait_file(chan, ints, fn, lang);tif (!res)ttres = ast_say_number(chan, tm.tm_mday, ints, lang, (char *) NULL);tif (!res)ttres = wait_file(chan, ints, ""digits/pt-de"", lang);tsnprintf(fn, sizeof(fn), ""digits/mon-%d"", tm.tm_mon);tif (!res)ttres = wait_file(chan, ints, fn, lang);tif (!res)ttres = wait_file(chan, ints, ""digits/pt-de"", lang);tif (!res)ttres = ast_say_number(chan, tm.tm_year + 1900, ints, lang, (char *) NULL);treturn res;}",2,"cwe119,cwe120"
"draw_island_port(ivl_island_t island,ttt      ivl_nexus_t nex, const char*src){      char result[64];      if (ivl_island_flag_test(island,0) == 0) {t    fprintf(vvp_out, ""I%p .island tran;"", island);t    ivl_island_flag_set(island,0,1);      }      fprintf(vvp_out, ""p%p .port I%p, %s;"", nex, island, src);      snprintf(result, sizeof result, ""p%p"", nex);      return strdup(result);}",2,"cwe119,cwe120"
"G__raster_misc_read_line(const char *elem, const char *name,ttt     const char *mapset, char *str){    FILE *fd;    char buff[GNAME_MAX];    buff[0] = '0';    if (G_find_file2_misc(""cell_misc"", elem, name, mapset) == NULL)treturn -1;    fd = G_fopen_old_misc(""cell_misc"", elem, name, mapset);    if (!fd) {tG_warning(_(""Can't read %s for [%s in %s]""), elem, name, mapset);treturn -1;    }    if (G_getl2(buff, sizeof(buff) - 1, fd) == 0) {t treturn fclose(fd);    }    strcpy(str, buff);    return fclose(fd);}",2,"cwe119,cwe120"
"static_parse (char *line, gamgi_xyz *xyz){gamgi_atom *atom;char token[GAMGI_ENGINE_TOKEN];char dummy;if (gamgi_io_token_check (line) == FALSE) return 1;switch (xyz->fileline)  {  case 1:     if (sscanf (line, ""%d %c"", &xyz->count, &dummy) != 1 ||   xyz->count <= 0) return -1;  break;  case 2:     break;  default:     atom = gamgi_engine_create_atom ();  gamgi_engine_start_atom (atom);  gamgi_mesa_start_atom (atom, gamgi->atom);  gamgi_engine_link_atom_molecule (atom, xyz->molecule);     if (sscanf (line, ""%3s %lf %lf %lf %c"", atom->object.name,   &atom->position[0], &atom->position[1], &atom->position[2], &dummy) != 4 ||   gamgi_chem_atom_number (atom->object.name, &atom->element) == FALSE ||  atom->element < 0 || atom->element > GAMGI_CHEM_ATOM_MAX) return -1;     gamgi_chem_atom_name (atom->element, token);  strcpy (atom->object.name, token);  gamgi_io_token_lower (token, token+10);  strcpy (atom->object.label, token+10);  atom->mass = gamgi->atom->mass[atom->element];  atom->radius = gamgi->atom->radius[atom->element];  atom->red = gamgi->atom->red[atom->element];  atom->green = gamgi->atom->green[atom->element];  atom->blue = gamgi->atom->blue[atom->element];  }xyz->fileline++;return 1;}",2,"cwe119,cwe120"
"scan_sys_class_net(pcap_if_t **devlistp, char *errbuf){tDIR *sys_class_net_d;tint fd;tstruct dirent *ent;tchar *p;tchar name[512];t tchar *q, *saveq;tstruct ifreq ifrflags;tint ret = 1;tsys_class_net_d = opendir(""/sys/class/net"");tif (sys_class_net_d == NULL) {tt ttif (errno == ENOENT)tttreturn (0);tt tt(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,tt    ""Can't open /sys/class/net: %s"", pcap_strerror(errno));ttreturn (-1);t}t tfd = socket(AF_INET, SOCK_DGRAM, 0);tif (fd < 0) {tt(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,tt    ""socket: %s"", pcap_strerror(errno));tt(void)closedir(sys_class_net_d);ttreturn (-1);t}tfor (;;) {tterrno = 0;ttent = readdir(sys_class_net_d);ttif (ent == NULL) {ttt tttbreak;tt}tt ttif (ent->d_type == DT_DIR)tttcontinue;tt ttp = &ent->d_name[0];ttq = &name[0];ttwhile (*p != '0' && isascii(*p) && !isspace(*p)) {tttif (*p == ':') {tttt ttttsaveq = q;ttttwhile (isascii(*p) && isdigit(*p))ttttt*q++ = *p++;ttttif (*p != ':') {ttttt tttttq = saveq;tttt}ttttbreak;ttt} elsetttt*q++ = *p++;tt}tt*q = '0';tt ttstrncpy(ifrflags.ifr_name, name, sizeof(ifrflags.ifr_name));ttif (ioctl(fd, SIOCGIFFLAGS, (char *)&ifrflags) < 0) {tttif (errno == ENXIO || errno == ENODEV)ttttcontinue;ttt(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,ttt    ""SIOCGIFFLAGS: %.*s: %s"",ttt    (int)sizeof(ifrflags.ifr_name),ttt    ifrflags.ifr_name,ttt    pcap_strerror(errno));tttret = -1;tttbreak;tt}ttif (!(ifrflags.ifr_flags & IFF_UP))tttcontinue;tt ttif (pcap_add_if(devlistp, name, ifrflags.ifr_flags, NULL,tt    errbuf) == -1) {ttt tttret = -1;tttbreak;tt}t}tif (ret != -1) {tt ttif (errno != 0) {ttt(void)snprintf(errbuf, PCAP_ERRBUF_SIZE,ttt    ""Error reading /sys/class/net: %s"",ttt    pcap_strerror(errno));tttret = -1;tt}t}t(void)close(fd);t(void)closedir(sys_class_net_d);treturn (ret);}",2,"cwe119,cwe120"
"send_message(const struct message *msg, const char *filename,             const char *ip, const char *port){    int sockfd, portno, n;    struct sockaddr_in server_addr;    struct hostent *server;    char buffer[MAX_BUF_LEN];    FILE *fp;    const char *temp = ""temp"";        portno = atoi(port);    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0)    {        printf(""Unable to create socket"");        return;    }    if((server = gethostbyname(ip)) == NULL)    {        printf(""Cannot resolve ip address"");        return;    }    bzero((char *)&server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    bcopy((char *)server->h_addr,             (char *)&server_addr.sin_addr.s_addr,            server->h_length);    server_addr.sin_port = htons(portno);    if (connect(sockfd, (struct sockaddr *)&server_addr,                 sizeof(server_addr)) < 0)     {        printf(""Cannot connect"");        return;    }         serialize(msg, ""temp"");         fp = fopen(""temp"", ""rb"");    while((n = fread(buffer, 1, MAX_BUF_LEN, fp)) != 0)    {        write(sockfd, buffer, n);    }    fclose(fp);    remove(""temp"");    printf(""File %s encrypted and sent to %s:%s"", msg->filename, ip, port);    close(sockfd);}",3,"cwe119,cwe120,cweother"
"get_rsf_feature(char *line, sint len){tchar c, s;tchar str1[MAXLINE+1],str2[MAXLINE+1],feature[MAXLINE+1];tint  i, tmp,start_pos, end_pos;ttif (sscanf(line,""%d%d%d%s%s%s"",&start_pos,&end_pos,&tmp,str1,str2,feature) != 6) {ttreturn;t}tif (strcmp(feature,""HELIX"") == 0) {ttc = 'A';tts = '$';t}telse if (strcmp(feature,""STRAND"") == 0) {ttc = 'B';tts = '%';t}telsettreturn;ttttif(start_pos>=len || end_pos >= len) return;tsec_struct_mask[start_pos-1] = s;tfor (i=start_pos;i<end_pos-1;i++)ttsec_struct_mask[i] = c;tsec_struct_mask[end_pos-1] = s;tt}",3,"cwe119,cwe120,cweother"
"zxid_find_ses(zxid_conf* cf, zxid_ses* ses, struct zx_str* ses_ix, struct zx_str* nid){  char buf[ZXID_MAX_BUF];  DIR* dir;  struct dirent * de;    D(""ses_ix(%.*s) nid(%.*s)"", ses_ix?ses_ix->len:0, ses_ix?ses_ix->s:"""", nid?nid->len:0, nid?nid->s:"""");    if (!name_from_path(buf, sizeof(buf), ""%s"" ZXID_SES_DIR, cf->path))    return 0;    dir = opendir(buf);  if (!dir) {    perror(""opendir to find session"");    ERR(""Finding session by opendir failed buf(%s), euid=%d egid=%d"", buf, geteuid(), getegid());    return 0;  }  while (de = readdir(dir)) {    if (de->d_name[0] == '.' && ONE_OF_2(de->d_name[1], '.', 0))          continue;    if (zxid_get_ses(cf, ses, de->d_name)) {      if (nid && (!ses->nid || memcmp(ses->nid, nid->s, nid->len) || ses->nid[nid->len]))tcontinue;      if (ses_ix && (!ses->sesix || memcmp(ses->sesix, ses_ix->s, ses_ix->len) || ses->sesix[ses_ix->len]))tcontinue;      return 1;    }  }  closedir(dir);  ZERO(ses, sizeof(zxid_ses));  return 0;}",2,"cwe119,cwe120"
"irc_getinput ( void ){  size_t      length;  int         anz_net = 0;  char       *anfang;  char       *ende;  char       *abs_ende;  char        inbuf[IRC_BUFLEN];  bzero(inbuf, sizeof(inbuf));    anz_net = recv (irc_data.ircsocket, inbuf, sizeof(inbuf), 0);  if (anz_net <= 0) {#ifdef WIN32    if ((anz_net == 0) || ((anz_net == -1) && (WSAGetLastError() != WSAEWOULDBLOCK))) {#else    if ((anz_net == 0) || ((anz_net == -1) && (errno != EAGAIN))) {#endif      gi.dprintf (""IRC: connection terminated!"");      close (irc_data.ircsocket);      irc_data.ircstatus = IRC_DISABLED;      strcpy (ircstatus->string, IRC_ST_DISABLED);    }  } else if (anz_net > 0) {    anfang = inbuf;    abs_ende = inbuf + strlen(inbuf);    if ((abs_ende - inbuf ) > sizeof(inbuf)) {      abs_ende = inbuf + sizeof(inbuf);    }    while (anfang < abs_ende) {      ende = memchr(anfang, 13, abs_ende - anfang);      if (ende != NULL) {t t*ende = 0;tif (strlen(irc_data.input)) {t   t  strcat (irc_data.input, anfang);t} else {t   t  strcpy (irc_data.input, anfang);t}tirc_parse();t tbzero(irc_data.input, sizeof(irc_data.input));tanfang = ende + 1;tif ((*anfang == 13) || (*anfang == 10)) {t  anfang++;t}      } else {tlength = abs_ende - anfang;tif (memchr(anfang, 0, length) != NULL) {t  length = strlen(anfang);t}tif (strlen(irc_data.input)) {t   t  strncat (irc_data.input, anfang, length);t} else {t   t  strncpy (irc_data.input, anfang, length);t}tirc_data.input[length] = 0;tanfang += length;      }    }  }}",3,"cwe119,cwe120,cweother"
"get_all_tags (TrackerSparqlConnection *connection,              GStrv                    files,              gint                     search_offset,              gint                     search_limit,              gboolean                 use_or_operator,              gboolean                 show_files){tTrackerSparqlCursor *cursor;tGError *error = NULL;tgchar *query;tif (files && g_strv_length (files) > 0) {ttgchar *filter;tt ttfilter = g_strjoinv ("""","""", files);tt ttquery = g_strdup_printf (""SELECT ?tag ?label nao:description(?tag) COUNT(?urns) AS urns ""tt                         ""WHERE {""tt                         ""  ?tag a nao:Tag ;""tt                         ""  nao:prefLabel ?label .""tt                         ""  OPTIONAL {""tt                         ""     ?urns nao:hasTag ?tag""tt                         ""  } .""tt                         ""  FILTER (?label IN (""%s""))""tt                         ""} ""tt                         ""GROUP BY ?tag ""tt                         ""ORDER BY ASC(?label) ""tt                         ""OFFSET %d ""tt                         ""LIMIT %d"",tt                         filter,tt                         search_offset,tt                         search_limit);ttg_free (filter);t} else {ttquery = g_strdup_printf (""SELECT ?tag ?label nao:description(?tag) COUNT(?urns) AS urns ""tt                         ""WHERE {""tt                         ""  ?tag a nao:Tag ;""tt                         ""  nao:prefLabel ?label .""tt                         ""  OPTIONAL {""tt                         ""     ?urns nao:hasTag ?tag""tt                         ""  }""tt                         ""} ""tt                         ""GROUP BY ?tag ""tt                         ""ORDER BY ASC(?label) ""tt                         ""OFFSET %d ""tt                         ""LIMIT %d"",tt                         search_offset,tt                         search_limit);t}tcursor = tracker_sparql_connection_query (connection, query, NULL, &error);tg_free (query);tif (error) {ttg_printerr (""%s, %s"",tt            _(""Could not get all tags""),tt            error->message);ttg_error_free (error);ttreturn FALSE;t}tif (!cursor) {ttg_print (""%s"",tt         _(""No tags were found""));t} else {ttgint count = 0;ttg_print (""%s:"", _(""Tags (shown by name)""));ttwhile (tracker_sparql_cursor_next (cursor, NULL, NULL)) {tttconst gchar *id;tttconst gchar *tag;tttconst gchar *description;tttconst gchar *files;tttgint n_files = 0;tttid = tracker_sparql_cursor_get_string (cursor, 0, NULL);tttfiles = tracker_sparql_cursor_get_string (cursor, 3, NULL);tttn_files = atoi (files);ttttag = tracker_sparql_cursor_get_string (cursor, 1, NULL);tttdescription = tracker_sparql_cursor_get_string (cursor, 2, NULL);tttif (description && *description == '0') {ttttdescription = NULL;ttt}tttg_print (""  %s %s%s%s"",ttt         tag,ttt         description ? ""("" : """",ttt         description ? description : """",ttt         description ? "")"" : """");tttif (show_files && n_files > 0) {ttttget_all_tags_show_tag_id (connection, id);ttt} else {ttttg_print (""    %s"", id);ttttg_print (""    "");ttttg_print (g_dngettext (NULL,tttt                      ""%d file"",tttt                      ""%d files"",tttt                      n_files),tttt         n_files);ttttg_print ("""");ttt}tttcount++;tt}ttif (count == 0) {tttg_print (""  %s"", _(""None""));tt}ttg_print ("""");ttif (count >= search_limit) {tttshow_limit_warning ();tt}ttg_object_unref (cursor);t}treturn TRUE;}",2,"cwe469,cweother"
"test_diff_diffiter__iterate_randomly_while_saving_state(void){tgit_repository *repo = cl_git_sandbox_init(""status"");tgit_diff_options opts = {0};tgit_diff_list *diff = NULL;tdiff_expects exp = {0};tgit_diff_patch *patches[PATCH_CACHE];tsize_t p, d, num_d;tmemset(patches, 0, sizeof(patches));topts.context_lines = 3;topts.interhunk_lines = 1;topts.flags |= GIT_DIFF_INCLUDE_IGNORED | GIT_DIFF_INCLUDE_UNTRACKED;tcl_git_pass(git_diff_workdir_to_index(&diff, repo, NULL, &opts));tnum_d = git_diff_num_deltas(diff);t tsrand(121212);tp = rand() % PATCH_CACHE;tfor (d = 0; d < num_d; ++d) {tt ttgit_diff_patch *patch = patches[p];ttpatches[p] = NULL;tt ttcl_git_pass(git_diff_get_patch(&patches[p], NULL, diff, d));ttcl_assert(patches[p] != NULL);tt ttif (patch != NULL) {tttiterate_over_patch(patch, &exp);tttgit_diff_patch_free(patch);tt}ttp = rand() % PATCH_CACHE;t}t tgit_diff_list_free(diff);t tfor (p = 0; p < PATCH_CACHE; p++) {ttgit_diff_patch *patch = patches[p];ttif (patch != NULL) {tttiterate_over_patch(patch, &exp);tttgit_diff_patch_free(patch);tt}t}t tcl_assert_equal_i(13, exp.files);tcl_assert_equal_i(8, exp.hunks);tcl_assert_equal_i(14, exp.lines);}",3,"cwe119,cwe120,cweother"
"fmt_ip6ifc(char *s,const char ip[16],uint32 scope_id){  if (ip6_isv4mapped(ip))    return fmt_ip4(s,ip+12);  else    return fmt_ip6if(s,ip,scope_id);}",2,"cwe119,cwe120"
"CtwmCurrentOccupation (Display *dpy, Window window){    unsigned chart*prop;    chartt*p;    unsigned longtbytesafter;    unsigned longtlen;    Atomttactual_type;    inttttactual_format;    inttttcount, l, i;    chartt**ret;    _XA_WM_OCCUPATION = XInternAtom (dpy, ""WM_OCCUPATION"", True);    if (_XA_WM_OCCUPATION == None) return ((char**) 0);    if (XGetWindowProperty (dpy, window, _XA_WM_OCCUPATION, 0L, 512,tttFalse, XA_STRING, &actual_type, &actual_format, &len,ttt&bytesafter, &prop) != Success) return 0;    if (len == 0) return 0;    count = 0;    p = (char*)prop;    l = 0;    while (l < len) {tl += strlen (p) + 1;tp += strlen (p) + 1;tcount++;    }    ret = (char**) malloc ((count + 1) * sizeof (char*));    p = (char*)prop;    l = 0;    i = 0;    while (l < len) {tret [i++] = (char*) p;tl += strlen (p) + 1;tp += strlen (p) + 1;    }    ret [i] = '0';    return (ret);}",2,"cwe120,cweother"
"plpgsql_parse_dblwordtype(char *word){tPLpgSQL_nsitem *nse;tboolttold_nsstate;tOidtttclassOid;tHeapTupletclasstup = NULL;tHeapTupletattrtup = NULL;tHeapTuplettypetup = NULL;tForm_pg_class classStruct;tForm_pg_attribute attrStruct;tchart   *cp[3];tintttti;tMemoryContext oldCxt;tinttttresult = T_ERROR;t toldCxt = MemoryContextSwitchTo(compile_tmp_cxt);t t ti = strlen(word) - 5;tAssert(word[i] == '%');tword[i] = '.';tplpgsql_convert_ident(word, cp, 3);tword[i] = '%';t tnse = plpgsql_ns_lookup(cp[0], NULL);t tif (nse != NULL)t{ttif (nse->itemtype == PLPGSQL_NSTYPE_LABEL)tt{tttold_nsstate = plpgsql_ns_setlocal(false);tttnse = plpgsql_ns_lookup(cp[1], cp[0]);tttplpgsql_ns_setlocal(old_nsstate);tttif (nse != NULL && nse->itemtype == PLPGSQL_NSTYPE_VAR)ttt{ttttplpgsql_yylval.dtype = ((PLpgSQL_var *) (plpgsql_Datums[nse->itemno]))->datatype;ttttresult = T_DTYPE;ttt}tt}tt ttgoto done;t}t tclassOid = RelnameGetRelid(cp[0]);tif (!OidIsValid(classOid))ttgoto done;tclasstup = SearchSysCache(RELOID,ttttttt  ObjectIdGetDatum(classOid),ttttttt  0, 0, 0);tif (!HeapTupleIsValid(classtup))ttgoto done;tclassStruct = (Form_pg_class) GETSTRUCT(classtup);t tif (classStruct->relkind != RELKIND_RELATION &&ttclassStruct->relkind != RELKIND_SEQUENCE &&ttclassStruct->relkind != RELKIND_VIEW &&ttclassStruct->relkind != RELKIND_COMPOSITE_TYPE)ttgoto done;t tattrtup = SearchSysCacheAttName(classOid, cp[1]);tif (!HeapTupleIsValid(attrtup))ttgoto done;tattrStruct = (Form_pg_attribute) GETSTRUCT(attrtup);ttypetup = SearchSysCache(TYPEOID,ttttttt ObjectIdGetDatum(attrStruct->atttypid),ttttttt 0, 0, 0);tif (!HeapTupleIsValid(typetup))ttelog(ERROR, ""cache lookup failed for type %u"", attrStruct->atttypid);t tMemoryContextSwitchTo(oldCxt);tplpgsql_yylval.dtype = build_datatype(typetup, attrStruct->atttypmod);tMemoryContextSwitchTo(compile_tmp_cxt);tresult = T_DTYPE;done:tif (HeapTupleIsValid(classtup))ttReleaseSysCache(classtup);tif (HeapTupleIsValid(attrtup))ttReleaseSysCache(attrtup);tif (HeapTupleIsValid(typetup))ttReleaseSysCache(typetup);tMemoryContextSwitchTo(oldCxt);treturn result;}",2,"cwe119,cwe120"
"my_numbox_ftoa(t_my_numbox *x){    double f=x->x_val;    int bufsize, is_exp=0, i, idecimal;    sprintf(x->x_buf, ""%g"", f);    bufsize = strlen(x->x_buf);    if(bufsize >= 5)     {        i = bufsize - 4;        if((x->x_buf[i] == 'e') || (x->x_buf[i] == 'E'))            is_exp = 1;    }    if(bufsize > x->x_gui.x_w)     {        if(is_exp)        {            if(x->x_gui.x_w <= 5)            {                x->x_buf[0] = (f < 0.0 ? '-' : '+');                x->x_buf[1] = 0;            }            i = bufsize - 4;            for(idecimal=0; idecimal < i; idecimal++)                if(x->x_buf[idecimal] == '.')                    break;            if(idecimal > (x->x_gui.x_w - 4))            {                x->x_buf[0] = (f < 0.0 ? '-' : '+');                x->x_buf[1] = 0;            }            else            {                int new_exp_index=x->x_gui.x_w-4, old_exp_index=bufsize-4;                for(i=0; i < 4; i++, new_exp_index++, old_exp_index++)                    x->x_buf[new_exp_index] = x->x_buf[old_exp_index];                x->x_buf[x->x_gui.x_w] = 0;            }        }        else        {            for(idecimal=0; idecimal < bufsize; idecimal++)                if(x->x_buf[idecimal] == '.')                    break;            if(idecimal > x->x_gui.x_w)            {                x->x_buf[0] = (f < 0.0 ? '-' : '+');                x->x_buf[1] = 0;            }            else                x->x_buf[x->x_gui.x_w] = 0;        }    }}",2,"cwe120,cweother"
"globus_gram_job_manager_request_acct(    globus_gram_jobmanager_request_t *  request,    const char *                        format,    ... ){    static const char *jm_syslog_id  = ""gridinfo"";    static int         jm_syslog_fac = LOG_DAEMON;    static int         jm_syslog_lvl = LOG_NOTICE;    static int         jm_syslog_init;    struct tm *curr_tm;    time_t curr_time;    va_list ap;    int rc = -1;    int fd;    const char * gk_acct_fd_var = ""GATEKEEPER_ACCT_FD"";    const char * gk_acct_fd;    int n;    int t;    char buf[1024 * 128];    time( &curr_time );    curr_tm = localtime( &curr_time );    n = t = sprintf( buf, ""JMA %04d/%02d/%02d %02d:%02d:%02d "",                curr_tm->tm_year + 1900,                curr_tm->tm_mon + 1, curr_tm->tm_mday,                curr_tm->tm_hour, curr_tm->tm_min,                curr_tm->tm_sec );    va_start( ap, format );         n += vsprintf( buf + t, format, ap );    if (!jm_syslog_init)    {        const char *s;        if ((s = globus_libc_getenv( ""JOBMANAGER_SYSLOG_ID""  )) != 0)        {            jm_syslog_id = *s ? s : 0;        }        if ((s = globus_libc_getenv( ""JOBMANAGER_SYSLOG_FAC"" )) != 0)        {            if (sscanf( s, ""%u"", &jm_syslog_fac ) != 1)            {                jm_syslog_id = 0;            }        }        if ((s = globus_libc_getenv( ""JOBMANAGER_SYSLOG_LVL"" )) != 0) {            if (sscanf( s, ""%u"", &jm_syslog_lvl ) != 1) {                jm_syslog_id = 0;            }        }        if (jm_syslog_id)        {            openlog( jm_syslog_id, LOG_PID, jm_syslog_fac );        }        jm_syslog_init = 1;    }    if (jm_syslog_id)    {        char *p, *q = buf;        while ((p = q) < buf + n) {            char c;            while ((c = *q) != 0 && c != '') {                q++;            }            *q = 0;            syslog( jm_syslog_lvl, ""%s"", p );            *q++ = c;        }    }    if (!(gk_acct_fd = globus_libc_getenv( gk_acct_fd_var )))    {        return -1;    }    if (sscanf( gk_acct_fd, ""%d"", &fd ) != 1)    {        return -1;    }    fcntl( fd, F_SETFD, FD_CLOEXEC );    if ((rc = write( fd, buf, n )) != n)    {        rc = -1;    }    return rc;}",3,"cwe119,cwe120,cweother"
"assoccopy(ASSOC *oldap){tASSOC *ap;tASSOCELEM *oldep;tASSOCELEM *ep;tASSOCELEM **listhead;tint oldhi;tint i;tap = assocalloc(oldap->a_count / CHAINLENGTH);tap->a_count = oldap->a_count;tfor (oldhi = 0; oldhi < oldap->a_size; oldhi++) {ttfor (oldep = oldap->a_table[oldhi]; oldep;tttoldep = oldep->e_next) {tttep = (ASSOCELEM *) malloc(ELEMSIZE(oldep->e_dim));tttif (ep == NULL) {ttttmath_error(""Cannot allocate association element"");tttt ttt}tttep->e_dim = oldep->e_dim;tttep->e_hash = oldep->e_hash;tttep->e_value.v_type = V_NULL;tttep->e_value.v_subtype = V_NOSUBTYPE;tttfor (i = 0; i < ep->e_dim; i++)ttttcopyvalue(&oldep->e_indices[i], &ep->e_indices[i]);tttcopyvalue(&oldep->e_value, &ep->e_value);tttlisthead = &ap->a_table[ep->e_hash % ap->a_size];tttep->e_next = *listhead;ttt*listhead = ep;tt}t}treturn ap;}",2,"cwe120,cwe476"
"vTmsg(const char *fmt, va_list args){    if (verbose) {        vsprintf(tmp_buf, fmt, args);        if (strlen(tmp_buf) + strlen(msg_buf) < MAX_MSG_SIZE) {            sprintf(msg_buf + strlen(msg_buf), ""t%s"", tmp_buf);        }        else {            fprintf(stderr, ""msg_buf full: %s"", tmp_buf);            fflush(stderr);        }    }}",2,"cwe120,cweother"
"DBFCreate( const char * pszFilename ){    DBFHandletpsDBF;    FILEt*fp;    chart*pszFullname, *pszBasename;    inttti;        pszBasename = (char *) malloc(strlen(pszFilename)+5);    strcpy( pszBasename, pszFilename );    for( i = strlen(pszBasename)-1; t i > 0 && pszBasename[i] != '.' && pszBasename[i] != '/'t       && pszBasename[i] != '';t i-- ) {}    if( pszBasename[i] == '.' )        pszBasename[i] = '0';    pszFullname = (char *) malloc(strlen(pszBasename) + 5);    sprintf( pszFullname, ""%s.dbf"", pszBasename );    free( pszBasename );       fp = fopen( pszFullname, ""wb"" );    if( fp == NULL )        return( NULL );    fputc( 0, fp );    fclose( fp );    fp = fopen( pszFullname, ""rb+"" );    if( fp == NULL )        return( NULL );    free( pszFullname );       psDBF = (DBFHandle) malloc(sizeof(DBFInfo));    psDBF->fp = fp;    psDBF->nRecords = 0;    psDBF->nFields = 0;    psDBF->nRecordLength = 1;    psDBF->nHeaderLength = 33;    psDBF->bUpdated = FALSE;        psDBF->panFieldOffset = NULL;    psDBF->panFieldSize = NULL;    psDBF->panFieldDecimals = NULL;    psDBF->pachFieldType = NULL;    psDBF->pszHeader = NULL;    psDBF->nCurrentRecord = -1;    psDBF->bCurrentRecordModified = FALSE;    psDBF->pszCurrentRecord = NULL;    psDBF->bNoHeader = TRUE;    return( psDBF );}",2,"cwe120,cweother"
"dse_updateNumSubordinates(Slapi_Entry *entry, int op){    int ret= 0;tint mod_op = 0;tSlapi_Attr *read_attr = NULL;tsize_t current_sub_count = 0;tint already_present = 0;t t tret = slapi_entry_attr_find(entry,subordinatecount,&read_attr);tif (0 == ret)t{tt ttSlapi_Value *sval;ttslapi_attr_first_value( read_attr,&sval );ttif (sval!=NULL)tt{tt    const struct berval *bval = slapi_value_get_berval( sval );tt    if (bval!=NULL)tt    {tttttalready_present = 1;ttttcurrent_sub_count = atol(bval->bv_val);tt    }tt}  t}t tif ( (SLAPI_OPERATION_ADD == op) && !already_present)t{tt ttmod_op = LDAP_MOD_ADD;t}telset{ttif (SLAPI_OPERATION_DELETE == op)tt{tttif (!already_present)ttt{tttt ttttslapi_log_error( SLAPI_LOG_FATAL, ""dse"",tttttt""numsubordinates assertion failure"" );ttttreturn;ttt}tttelsettt{ttttif (current_sub_count == 1)tttt{tttttmod_op = LDAP_MOD_DELETE;tttt}ttttelsetttt{tttttmod_op = LDAP_MOD_REPLACE;tttt}ttt}tt}ttelsett{tttmod_op = LDAP_MOD_REPLACE;tt}t}tt tif (SLAPI_OPERATION_ADD == op)t{ttcurrent_sub_count++;t}telset{ttcurrent_sub_count--;t}    {        char value_buffer[20];          struct berval *vals[2];        struct berval val;        vals[0] = &val;        vals[1] = NULL;        sprintf(value_buffer,""%lu"",(long unsigned int)current_sub_count);        val.bv_val = value_buffer;        val.bv_len = strlen (val.bv_val);        switch(mod_op)        {        case LDAP_MOD_ADD:            attrlist_merge( &entry->e_attrs, subordinatecount, vals);            break;        case LDAP_MOD_REPLACE:            attrlist_replace( &entry->e_attrs, subordinatecount, vals);            break;        case LDAP_MOD_DELETE:            attrlist_delete( &entry->e_attrs, subordinatecount);            break;        }    }}",3,"cwe119,cwe120,cweother"
"e_container_shutdown(void){   E_FREE_LIST(handlers, ecore_event_handler_del);   return 1;}",3,"cwe119,cwe120,cweother"
"available(MUC_REC *channel, const char *from, LmMessage *lmsg){tLmMessageNode *node;tconst char *item_affiliation, *item_role, *nick;tchar *item_jid, *item_nick, *status;tgboolean own, forced, created;titem_affiliation = item_role = status = NULL;titem_jid = item_nick = NULL;t tif ((node = lm_find_node(lmsg->node, ""user:x"", XMLNS "":user"", XMLNS_MUC_USER)) == NULL &&t    (node = lm_find_node(lmsg->node, ""x"", XMLNS, XMLNS_MUC_USER)) == NULL)ttreturn;t town = lm_find_node(node, ""status"", ""code"", ""110"") != NULL || lm_find_node(node, ""user:status"", ""code"", ""110"") != NULL ;t tforced = lm_find_node(node, ""status"", ""code"", ""210"") != NULL || lm_find_node(node, ""user:status"", ""code"", ""210"") != NULL;t tcreated = lm_find_node(node, ""status"", ""code"", ""201"") != NULL || lm_find_node(node, ""user:status"", ""code"", ""201"") != NULL;tif (created) {ttchar str[MAX_LONG_STRLEN], *data;ttg_snprintf(str, sizeof(str), ""%ld"", (long)time(NULL));ttdata = g_strconcat(""_ "", channel->name, "" "", str, (void *)NULL);tt ttsignal_emit(""event 329"", 2, channel->server, data);ttg_free(data);t}        LmMessageNode *parent = node;tif ((node = lm_message_node_get_child(parent, ""user:item"")) == NULL &&t    (node = lm_message_node_get_child(parent, ""item"")) == NULL)ttreturn;t titem_affiliation = lm_message_node_get_attribute(node, ""affiliation"");titem_role = lm_message_node_get_attribute(node, ""role"");titem_jid = xmpp_recode_in( lm_message_node_get_attribute(node, ""jid""));titem_nick = xmpp_recode_in( lm_message_node_get_attribute(node, ""nick""));tnick = item_nick != NULL ? item_nick : from;tif (nick == NULL)ttgoto err;tif (own || strcmp(nick, channel->nick) == 0)ttown_event(channel, nick, item_jid, item_affiliation, item_role,tt    forced);telsettnick_event(channel, nick, item_jid, item_affiliation, item_role);t tif ((node = lm_message_node_get_child(lmsg->node, ""user:status"")) != NULL ||t    (node = lm_message_node_get_child(lmsg->node, ""status"")) != NULL)ttstatus = xmpp_recode_in(node->value);t tnode = lm_message_node_get_child(lmsg->node, ""show"");tnick_presence(channel, nick, node != NULL ? node->value : NULL, status);tg_free(status);err:tg_free(item_jid);tg_free(item_nick);}",2,"cwe119,cwe120"
"sig_file_open(state *s, char * fn, file_info_t * info){  char str[MAX_STR_LEN];  if (NULL == s || NULL == fn || NULL == info)    return TRUE;  info->handle = fopen(fn,""rb"");  if (NULL == info->handle)  {    if (!(MODE(mode_silent)))      perror(fn);    return TRUE;  }        if (NULL == fgets(str,MAX_STR_LEN,info->handle))  {    if (!(MODE(mode_silent)))      perror(fn);    fclose(info->handle);    return TRUE;  }  if (strncmp(str,SSDEEPV1_0_HEADER,strlen(SSDEEPV1_0_HEADER)) &&      strncmp(str,SSDEEPV1_1_HEADER,strlen(SSDEEPV1_1_HEADER)))  {    if (!MODE(mode_silent))      print_error(s,""%s: invalid file header: %s!!"", fn, str);    fclose(info->handle);    return TRUE;  }  return FALSE;}",3,"cwe119,cwe120,cweother"
"do_lvresize (const char *logvol, int mbytes){  CLEANUP_FREE char *err = NULL;  int r;  char size[64];  snprintf (size, sizeof size, ""%d"", mbytes);  r = command (NULL, &err,               str_lvm, ""lvresize"",               ""--force"", ""-L"", size, logvol, NULL);  if (r == -1) {    if (!ignore_same_size_error (err)) {      reply_with_error (""%s"", err);      return -1;    }  }  return 0;}",2,"cwe119,cwe120"
"_tarGetHeader(ArchiveHandle *AH, TAR_MEMBER *th){tlclContext *ctx = (lclContext *) AH->formatData;tchartth[512];tchartttag[100];tinttttsum,ttttchk;tsize_tttlen;tunsigned long ullen;tpgoff_ttthPos;tboolttgotBlock = false;twhile (!gotBlock)t{tt tthPos = ctx->tarFHpos;tt ttlen = _tarReadRaw(AH, h, 512, NULL, ctx->tarFH);ttif (len == 0)ttt tttreturn 0;ttif (len != 512)tttexit_horribly(modulename,tttttt  ngettext(""incomplete tar header found (%lu byte)"",tttttttt ""incomplete tar header found (%lu bytes)"",tttttttt   len),tttttt  (unsigned long) len);tt ttchk = tarChecksum(h);ttsscanf(&h[148], ""%8o"", &sum);tt ttif (chk == sum)tttgotBlock = true;ttelsett{tttintttti;tttfor (i = 0; i < 512; i++)ttt{ttttif (h[i] != 0)tttt{tttttgotBlock = true;tttttbreak;tttt}ttt}tt}t}tsscanf(&h[0], ""%99s"", tag);tsscanf(&h[124], ""%12lo"", &ullen);tlen = (size_t) ullen;t{ttcharttbuf[100];ttsnprintf(buf, sizeof(buf), INT64_FORMAT, (int64) hPos);ttahlog(AH, 3, ""TOC Entry %s at %s (length %lu, checksum %d)"",ttt  tag, buf, (unsigned long) len, sum);t}tif (chk != sum)t{ttcharttbuf[100];ttsnprintf(buf, sizeof(buf), INT64_FORMAT, (int64) ftello(ctx->tarFH));ttexit_horribly(modulename,ttttt  ""corrupt tar header found in %s ""ttttt  ""(expected %d, computed %d) file position %s"",ttttt  tag, sum, chk, buf);t}tth->targetFile = pg_strdup(tag);tth->fileLen = len;treturn 1;}",3,"cwe119,cwe120,cweother"
"yuv4_write_packet(AVFormatContext *s, AVPacket *pkt){    AVStream *st = s->streams[pkt->stream_index];    ByteIOContext *pb = s->pb;    AVPicture *picture;    int* first_pkt = s->priv_data;    int width, height, h_chroma_shift, v_chroma_shift;    int i, m;    char buf2[Y4M_LINE_MAX+1];    char buf1[20];    uint8_t *ptr, *ptr1, *ptr2;    picture = (AVPicture *)pkt->data;         if (*first_pkt) {        *first_pkt = 0;        if (yuv4_generate_header(s, buf2) < 0) {            av_log(s, AV_LOG_ERROR, ""Error. YUV4MPEG stream header write failed."");            return AVERROR(EIO);        } else {            put_buffer(pb, buf2, strlen(buf2));        }    }         m = snprintf(buf1, sizeof(buf1), ""%s"", Y4M_FRAME_MAGIC);    put_buffer(pb, buf1, strlen(buf1));    width = st->codec->width;    height = st->codec->height;    ptr = picture->data[0];    for(i=0;i<height;i++) {        put_buffer(pb, ptr, width);        ptr += picture->linesize[0];    }    if (st->codec->pix_fmt != PIX_FMT_GRAY8){         avcodec_get_chroma_sub_sample(st->codec->pix_fmt, &h_chroma_shift, &v_chroma_shift);    width >>= h_chroma_shift;    height >>= v_chroma_shift;    ptr1 = picture->data[1];    ptr2 = picture->data[2];    for(i=0;i<height;i++) {              put_buffer(pb, ptr1, width);        ptr1 += picture->linesize[1];    }    for(i=0;i<height;i++) {              put_buffer(pb, ptr2, width);            ptr2 += picture->linesize[2];    }    }    put_flush_packet(pb);    return 0;}",2,"cwe119,cwe120"
"netfile_download_file_core(const char *URL, FILE *fp,                                       nf_errmsg cb, void *data){  CURLcode curlret;  struct curl_slist *headers = NULL;  if (handle == NULL) {    handle = curl_easy_init();  }  headers = curl_slist_append(headers,""User-Agent: Freeciv/"" VERSION_STRING);  curl_easy_setopt(handle, CURLOPT_URL, URL);  curl_easy_setopt(handle, CURLOPT_WRITEDATA, fp);  curl_easy_setopt(handle, CURLOPT_HTTPHEADER, headers);  curlret = curl_easy_perform(handle);  curl_slist_free_all(headers);  if (curlret != CURLE_OK) {    if (cb != NULL) {      char buf[2048];      fc_snprintf(buf, sizeof(buf),                  _(""Failed to fetch %s""), URL);      cb(buf, data);    }    return FALSE;  }  return TRUE;}",3,"cwe119,cwe120,cweother"
"par_item_restore_default(GcxPar p){tif (PAR(p)->flags & (PAR_TREE)) {  ttGcxPar pp;ttPAR(p)->flags &= ~PAR_USER;ttpp = PAR(p)->child;ttwhile(pp != PAR_NULL) {tttpar_item_restore_default(pp);tttpp = PAR(pp)->next;tt}t} else if (PAR(p)->flags & (PAR_USER)) {tttif (PAR_TYPE(p) == PAR_STRING) {ttttchange_par_string(p, PAR(p)->defval.s);ttt} else {ttttmemcpy(&(PAR(p)->val), &(PAR(p)->defval), sizeof(union pval));ttt}tttPAR(p)->flags &= ~PAR_USER;tttPAR(p)->flags &= ~PAR_TO_SAVE;t}}",2,"cwe120,cwe476"
"verify_slab_v1(struct meminfo *si, ulong last, int s){tchar slab_s_buf[BUFSIZE];tstruct kernel_list_head *list_head;tunsigned int inuse;tulong s_mem;tchar *list;tint errcnt;tlist = slab_chain_name_v1[s];terrcnt = 0;        if (!readmem(si->slab, KVADDR, slab_s_buf,            SIZE(slab_s), ""slab_s buffer"", QUIET|RETURN_ON_ERROR)) {                error(INFO, ""%s: %s list: bad slab pointer: %lx"",                        si->curname, list, si->slab);ttreturn FALSE;        }                                list_head = (struct kernel_list_head *)tt(slab_s_buf + OFFSET(slab_s_list));tif (!IS_KVADDR((ulong)list_head->next) || t    !accessible((ulong)list_head->next)) {                error(INFO, ""%s: %s list: slab: %lx  bad next pointer: %lx"",                        si->curname, list, si->slab,ttt(ulong)list_head->next);tterrcnt++;t}tif (last && (last != (ulong)list_head->prev)) {                error(INFO, ""%s: %s list: slab: %lx  bad prev pointer: %lx"",                        si->curname, list, si->slab,                        (ulong)list_head->prev);tterrcnt++;t}tinuse = UINT(slab_s_buf + OFFSET(slab_s_inuse));tif (inuse > si->c_num) {                error(INFO, ""%s: %s list: slab: %lx  bad inuse counter: %ld"",                        si->curname, list, si->slab, inuse);tterrcnt++;t}tif (!last)ttgoto no_inuse_check_v1;tswitch (s) t{tcase 0:                  if (VALID_MEMBER(kmem_cache_s_slabs_full) && tt    (inuse != si->c_num)) {                        error(INFO,                            ""%s: %s list: slab: %lx  bad inuse counter: %ld"",                                si->curname, list, si->slab, inuse);                        errcnt++;                }ttbreak;tcase 1:  ttif ((inuse == 0) || (inuse == si->c_num)) {                terror(INFO, tt t    ""%s: %s list: slab: %lx  bad inuse counter: %ld"",                        tsi->curname,  list, si->slab, inuse);ttterrcnt++;tt}ttbreak;tcase 2:  ttif (inuse > 0) {                terror(INFO, tt t    ""%s: %s list: slab: %lx  bad inuse counter: %ld"",                        tsi->curname, list, si->slab, inuse);ttterrcnt++;tt}ttbreak;t}no_inuse_check_v1:ts_mem = ULONG(slab_s_buf + OFFSET(slab_s_s_mem));tif (!IS_KVADDR(s_mem) || !accessible(s_mem)) {                error(INFO, ""%s: %s list: slab: %lx  bad s_mem pointer: %lx"",                        si->curname, list, si->slab, s_mem);tterrcnt++;t}tsi->errors += errcnt;treturn(errcnt ? FALSE : TRUE);}",2,"cwe119,cwe120"
"main(int    argc,             char **argv){char          buf[512];l_int32       delx, dely, etransx, etransy, w, h, area1, area2;l_int32      *stab, *ctab;l_float32     cx1, cy1, cx2, cy2, score;PIX          *pix0, *pix1, *pix2;L_REGPARAMS  *rp;    if (regTestSetup(argc, argv, &rp))        return 1;         pix0 = pixRead(""harmoniam100-11.png"");    pix1 = pixConvertTo1(pix0, 160);    pixGetDimensions(pix1, &w, &h, NULL);             pix2 = pixCreate(w - 10, h, 1);    pixRasterop(pix2, 0, 0, w, h, PIX_SRC, pix1, 32, 12);             stab = makePixelSumTab8();    ctab = makePixelCentroidTab8();    pixCountPixels(pix1, &area1, stab);    pixCountPixels(pix2, &area2, stab);    pixCentroid(pix1, ctab, stab, &cx1, &cy1);    pixCentroid(pix2, ctab, stab, &cx2, &cy2);    etransx = lept_roundftoi(cx1 - cx2);    etransy = lept_roundftoi(cy1 - cy2);    fprintf(stderr, ""delta cx = %d, delta cy = %d"",            etransx, etransy);             pixBestCorrelation(pix1, pix2, area1, area2, etransx, etransy,                       4, stab, &delx, &dely, &score, 5);    fprintf(stderr, ""delx = %d, dely = %d, score = %7.4f"",            delx, dely, score);    regTestCompareValues(rp, 32, delx, 0);        regTestCompareValues(rp, 12, dely, 0);        regTestCheckFile(rp, ""/tmp/junkcorrel_5.png"");        lept_rm(NULL, ""junkcorrel_5.png"");    FREE(stab);    FREE(ctab);    pixDestroy(&pix0);    pixDestroy(&pix1);    pixDestroy(&pix2);                  pix1 = pixRead(""harmoniam-11.tif"");    pix2 = pixTranslate(NULL, pix1, -45, 25, L_BRING_IN_WHITE);    l_pdfSetDateAndVersion(0);    pixCompareWithTranslation(pix1, pix2, 160, &delx, &dely, &score, 1);    pixDestroy(&pix1);    pixDestroy(&pix2);    fprintf(stderr, ""delx = %d, dely = %d"", delx, dely);    regTestCompareValues(rp, 45, delx, 0);        regTestCompareValues(rp, -25, dely, 0);        regTestCheckFile(rp, ""/tmp/junkcmp.pdf"");        regTestCheckFile(rp, ""/tmp/junkcorrel.pdf"");       return regTestCleanup(rp);}",2,"cwe119,cwe120"
"readData(t_Data *ptData, t_Params *ptParams){  FILE *ifp = NULL;  char szLine[MAX_LINE_LENGTH];  int  nPos = 0, i = 0, j = 0, nSequences = 0;  char *szBrk;    char *szRet;     ptData->nSeq    = 0;  ptData->nMaxLen = 0;    ifp = fopen(ptParams->szInputFile, ""r"");  if(ifp){    while(fgets(szLine, MAX_LINE_LENGTH, ifp)){      if(szLine[0] == '>'){tif(nPos > ptData->nMaxLen){t  ptData->nMaxLen = nPos;t}ttptData->nSeq++;tnPos = 0;      }      else{ti = 0;twhile(strrchr(szSequence,szLine[i]) != NULL){t  i++;t  nPos++;t}      }    }    fclose(ifp);  }  else{    fprintf(stderr, ""Can't open input file %s"", ptParams->szInputFile);    exit(EXIT_FAILURE);  }  ptData->aszID        = (char **) malloc(ptData->nSeq*sizeof(char *));  ptData->aacSequences = (char **) malloc(ptData->nSeq*sizeof(char *));  ptData->anLen        = (int *)   malloc(ptData->nSeq*sizeof(int));  ifp = fopen(ptParams->szInputFile, ""r"");  if(ifp){    while(szRet = fgets(szLine, MAX_LINE_LENGTH, ifp)){      if(szLine[0] == '>'){tif(nSequences > 0){t  ptData->anLen[nSequences - 1] = nPos;t}tptData->aacSequences[nSequences] = (char *) malloc(ptData->nMaxLen*sizeof(char));tszBrk = strpbrk(szLine, "" "");t(*szBrk) = '0';tptData->aszID[nSequences] = strdup(szLine + 1);tnPos = 0;tnSequences++;      }          i = 0;      while(szLine[i] != '0' && strrchr(szSequence,szLine[i]) != NULL){tptData->aacSequences[nSequences - 1][nPos] = szLine[i];tnPos++; i++;      }    }    ptData->anLen[nSequences - 1] = nPos;    fclose(ifp);  }  else{    fprintf(stderr, ""Can't open input file %s"", ptParams->szInputFile);    exit(EXIT_FAILURE);  }}",5,"cwe119,cwe120,cwe476,cwe469,cweother"
"mtd_read(const struct mtd_dev_info *mtd, int fd, int eb, int offs,t     void *buf, int len){tint ret, rd = 0;toff_t seek;tret = mtd_valid_erase_block(mtd, eb);tif (ret)ttreturn ret;tif (offs < 0 || offs + len > mtd->eb_size) {tterrmsg(""bad offset %d or length %d, mtd%d eraseblock size is %d"",tt       offs, len, mtd->mtd_num, mtd->eb_size);tterrno = EINVAL;ttreturn -1;t}t tseek = (off_t)eb * mtd->eb_size + offs;tif (lseek(fd, seek, SEEK_SET) != seek)ttreturn sys_errmsg(""cannot seek mtd%d to offset %""PRIdoff_t,tttt  mtd->mtd_num, seek);twhile (rd < len) {ttret = read(fd, buf, len);ttif (ret < 0)tttreturn sys_errmsg(""cannot read %d bytes from mtd%d (eraseblock %d, offset %d)"",ttttt  len, mtd->mtd_num, eb, offs);ttrd += ret;t}treturn 0;}",2,"cwe120,cweother"
"options_dialogs_update(void){  char buf[64];  int i;  fc_assert_ret(NULL != dialog_options_hash);     for (i = 1; i < num_player_dlg_columns; i++) {    fc_snprintf(buf, sizeof(buf), ""player_dlg_%s"",                player_dlg_columns[i].tagname);    dialog_options_hash_replace(dialog_options_hash, buf,                                player_dlg_columns[i].show);  }     for (i = 0; i < num_city_report_spec(); i++) {    fc_snprintf(buf, sizeof(buf), ""city_report_%s"",                city_report_spec_tagname(i));    dialog_options_hash_replace(dialog_options_hash, buf,                                *city_report_spec_show_ptr(i));  }}",2,"cwe119,cwe120"
"scen_get_date( char *date_str ){    int hour;    int phase;    char buf[256];    Date date = scen_info->start_date;    if ( scen_info->days_per_turn > 0 ) {        date_add_days( &date, scen_info->days_per_turn * turn );        date_to_str( date_str, date, FULL_NAME_DATE );    }    else {        date_add_days( &date, turn / scen_info->turns_per_day );        date_to_str( buf, date, FULL_NAME_DATE );        phase = turn % scen_info->turns_per_day;        hour = 8 + phase * 6;        sprintf( date_str, ""%s %02i:00"", buf, hour );    }}",2,"cwe119,cwe120"
"sread(int sock, char *buf, int nbytes){  int nread = 0;tt   int r;ttt   double starttime = 0.0;t   if (((_kio.ki_rtf & RTF_TRON) == RTF_TRON)      && FD_ISSET(sock, &lam_ssi_rpi_tcp_block)) {    starttime = ttime();  }  do {    r = read(sock, buf, nbytes);    if (r < 0) {      if (errno == EAGAIN) {tbreak;      }      if (errno != EINTR) {tcomminvalidate(sock);treturn (0);      }    } else if ((r == 0) && (nbytes > 0)) {t       if (FD_ISSET(sock, &lam_ssi_rpi_tcp_eoferr)) {tcomminvalidate(sock);      }      return (0);    } else {      nread += r;      buf += r;      nbytes -= r;    }  } while (nbytes > 0);  if (((_kio.ki_rtf & RTF_TRON) == RTF_TRON)      && FD_ISSET(sock, &lam_ssi_rpi_tcp_block)) {    _kio.ki_blktime += (ttime() - starttime);  }  FD_CLR(sock, &lam_ssi_rpi_tcp_eoferr);  return (nread);}",2,"cwe120,cweother"
"main(int argc,char* argv[]) {tprintf(t""""tt""|_  _ || _  _  _ ||   a blazingly-fast async HTTP server written in C++""tt""[ )(/,||(/,[_)(_)||   (c) William Edwards, 2011""tt""           |          The Simplified BSD License""tt"""");tint port = 42042;tbool console = false, timeouts = true, logging = true;tint opt;twhile((opt = getopt(argc,argv,""p:chzlr"")) != -1) {ttswitch(opt) {ttcase 'p':tttport = atoi(optarg);tttif(port < 1 || port > 0xffff) {ttttfprintf(stderr,""port out of bounds"");ttttreturn 1;ttt}tttbreak;ttcase 'c':tttconsole = true;tttbreak;ttcase 'z':ttttimeouts = false;tttbreak;ttcase 'l':tttlogging = false;tttbreak;ttcase '?':tttif('p'==optopt)ttttfprintf (stderr,""Option -%c requires an argument."",optopt);tttelse if(32 < optopt)ttttfprintf (stderr,""Unknown option `-%c'."",optopt);tttelsettttfprintf (stderr,""Unknown option character `x%x'."",optopt);             ttreturn 1;             tdefault:             ttfprintf(stderr,""unknown option %c"",opt);             tt              tcase 'h':tttfprintf(stderr,""usage: ./helloworld {-p [port]} {-f [num]} {-c} {-z} {-l}""tttt""  -c enables a console (so you can type ""quit"" for a clean shutdown in valgrind)""tttt""  -z disables all timeouts (useful for test scripts or debugging clients)""tttt""  -l disables logging to file (logging is turned off if running under valgrind)""tttt""  -r enables rtmp on port+2 (experimental)"");tttreturn 0;tt}t}ttry {ttif(logging && !RUNNING_ON_VALGRIND)tttInitLog(""helloworld.log"");ttprintf(""=== Starting HelloWorld ==="");ttScheduler scheduler;ttif(!timeouts)tttscheduler.enable_timeouts(false);ttsignal(SIGPIPE, SIG_IGN);  ttsignal(SIGCHLD, SIG_IGN);ttif(console)tttConsole::create(scheduler);ttListener::create(scheduler,""HTTP"",port,HelloWorld::factory,100,true);ttscheduler.run();t} catch(Error* e) {tte->dump();tte->release();t} catch(std::exception& e) {ttfprintf(stderr,""%s"",e.what());t} catch(...) {ttfprintf(stderr,""unexpected exception!"");t}treturn 0;}",2,"cwe120,cweother"
"Niall_LoadDictionary(char *FileName){tchar Buffer[BUFSIZ];tFILE *fHandle;tint nWords,i,d;tint nAsocs,j,w,p,k;tWORD *Word;tfHandle=fopen(FileName,""r"");tif(!fHandle)t{ttNiall_Warning(""File %s not found."",FileName);ttreturn;t}tfscanf(fHandle,""%s %d"",Buffer,&nWords);tif((strcmp(Buffer,FILE_ID))||(nWords<2))t{ttNiall_Warning(""File %s is not a valid Niall file."",FileName);ttreturn;t}tClearDictionary();tfor(i=0;i<nWords;i++)t{ttfscanf(fHandle,""%4d: %s %d|"",&d,Buffer,&nAsocs);ttif((d!=i)||(nAsocs<1))tt{tttNiall_Warning(""Word %d is corrupted."",i);tttNiall_NewDictionary();tttreturn;tt}ttif(Buffer[0]=='>')tt{tttif(i!=0)ttt{ttttNiall_Warning(""Word %d is corrupted."",i);ttttNiall_NewDictionary();ttttreturn;ttt}tttBuffer[0]=0;tt}ttWord=AddWord(Buffer);ttif(Word==NULL) Niall_Error(""Out of memory."");ttfor(j=0;j<nAsocs;)tt{tttfscanf(fHandle,"" %d(%d)"",&w,&p);tttif(w>=nWords)ttt{ttttNiall_Warning(""Word %d/Assoc %d is corrupted."",i,j);ttttNiall_NewDictionary();ttttreturn;ttt}tttfor(k=0;k<p;k++) Associate(Word,w);tttj+=p;tt}t}}",2,"cwe469,cweother"
"remove_affiliate(GHashTable *hash, jid userid){  xmlnode old;  xmlnode store;  xmlnode node;  char ujid[2048];  if(userid == NULL)  {    return -1;  }  snprintf(ujid, sizeof(ujid), ""%s@%s"", userid->user, userid->server);  old = g_hash_table_lookup(hash, ujid);  if(old == NULL)    return 1;  store = xmlnode_dup(old);  node = xmlnode_get_tag(store, spools(xmlnode_pool(store), ""item?jid="", jid_full(userid), xmlnode_pool(store)));   if(node == NULL)  {    xmlnode_free(store);    return 1;  }  xmlnode_hide(node);  g_hash_table_insert(hash, j_strdup(ujid), store);  return 1;}",2,"cwe119,cwe120"
"DBFCloneEmpty(DBFHandle psDBF, const char * pszFilename ) {    DBFHandletnewDBF;   newDBF = DBFCreate ( pszFilename );   if ( newDBF == NULL ) return ( NULL );       newDBF->pszHeader = (void *) malloc ( 32 * psDBF->nFields );   memcpy ( newDBF->pszHeader, psDBF->pszHeader, 32 * psDBF->nFields );      newDBF->nFields = psDBF->nFields;   newDBF->nRecordLength = psDBF->nRecordLength;   newDBF->nHeaderLength = psDBF->nHeaderLength;       newDBF->panFieldOffset = (void *) malloc ( sizeof(int) * psDBF->nFields );    memcpy ( newDBF->panFieldOffset, psDBF->panFieldOffset, sizeof(int) * psDBF->nFields );   newDBF->panFieldSize = (void *) malloc ( sizeof(int) * psDBF->nFields );   memcpy ( newDBF->panFieldSize, psDBF->panFieldSize, sizeof(int) * psDBF->nFields );   newDBF->panFieldDecimals = (void *) malloc ( sizeof(int) * psDBF->nFields );   memcpy ( newDBF->panFieldDecimals, psDBF->panFieldDecimals, sizeof(int) * psDBF->nFields );   newDBF->pachFieldType = (void *) malloc ( sizeof(int) * psDBF->nFields );   memcpy ( newDBF->pachFieldType, psDBF->pachFieldType, sizeof(int) * psDBF->nFields );   newDBF->bNoHeader = TRUE;   newDBF->bUpdated = TRUE;      DBFWriteHeader ( newDBF );   DBFClose ( newDBF );      newDBF = DBFOpen ( pszFilename, ""rb+"" );   return ( newDBF );}",2,"cwe120,cweother"
"read_gamess_trj_first_geometry(gchar *FileName, GeometryMD* geometry){ tgchar *t; tgchar *pos; tFILE *file; tgint i;tgint nAtoms = 0;tAtomMD* listOfAtoms = NULL;   tfile = FOpen(FileName, ""rb"");tt=g_malloc(BSIZE*sizeof(gchar));tif(!t) return FALSE; twhile(!feof(file))t{  ttif(!fgets(t,BSIZE,file))break;ttif(strstr( t,""NAT=""))tt{tttpos = strstr( t,""AT="")+3;tttnAtoms = atoi(pos);tttbreak;tt}t}tif(nAtoms<1) t{ ttfclose(file);ttg_free(t);ttreturn FALSE;t}    tlistOfAtoms = g_malloc(nAtoms*sizeof(AtomMD)); twhile(!feof(file))t{  ttif(!fgets(t,BSIZE,file))break;ttif(strstr( t,""QM PARTICLE COORDINATES""))tt{tttfor(i=0;i<nAtoms;i++)ttt{  ttttif(!fgets(t,BSIZE,file))break;ttttif(5!=sscanf(t,""%s %lf %lf %lf %lf"",ttttlistOfAtoms[i].symbol,tttt&listOfAtoms[i].nuclearCharge,tttt&listOfAtoms[i].C[0],tttt&listOfAtoms[i].C[1],tttt&listOfAtoms[i].C[2]))break;ttttlistOfAtoms[i].partialCharge = 0.0;ttttlistOfAtoms[i].variable = TRUE;ttttlistOfAtoms[i].C[0] *= ANG_TO_BOHR;ttttlistOfAtoms[i].C[1] *= ANG_TO_BOHR;ttttlistOfAtoms[i].C[2] *= ANG_TO_BOHR;ttttsprintf(listOfAtoms[i].mmType,""%s"",listOfAtoms[i].symbol);ttttsprintf(listOfAtoms[i].pdbType,""%s"",listOfAtoms[i].symbol);ttttsprintf(listOfAtoms[i].resName,""%s"",listOfAtoms[i].symbol);ttttlistOfAtoms[i].resNumber = i;ttt}tttif(i!=nAtoms)ttt{ttttg_free(listOfAtoms);ttttlistOfAtoms = NULL; ttttfclose(file);ttttg_free(t);ttttreturn FALSE;ttt}tttelse ttt{ttttgeometry->listOfAtoms = listOfAtoms;ttttgeometry->numberOfAtoms = nAtoms;ttt}tttbreak;tt}t} tfclose(file); tg_free(t);treturn TRUE;}",2,"cwe120,cweother"
"SetupForEnc(AESArguments *input, const unsigned char *m, Chunk r,ttunsigned long long mLen, unsigned long long numOfChunks){tint i = 0, j = 0;tunsigned char temp[SIZE];  tint sizeOfPadding = 0;tint sizeOfLastChunk = 0;tsizeOfLastChunk = mLen % SIZE;tif (sizeOfLastChunk != 0)ttsizeOfPadding = SIZE - sizeOfLastChunk - 1;tfor (i = 0; i < SIZE; i++)ttinput[0].plainText[i] = r[i];tfor (i = 0; i < numOfChunks - 2; i++)t{ttmemset(temp, 0, SIZE);ttmemcpy(temp, m + (SIZE * i), SIZE);ttfor (j = 0; j < SIZE; j++)tttinput[i + 1].plainText[j] = temp[j];t}tmemset(temp, 0, SIZE);tmemcpy(temp, m + (SIZE * i), SIZE - sizeOfPadding - 1);  tif (sizeOfLastChunk == 0)t{ttmemset(temp, 0, SIZE);tttemp[0] = EOT;t}ttif (sizeOfPadding == 0 && sizeOfLastChunk == 15)tttemp[SIZE-1] = EOT;tt tif (sizeOfLastChunk != 0 && sizeOfLastChunk != 15)t{tttemp[SIZE - sizeOfPadding - 1] = EOT;tt ttfor (i = 0; i < sizeOfPadding - 1; i++)ttttemp[SIZE - sizeOfPadding + i] = pad;tttemp[SIZE - 1] = (char) sizeOfPadding;t}ttfor (j = 0; j < SIZE; j++)ttinput[numOfChunks - 1].plainText[j] = temp[j];}",2,"cwe119,cwe120"
"RewriteControlFile(void){tinttttfd;tcharttbuffer[PG_CONTROL_SIZE];tt t tXLogSegNoOffsetToRecPtr(newXlogSegNo, SizeOfXLogLongPHD,tttttttControlFile.checkPointCopy.redo);tControlFile.checkPointCopy.time = (pg_time_t) time(NULL);tControlFile.state = DB_SHUTDOWNED;tControlFile.time = (pg_time_t) time(NULL);tControlFile.checkPoint = ControlFile.checkPointCopy.redo;tControlFile.prevCheckPoint = 0;tControlFile.minRecoveryPoint = 0;tControlFile.minRecoveryPointTLI = 0;tControlFile.backupStartPoint = 0;tControlFile.backupEndPoint = 0;tControlFile.backupEndRequired = false;t tControlFile.wal_level = WAL_LEVEL_MINIMAL;tControlFile.wal_log_hints = false;tControlFile.track_commit_timestamp = false;tControlFile.MaxConnections = 100;tControlFile.max_worker_processes = 8;tControlFile.max_prepared_xacts = 0;tControlFile.max_locks_per_xact = 64;t tControlFile.xlog_seg_size = XLogSegSize;t tINIT_CRC32C(ControlFile.crc);tCOMP_CRC32C(ControlFile.crc,tttt(char *) &ControlFile,ttttoffsetof(ControlFileData, crc));tFIN_CRC32C(ControlFile.crc);t tif (sizeof(ControlFileData) > PG_CONTROL_SIZE)t{ttfprintf(stderr,tttt_(""%s: internal error -- sizeof(ControlFileData) is too large ... fix PG_CONTROL_SIZE""),ttttprogname);ttexit(1);t}tmemset(buffer, 0, PG_CONTROL_SIZE);tmemcpy(buffer, &ControlFile, sizeof(ControlFileData));tunlink(XLOG_CONTROL_FILE);tfd = open(XLOG_CONTROL_FILE,ttt  O_RDWR | O_CREAT | O_EXCL | PG_BINARY,ttt  S_IRUSR | S_IWUSR);tif (fd < 0)t{ttfprintf(stderr, _(""%s: could not create pg_control file: %s""),ttttprogname, strerror(errno));ttexit(1);t}terrno = 0;tif (write(fd, buffer, PG_CONTROL_SIZE) != PG_CONTROL_SIZE)t{tt ttif (errno == 0)ttterrno = ENOSPC;ttfprintf(stderr, _(""%s: could not write pg_control file: %s""),ttttprogname, strerror(errno));ttexit(1);t}tif (fsync(fd) != 0)t{ttfprintf(stderr, _(""%s: fsync error: %s""), progname, strerror(errno));ttexit(1);t}tclose(fd);}",3,"cwe119,cwe120,cweother"
"chnames_ColorSpaceSignature(icColorSpaceSignature sig,char *cvals[]tttt ) {tswitch (sig) {    tcase icSigXYZData:tttcvals[0] = ""CIE X"";tttcvals[1] = ""CIE Y"";tttcvals[2] = ""CIE Z"";tttreturn 2;    tcase icSigLabData:tttcvals[0] = ""CIE L*"";tttcvals[1] = ""CIE a*"";tttcvals[2] = ""CIE b*"";tttreturn 2;    tcase icSigLuvData:tttcvals[0] = ""CIE L*"";tttcvals[1] = ""CIE u*"";tttcvals[2] = ""CIE v*"";tttreturn 2;tt     tcase icSigYCbCrData:tttcvals[0] = ""ITU Y"";tttcvals[1] = ""ITU Cb"";tttcvals[2] = ""ITU Cr"";tttreturn 2;    tcase icSigYxyData:tttcvals[0] = ""CIE Y"";tttcvals[1] = ""CIE x"";tttcvals[2] = ""CIE y"";tttreturn 2;tt     tcase icSigHsvData:tttcvals[0] = ""RGB Hue"";tttcvals[1] = ""RGB Saturation"";tttcvals[2] = ""RGB Value"";tttreturn 2;tt     tcase icSigHlsData:tttcvals[0] = ""RGB Hue"";tttcvals[1] = ""RGB Lightness"";tttcvals[2] = ""RGB Saturation"";tttreturn 2;ttcase icSigCmyData:tttcvals[0] = ""Cyan"";tttcvals[1] = ""Magenta"";tttcvals[2] = ""Yellow"";tttreturn 1;ttcase icSigRgbData:tttcvals[0] = ""Red"";tttcvals[1] = ""Green"";tttcvals[2] = ""Blue"";tttreturn 1;ttcase icSigCmykData:tttcvals[0] = ""Cyan"";tttcvals[1] = ""Magenta"";tttcvals[2] = ""Yellow"";tttcvals[3] = ""Black"";tttreturn 1;tttt     tcase icmSigYData:tttcvals[0] = ""CIE Y"";tttreturn 2;    tcase icmSigLData:tttcvals[0] = ""CIE L*"";tttreturn 2;ttdefault:tttbreak;t}treturn 0;}",2,"cwe119,cwe120"
"""read_line(FILE *fp, char *ident){tint c;tint x;tc = fgetc(fp);twhile (c != '') {ttc = fgetc(fp);t}tx = 0;tc = fgetc(fp);twhile (c != EOFt    && c != '0't    && c != ''t    && c != 'r') {ttident[x++] = c;ttc = fgetc(fp);t}tident[x] = '0';t_ungetc(c, fp);treturn 0;}""",2,"cwe120,cweother"
"ld_lbxtab(char *lbxptr, struct optlst_t *olp){ int32 len; char *cp, *cpbg, *chp2; char s1[IDLEN], s2[IDLEN]; len = strlen(lbxptr); if (len == 0)  {   __gfwarn(505, olp->optfnam_ind, olp->optlin_cnt,    ""+libext+ option missing libary extension list - ignored"");   return(FALSE);  }    if (lbxptr[len - 1] != '+')  { chp2 = s2; strcpy(chp2, lbxptr); chp2[len] = '+'; chp2[len + 1] = '0'; } else chp2 = lbxptr; for (cpbg = chp2, len = 0;;)  {       if ((cp = strchr(cpbg, '+')) == NULL || (len = cp - cpbg) >= IDLEN - 1)    __misc_terr(__FILE__, __LINE__);   if (++__last_lbx >= MAXLBEXTS)    {     __pv_terr(306, ""+libext+ option - too many library suffixes (%d)"",      MAXLBEXTS);    }       if (len > 0) strncpy(s1, cpbg, len);   s1[len] = '0';   __lbexts[__last_lbx] = __pv_stralloc(s1);   cpbg = ++cp;   if (*cpbg == '0') break;  } return(TRUE);}",2,"cwe119,cwe120"
"decode_user(uid_t uid, uid_t *sav_uid, char *sav_uidstr){tstruct passwd *pw;tif (uid != *sav_uid) {#ifdef VIRTUAL_IDttif (uid == 0)tttreturn (""root"");tt*sav_uid = uid;ttif (Cns_getusrbyuid (*sav_uid, sav_uidstr) < 0)#elsett*sav_uid = uid;ttif (pw = getpwuid (*sav_uid))tttstrcpy (sav_uidstr, pw->pw_name);ttelse#endiftttreturn (NULL);t}treturn (sav_uidstr);}",2,"cwe119,cwe120"
"__pv_ferr(int32 id_num, char *s, ...){ va_list va, va2, va3; int32 slen; char vpis1[IDLEN], vpis2[4*IDLEN], *vpichp;  __pv_err_cnt++; if (__iact_state)  {       va_start(va, s);   va_start(va2, s);   __via_err(id_num, s, va, va2);   va_end(va);   va_end(va2);   return;  }  if (!__no_errs)  {   if (__vpierr_cb_active)    {           __errorcb_suppress_msg = FALSE;     sprintf(vpis1, ""**%s(%d) ERROR** [%d] "", __cur_fnam, __lin_cnt, id_num);     va_start(va, s);     vsprintf(vpis2, s, va);     va_end(va);        slen = strlen(vpis1) + strlen(vpis2) + 1;     vpichp = __my_malloc(slen);     strcpy(vpichp, vpis1);     strcat(vpichp, vpis2);     __cberror_fill_einfo(ERROR, id_num, vpichp, __cur_fnam, __lin_cnt);     __vpi_error_trycall();     __my_free(vpichp, slen);            if (__errorcb_suppress_msg)      { __errorcb_suppress_msg = FALSE; return; }    }   __my_fprintf(stdout, ""**%s(%d) ERROR** [%d] "", __cur_fnam, __lin_cnt,    id_num);       va_start(va2, s);   va_start(va3, s);   __my_vfprintf(stdout, s, va2, va3);   va_end(va2);   va_end(va3);   my_putc_('', stdout);  } if ((__run_state == SS_COMP || __run_state == SS_LOAD)   && __max_errors != 0 && __pv_err_cnt > __max_errors)  __pv_terr(id_num, ""maximum error count exceeded"");}",3,"cwe119,cwe120,cweother"
"int32_put(cram_block *b, int32_t val) {    unsigned char cp[4];    cp[0] = ( val      & 0xff);    cp[1] = ((val>>8)  & 0xff);    cp[2] = ((val>>16) & 0xff);    cp[3] = ((val>>24) & 0xff);    BLOCK_APPEND(b, cp, 4);    return b->data ? 0 : -1;}",2,"cwe119,cwe120"
"SAF_DisconnectChannel(GF_InputService *plug, LPNETCHANNEL channel){tSAFChannel *ch;tSAFIn *read = (SAFIn *)plug->priv;tGF_Err e = GF_STREAM_NOT_FOUND;tch = saf_get_channel(read, 0, channel);tif (ch) {ttgf_list_del_item(read->channels, ch);ttif (ch->esd) gf_odf_desc_del((GF_Descriptor*)ch->esd);ttgf_free(ch);tte = GF_OK;t}tgf_term_on_disconnect(read->service, channel, e);treturn GF_OK;}",2,"cwe120,cweother"
"""resolve(ParamElem plst[]){  int i;  if (allLength > 0) return;t/* ALL has already done this */  /* Resolve ambiguities by presence */  for (i=0; plst[i].code != EOF; i++)    if (plst[i].code < LITMIN)t/* Literals are always 'here' */      if (!isHere(plst[i].code)) {tparams[0] = plst[i];t/* Copy error param as first one for message */tparams[1].code = EOF;t/* But be sure to terminate */terror(M_NO_SUCH);      }}""",2,"cwe119,cwe120"
"php_plain_files_metadata(php_stream_wrapper *wrapper, char *url, int option, void *value, php_stream_context *context TSRMLS_DC){tstruct utimbuf *newtime;tchar *p;#if !defined(WINDOWS) && !defined(NETWARE)tuid_t uid;tgid_t gid;#endiftmode_t mode;tint ret = 0;#if PHP_WIN32tint url_len = strlen(url);#endif#if PHP_WIN32tif (!php_win32_check_trailing_space(url, url_len)) {ttphp_error_docref1(NULL TSRMLS_CC, url, E_WARNING, ""%s"", strerror(ENOENT));ttreturn 0;t}#endiftif ((p = strstr(url, ""://"")) != NULL) {tturl = p + 3;t}tif (php_check_open_basedir(url TSRMLS_CC)) {ttreturn 0;t}tswitch(option) {ttcase PHP_STREAM_META_TOUCH:tttnewtime = (struct utimbuf *)value;tttif (VCWD_ACCESS(url, F_OK) != 0) {ttttFILE *file = VCWD_FOPEN(url, ""w"");ttttif (file == NULL) {tttttphp_error_docref1(NULL TSRMLS_CC, url, E_WARNING, ""Unable to create file %s because %s"", url, strerror(errno));tttttreturn 0;tttt}ttttfclose(file);ttt}tttret = VCWD_UTIME(url, newtime);tttbreak;#if !defined(WINDOWS) && !defined(NETWARE)ttcase PHP_STREAM_META_OWNER_NAME:ttcase PHP_STREAM_META_OWNER:tttif(option == PHP_STREAM_META_OWNER_NAME) {ttttif(php_get_uid_by_name((char *)value, &uid TSRMLS_CC) != SUCCESS) {tttttphp_error_docref1(NULL TSRMLS_CC, url, E_WARNING, ""Unable to find uid for %s"", (char *)value);tttttreturn 0;tttt}ttt} else {ttttuid = (uid_t)*(long *)value;ttt}tttret = VCWD_CHOWN(url, uid, -1);tttbreak;ttcase PHP_STREAM_META_GROUP:ttcase PHP_STREAM_META_GROUP_NAME:tttif(option == PHP_STREAM_META_OWNER_NAME) {ttttif(php_get_gid_by_name((char *)value, &gid TSRMLS_CC) != SUCCESS) {tttttphp_error_docref1(NULL TSRMLS_CC, url, E_WARNING, ""Unable to find gid for %s"", (char *)value);tttttreturn 0;tttt}ttt} else {ttttgid = (gid_t)*(long *)value;ttt}tttret = VCWD_CHOWN(url, -1, gid);tttbreak;#endifttcase PHP_STREAM_META_ACCESS:tttmode = (mode_t)*(long *)value;tttret = VCWD_CHMOD(url, mode);tttbreak;ttdefault:tttphp_error_docref1(NULL TSRMLS_CC, url, E_WARNING, ""Unknown option %d for stream_metadata"", option);tttreturn 0;t}tif (ret == -1) {ttphp_error_docref1(NULL TSRMLS_CC, url, E_WARNING, ""Operation failed: %s"", strerror(errno));ttreturn 0;t}tphp_clear_stat_cache(0, NULL, 0 TSRMLS_CC);treturn 1;}",2,"cwe119,cwe120"
"infopath_init (){     char *path_from_env = getenv (""INFOPATH"");  if (path_from_env)    {      unsigned len = strlen (path_from_env);             if (len && path_from_env[len - 1] == PATH_SEP[0])t{t  path_from_env[len - 1] = 0;t  infopath_add (DEFAULT_INFOPATH, INFOPATH_PREPEND);t}#ifdef INFODIR        infopath_add (INFODIR, INFOPATH_PREPEND);#endif      infopath_add (path_from_env, INFOPATH_PREPEND);    }  else    {      infopath_add (DEFAULT_INFOPATH, INFOPATH_PREPEND);#ifdef INFODIR        infopath_add (INFODIR, INFOPATH_PREPEND);#endif#ifdef INFODIR2  #  ifdef INFODIR      if (!STREQ (INFODIR, INFODIR2))#  endiftinfopath_add (INFODIR2, INFOPATH_PREPEND);#endif    }}",2,"cwe469,cweother"
"register_bi_functions(){    int loop, num_registries =    sizeof(bi_function_registries) / sizeof(bi_function_registries[0]);    for (loop = 0; loop < num_registries; loop++)t(void) (*(bi_function_registries[loop])) ();}",2,"cwe120,cweother"
"sms_debug (int dir, sms_t *h){tchar txt[259 * 3 + 1];tchar *p = txt;                           tunsigned char *msg = (dir == DIR_RX) ? h->imsg : h->omsg;tint n = (dir == DIR_RX) ? h->ibytep : msg[1] + 2;tint q = 0;twhile (q < n && q < 30) {ttsprintf(p, "" %02X"", msg[q++]);ttp += 3;t}tif (q < n) {ttsprintf(p, ""..."");t}tast_verb(3, ""SMS %s%s"", dir == DIR_RX ? ""RX"" : ""TX"", txt);}",2,"cwe119,cwe120"
"mlxsw_sp_base_mac_get(struct mlxsw_sp *mlxsw_sp){tchar spad_pl[MLXSW_REG_SPAD_LEN];tint err;terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(spad), spad_pl);tif (err)ttreturn err;tmlxsw_reg_spad_base_mac_memcpy_from(spad_pl, mlxsw_sp->base_mac);treturn 0;}",2,"cwe119,cwe120"
"segment_create(opal_shmem_ds_t *ds_buf,               const char *file_name,               size_t size){    int rc = OPAL_SUCCESS;    pid_t my_pid = getpid();         size_t real_size = size + sizeof(opal_shmem_seg_hdr_t);    opal_shmem_seg_hdr_t *seg_hdrp = MAP_FAILED;         shmem_ds_reset(ds_buf);              if (-1 == (ds_buf->seg_id = shmget(IPC_PRIVATE, real_size,                                       IPC_CREAT | IPC_EXCL | S_IRWXU))) {        int err = errno;        char hn[MAXHOSTNAMELEN];        gethostname(hn, MAXHOSTNAMELEN - 1);        hn[MAXHOSTNAMELEN - 1] = '0';        opal_show_help(""help-opal-shmem-sysv.txt"", ""sys call fail"", 1, hn,                       ""shmget(2)"", """", strerror(err), err);        rc = OPAL_ERROR;        goto out;    }         else if ((void *)-1 == (seg_hdrp = shmat(ds_buf->seg_id, NULL, 0))) {        int err = errno;        char hn[MAXHOSTNAMELEN];        gethostname(hn, MAXHOSTNAMELEN - 1);        hn[MAXHOSTNAMELEN - 1] = '0';        opal_show_help(""help-opal-shmem-sysv.txt"", ""sys call fail"", 1, hn,                       ""shmat(2)"", """", strerror(err), err);        shmctl(ds_buf->seg_id, IPC_RMID, NULL);        rc = OPAL_ERROR;        goto out;    }         else if (0 != shmctl(ds_buf->seg_id, IPC_RMID, NULL)) {        int err = errno;        char hn[MAXHOSTNAMELEN];        gethostname(hn, MAXHOSTNAMELEN - 1);        hn[MAXHOSTNAMELEN - 1] = '0';        opal_show_help(""help-opal-shmem-sysv.txt"", ""sys call fail"", 1, hn,                       ""shmctl(2)"", """", strerror(err), err);        rc = OPAL_ERROR;        goto out;    }         else {                 opal_atomic_rmb();                 opal_atomic_init(&seg_hdrp->lock, OPAL_ATOMIC_UNLOCKED);                 seg_hdrp->cpid = my_pid;        opal_atomic_wmb();                 ds_buf->seg_cpid = my_pid;        ds_buf->seg_size = real_size;        ds_buf->seg_base_addr = (unsigned char *)seg_hdrp;                          OPAL_SHMEM_DS_SET_VALID(ds_buf);        OPAL_OUTPUT_VERBOSE(            (70, opal_shmem_base_framework.framework_output,             ""%s: %s: create successful ""             ""(id: %d, size: %lu, name: %s)"",             mca_shmem_sysv_component.super.base_version.mca_type_name,             mca_shmem_sysv_component.super.base_version.mca_component_name,             ds_buf->seg_id, (unsigned long)ds_buf->seg_size, ds_buf->seg_name)        );    }out:         if (OPAL_SUCCESS != rc) {                 if ((void *)-1 != seg_hdrp) {            shmdt((char*)seg_hdrp);        }        shmctl(ds_buf->seg_id, IPC_RMID, NULL);                 shmem_ds_reset(ds_buf);    }    return rc;}",2,"cwe119,cwe120"
"generate_cut_list(struct pattern *pattern, int ll, int anchor,    tt  int cuts[MAX_CUTS], struct local_owl_data *owl){  int k;  int num = 0;  signed char mark[BOARDMAX];  memset(mark, 0, BOARDMAX);  for (k = 0; k < pattern->patlen; k++) {    int pos = AFFINE_TRANSFORM(pattern->patn[k].offset, ll, anchor);    if (!IS_STONE(board[pos]))      continue;    pos = find_origin(pos);    if (!mark[pos] && board[pos] == owl->color && owl->goal[pos]) {      cuts[num++] = pos;      mark[pos] = 1;      if (num == MAX_CUTS)treturn;    }  }  if (num == 1)    cuts[0] = NO_MOVE;  else if ((debug & DEBUG_SPLIT_OWL) && num > 1)    gprintf(""Move provokes %d cuts, among them %1m and %1m."", num,t    cuts[0], cuts[1]);}",2,"cwe119,cwe120"
"ExecConstruct (    PTreeNode *pt,     ObjStruct *os,     int numInputs,    Pointer *inputs,    Pointer result,    InvalidComponentHandle *invalids,    InvalidComponentHandle outInvalid){    int i, j;    int numBasic;    int size;    int subSize;    PTreeNode *arg;    int items;    int allValid;#ifdef COMP_DEBUG    DXDebug (""C"", ""ExecConstruct, %d: pt = 0x%08x, os = 0x%08x"",t__LINE__, pt, os);#endif             arg = pt->args;    for (numBasic = 1, i = 0; i < arg->metaType.rank; ++i) {tnumBasic *= arg->metaType.shape[i];    }    subSize = DXTypeSize (arg->metaType.type) *t   DXCategorySize (arg->metaType.category) *t   numBasic;             size = subSize * numInputs;    items = pt->metaType.items;    for (i = 0; i < items; ++i) {targ = pt->args;tfor (j = 0; j < numInputs; ++j) {t    allValid =tt(invalids[j] == NULL || DXGetInvalidCount(invalids[j]) == 0);t    if (allValid || _dxfComputeInvalidOne(outInvalid, i, invalids[j], i)) {ttif (arg->metaType.items == 1)tt    bcopy ((Pointer)((char *)inputs[j]),ttt   (Pointer)(((char *)result) + (i * size) + j*subSize),ttt   subSize);ttelsett    bcopy ((Pointer)(((char *)inputs[j]) + (i * subSize)),ttt   (Pointer)(((char *)result) + (i * size) + j*subSize),ttt   subSize);t    }t    elsettbreak;t    arg = arg->next;t}    }    return (OK);}",2,"cwe119,cwe120"
"gftp_fd_read (gftp_request * request, void *ptr, size_t size, int fd){  intptr_t network_timeout;  struct timeval tv;  fd_set fset;  ssize_t ret;  int s_ret;  g_return_val_if_fail (fd >= 0, GFTP_EFATAL);  gftp_lookup_request_option (request, ""network_timeout"", &network_timeout);    errno = 0;  ret = 0;  FD_ZERO (&fset);  do    {      FD_SET (fd, &fset);      tv.tv_sec = network_timeout;      tv.tv_usec = 0;      s_ret = select (fd + 1, &fset, NULL, NULL, &tv);      if (s_ret == -1 && (errno == EINTR || errno == EAGAIN))        {          if (request != NULL && request->cancel)            {              gftp_disconnect (request);              return (GFTP_ERETRYABLE);            }          continue;        }      else if (s_ret <= 0)        {          if (request != NULL)            {              request->logging_function (gftp_logging_error, request,                                         _(""Connection to %s timed out""),                                         request->hostname);              gftp_disconnect (request);            }          return (GFTP_ERETRYABLE);        }      if ((ret = read (fd, ptr, size)) < 0)        {          if (errno == EINTR || errno == EAGAIN)            {              if (request != NULL && request->cancel)                {                  gftp_disconnect (request);                  return (GFTP_ERETRYABLE);                }              continue;            }           if (request != NULL)            {              request->logging_function (gftp_logging_error, request,                                   _(""Error: Could not read from socket: %s""),                                    g_strerror (errno));              gftp_disconnect (request);            }          return (GFTP_ERETRYABLE);        }      break;    }  while (1);  return (ret);}",2,"cwe120,cweother"
"handle_options(int argc, char *argv[]){    int c;    int option_index = 0;    while (1) {        c = getopt_long(argc, argv, short_options, long_options, &option_index);        if (c == -1)            break;        switch (c)        {            case '?':            case 'h':                usage(argv);                break;            case 'b':                opt_blind = 1;                break;            case 'd':                opt_debug = 1;                break;            case 'V':                opt_version = 1;                break;            case 'x':                opt_width = atol(optarg);                break;            case 'y':                opt_height = atol(optarg);                break;            case 's':                opt_skip = atol(optarg);                break;            default:                printf(""?? getopt return character code 0x%x ??"", c);                break;        }    }    return optind;}",2,"cwe120,cweother"
"split_to_dom_tree(const gchar *tag, Split *spl){    xmlNodePtr ret;    ret = xmlNewNode(NULL, BAD_CAST tag);    xmlAddChild(ret, guid_to_dom_tree(""split:id"", xaccSplitGetGUID(spl)));    {        char *memo = g_strdup (xaccSplitGetMemo(spl));        if (memo && g_strcmp0(memo, """") != 0)        {            xmlNewTextChild(ret, NULL, BAD_CAST ""split:memo"",ttt    checked_char_cast (memo));        }tg_free (memo);    }    {        char *action = g_strdup (xaccSplitGetAction(spl));        if (action && g_strcmp0(action, """") != 0)        {            xmlNewTextChild(ret, NULL, BAD_CAST ""split:action"",ttt    checked_char_cast (action));        }tg_free (action);    }    {        char tmp[2];        tmp[0] = xaccSplitGetReconcile(spl);        tmp[1] = '0';        xmlNewTextChild(ret, NULL, BAD_CAST ""split:reconciled-state"",tttBAD_CAST tmp);    }    add_timespec(ret, ""split:reconcile-date"",                 xaccSplitRetDateReconciledTS(spl), FALSE);    add_gnc_num(ret, ""split:value"", xaccSplitGetValue(spl));    add_gnc_num(ret, ""split:quantity"", xaccSplitGetAmount(spl));    {        Account * account = xaccSplitGetAccount (spl);        xmlAddChild (ret, guid_to_dom_tree(""split:account"",                                           xaccAccountGetGUID (account)));    }    {        GNCLot * lot = xaccSplitGetLot (spl);        if (lot)        {            xmlAddChild (ret, guid_to_dom_tree(""split:lot"",                                               gnc_lot_get_guid(lot)));        }    }    {        xmlNodePtr kvpnode = kvp_frame_to_dom_tree(""split:slots"",                             xaccSplitGetSlots(spl));        if (kvpnode)        {            xmlAddChild(ret, kvpnode);        }    }    return ret;}",2,"cwe119,cwe120"
"uild_iso(FILE *psar, FILE *iso_table, int base_offset, int disc_num)r{rtif ((psar == NULL) || (iso_table == NULL))rt{rttprintf(""ERROR: Can't open input files for ISO!"");rttreturn -1;rt}rrt tint iso_block_size = 0x9300;rtunsigned char iso_block_comp[0x9300];    tunsigned char iso_block_decomp[0x9300];  tmemset(iso_block_comp, 0, iso_block_size);rtmemset(iso_block_decomp, 0, iso_block_size);rrt tint table_offset = 0x3C00;   tfseek(iso_table, table_offset, SEEK_SET);rrt tchar iso_filename[0x10];rtif (disc_num > 0)rttsprintf(iso_filename, ""ISO_%d.BIN"", disc_num);rtelserttsprintf(iso_filename, ""ISO.BIN"");rrt tFILE* iso = fopen(iso_filename, ""wb"");rtif (iso == NULL)rt{rttprintf(""ERROR: Can't open output file for ISO!"");rttreturn -1;rt}rrtint iso_base_offset = 0x100000 + base_offset;   tISO_ENTRY entry[sizeof(ISO_ENTRY)];tmemset(entry, 0, sizeof(ISO_ENTRY));rrt tfread(entry, sizeof(ISO_ENTRY), 1, iso_table);rrt twhile (entry->size > 0)rt{rtt ttfseek(psar, iso_base_offset + entry->offset, SEEK_SET);rttfread(iso_block_comp, entry->size, 1, psar);rrtt ttif (entry->size < iso_block_size)    tttdecompress(iso_block_decomp, iso_block_comp, iso_block_size);rttelsetttttttt tttmemcpy(iso_block_decomp, iso_block_comp, iso_block_size);rtttrtt ttif (!entry->marker)rtt{rttt tttchar junk_data_filename[0x20];rtttsprintf(junk_data_filename, ""JUNK_%08X.BIN"", entry->offset);rtttrttt tttFILE* junk_data = fopen(junk_data_filename, ""wb"");rtttfwrite(iso_block_decomp, iso_block_size, 1, junk_data);rtttfclose(junk_data);rtt}rttelsertt{rttt tttfwrite(iso_block_decomp, iso_block_size, 1, iso);rtt}rrtt ttmemset(iso_block_comp, 0, iso_block_size);rttmemset(iso_block_decomp, 0, iso_block_size);rrtt tttable_offset += sizeof(ISO_ENTRY);rttfseek(iso_table, table_offset, SEEK_SET);rttfread(entry, sizeof(ISO_ENTRY), 1, iso_table);rt}rtrtfclose(iso);rtreturn 0;r}",3,"cwe119,cwe120,cweother"
"snd_pcm_lib_preallocate_proc_write(struct snd_info_entry *entry,ttttt       struct snd_info_buffer *buffer){tstruct snd_pcm_substream *substream = entry->private_data;tchar line[64], str[64];tsize_t size;tstruct snd_dma_buffer new_dmab;tif (substream->runtime) {ttbuffer->error = -EBUSY;ttreturn;t}tif (!snd_info_get_line(buffer, line, sizeof(line))) {ttsnd_info_get_str(str, line, sizeof(str));ttsize = simple_strtoul(str, NULL, 10) * 1024;ttif ((size != 0 && size < 8192) || size > substream->dma_max) {tttbuffer->error = -EINVAL;tttreturn;tt}ttif (substream->dma_buffer.bytes == size)tttreturn;ttmemset(&new_dmab, 0, sizeof(new_dmab));ttnew_dmab.dev = substream->dma_buffer.dev;ttif (size > 0) {tttif (snd_dma_alloc_pages(substream->dma_buffer.dev.type,ttttttsubstream->dma_buffer.dev.dev,ttttttsize, &new_dmab) < 0) {ttttbuffer->error = -ENOMEM;ttttreturn;ttt}tttsubstream->buffer_bytes_max = size;tt} else {tttsubstream->buffer_bytes_max = UINT_MAX;tt}ttif (substream->dma_buffer.area)tttsnd_dma_free_pages(&substream->dma_buffer);ttsubstream->dma_buffer = new_dmab;t} else {ttbuffer->error = -EINVAL;t}}",2,"cwe119,cwe120"
"cli_cmd_volume_statedump_cbk (struct cli_state *state, struct cli_cmd_word *word,                              const char **words, int wordcount){        int                             ret = -1;        rpc_clnt_procedure_t            *proc = NULL;        call_frame_t                    *frame = NULL;        dict_t                          *options = NULL;        int                             sent = 0;        int                             parse_error = 0;        frame = create_frame (THIS, THIS->ctx->pool);        if (!frame)                goto out;        if (wordcount < 3) {                cli_usage_out (word->pattern);                parse_error = 1;                goto out;        }        if (wordcount >= 3) {               ret = cli_cmd_volume_statedump_options_parse (words, wordcount,                                                              &options);               if (ret) {                       parse_error = 1;                       gf_log (""cli"", GF_LOG_ERROR, ""Error parsing ""                               ""statedump options"");                       cli_out (""Error parsing options"");                       cli_usage_out (word->pattern);               }        }        ret = dict_set_str (options, ""volname"", (char *)words[2]);        if (ret)                goto out;        proc = &cli_rpc_prog->proctable[GLUSTER_CLI_STATEDUMP_VOLUME];        if (proc->fn) {                ret = proc->fn (frame, THIS, options);        }out:        if (ret) {                cli_cmd_sent_status_get (&sent);                if ((sent == 0) && (parse_error = 0))                        cli_out (""Volume statedump failed"");        }        return ret;}",2,"cwe119,cwe120"
"HB_GetSentenceBoundaries(const HB_UChar16 *string, hb_uint32 stringLength,                              const HB_ScriptItem * items, hb_uint32 numItems,                              HB_CharAttributes *attributes){   hb_uint32 i;   hb_uint32 brk;    if (stringLength == 0)        return;    brk = sentenceBreakTable[SB_Initial][HB_GetSentenceClass(string[0])];    attributes[0].sentenceBoundary = true;    for (i = 1; i < stringLength; ++i) {        if (!attributes[i].charStop) {            attributes[i].sentenceBoundary = false;            continue;        }        brk = sentenceBreakTable[brk][HB_GetSentenceClass(string[i])];        if (brk == SB_Look) {            hb_uint32 lookahead = i + 1;            brk = SB_Break;                        while (lookahead < stringLength) {                hb_uint32 sbrk = HB_GetSentenceClass(string[lookahead]);                if (sbrk != HB_Sentence_Other && sbrk != HB_Sentence_Numeric && sbrk != HB_Sentence_Close) {                    break;                } else if (sbrk == HB_Sentence_Lower) {                    brk = SB_Initial;                    break;                }                ++lookahead;            }            if (brk == SB_Initial) {                while (i < lookahead)                    attributes[i++].sentenceBoundary = false;            }        }        if (brk == SB_Break) {            attributes[i].sentenceBoundary = true;            brk = sentenceBreakTable[SB_Initial][HB_GetSentenceClass(string[i])];        } else {            attributes[i].sentenceBoundary = false;        }    }}",2,"cwe119,cwe120"
"dounicode(BW *bw, unsigned char *s, void *object, int *notify){tint num;tsscanf((char *)s,""%x"",&num);tif (notify)tt*notify = 1;tvsrm(s);tif (bw->b->o.charmap->type)ttutypebw_raw(bw, num, 1);telse {ttunsigned char buf[8];ttint x;ttutf8_encode(buf,num);ttfor(x=0;buf[x];++x)tttutypebw_raw(bw, buf[x], 1);t}tbw->cursor->xcol = piscol(bw->cursor);treturn 0;}",2,"cwe119,cwe120"
"dosum (struct md5_ctx *ctx, const char *file){  FILE *f;  char buffer[BLOCKSIZE + 72];  size_t sum;  f = fopen (file, ""rb"");  if (!f)    {      fprintf (stderr, ""opening %s: %s"", file, xstrerror (errno));      exit (1);    }     if (fseek (f, 16, SEEK_SET) != 0)     {      fprintf (stderr, ""seeking in %s: %s"", file, xstrerror (errno));      exit (1);    }     while (1)    {             size_t n;      sum = 0;             dot{t  n = fread (buffer + sum, 1, BLOCKSIZE - sum, f);t  sum += n;t}      while (sum < BLOCKSIZE && n != 0);      if (n == 0 && ferror (f))        exit (1);             if (n == 0)tbreak;             md5_process_block (buffer, BLOCKSIZE, ctx);    }     if (sum > 0)    md5_process_bytes (buffer, sum, ctx);  if (fclose (f) != 0)     {      fprintf (stderr, ""reading %s: %s"", file, xstrerror (errno));      exit (1);    }}",3,"cwe119,cwe120,cweother"
"lookup_init(const char *mapfmt, int argc, const char *const *argv, void **context){tstruct lookup_context *ctxt;tchar buf[MAX_ERR_BUF];tchar dlbuf[PATH_MAX];tchar *estr;tvoid *dh;tsize_t size;t*context = NULL;tctxt = malloc(sizeof(struct lookup_context));tif (!ctxt) {ttestr = strerror_r(errno, buf, MAX_ERR_BUF);ttlogerr(MODPREFIX ""malloc: %s"", estr);ttreturn 1;t}tif (argc < 1) {ttfree(ctxt);ttlogerr(MODPREFIX ""No map name"");ttreturn 1;t}tctxt->mapname = argv[0];tif (!mapfmt)ttmapfmt = MAPFMT_DEFAULT;tsize = snprintf(dlbuf, sizeof(dlbuf),ttt""%s/%s.so"", SSS_LIB_DIR, SSS_SO_NAME);tif (size >= sizeof(dlbuf)) {ttfree(ctxt);ttlogmsg(MODPREFIX ""sss library path too long"");ttreturn 1;t}tdh = dlopen(dlbuf, RTLD_LAZY);tif (!dh) {ttlogerr(MODPREFIX ""failed to open %s: %s"", dlbuf, dlerror());ttfree(ctxt);ttreturn 1;t}tctxt->dlhandle = dh;tctxt->setautomntent = (setautomntent_t) dlsym(dh, ""_sss_setautomntent"");tif (!ctxt->setautomntent)ttgoto lib_names_fail;tctxt->getautomntent_r = (getautomntent_t) dlsym(dh, ""_sss_getautomntent_r"");tif (!ctxt->getautomntent_r)ttgoto lib_names_fail;tctxt->getautomntbyname_r = (getautomntbyname_t) dlsym(dh, ""_sss_getautomntbyname_r"");tif (!ctxt->getautomntbyname_r)ttgoto lib_names_fail;tctxt->endautomntent = (endautomntent_t) dlsym(dh, ""_sss_endautomntent"");tif (!ctxt->setautomntent)ttgoto lib_names_fail;tctxt->parse = open_parse(mapfmt, MODPREFIX, argc - 1, argv + 1);tif (!ctxt->parse) {ttlogmsg(MODPREFIX ""failed to open parse context"");ttdlclose(dh);ttfree(ctxt);ttreturn 1;t}t*context = ctxt;treturn 0;lib_names_fail:tif ((estr = dlerror()) == NULL)ttlogmsg(MODPREFIX ""failed to locate sss library entry points"");telsettlogerr(MODPREFIX ""dlsym: %s"", estr);tdlclose(dh);tfree(ctxt);treturn 1;}",2,"cwe119,cwe120"
"odbc_errs_add_rdbms(struct _sql_errors *errs, TDS_UINT native, const char *sqlstate, const char *msg, int linenum, int msgstate,tt    const char *server){tstruct _sql_error *p;tint n = errs->num_errors;tif (errs->errs)ttp = (struct _sql_error *) realloc(errs->errs, sizeof(struct _sql_error) * (n + 1));telsettp = (struct _sql_error *) malloc(sizeof(struct _sql_error));tif (!p)ttreturn;terrs->errs = p;tmemset(&errs->errs[n], 0, sizeof(struct _sql_error));terrs->errs[n].native = native;tif (sqlstate)tttds_strlcpy(errs->errs[n].state2, sqlstate, 6);telsetterrs->errs[n].state2[0] = '0';tstrcpy(errs->errs[n].state3, errs->errs[n].state2);tsqlstate2to3(errs->errs[n].state3);t terrs->errs[n].server = (server) ? strdup(server) : strdup(""DRIVER"");terrs->errs[n].msg = msg ? strdup(msg) : odbc_get_msg(errs->errs[n].state3);terrs->errs[n].linenum = linenum;terrs->errs[n].msgstate = msgstate;t++errs->num_errors;}",2,"cwe120,cwe469"
"tetris_get_pixmap (int idx, int color){tint i;tstatic char *pixmap [TETRIS_CELL_SIZE + 2];tchar *line = ""                    "";t tpixmap[0] = ""20 20 1 1"";tif (idx == TETRIS_UNUSED)ttpixmap[1] = ""  c #969696"";telsettswitch (idx & TETRIS_BRICK_MASK)tt{tttcase TETRIS_BRICK_4: pixmap[1] = ""  c blue""; break;tttcase TETRIS_BRICK_22: pixmap[1] = ""  c red""; break;tttcase TETRIS_BRICK_121A: pixmap[1] = ""  c yellow""; break;tttcase TETRIS_BRICK_121B: pixmap[1] = ""  c magenta""; break;tttcase TETRIS_BRICK_T: pixmap[1] = ""  c green""; break;tttcase TETRIS_BRICK_LA: pixmap[1] = ""  c pink""; break;tttcase TETRIS_BRICK_LB: pixmap[1] = ""  c orange""; break;tttcase TETRIS_BRICK_INACTIVE: pixmap[1] = ""  c gray""; break;tttdefault: return NULL;tt}tfor (i=0; i<TETRIS_CELL_SIZE; i++) pixmap[2+i] = line;treturn pixmap;}",2,"cwe119,cwe120"
"readline(void){        unsigned char buffer[128];tchar *p;tint ret, i;tret = read(0, buffer, sizeof(buffer));tif (ret == 0 || (ret == -1 && errno != EINTR)) {tt ttsignal_emit(""command quit"", 1, ""Lost terminal"");                return;t}tfor (i = 0; i < ret; i++)ttg_string_append_c(input, buffer[i]);tp = strchr(input->str, '');tif (p != NULL) {tt*p = '0';ttsignal_emit(""send command"", 3, input->str,ttt    active_win->active_server, active_win->active);tt*p = '';ttg_string_erase(input, 0, (int) (p-input->str)+1);t}}",3,"cwe119,cwe120,cweother"
"ReadConstantParameters(char *filename, TStateModel *model){  char *id;  int i, j, s;  FILE *f_in;  TMatrix A0=(TMatrix)NULL, Aplus=(TMatrix)NULL;  T_VAR_Parameters *p=(T_VAR_Parameters*)(model->theta);  if (!(f_in=fopen(filename,""rt"")))    {      printf(""Unable to read the input data file: %s"", filename);      dw_exit(0);    }     id=""//== A0hat: nvar-by-nvar ==//"";  if (!dw_SetFilePosition(f_in,id) || !dw_ReadMatrix(f_in,A0=CreateMatrix(p->nvars,p->nvars))) ReadError_VARio_matlab(id);  for (j=p->nvars-1; j >= 0; j--)    for (s=p->n_coef_states[j]-1; s >= 0; s--)      for (i=p->nvars-1; i >= 0; i--)tElementV(p->A0[j][s],i)=ElementM(A0,i,j);  FreeMatrix(A0);     id=""//== Aphat: ncoef(lags*nvar+1)-by-nvar ==//"";  if (!dw_SetFilePosition(f_in,id) || !dw_ReadMatrix(f_in,Aplus=CreateMatrix(p->npre,p->nvars))) ReadError_VARio_matlab(id);  for (j=p->nvars-1; j >= 0; j--)    for (s=p->n_coef_states[j]-1; s >= 0; s--)      for (i=p->npre-1; i >= 0; i--)tElementV(p->Aplus[j][s],i)=ElementM(Aplus,i,j);  FreeMatrix(Aplus);       for (j=p->nvars-1; j >= 0; j--)    for (s=p->n_var_states[j]-1; s >= 0; s--)      p->Zeta[j][s]=1.0;     Update_b0_bplus_from_A0_Aplus(p);  if (p->Specification & SPEC_SIMS_ZHA) Update_lambda_psi_from_bplus(p);     p->valid_parameters=1;     DefaultTransitionMatrixParameters(model);  ThetaChanged(model);     fclose(f_in);}",2,"cwe476,cweother"
"Read(int fd, void *ubuf, int size){    register int ret=0,r;    register char *buf=ubuf;    do {tr=read(fd,buf,size);tif (r<0) t    return r;telse if (!r)t    return ret;telset    size-=r, buf+=r, ret+=r;    } while (size);    return ret;}",2,"cwe120,cweother"
"append_comment(const char *t) { tif (data_dest == DEST_GAME) {tt ttif (GameCnt < 1) {tttappend_str(&initial_comments,t);tt} else {tttappend_str(&(Game[GameCnt].comments),t);tt}t}}",3,"cwe119,cwe120,cweother"
"dumpalign(NCalignment* ncalign){    char* result;    char tmp[1024];    if(ncalign == NULL)tresult = nulldup(""NCalignment{size=-- alignment=-- offset=--}"");    else {        snprintf(tmp,sizeof(tmp),""NCalignment{size=%lu alignment=%lu offset=%lu}"",tt ncalign->size,ncalign->alignment,ncalign->offset);        result = nulldup(tmp);    }    return result;}",3,"cwe119,cwe120,cwe469"
"shutdown_file(char *buf, int size){    FILE *f;    static char shutdownfilename[1024] = """";    char *p;        if (!shutdownfilename[0])tsnprintf(shutdownfilename, sizeof(shutdownfilename), tt ""%s/msg/shutdown"", config_dir);    f = fopen(shutdownfilename, ""r"");    if (!f) return 0;    if (!fgets(buf, size, f)) {t*buf = '0';tsyslog(LOG_DEBUG, ""Shutdown file exists with no contents"");    }    else {tif ((p = strchr(buf, 'r')) != NULL) *p = 0;tif ((p = strchr(buf, '')) != NULL) *p = 0;tsyslog(LOG_DEBUG, ""Shutdown file: %s, closing connection"", buf);    }    fclose(f);    return 1;}",3,"cwe119,cwe120,cweother"
"allocate_data_buffer(void) {  free_data_buffer();  data_buffer=(data_buffer_t*)malloc(sizeof(data_buffer_t)*data_buffer_num);  if(data_buffer == NULL) return false;  unsigned int i;  for(i = 0;i<data_buffer_num;i++) {    data_buffer[i].used=0;    data_buffer[i].data=(unsigned char*)malloc(data_buffer_size);    if(data_buffer[i].data == NULL) {      logger.msg(Arc::ERROR, ""Failed to allocate memory for buffer"");      break;    };  };  if(i == 0) {    free(data_buffer); data_buffer=NULL; return false;  };  logger.msg(Arc::VERBOSE, ""Allocated %u buffers %llu bytes each."", i, data_buffer_size);  data_buffer_num=i;  return true;}",2,"cwe120,cweother"
"lpfc_option_rom_version_show(struct device *dev, struct device_attribute *attr,ttt     char *buf){tstruct Scsi_Host  *shost = class_to_shost(dev);tstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;tstruct lpfc_hba   *phba = vport->phba;tchar fwrev[FW_REV_STR_SIZE];tif (phba->sli_rev < LPFC_SLI_REV4)ttreturn snprintf(buf, PAGE_SIZE, ""%s"", phba->OptionROMVersion);tlpfc_decode_firmware_rev(phba, fwrev, 1);treturn snprintf(buf, PAGE_SIZE, ""%s"", fwrev);}",2,"cwe119,cwe120"
"yyline(){    include * const i = incp;    if ( !incp )        return EOF;              if ( *i->string )        return *i->string++;         if ( i->strings )    {        if ( *i->strings )        {            ++i->line;            i->string = *(i->strings++);            return *i->string++;        }    }    else    {                 if ( !i->file )        {            FILE * f = stdin;            if ( strcmp( object_str( i->fname ), ""-"" ) && !( f = fopen( object_str( i->fname ), ""r"" ) ) )                perror( object_str( i->fname ) );            i->file = f;        }                 if ( i->file && fgets( i->buf, sizeof( i->buf ), i->file ) )        {            ++i->line;            i->string = i->buf;            return *i->string++;        }    }         incp = i->next;         if ( i->file && ( i->file != stdin ) )        fclose( i->file );    object_free( i->fname );    BJAM_FREE( (char *)i );    return EOF;}",2,"cwe469,cweother"
"ds1347_read_time(struct device *dev, struct rtc_time *dt){tstruct spi_device *spi = to_spi_device(dev);tint err;tunsigned char buf[8];tbuf[0] = DS1347_CLOCK_BURST | 0x80;terr = spi_write_then_read(spi, buf, 1, buf, 8);tif (err)ttreturn err;tdt->tm_sec = bcd2bin(buf[0]);tdt->tm_min = bcd2bin(buf[1]);tdt->tm_hour = bcd2bin(buf[2] & 0x3F);tdt->tm_mday = bcd2bin(buf[3]);tdt->tm_mon = bcd2bin(buf[4]) - 1;tdt->tm_wday = bcd2bin(buf[5]) - 1;tdt->tm_year = bcd2bin(buf[6]) + 100;treturn rtc_valid_tm(dt);}",2,"cwe119,cwe120"
"cmd_myrights(const char *tag, const char *name){    char mailboxname[MAX_MAILBOX_BUFFER];    int r, rights = 0;    char *acl;    char str[ACL_MAXSTR];    r = (*imapd_namespace.mboxname_tointernal)(&imapd_namespace, name,ttttt       imapd_userid, mailboxname);    if (!r) {tr = mlookup(tag, name, mailboxname, NULL, NULL, &acl, NULL);    }    if (r == IMAP_MAILBOX_MOVED) return;    if (!r) {trights = cyrus_acl_myrights(imapd_authstate, acl);t tif (imapd_userisadmin) {t    rights |= ACL_LOOKUP|ACL_ADMIN;t}telse if (mboxname_userownsmailbox(imapd_userid, mailboxname)) {t    rights |= config_implicitrights;t}tif (!(rights & (ACL_LOOKUP|ACL_READ|ACL_INSERT|ACL_CREATE|ACL_DELETEMBOX|ACL_ADMIN))) {t    r = IMAP_MAILBOX_NONEXISTENT;t}    }    imapd_check(NULL, 0);    if (r) {tprot_printf(imapd_out, ""%s NO %sr"", tag, error_message(r));treturn;    }        prot_printf(imapd_out, ""* MYRIGHTS "");    prot_printastring(imapd_out, name);    prot_printf(imapd_out, "" "");    prot_printastring(imapd_out, cyrus_acl_masktostr(rights, str));    prot_printf(imapd_out, ""r%s OK %sr"", tag,tterror_message(IMAP_OK_COMPLETED));}",2,"cwe119,cwe120"
"""tree_write_stack_finish_subtree(struct tree_write_stack *tws){tint ret;tstruct tree_write_stack *n = tws->next;tunsigned char s[20];tif (n) {ttret = tree_write_stack_finish_subtree(n);ttif (ret)tttreturn ret;ttret = write_sha1_file(n->buf.buf, n->buf.len, tree_type, s);ttif (ret)tttreturn ret;ttstrbuf_release(&n->buf);ttfree(n);tttws->next = NULL;ttwrite_tree_entry(&tws->buf, 040000, tws->path, 2, s);tttws->path[0] = tws->path[1] = '0';t}treturn 0;}""",3,"cwe119,cwe120,cwe476"
"ciconvert (char *filename){#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__  return;#else     char *cur_dir = NULL;  char *pcur_elt, *pend_of_elt, *pend_of_cur_dir;  int error = 0;       FILE *f;  if ((f = fopen(filename, ""r"")) != NULL)    {      fclose(f);      return;    }        if (filename[0] == '/')    {      cur_dir = malloc(strlen(""/"") + strlen(filename) + 1);      strcpy(cur_dir, ""/"");      pend_of_cur_dir = cur_dir + 1;    }  else    {      cur_dir = malloc(strlen(""./"") + strlen(filename) + 1);      strcpy(cur_dir, ""./"");      pend_of_cur_dir = cur_dir + 2;    }  pcur_elt = filename;  do    {      char end_of_elt_backup;             while (*pcur_elt == '/' || *pcur_elt == '')t{t  *pcur_elt = '/';t  pcur_elt++;t}      pend_of_elt = end_of_elt(pcur_elt);      end_of_elt_backup = *pend_of_elt;      *pend_of_elt = '0';                          DIR *list;      struct dirent *entry;      int found = 0;            list = opendir (cur_dir);      if (list != NULL)t{t   t  while ((entry = readdir (list)) != NULL && !found)t    {t      if (strcasecmp(pcur_elt, entry->d_name) == 0)tt{tt   tt  strcpy(pcur_elt, entry->d_name);tt  found = 1;tt}t    }t  closedir (list);t}      if (!found)terror = 1;             if (end_of_elt_backup != '0')t{t  *pend_of_elt = '/';  t   t  {t    int cur_elt_len = pend_of_elt - pcur_elt;t    strncpy(pend_of_cur_dir, pcur_elt, cur_elt_len + 1);t    pend_of_cur_dir += cur_elt_len + 1;t    *pend_of_cur_dir = '0';t  }t  t   t  pcur_elt = pend_of_elt + 1;t}    }  while(*pend_of_elt != '0' && !error);  free(cur_dir);   #endif  }",2,"cwe120,cweother"
isPalindrome(int i) {tchar buf[6];  tint len = 0;tint temp;t twhile (i) {tttemp = i;tti /= 10;ttbuf[len++] = temp - (i * 10);t}t ttemp = 0;tlen--;twhile (len > temp) {ttif (buf[len--] != buf[temp++]) {tttreturn false;tt}t}treturn true;},2,"cwe119,cwe120"
"isspf1(struct rfc1035_reply *reply, int n){tcharttxtbuf[256];tconst char *p;trfc1035_rr_gettxt(reply->allrrs[n], 0, txtbuf);tfor (p=txtbuf; *p; p++)ttif (!isspace((int)(unsigned char)*p))tttbreak;tif (strncasecmp(p, ""v=spf1"", 6) == 0 &&t    (p[6] == 0 ||t     isspace((int)(unsigned char)p[6])))ttreturn 1;treturn 0;}",2,"cwe119,cwe120"
"gsc_status_print (void){  static char current_status[GSC_STATUS_BUFFER_LENGTH + 1];  const sc_char *room;     room = sc_get_game_room (gsc_game);  if (gsc_is_string_usable (room))    {      char buffer[GSC_STATUS_BUFFER_LENGTH + 1];      const sc_char *status;      char score[64];             strcpy (buffer, """");      gsc_status_safe_strcat (buffer, sizeof (buffer), room);             status = sc_get_game_status_line (gsc_game);      if (!gsc_is_string_usable (status))        {          sprintf (score, ""Score: %ld"", sc_get_game_score (gsc_game));          status = score;        }             gsc_status_safe_strcat (buffer, sizeof (buffer), "" | "");      gsc_status_safe_strcat (buffer, sizeof (buffer), status);             if (strcmp (buffer, current_status) != 0)        {                     glk_put_string (""[ "");          gsc_put_string (buffer);          glk_put_string ("" ]"");                     strcpy (current_status, buffer);        }    }}",3,"cwe119,cwe120,cwe469"
"invent_message(struct ast_channel *chan, char *context, char *ext, int busy, char *ecodes){tint res;tchar fn[PATH_MAX];tchar dest[PATH_MAX];tsnprintf(fn, sizeof(fn), ""%s%s/%s/greet"", VM_SPOOL_DIR, context, ext);tif ((res = create_dirpath(dest, sizeof(dest), context, ext, """"))) {ttast_log(AST_LOG_WARNING, ""Failed to make directory(%s)"", fn);ttreturn -1;t}tRETRIEVE(fn, -1, ext, context);tif (ast_fileexists(fn, NULL, NULL) > 0) {ttres = ast_stream_and_wait(chan, fn, ecodes);ttif (res) {tttDISPOSE(fn, -1);tttreturn res;tt}t} else {tt ttDISPOSE(fn, -1);ttres = ast_stream_and_wait(chan, ""vm-theperson"", ecodes);ttif (res)tttreturn res;ttres = ast_say_digit_str(chan, ext, ecodes, ast_channel_language(chan));ttif (res)tttreturn res;t}tres = ast_stream_and_wait(chan, busy ? ""vm-isonphone"" : ""vm-isunavail"", ecodes);treturn res;}",2,"cwe119,cwe120"
"fl_show_question( const char * str,                  int          ans ){    FL_OBJECT *retobj;    char shortcut[ 4 ];    int k = 0;    if ( fd_yesno )    {        fl_hide_form( fd_yesno->form );        fl_free_form( fd_yesno->form );        fl_free( fd_yesno );    }    else        fl_deactivate_all_forms( );    fd_yesno = create_yesno( );    default_ans = ans;    fli_parse_goodies_label( fd_yesno->yes, FLQuestionYesLabel );    fli_parse_goodies_label( fd_yesno->no, FLQuestionNoLabel );         while (    fd_yesno->no->label[ k ]            && tolower( ( int ) fd_yesno->yes->label[ 0 ] ) ==                                 tolower( ( int ) fd_yesno->yes->label[ k ] ) )        k++;    if ( fd_yesno->no->label[ k ] )    {        shortcut[ 0 ] = fd_yesno->yes->label[ 0 ];        shortcut[ 1 ] = tolower( ( int ) fd_yesno->yes->label[ 0 ] );        shortcut[ 2 ] = toupper( ( int ) fd_yesno->yes->label[ 0 ] );        shortcut[ 3 ] = '0';        fl_set_button_shortcut( fd_yesno->yes, shortcut, 1 );        shortcut[ 0 ] = fd_yesno->no->label[ k ];        shortcut[ 1 ] = toupper( ( int ) fd_yesno->no->label[ k ] );        shortcut[ 2 ] = tolower( ( int ) fd_yesno->no->label[ k ] );        fl_set_button_shortcut( fd_yesno->no, shortcut, 1 );    }    fli_get_goodie_title( fd_yesno->form, FLQuestionTitle );    fli_handle_goodie_font( fd_yesno->yes, fd_yesno->str );    fli_handle_goodie_font( fd_yesno->no, NULL );    fl_set_object_label( fd_yesno->str, str );    if ( ans == 1 )        fl_set_form_hotobject( fd_yesno->form, fd_yesno->yes );    else if ( ans == 0 )        fl_set_form_hotobject( fd_yesno->form, fd_yesno->no );    else        fl_set_form_hotspot( fd_yesno->form, -1, -1 );    fl_show_form( fd_yesno->form, FL_PLACE_HOTSPOT, FL_TRANSIENT,                  fd_yesno->form->label );    fl_update_display( 0 );    while ( ( retobj = fl_do_only_forms( ) ) != fd_yesno->yes            && retobj != fd_yesno->no )         ;    k = retobj == fd_yesno->yes;    fl_hide_form( fd_yesno->form );    fl_free_form( fd_yesno->form );    fl_safe_free( fd_yesno );    fl_activate_all_forms( );    return k;}",2,"cwe119,cwe120"
"write_batch_shell_file(int argc, char *argv[], int file_arg_cnt){tint fd, i, len, err = 0;tchar *p, filename[MAXPATHLEN];tstringjoin(filename, sizeof filename,tt   batch_name, "".sh"", NULL);tfd = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,tt     S_IRUSR | S_IWUSR | S_IXUSR);tif (fd < 0) {ttrsyserr(FERROR, errno, ""Batch file %s open error"",tttfilename);ttexit_cleanup(RERR_FILESELECT);t}t tif (write_arg(fd, argv[0]) < 0)tterr = 1;tif (filter_list.head) {ttif (protocol_version >= 29)tttwrite_sbuf(fd, "" --filter=._-"");ttelsetttwrite_sbuf(fd, "" --exclude-from=-"");t}tfor (i = 1; i < argc - file_arg_cnt; i++) {ttp = argv[i];ttif (strncmp(p, ""--files-from"", 12) == 0tt    || strncmp(p, ""--filter"", 8) == 0tt    || strncmp(p, ""--include"", 9) == 0tt    || strncmp(p, ""--exclude"", 9) == 0) {tttif (strchr(p, '=') == NULL)tttti++;tttcontinue;tt}ttif (strcmp(p, ""-f"") == 0) {ttti++;tttcontinue;tt}ttif (write(fd, "" "", 1) != 1)ttterr = 1;ttif (strncmp(p, ""--write-batch"", len = 13) == 0tt || strncmp(p, ""--only-write-batch"", len = 18) == 0) {tttif (write(fd, ""--read-batch"", 12) != 12)tttterr = 1;tttif (p[len] == '=') {ttttif (write(fd, ""="", 1) != 1tttt || write_arg(fd, p + len + 1) < 0)ttttterr = 1;ttt}tt} else {tttif (write_arg(fd, p) < 0)tttterr = 1;tt}t}tif (!(p = check_for_hostspec(argv[argc - 1], &p, &i)))ttp = argv[argc - 1];tif (write(fd, "" ${1:-"", 6) != 6t || write_arg(fd, p) < 0)tterr = 1;twrite_byte(fd, '}');tif (filter_list.head)ttwrite_filter_rules(fd);tif (write(fd, """", 1) != 1 || close(fd) < 0 || err) {ttrsyserr(FERROR, errno, ""Batch file %s write error"",tttfilename);ttexit_cleanup(RERR_FILEIO);t}}",3,"cwe119,cwe120,cwe469"
"psmouse_probe(struct psmouse *psmouse){tstruct ps2dev *ps2dev = &psmouse->ps2dev;tunsigned char param[2]; tparam[0] = 0xa5;tif (ps2_command(ps2dev, param, PSMOUSE_CMD_GETID))ttreturn -1;tif (param[0] != 0x00 && param[0] != 0x03 &&t    param[0] != 0x04 && param[0] != 0xff)ttreturn -1; tif (ps2_command(ps2dev, NULL, PSMOUSE_CMD_RESET_DIS))ttpsmouse_warn(psmouse, ""Failed to reset mouse on %s"",ttt     ps2dev->serio->phys);treturn 0;}",2,"cwe119,cwe120"
"ap_abstract0_check_dim_array(ap_funid_t funid, ap_manager_t* man,tttt  ap_dimension_t dimension, ap_dim_t* tdim, size_t size){  size_t i;  for (i=0;i<size;i++){    ap_dim_t dim = tdim[i];    if (dim>=dimension.intdim+dimension.realdim){      char str[80];      sprintf(str,""incompatible %luth dimension in the array for the abstract value"",(unsigned long)i);      ap_abstract0_check_dim_raise(funid,man,dimension,dim,str);      return false;    }  }  return true;}",2,"cwe119,cwe120"
"sftp_cmd_proxy(struct sftp_command *cmd){    int proxy_type;    int portnumber;    if (cmd->nwords < 2) {tfzprintf(sftpError, ""Not enough arguments to proxy command"");treturn 0;    }    if (!strcmp(cmd->words[1], ""0"")) {tcfg.proxy_type = PROXY_NONE;        fznotify1(sftpDone, 1);treturn 1;    }    if (!strcmp(cmd->words[1], ""1"")) {tproxy_type = PROXY_HTTP;    }    else if (!strcmp(cmd->words[1], ""2"")) {tproxy_type = PROXY_SOCKS5;    }    else {tfzprintf(sftpError, ""Unknown proxy type"");treturn 0;    }    if (cmd->nwords < 4) {tfzprintf(sftpError, ""Not enough arguments to proxy command"");treturn 0;    }    portnumber = atoi(cmd->words[3]);    if (portnumber < 0 || portnumber > 65535) {tfzprintf(sftpError, ""Invalid port"");treturn 0;    }    if (strlen(cmd->words[2]) >= sizeof(cfg.proxy_host)) {tfzprintf(sftpError,  ""Host too long"");treturn 0;    }    if (cmd->nwords > 4 && strlen(cmd->words[4]) >= sizeof(cfg.proxy_username)) {tfzprintf(sftpError,  ""User too long"");treturn 0;    }    if (cmd->nwords > 5 && strlen(cmd->words[5]) >= sizeof(cfg.proxy_password)) {tfzprintf(sftpError,  ""Password too long"");treturn 0;    }    if (cmd->nwords > 5) {tstrcpy(cfg.proxy_username, cmd->words[4]);tstrcpy(cfg.proxy_password, cmd->words[5]);    }    else if (cmd->nwords > 4) {tstrcpy(cfg.proxy_username, cmd->words[4]);tcfg.proxy_password[0] = 0;    }    else {tcfg.proxy_username[0] = 0;tcfg.proxy_password[0] = 0;    }    cfg.proxy_type = proxy_type;    strcpy(cfg.proxy_host, cmd->words[2]);    cfg.proxy_port = portnumber;    fznotify1(sftpDone, 1);    return 1;}",3,"cwe120,cwe476,cweother"
"sortrows (GtkCList * clist, gint column, gpointer data){  char sortcol_name[25], sortasds_name[25];  intptr_t sortcol, sortasds;  gftp_window_data * wdata;  GtkWidget * sort_wid;  GList * templist;  int swap_col;  wdata = data;  g_snprintf (sortcol_name, sizeof (sortcol_name), ""%s_sortcol"",              wdata->prefix_col_str);  gftp_lookup_global_option (sortcol_name, &sortcol);  g_snprintf (sortasds_name, sizeof (sortasds_name), ""%s_sortasds"",              wdata->prefix_col_str);  gftp_lookup_global_option (sortasds_name, &sortasds);  if (column == -1)    column = sortcol;  if (column == 0 || (column == sortcol && wdata->sorted))    {      sortasds = !sortasds;      gftp_set_global_option (sortasds_name, GINT_TO_POINTER (sortasds));      swap_col = 1;    }  else    swap_col = 0;  if (swap_col || !wdata->sorted)    {      sort_wid = gtk_clist_get_column_widget (clist, 0);      gtk_widget_destroy (sort_wid);#if GTK_MAJOR_VERSION == 1      if (sortasds)tsort_wid = toolbar_pixmap (wdata->listbox, ""down.xpm"");      elsetsort_wid = toolbar_pixmap (wdata->listbox, ""up.xpm"");#else      if (sortasds)        sort_wid = gtk_image_new_from_stock (GTK_STOCK_SORT_ASCENDING,                                              GTK_ICON_SIZE_SMALL_TOOLBAR);      else        sort_wid = gtk_image_new_from_stock (GTK_STOCK_SORT_DESCENDING,                                              GTK_ICON_SIZE_SMALL_TOOLBAR);#endif      gtk_clist_set_column_widget (clist, 0, sort_wid);    }  else    {      sortcol = column;      gftp_set_global_option (sortcol_name, GINT_TO_POINTER (sortcol));    }  if (!GFTP_IS_CONNECTED (wdata->request))    return;  gtk_clist_freeze (clist);  gtk_clist_clear (clist);  wdata->files = gftp_sort_filelist (wdata->files, sortcol, sortasds);  templist = wdata->files;   while (templist != NULL)    {      add_file_listbox (wdata, templist->data);      templist = templist->next;    }  wdata->sorted = 1;  gtk_clist_thaw (clist);}",2,"cwe119,cwe120"
"EnvisatFile_RewriteHeader( EnvisatFile *self ){    intttdsd, dsd_size;         if( S_NameValueList_Rewrite( self->fp,                         self->mph_count, self->mph_entries ) == FAILURE )        return FAILURE;    if( S_NameValueList_Rewrite( self->fp,                         self->sph_count, self->sph_entries ) == FAILURE )        return FAILURE;         dsd_size = EnvisatFile_GetKeyValueAsInt( self, MPH, ""DSD_SIZE"", 0 );    if( dsd_size == 0 )        return FAILURE;    for( dsd = 0; dsd < self->ds_count; dsd++ )    {        chart*dsd_text;        inttdsdh_count = 0, key_index;        EnvisatNameValue **dsdh_entries = NULL;        dsd_text = (char *) calloc(1,dsd_size+1);        if( VSIFSeekL( self->fp, self->dsd_offset + dsd * dsd_size,                    SEEK_SET ) != 0 )        {            SendError( ""VSIFSeekL() failed in EnvisatFile_RewriteHeader()"" );            return FAILURE;        }                if( (int) VSIFReadL( dsd_text, 1, dsd_size, self->fp ) != dsd_size )        {            SendError( ""VSIFReadL() failed in EnvisatFile_RewriteHeader()"" );            return FAILURE;        }        if( S_NameValueList_Parse( dsd_text, self->dsd_offset + dsd*dsd_size,                                    &dsdh_count, &dsdh_entries ) == FAILURE )            return FAILURE;        free( dsd_text );        key_index = S_NameValueList_FindKey( ""DS_OFFSET"",                                              dsdh_count, dsdh_entries );        if( key_index == -1 )            continue;        sprintf( dsdh_entries[key_index]->value, ""%+021d"",                  self->ds_info[dsd]->ds_offset );        key_index = S_NameValueList_FindKey( ""DS_SIZE"",                                              dsdh_count, dsdh_entries );        sprintf( dsdh_entries[key_index]->value, ""%+021d"",                  self->ds_info[dsd]->ds_size );        key_index = S_NameValueList_FindKey( ""NUM_DSR"",                                              dsdh_count, dsdh_entries );        sprintf( dsdh_entries[key_index]->value, ""%+011d"",                  self->ds_info[dsd]->num_dsr );        key_index = S_NameValueList_FindKey( ""DSR_SIZE"",                                              dsdh_count, dsdh_entries );        sprintf( dsdh_entries[key_index]->value, ""%+011d"",                  self->ds_info[dsd]->dsr_size );        if( S_NameValueList_Rewrite( self->fp, dsdh_count, dsdh_entries )            == FAILURE )            return FAILURE;        S_NameValueList_Destroy( &dsdh_count, &dsdh_entries );    }    self->header_dirty = 0;    return SUCCESS;}",2,"cwe120,cweother"
"""mpi_read_file( mpi *X, int radix, FILE *fin ){    t_int d;    int slen;    char *p;    char s[1024];    memset( s, 0, sizeof( s ) );    if( fgets( s, sizeof( s ) - 1, fin ) == NULL )        return( POLARSSL_ERR_MPI_FILE_IO_ERROR );    slen = strlen( s );    if( s[slen - 1] == '' ) { slen--; s[slen] = '0'; }    if( s[slen - 1] == 'r' ) { slen--; s[slen] = '0'; }    p = s + slen;    while( --p >= s )        if( mpi_get_digit( &d, radix, *p ) != 0 )            break;    return( mpi_read_string( X, radix, p + 1 ) );}""",2,"cwe119,cwe120"
"chunks_create( struct state * s ){  struct chunks * c;  uint8_t zero = 0;  if ( !( c = s->chunk_mngr) )  {    return;  }     c->primes_capacity = s->chunk_size << 4;  c->primes_count = 0;  c->primes_size = c->primes_capacity * sizeof( uint64_t );  if ( ( c->primes_fd = open( s->primes_file, O_CREAT |                              O_RDWR | O_TRUNC, 0666 ) ) < 0 )  {    state_error( s, ""Cannot open file '%s'"", s->primes_file );  }  lseek( c->primes_fd, c->primes_size - 1, SEEK_SET );  if ( write( c->primes_fd, &zero, 1 ) != 1 )  {    state_error( s, ""Cannot resize file '%s'"", s->primes_file );  }  lseek( c->primes_fd, 0, SEEK_SET );     c->primes_index = (uint64_t*)malloc( sizeof(uint64_t) * s->chunk_count );  if ( !c->primes_index )  {    state_error( s, ""Cannot create index"" );  }     if ( ( c->primes_data = mmap( 0, c->primes_size, PROT_READ | PROT_WRITE,                                MAP_SHARED, c->primes_fd, 0 ) ) == MAP_FAILED )  {    state_error( s, ""Cannot mmap file '%s'"", s->primes_file );  }     c->sieve_chunks = s->chunk_count;  c->sieve_size = c->sieve_chunks * s->chunk_size;  if ( ( c->sieve_fd = open( s->sieve_file, O_CREAT |                             O_RDWR | O_TRUNC, 0666 ) ) < 0 )  {    state_error( s, ""Cannot open chunk cache '%s'"", s->sieve_file );  }  lseek( c->sieve_fd, c->sieve_size - 1, SEEK_SET );  if ( write( c->sieve_fd, &zero, 1 ) != 1 )  {    state_error( s, ""Cannot resize file '%s'"", s->sieve_file );  }  lseek( c->sieve_fd, 0, SEEK_SET );     if ( ( c->sieve_data = mmap( 0, c->sieve_size, PROT_READ | PROT_WRITE,                               MAP_SHARED, c->sieve_fd, 0 ) ) == MAP_FAILED )  {    state_error( s, ""Cannot mmap file '%s'"", s->sieve_file );  }}",2,"cwe120,cweother"
"mos_distortions_rms(cpl_image *rectified, cpl_vector *lines,                            double wavestart, double dispersion, int radius,                           int highres){    const char *func = ""mos_distortions_rms"";    int xlen;    int ylen;    int numLines;    int cpix, npix, nzero;    int sp, ep;    int i, j, k;    int npeaks, allPeaks;    float *profile;    float  peak, expectPeak, offset;    double lambda;    double  average;    double  rms, oneRms;    float  *sdata;    double *wdata;      xlen = cpl_image_get_size_x(rectified);    ylen = cpl_image_get_size_y(rectified);    sdata = cpl_image_get_data(rectified);    if (lines) {        wdata = cpl_vector_get_data(lines);        numLines = cpl_vector_get_size(lines);    }    else {        cpl_msg_warning(func, ""A catalog of sky lines wavelengths was not ""                        ""given: using internal list of reference sky lines"");        if (highres) {           wdata = default_lines_hi;           numLines = sizeof(default_lines_hi) / sizeof(double);        }        else {           wdata = default_lines_lo;           numLines = sizeof(default_lines_lo) / sizeof(double);        }    }    npix = 2 * radius + 1;    profile = cpl_calloc(npix, sizeof(float));    rms = 0.0;    allPeaks = 0;    for (i = 0; i < numLines; i++) {                 lambda = wdata[i];        expectPeak = (lambda - wavestart) / dispersion;        cpix = floor(expectPeak + 0.5);                 sp = cpix - radius;        ep = cpix + radius;        if (sp < 0 || ep > xlen)            continue;        average = 0.0;        npeaks = 0;        oneRms = 0.0;        for (j = 0; j < ylen; j++) {                 nzero = 0;            for (k = 0; k < npix; k++) {                profile[k] = sdata[sp + k + j * xlen];                if (fabs(profile[k]) < 0.0001)                    nzero++;              }            if (nzero > 0)                continue;            if (peakPosition(profile, npix, &peak, 1) == 0) {                offset = (sp + peak) - expectPeak;                average += offset;                rms += fabs(offset);                oneRms += fabs(offset);                npeaks++;                allPeaks++;            }        }        if (npeaks)            cpl_msg_info(func, ""RMS for %.2f: %.3f pixel (%d points)"",                         lambda, oneRms / npeaks * 1.25, npeaks);        else            cpl_msg_info(func, ""RMS for %.2f: line not available"", lambda);    }    cpl_free(profile);    if (allPeaks < 10)        return 0.0;    rms /= allPeaks;    rms *= 1.25;            return rms;}",2,"cwe119,cwe120"
"varnish_wait(struct varnish *v){tvoid *p;tint status, r;tif (v->cli_fd < 0)ttreturn;tif (vtc_error)tt(void)sleep(1);t tvarnish_stop(v);tvtc_log(v->vl, 2, ""Wait"");tAZ(close(v->cli_fd));tv->cli_fd = -1;t(void)close(v->fds[1]);tt tAZ(pthread_join(v->tp, &p));tAZ(close(v->fds[0]));tr = wait4(v->pid, &status, 0, NULL);tvtc_log(v->vl, 2, ""R %d Status: %04x"", r, status);tif (WIFEXITED(status) && WEXITSTATUS(status) == 0)ttreturn;#ifdef WCOREDUMPtvtc_log(v->vl, 0, ""Bad exit code: %04x sig %x exit %x core %x"",t    status, WTERMSIG(status), WEXITSTATUS(status),t    WCOREDUMP(status));#elsetvtc_log(v->vl, 0, ""Bad exit code: %04x sig %x exit %x"",t    status, WTERMSIG(status), WEXITSTATUS(status));#endif}",2,"cwe469,cweother"
"handle_cli_recalc(struct ast_cli_args *a){tint time = a->argv[4] ? atoi(a->argv[4]) : 1;tif (time <= 0) {ttast_cli(a->fd, ""         Recalc must be greater than 0.  Defaulting to 1."");tttime = 1;t}tif (time > MAX_RECALC) {ttast_cli(a->fd, ""         Maximum limit of recalc exceeded by %d, truncating value to %d"", time - MAX_RECALC, MAX_RECALC);tttime = MAX_RECALC;t}tast_cli(a->fd, ""         Recalculating Codec Translation (number of sample seconds: %d)"", time);tAST_RWLIST_WRLOCK(&translators);tmatrix_rebuild(time);tAST_RWLIST_UNLOCK(&translators);}",3,"cwe119,cwe120,cweother"
"new_token (enum token_type type, const char *buf, size_t length){  TOKEN t;     t = malloc (sizeof *t + length);  if (t)    {      t->next = NULL;      t->type = type;      memset (&t->flags, 0, sizeof (t->flags));      t->data[0] = 0;      if (buf)        {          memcpy (t->data, buf, length);          t->data[length] = 0;t         }      else        t->data[0] = 0;    }  return t;}",2,"cwe120,cweother"
"auth_user(CLI *c) {#ifndef _WIN32_WCE    struct servent *s_ent;     #endif    SOCKADDR_UNION ident;          char *line, *type, *system, *user;    if(!c->opt->username)        return;      c->fd=s_socket(c->peer_addr.addr[0].sa.sa_family, SOCK_STREAM,        0, 1, ""socket (auth_user)"");    if(c->fd<0)        longjmp(c->err, 1);    memcpy(&ident, &c->peer_addr.addr[0], sizeof ident);#ifndef _WIN32_WCE    s_ent=getservbyname(""auth"", ""tcp"");    if(s_ent) {        ident.in.sin_port=s_ent->s_port;    } else#endif    {        s_log(LOG_WARNING, ""Unknown service 'auth': using default 113"");        ident.in.sin_port=htons(113);    }    if(connect_blocking(c, &ident, addr_len(ident)))        longjmp(c->err, 1);    s_log(LOG_DEBUG, ""IDENT server connected"");    fdprintf(c, c->fd, ""%u , %u"",        ntohs(c->peer_addr.addr[0].in.sin_port),        ntohs(c->opt->local_addr.addr[0].in.sin_port));    line=fdgetline(c, c->fd);    closesocket(c->fd);    c->fd=-1;      type=strchr(line, ':');    if(!type) {        s_log(LOG_ERR, ""Malformed IDENT response"");        longjmp(c->err, 1);    }    *type++='0';    system=strchr(type, ':');    if(!system) {        s_log(LOG_ERR, ""Malformed IDENT response"");        longjmp(c->err, 1);    }    *system++='0';    if(strcmp(type, "" USERID "")) {        s_log(LOG_ERR, ""Incorrect INETD response type"");        longjmp(c->err, 1);    }    user=strchr(system, ':');    if(!user) {        s_log(LOG_ERR, ""Malformed IDENT response"");        longjmp(c->err, 1);    }    *user++='0';    while(*user==' ')          ++user;    if(strcmp(user, c->opt->username)) {        safestring(user);        s_log(LOG_WARNING, ""Connection from %s REFUSED by IDENT (user %s)"",            c->accepted_address, user);        longjmp(c->err, 1);    }    s_log(LOG_INFO, ""IDENT authentication passed"");}",2,"cwe120,cweother"
"NITFWriteBLOCKA( VSILFILE* fp, vsi_l_offset nOffsetUDIDL,                            int *pnOffset,                            char **papszOptions ){    static const char *apszFields[] = {         ""BLOCK_INSTANCE"", ""0"", ""2"",        ""N_GRAY"",         ""2"", ""5"",        ""L_LINES"",        ""7"", ""5"",        ""LAYOVER_ANGLE"",  ""12"", ""3"",        ""SHADOW_ANGLE"",   ""15"", ""3"",        ""BLANKS"",         ""18"", ""16"",        ""FRLC_LOC"",       ""34"", ""21"",        ""LRLC_LOC"",       ""55"", ""21"",        ""LRFC_LOC"",       ""76"", ""21"",        ""FRFC_LOC"",       ""97"", ""21"",        NULL,             NULL, NULL };    int nBlockCount =         atoi(CSLFetchNameValue( papszOptions, ""BLOCKA_BLOCK_COUNT"" ));    int iBlock;       for( iBlock = 1; iBlock <= nBlockCount; iBlock++ )    {        char szBLOCKA[123];        int iField;           for( iField = 0; apszFields[iField*3] != NULL; iField++ )        {            char szFullFieldName[64];            int  iStart = atoi(apszFields[iField*3+1]);            int  iSize = atoi(apszFields[iField*3+2]);            const char *pszValue;            sprintf( szFullFieldName, ""BLOCKA_%s_%02d"",                      apszFields[iField*3 + 0], iBlock );            pszValue = CSLFetchNameValue( papszOptions, szFullFieldName );            if( pszValue == NULL )                pszValue = """";            if (strlen(pszValue) > (size_t)iSize)            {                CPLError(CE_Failure, CPLE_AppDefined,                         ""Too much data for %s. Got %d bytes, max allowed is %d"",                         szFullFieldName, (int)strlen(pszValue), iSize);                return FALSE;            }                         memset( szBLOCKA + iStart, ' ', iSize );            memcpy( szBLOCKA + iStart + MAX((size_t)0,iSize-strlen(pszValue)),                    pszValue, strlen(pszValue) );        }                 memcpy( szBLOCKA + 118, ""010.0"", 5);        if( !NITFWriteTRE( fp,                           nOffsetUDIDL,                           pnOffset,                           ""BLOCKA"", szBLOCKA, 123 ) )            return FALSE;    }        return TRUE;}",3,"cwe119,cwe120,cweother"
"download_queue_update_status(struct download *d){tchar event[80];tsize_t rw;t ttime_locale_to_string_buf(tm_time(), event, sizeof event);trw = strlen(d->error_str);trw += str_bprintf(&d->error_str[rw], sizeof d->error_str - rw,tt_("" at %s""), lazy_locale_to_ui_string(event));t tif (download_is_partial(d)) {ttstr_bprintf(&d->error_str[rw], sizeof d->error_str - rw,ttt"" <PFS %4.02f%%>"", d->ranges_size * 100.0 / download_filesize(d));t}}",2,"cwe119,cwe120"
"rivchat_plugin_init(int prio) {tstatic char pwd_name[100];tstatic char pwd_hostname[100];tstruct passwd *pwd_entry;tt t t tPLUGIN_CHECK_VER(""rivchat""); tif ((pwd_entry = getpwuid(getuid()))) {ttstrlcpy(pwd_name, pwd_entry->pw_name, sizeof(pwd_name));tt ttrivchat_plugin_vars[RIVCHAT_VAR_NICKNAME].value = pwd_name;ttrivchat_plugin_vars[RIVCHAT_VAR_USERNAME].value = pwd_name;t}tif (gethostname(pwd_hostname, sizeof(pwd_hostname))) {ttdebug_error(""[rivchat] gethostname() failed"");ttstrlcpy(pwd_hostname, ""localhost"", sizeof(pwd_hostname));t}trivchat_plugin_vars[RIVCHAT_VAR_HOSTNAME].value = pwd_hostname;trivchat_plugin.params = rivchat_plugin_vars;tplugin_register(&rivchat_plugin, prio);tekg_recode_cp_inc();tquery_connect_id(&rivchat_plugin, PROTOCOL_VALIDATE_UID, rivchat_validate_uid, NULL);tquery_connect_id(&rivchat_plugin, SESSION_ADDED, rivchat_session_init, NULL);tquery_connect_id(&rivchat_plugin, SESSION_REMOVED, rivchat_session_deinit, NULL);tquery_connect_id(&rivchat_plugin, PLUGIN_PRINT_VERSION, rivchat_print_version, NULL);tquery_connect_id(&rivchat_plugin, USERLIST_INFO, rivchat_userlist_info_handle, NULL);tquery_connect_id(&rivchat_plugin, USERLIST_PRIVHANDLE, rivchat_userlist_priv_handler, NULL);tquery_connect_id(&rivchat_plugin, IRC_TOPIC, rivchat_topic_header, NULL);#if 0tquery_connect(&irc_plugin, (""ui-window-kill""),tirc_window_kill, NULL);tquery_connect(&irc_plugin, (""status-show""),tirc_status_show_handle, NULL);#endif#define RIVCHAT_ONLYttSESSION_MUSTBELONG | SESSION_MUSTHASPRIVATE#define RIVCHAT_FLAGSttRIVCHAT_ONLY | SESSION_MUSTBECONNECTEDtcommand_add(&rivchat_plugin, ""rivchat:"", ""?"",ttrivchat_command_inline_msg, RIVCHAT_ONLY, NULL);tcommand_add(&rivchat_plugin, ""rivchat:connect"", NULL,trivchat_command_connect,    RIVCHAT_ONLY, NULL);tcommand_add(&rivchat_plugin, ""rivchat:dcc"", ""p uU f ?"", rivchat_command_dcc,t    RIVCHAT_ONLY, ""send get close list"");tcommand_add(&rivchat_plugin, ""rivchat:disconnect"", ""r"",trivchat_command_disconnect, RIVCHAT_ONLY, NULL);tcommand_add(&rivchat_plugin, ""rivchat:me"", ""?"",ttrivchat_command_me,t    RIVCHAT_FLAGS, NULL);tcommand_add(&rivchat_plugin, ""rivchat:nick"", ""!"",trivchat_command_nick,t    RIVCHAT_FLAGS | COMMAND_ENABLEREQPARAMS, NULL);tcommand_add(&rivchat_plugin, ""rivchat:places"", NULL,trivchat_command_places,     RIVCHAT_FLAGS, NULL);tcommand_add(&rivchat_plugin, ""rivchat:topic"", ""?"",trivchat_command_topic,t    RIVCHAT_FLAGS, NULL);tcommand_add(&rivchat_plugin, ""rivchat:reconnect"", ""r"",trivchat_command_reconnect,  RIVCHAT_ONLY, NULL);treturn 0;}",2,"cwe119,cwe120"
"""utf16le_get_codepoint(FILE *file, const char **astr){    int c;    int rune;    int trail;    /* This code spots the BOM for 16bit LE and ignores it. Strictly speaking     * this may be wrong, as we are only supposed to ignore it at the beginning     * of the string, but if anyone is stupid enough to use ZWNBSP (zero width     * non breaking space) in the middle of their strings, then they deserve     * what they get. */    /* We spot the BOM for 16bit BE and treat that as EOF. We'd rather give     * up on dealing with a broken file than try to run something we know to     * be wrong. */    do {        if (file) {            rune = fgetc(file);            if (rune == EOF)                return EOF;            c = fgetc(file);            if (c == EOF)                return EOF;            rune += c<<8;        } else {            rune = (*astr)[0] | ((*astr)[1]<<8);            if (rune != 0)                (*astr) += 2;            else                return EOF;        }        if (rune == 0xFEFF) /* BOM - ignore it */            continue;        if (rune == 0xFFFE) /* BOM for BE - hopelessly broken */            return EOF;        if (rune < 0xD800 || rune >= 0xE000)            return rune;        if (rune >= 0xDC00) /* Found a trailing surrogate pair. Skip it */            continue;lead: /* We've just read a leading surrogate */        rune -= 0xD800;        rune <<= 10;        if (file) {            trail = fgetc(file);            if (trail == EOF)                return EOF;            c = fgetc(file);            if (c == EOF)                return EOF;            trail += c<<8;        } else {            trail = (*astr)[0] | ((*astr)[1]<<8);            if (trail != 0)                (*astr) += 2;            else                return EOF;        }        if (trail < 0xd800 || trail >= 0xE000) {            if (rune == 0xFEFF) /* BOM - ignore it. */                continue;            if (rune == 0xFFFE) /* BOM for BE - hopelessly broken. */                return EOF;            /* No trail surrogate was found, so skip the lead surrogate and             * return the rune we landed on. */            return trail;        }        if (trail < 0xdc00) {            /* We found another leading surrogate. */            rune = trail;            goto lead;        }        break;    } while (1);    return rune + (trail-0xDC00) + 0x10000;}""",2,"cwe120,cweother"
"chirp_client_setxattr(struct chirp_client * c, const char *path, const char *name, const void *data, size_t size, int flags, time_t stoptime){tchar safepath[CHIRP_LINE_MAX];turl_encode(path, safepath, sizeof(safepath));tINT64_T result = send_command(c, stoptime, ""setxattr %s %s %zu %d"", safepath, name, size, flags);tif(result < 0)ttreturn result;tresult = link_putlstring(c->link, data, size, stoptime);tif(result != (int) size) {ttc->broken = 1;tterrno = ECONNRESET;ttreturn -1;t}tresult = get_result(c, stoptime);tif(result < 0) {ttif(errno == EINVAL)ttterrno = ENOATTR;ttreturn result;t}treturn 0;}",2,"cwe119,cwe120"
"touch_laston(struct userrec *u, char *where, time_t timeval){  if (!u)    return;  if (timeval > 1) {    struct laston_info *li = get_user(&USERENTRY_LASTON, u);    if (!li)      li = nmalloc(sizeof *li);    else if (li->lastonplace)      nfree(li->lastonplace);    li->laston = timeval;    if (where) {      li->lastonplace = nmalloc(strlen(where) + 1);      strcpy(li->lastonplace, where);    } else      li->lastonplace = NULL;    set_user(&USERENTRY_LASTON, u, li);  } else if (timeval == 1)    set_user(&USERENTRY_LASTON, u, 0);}",2,"cwe119,cwe120"
"is_chown_supported (const char *dir){  size_t len = sysroot_len + strlen (dir) + 64;  char buf[len];  int fd, r, saved_errno;     snprintf (buf, len, ""%s%s/XXXXXXXX.XXX"", sysroot, dir);  if (random_name (buf) == -1) {    reply_with_perror (""random_name"");    return -1;  }     fd = open (buf, O_WRONLY|O_CREAT|O_NOCTTY|O_CLOEXEC, 0666);  if (fd == -1) {    reply_with_perror (""%s"", dir);    return -1;  }     r = fchown (fd, 1000, 1000);  saved_errno = errno;     close (fd);  unlink (buf);  if (r == -1 && saved_errno == EPERM) {         return 0;  }  if (r == -1) {         reply_with_perror_errno (saved_errno, ""unexpected error in fchown"");    return -1;  }     return 1;}",3,"cwe119,cwe120,cweother"
"uiDXLResetServer(DXLConnection *conn){    int sts;    if (conn->dxuiConnected) {tDXLEndExecution(conn);        sts = DXLSend(conn, ""reset"");    } else  {         tsts = DXLSendImmediate(conn, ""sync"");        if (sts) {t    char buffer[256];t     t    DXLEndExecution(conn);t                 sprintf(buffer, ""Executive(""flush cache"");"");t    DXLSend(conn,buffer);t    sts = DXLSendImmediate(conn, ""sync"");        }     }    return sts;}",2,"cwe119,cwe120"
"_prefix_check(void){   int argc = 0;   char **argv = NULL;   const char *dirs[4] = { NULL, NULL, NULL, NULL };   char *caps = NULL, *p1, *p2;   char buf[PATH_MAX];   if (app_pfx) return;   if (!app_domain) return;   ecore_app_args_get(&argc, &argv);   if (argc < 1) return;   dirs[0] = app_compile_bin_dir;   dirs[1] = app_compile_lib_dir;   dirs[2] = app_compile_data_dir;   dirs[3] = app_compile_locale_dir;      if (!dirs[0]) dirs[0] = ""/usr/local/bin"";   if (!dirs[1]) dirs[1] = ""/usr/local/lib"";   if (!dirs[2])     {        snprintf(buf, sizeof(buf), ""/usr/local/share/%s"", app_domain);        dirs[2] = buf;     }   if (!dirs[3]) dirs[3] = dirs[2];   if (app_domain)     {        caps = alloca(strlen(app_domain) + 1);        for (p1 = (char *)app_domain, p2 = caps; *p1; p1++, p2++)           *p2 = toupper(*p1);        *p2 = 0;     }   app_pfx = eina_prefix_new(argv[0], app_mainfunc, caps, app_domain,                             app_checkfile, dirs[0], dirs[1], dirs[2], dirs[3]);}",2,"cwe119,cwe120"
"""b58check(const void *bin, size_t binsz, const char *base58str){tunsigned char buf[32];tconst uint8_t *binc = bin;tunsigned i;tif (binsz < 4)ttreturn -4;tsha256_Raw(bin, binsz - 4, buf);tsha256_Raw(buf, 32, buf);tif (memcmp(&binc[binsz - 4], buf, 4))ttreturn -1;t// Check number of zeros is correct AFTER verifying checksum (to avoid possibility of accessing base58str beyond the end)tfor (i = 0; binc[i] == '0' && base58str[i] == '1'; ++i)t{}  // Just finding the end of zeros, nothing to do in looptif (binc[i] == '0' || base58str[i] == '1')ttreturn -3;treturn binc[0];}""",2,"cwe119,cwe120"
"read_header(FILE *infile)   {   long num;   unsigned char first_two_bytes[2];   char abuf[NSAMPLES];   num = fread(abuf, 1, 12, infile);   if (num < 0)      {      perror(""input file"");      return(1);      }   if (num < 12) return 1;   if (strncmp(abuf, ""RIFF"", 4))      {      first_two_bytes[0] = abuf[0];      first_two_bytes[1] = abuf[1];      if (first_two_bytes[0] == 0xFF)         {         if ((first_two_bytes[1] & 0xE0) == 0xE0)            {                         fprintf(stderr, ""This appears to be an MP3 filer"");            fprintf(stderr, ""This just rename to *.mp3r"");            return 77;              }         }      return 2;      }   if (strncmp(abuf+8, ""WAVE"", 4))      return 3;   num = fread(&fc, 1, sizeof(FormatChunk), infile);       fc.chunkSize = le32toh(fc.chunkSize);   fc.wFormatTag = le16toh(fc.wFormatTag);   fc.wChannels = le16toh(fc.wChannels);   fc.dwSamplesPerSec = le32toh(fc.dwSamplesPerSec);   fc.dwAvgBytesPerSec = le32toh(fc.dwAvgBytesPerSec);   fc.wBlockAlign = le16toh(fc.wBlockAlign);   fc.wBitsPerSample = le16toh(fc.wBitsPerSample);   if (num < 0)      {      perror(""input file"");      return(1);      }   if (num < (signed)sizeof(fc))       return 4;   if (strncmp(fc.chunkID, ""fmt "", 4))       return 5;   if ((fc.wFormatTag) != 0x11)      {      fprintf(stderr, ""This doesn't seem to be a rec filer"");      return(1);      }   if ((fc.wChannels>2) || (!fc.wChannels))      {      fprintf(stderr, ""I can only handle 1 or 2 channel[s]sr"");      return(1);      }   fread(abuf, fc.chunkSize + 8 - sizeof(fc), 1, infile);   fread(abuf, 4, 1, infile);   if (strncmp(abuf, ""fact"", 4))       return 6;   fread(&num, 4, 1, infile);   num = le32toh(num);   fread(abuf, num, 1, infile);   fread(abuf, 4, 1, infile);   if (strncmp(abuf, ""data"", 4))       return 6;   fread(abuf, 4, 1, infile);   return 0;   }",3,"cwe119,cwe120,cweother"
"SetProfile(gn_data *data, struct gn_statemachine *state){tunsigned char req[64] = {FBUS_FRAME_HEADER, 0x1c, 0x01, 0x03};tgn_profile *prof;tgn_error error;tif (!data->profile)ttreturn GN_ERR_UNKNOWN;tif ((data->profile->number < 0) || (data->profile->number > 255))ttreturn GN_ERR_INVALIDLOCATION;tprof = data->profile;tdprintf(""Setting profile %d (%s)"", prof->number, prof->name);tif (prof->number == 0) {tt tt ttdprintf(""You cannot rename General profile"");ttreturn GN_ERR_NOTSUPPORTED;t} else if (prof->default_name > -1) {ttprof->name[0] = 0;t}treq[7] = prof->number;treq[8] = pnok_string_encode(req+9, 39, prof->name);treq[6] = req[8] + 2;tif (sm_message_send(req[8]+9, 0x05, req, state)) return GN_ERR_NOTREADY;tif ((error = sm_block(0x05, data, state)))ttreturn error;terror  = SetProfileFeature(data, state, 0x00, prof->keypad_tone);terror |= SetProfileFeature(data, state, 0x01, prof->lights);terror |= SetProfileFeature(data, state, 0x02, prof->call_alert);terror |= SetProfileFeature(data, state, 0x03, prof->ringtone);terror |= SetProfileFeature(data, state, 0x04, prof->volume);terror |= SetProfileFeature(data, state, 0x05, prof->message_tone);terror |= SetProfileFeature(data, state, 0x06, prof->vibration);terror |= SetProfileFeature(data, state, 0x07, prof->warning_tone);terror |= SetProfileFeature(data, state, 0x08, prof->caller_groups);terror |= SetProfileFeature(data, state, 0x09, prof->automatic_answer);treturn (error == GN_ERR_NONE) ? GN_ERR_NONE : GN_ERR_UNKNOWN;}",2,"cwe119,cwe120"
amdlibFree2DArrayUnsignedChar(unsigned char **arrayToFree){    if (arrayToFree != NULL)    {        free((unsigned char *)arrayToFree[0]);        free((unsigned char **)arrayToFree);        arrayToFree = NULL;    }},2,"cwe119,cwe120"
"conflict_rename_rename_1to2(struct merge_options *o,tttttstruct diff_filepair *pair1,tttttconst char *branch1,tttttstruct diff_filepair *pair2,tttttconst char *branch2){t tchar *del[2];tint delp = 0;tconst char *ren1_dst = pair1->two->path;tconst char *ren2_dst = pair2->two->path;tconst char *dst_name1 = ren1_dst;tconst char *dst_name2 = ren2_dst;tstruct stat st;tif (lstat(ren1_dst, &st) == 0 && S_ISDIR(st.st_mode)) {ttdst_name1 = del[delp++] = unique_path(o, ren1_dst, branch1);ttoutput(o, 1, ""%s is a directory in %s adding as %s instead"",tt       ren1_dst, branch2, dst_name1);t}tif (lstat(ren2_dst, &st) == 0 && S_ISDIR(st.st_mode)) {ttdst_name2 = del[delp++] = unique_path(o, ren2_dst, branch2);ttoutput(o, 1, ""%s is a directory in %s adding as %s instead"",tt       ren2_dst, branch1, dst_name2);t}tif (o->call_depth) {ttremove_file_from_cache(dst_name1);ttremove_file_from_cache(dst_name2);tt t} else {ttupdate_stages(ren1_dst, NULL, pair1->two, NULL, 1);ttupdate_stages(ren2_dst, NULL, NULL, pair2->two, 1);ttupdate_file(o, 0, pair1->two->sha1, pair1->two->mode, dst_name1);ttupdate_file(o, 0, pair2->two->sha1, pair2->two->mode, dst_name2);t}twhile (delp--)ttfree(del[delp]);}",2,"cwe119,cwe120"
"file_pipe2file(struct magic_set *ms, int fd, const void *startbuf,    size_t nbytes){tchar buf[4096];tssize_t r;tint tfd;t(void)strlcpy(buf, ""/tmp/file.XXXXXX"", sizeof buf);#ifndef HAVE_MKSTEMPt{ttchar *ptr = mktemp(buf);tttfd = open(ptr, O_RDWR|O_TRUNC|O_EXCL|O_CREAT, 0600);ttr = errno;tt(void)unlink(ptr);tterrno = r;t}#elset{ttint te;tttfd = mkstemp(buf);ttte = errno;tt(void)unlink(buf);tterrno = te;t}#endiftif (tfd == -1) {ttfile_error(ms, errno,tt    ""cannot create temporary file for pipe copy"");ttreturn -1;t}tif (swrite(tfd, startbuf, nbytes) != (ssize_t)nbytes)ttr = 1;telse {ttwhile ((r = sread(fd, buf, sizeof(buf), 1)) > 0)tttif (swrite(tfd, buf, (size_t)r) != r)ttttbreak;t}tswitch (r) {tcase -1:ttfile_error(ms, errno, ""error copying from pipe to temp file"");ttreturn -1;tcase 0:ttbreak;tdefault:ttfile_error(ms, errno, ""error while writing to temp file"");ttreturn -1;t}t tif ((fd = dup2(tfd, fd)) == -1) {ttfile_error(ms, errno, ""could not dup descriptor for temp file"");ttreturn -1;t}t(void)close(tfd);tif (lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1) {ttfile_badseek(ms);ttreturn -1;t}treturn fd;}",3,"cwe119,cwe120,cweother"
"gegl_operation_point_filter_process (GeglOperation       *operation,                                     GeglBuffer          *input,                                     GeglBuffer          *output,                                     const GeglRectangle *result,                                     gint                 level){  const Babl *in_format  = gegl_operation_get_format (operation, ""input"");  const Babl *out_format = gegl_operation_get_format (operation, ""output"");  GeglOperationPointFilterClass *point_filter_class;  point_filter_class = GEGL_OPERATION_POINT_FILTER_GET_CLASS (operation);  if ((result->width > 0) && (result->height > 0))    {      if (gegl_cl_is_accelerated () && point_filter_class->cl_process)        {          if (gegl_operation_point_filter_cl_process (operation, input, output, result, level))            return TRUE;        }      {        GeglBufferIterator *i = gegl_buffer_iterator_new (output, result, level, out_format, GEGL_BUFFER_WRITE, GEGL_ABYSS_NONE);        gint read =   gegl_buffer_iterator_add (i, input,  result, level, in_format, GEGL_BUFFER_READ, GEGL_ABYSS_NONE);                   while (gegl_buffer_iterator_next (i))            point_filter_class->process (operation, i->data[read], i->data[0], i->length, &i->roi[0], level);      }    }  return TRUE;}",2,"cwe120,cweother"
"iscsit_ta_authentication(struct iscsi_portal_group *tpg, u32 authentication){tunsigned char buf1[256], buf2[256], *none = NULL;tint len;tstruct iscsi_param *param;tstruct iscsi_tpg_attrib *a = &tpg->tpg_attrib;tif ((authentication != 1) && (authentication != 0)) {ttpr_err(""Illegal value for authentication parameter:""ttt"" %u, ignoring request."", authentication);ttreturn -EINVAL;t}tmemset(buf1, 0, sizeof(buf1));tmemset(buf2, 0, sizeof(buf2));tparam = iscsi_find_param_from_key(AUTHMETHOD, tpg->param_list);tif (!param)ttreturn -EINVAL;tif (authentication) {ttsnprintf(buf1, sizeof(buf1), ""%s"", param->value);ttnone = strstr(buf1, NONE);ttif (!none)tttgoto out;ttif (!strncmp(none + 4, "","", 1)) {tttif (!strcmp(buf1, none))ttttsprintf(buf2, ""%s"", none+5);tttelse {ttttnone--;tttt*none = '0';ttttlen = sprintf(buf2, ""%s"", buf1);ttttnone += 5;ttttsprintf(buf2 + len, ""%s"", none);ttt}tt} else {tttnone--;ttt*none = '0';tttsprintf(buf2, ""%s"", buf1);tt}ttif (iscsi_update_param_value(param, buf2) < 0)tttreturn -EINVAL;t} else {ttsnprintf(buf1, sizeof(buf1), ""%s"", param->value);ttnone = strstr(buf1, NONE);ttif (none)tttgoto out;ttstrncat(buf1, "","", strlen("",""));ttstrncat(buf1, NONE, strlen(NONE));ttif (iscsi_update_param_value(param, buf1) < 0)tttreturn -EINVAL;t}out:ta->authentication = authentication;tpr_debug(""%s iSCSI Authentication Methods for TPG: %hu."",tta->authentication ? ""Enforcing"" : ""Disabling"", tpg->tpgt);treturn 0;}",3,"cwe119,cwe120,cweother"
"flag_is_owned(int fd){tint pid = 0, tries = 3;twhile (tries--) {ttchar pidbuf[MAX_PIDSIZE + 1];ttint got;ttlseek(fd, 0, SEEK_SET);ttgot = read(fd, pidbuf, MAX_PIDSIZE);tt ttif (got > 0 && pidbuf[got - 1] == '') {tttsscanf(pidbuf, ""%d"", &pid);tttbreak;tt} else {tttstruct timespec t = { 0, 100000000 };tttstruct timespec r;tttwhile (nanosleep(&t, &r) == -1 && errno == EINTR)ttttmemcpy(&t, &r, sizeof(struct timespec));tttcontinue;tt}tt ttif (!tries)tttreturn 0;t}tif (pid) {ttint ret;ttret = kill(pid, 0);tt ttif (ret == -1 && errno == ESRCH)tttreturn 0;t} else {tt ttreturn 0;t}treturn 1;}",3,"cwe119,cwe120,cweother"
"process_s3_data(struct srec_data *srec, char *data, int len,tt    unsigned int addr){tunsigned char buf[MAX_S3_LEN];tint i;tfor (i = 0; i < len; i++)ttbuf[i] = get_hex8(data + i * 2);tif (srec->s3_used > 0 &&t    srec->s3_records[srec->s3_used - 1].addr +t    srec->s3_records[srec->s3_used - 1].len == addr) {tt ttsrec->s3_records[srec->s3_used - 1].data = (unsigned char *)tttrealloc(srec->s3_records[srec->s3_used - 1].data,ttttsrec->s3_records[srec->s3_used - 1].len + len);ttif (srec->s3_records[srec->s3_used - 1].data == NULL) {tttprintf(""realloc() failed"");tttreturn 1;tt}ttmemcpy(srec->s3_records[srec->s3_used - 1].data +tt       srec->s3_records[srec->s3_used - 1].len, buf, len);ttsrec->s3_records[srec->s3_used - 1].len += len;t} else {ttif (srec->s3_used + 1 == srec->s3_entries)tttenlarge_s3_buf(srec);ttsrec->s3_records[srec->s3_used].addr = addr;ttsrec->s3_records[srec->s3_used].len = len;ttsrec->s3_records[srec->s3_used].data = (unsigned char *)tttmalloc(len);ttif (srec->s3_records[srec->s3_used].data == NULL) {tttprintf(""malloc() failed"");tttreturn 1;tt}ttmemcpy(srec->s3_records[srec->s3_used].data, buf, len);ttsrec->s3_used++;t}treturn 0;}",3,"cwe119,cwe120,cweother"
"run_update_post_hook(struct command *commands){tstruct command *cmd;tint argc;tconst char **argv;tstruct child_process proc;tfor (argc = 0, cmd = commands; cmd; cmd = cmd->next) {ttif (cmd->error_string)tttcontinue;ttargc++;t}tif (!argc || access(update_post_hook, X_OK) < 0)ttreturn;targv = xmalloc(sizeof(*argv) * (2 + argc));targv[0] = update_post_hook;tfor (argc = 1, cmd = commands; cmd; cmd = cmd->next) {ttchar *p;ttif (cmd->error_string)tttcontinue;ttp = xmalloc(strlen(cmd->ref_name) + 1);ttstrcpy(p, cmd->ref_name);ttargv[argc] = p;ttargc++;t}targv[argc] = NULL;tmemset(&proc, 0, sizeof(proc));tproc.no_stdin = 1;tproc.stdout_to_stderr = 1;tproc.err = use_sideband ? -1 : 0;tproc.argv = argv;tif (!start_command(&proc)) {ttif (use_sideband)tttcopy_to_sideband(proc.err, -1, NULL);ttfinish_command(&proc);t}}",2,"cwe120,cweother"
"simulate(double *dwiSim, const double *parm, const tenExperSpec *espec) {  unsigned int ii;  double b0, diff;  b0 = parm[0];  diff = parm[1];  for (ii=0; ii<espec->imgNum; ii++) {    dwiSim[ii] = b0*exp(-espec->bval[ii]*diff);  }  return;}",2,"cwe119,cwe120"
"_profile_volume_add_friend_rsp (dict_t *this, char *key, data_t *value,                               void *data){        char    new_key[256] = {0};        glusterd_pr_brick_rsp_conv_t *rsp_ctx = NULL;        data_t  *new_value = NULL;        int     brick_count = 0;        char    brick_key[256];        if (strcmp (key, ""count"") == 0)                return;        sscanf (key, ""%d%s"", &brick_count, brick_key);        rsp_ctx = data;        new_value = data_copy (value);        GF_ASSERT (new_value);        snprintf (new_key, sizeof (new_key), ""%d%s"",                  rsp_ctx->count + brick_count, brick_key);        dict_set (rsp_ctx->dict, new_key, new_value);}",4,"cwe119,cwe120,cwe476,cweother"
"CopyTypeInto(struct Type * type, struct Type * src){*type = *src;type->name = __ecereNameSpace__ecere__sys__CopyString(src->name);type->refCount = 1;if(src->kind == 15){struct __ecereNameSpace__ecere__sys__NamedLink * member;__ecereMethod___ecereNameSpace__ecere__sys__OldList_Clear(&type->members);for(member = src->members.first; member; member = member->next){__ecereMethod___ecereNameSpace__ecere__sys__OldList_Add(&type->members, __extension__ ({struct __ecereNameSpace__ecere__sys__NamedLink * __ecereInstance1 = __ecereNameSpace__ecere__com__eSystem_New0(structSize_NamedLink);__ecereInstance1->name = __ecereNameSpace__ecere__sys__CopyString(member->name), __ecereInstance1->data = member->data, __ecereInstance1;}));}type->enumName = __ecereNameSpace__ecere__sys__CopyString(src->enumName);}else if(src->kind == 9 || src->kind == 10){struct Type * member;for(member = type->members.first; member; member = member->next)member->refCount++;type->enumName = __ecereNameSpace__ecere__sys__CopyString(src->enumName);}else if(src->kind == 11){struct Type * param;type->returnType->refCount++;for(param = type->params.first; param; param = param->next)param->refCount++;}else if(src->kind == 13 || src->kind == 12){type->type->refCount++;if(src->kind == 12){if(type->arraySizeExp)type->arraySizeExp = CopyExpression(type->arraySizeExp);}}}",2,"cwe119,cwe120"
"init_all_hw(){tint i, rv;tchar name[50];tLOG(""starting init_all_hw %d"", init_complete);tif (init_complete)ttreturn num_adapters;tmutex_init(&a_mutex);tmutex_lock(&a_mutex);tfind_adapters();tnum_adapters = 0;tinit_complete = 1;tfor (i = 0; i < MAX_ADAPTERS; i++)ttif (!a[i]tttt|| ((!a[i]->enabled || a[i]->fe <= 0)tttttt&& ((a[i]->pa >= 0 && a[i]->fn >= 0)tttttttt|| a[i]->type > ADAPTER_DVB)))  tt{tttif (!(rv = init_hw(i)))ttttnum_adapters++;tttelse if (rv != 2)ttttLOG(""Failed to init device %d with return value %d"", i, rv);tt}ttelse if (a[i]->enabled)tttnum_adapters++;tif (num_adapters == 0)ttinit_complete = 0;tLOG(""done init_hw %d"", init_complete);tgetAdaptersCount();tmutex_unlock(&a_mutex);treturn num_adapters;}",2,"cwe119,cwe120"
"skip_sequence (Genomicpos_T seglength) {  int c;  char Buffer[BUFFERSIZE];  while (seglength > BUFFERSIZE) {    if (fread(Buffer,sizeof(char),BUFFERSIZE,stdin) < BUFFERSIZE) {      fprintf(stderr,""End of file reached.  Expecting %u more characters"",seglength);      exit(9);    }    seglength -= BUFFERSIZE;  }  if (seglength > 0U) {    if (fread(Buffer,sizeof(char),seglength,stdin) < seglength) {      fprintf(stderr,""End of file reached.  Expecting %u more characters"",seglength);      exit(9);    }  }  if ((c = getchar()) != EOF && c != '') {    fprintf(stderr,""Expecting linefeed at end of sequence.  Saw %d (%c) instead"",c,c);    exit(9);  }  if ((c = getchar()) != EOF && c != '>') {    fprintf(stderr,""Expecting new FASTA line.  Saw %d (%c) instead"",c,c);    exit(9);  }  return;}",3,"cwe119,cwe120,cweother"
"main(int argc, char *argv[]){    EB_Error_Code error_code;    int ch;    char *book_path;    int booklist_flag;    int multi_flag;    invoked_name = argv[0];     #ifdef ENABLE_NLS#ifdef HAVE_SETLOCALE       setlocale(LC_ALL, """");#endif       bindtextdomain(TEXT_DOMAIN_NAME, LOCALEDIR);       textdomain(TEXT_DOMAIN_NAME);#endif         multi_flag = 0;    booklist_flag = 0;    for (;;) {tch = getopt_long(argc, argv, short_options, long_options, NULL);tif (ch == -1)t    break;tswitch (ch) {tcase 'h':t     t    output_help();t    exit(0);tcase 'l':t     t    booklist_flag = 1;t    break;tcase 'm':t     t    multi_flag = 1;t    break;tcase 'v':t     t    output_version(program_name, program_version);t    exit(0);tdefault:t    output_try_help(invoked_name);t    exit(1);t}    }         if (1 < argc - optind) {tfprintf(stderr, _(""%s: too many arguments""), invoked_name);toutput_try_help(invoked_name);texit(1);    }         if (argc == optind)tbook_path = DEFAULT_BOOK_DIRECTORY;    elsetbook_path = argv[optind];    if (booklist_flag)terror_code = output_booklist(book_path);    elseterror_code = output_information(book_path, multi_flag);    if (error_code != EB_SUCCESS)texit(1);    return 0;}",2,"cwe120,cweother"
"cddap_init_drive (cdrom_drive_t *d){  int ret;#if HAVE_LINUX_MAJOR_H  switch(d->drive_type){  case MATSUSHITA_CDROM_MAJOR:t   case MATSUSHITA_CDROM2_MAJOR:t   case MATSUSHITA_CDROM3_MAJOR:t   case MATSUSHITA_CDROM4_MAJOR:t          cdmessage(d,""Attempting to set sbpcd buffer size..."");    d->nsectors=8;#if BUFSIZE_DETERMINATION_FIXED    while(1){             if (ioctl(d->ioctl_fd, CDROMAUDIOBUFSIZ, d->nsectors)==0) {td->nsectors>>=1;tif(d->nsectors==0){t  char buffer[256];t  d->nsectors=8;t  sprintf(buffer,""tTrouble setting buffer size.  Defaulting to %d sectors."",tt  d->nsectors);t  cdmessage(d,buffer);t  break;  t}      } else {tchar buffer[256];tsprintf(buffer,""tSetting read block size at %d sectors (%ld bytes)."",ttd->nsectors,(long)d->nsectors*CDIO_CD_FRAMESIZE_RAW);tcdmessage(d,buffer);tbreak;      }    }#endif      break;  case IDE0_MAJOR:  case IDE1_MAJOR:  case IDE2_MAJOR:  case IDE3_MAJOR:    d->nsectors=8;      d->bigendianp=0;    d->is_atapi=1;    check_exceptions(d, atapi_list);    break;  default:    d->nsectors=25;     }#else  { t     char buffer[256]; t     d->nsectors = 8; t     sprintf(buffer,""tSetting read block size at %d sectors (%ld bytes)."", t t    d->nsectors,(long)d->nsectors*CDIO_CD_FRAMESIZE_RAW); t     cdmessage(d,buffer); t   } t #endif    d->enable_cdda = dummy_exception;  d->set_speed   = cddap_setspeed;  d->read_toc    = cddap_readtoc;  d->read_audio  = cddap_read;  ret = d->tracks = d->read_toc(d);  if(d->tracks<1)    return(ret);  d->opened=1;  if( (ret=verify_read_command(d)) ) return(ret);  d->error_retry=1;  return(0);}",2,"cwe119,cwe120"
"debugcmdline(int level, const char *msg, char *const argv[]){tchartcmdline[LARGEBUF];tsnprintf(cmdline, sizeof(cmdline), ""%s"", msg);twhile (*argv) {ttsnprintfcat(cmdline, sizeof(cmdline), "" %s"", *argv++);t}tupsdebugx(level, ""%s"", cmdline);}",3,"cwe119,cwe120,cweother"
"wallmsg (struct filed *f, struct iovec *iov){  static int reenter;tt   STRUCT_UTMP *utp;#if defined UTMP_NAME_FUNCTION || !defined HAVE_GETUTXENT  STRUCT_UTMP *utmpbuf;  size_t utmp_count;#endif    int i;  char *p;  char line[sizeof (utp->ut_line) + 1];  if (reenter++)    return;#if !defined UTMP_NAME_FUNCTION && defined HAVE_GETUTXENT  setutxent ();  while ((utp = getutxent ()))#else    if (read_utmp (UTMP_FILE, &utmp_count, &utmpbuf,tt READ_UTMP_USER_PROCESS | READ_UTMP_CHECK_PIDS) < 0)    {      logerror (""opening utmp file"");      return;    }  for (utp = utmpbuf; utp < utmpbuf + utmp_count; utp++)#endif      {      strncpy (line, utp->ut_line, sizeof (utp->ut_line));      line[sizeof (utp->ut_line)] = '0';      if (f->f_type == F_WALL)t{t   t  p = ttymsg (iov, IOVCNT, line, TTYMSGTIME);t  if (p != NULL)t    {t      errno = 0;t t      logerror (p);t    }t  continue;t}             for (i = 0; i < f->f_un.f_user.f_nusers; i++)tif (!strncmp (f->f_un.f_user.f_unames[i], UT_USER (utp),tt      sizeof (UT_USER (utp))))t  {t    p = ttymsg (iov, IOVCNT, line, TTYMSGTIME);t    if (p != NULL)t      {tterrno = 0;t ttlogerror (p);t      }t    break;t  }    }#if defined UTMP_NAME_FUNCTION || !defined HAVE_GETUTXENT  free (utmpbuf);#else    endutxent ();#endif  reenter = 0;}",2,"cwe119,cwe120"
"add_config_entry(const char *name, const char *value){   config_entry *new;   if ((new = (config_entry *)malloc(sizeof(config_entry))) == NULL) {      return 1;   }      if ((new->name = strdup(name)) == NULL) {      free(new);      return 1;   }     if (value != NULL) {      if ((new->value = strdup(value)) == NULL) {         free(new->name);         free(new);         return 1;      }   } else {      new->value = NULL;   }     new->next = config_list;   config_list = new;   return 0;}",3,"cwe119,cwe120,cweother"
"proxy_http_canon(request_rec *r, char *url){    char *host, *path, sport[7];    char *search = NULL;    const char *err;    const char *scheme;    apr_port_t port, def_port;         if (strncasecmp(url, ""http:"", 5) == 0) {        url += 5;        scheme = ""http"";    }    else if (strncasecmp(url, ""https:"", 6) == 0) {        url += 6;        scheme = ""https"";    }    else {        return DECLINED;    }    port = def_port = ap_proxy_port_of_scheme(scheme);    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r,                  ""HTTP: canonicalising URL %s"", url);         err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);    if (err) {        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(01083)                      ""error parsing URL %s: %s"", url, err);        return HTTP_BAD_REQUEST;    }         switch (r->proxyreq) {    default:      case PROXYREQ_REVERSE:        if (apr_table_get(r->notes, ""proxy-nocanon"")) {            path = url;            }        else {            path = ap_proxy_canonenc(r->pool, url, strlen(url),                                     enc_path, 0, r->proxyreq);            search = r->args;        }        break;    case PROXYREQ_PROXY:        path = url;        break;    }    if (path == NULL)        return HTTP_BAD_REQUEST;    if (port != def_port)        apr_snprintf(sport, sizeof(sport), "":%d"", port);    else        sport[0] = '0';    if (ap_strchr_c(host, ':')) {          host = apr_pstrcat(r->pool, ""["", host, ""]"", NULL);    }    r->filename = apr_pstrcat(r->pool, ""proxy:"", scheme, ""://"", host, sport,            ""/"", path, (search) ? ""?"" : """", (search) ? search : """", NULL);    return OK;}",2,"cwe119,cwe120"
"""CopyString(char **dest, char *source){  int len;  char *start;    while(((isspace((unsigned char)*source))&&(*source != ''))&&(*source != 0))    {      source++;    }  len = 0;  start = source;  while((*source != '')&&(*source != 0))    {      len++;      source++;    }    source--;  while((isspace((unsigned char)*source))&&(*source != 0)&&(len >0))    {      len--;      source--;    }  *dest = safemalloc(len+1);  strncpy(*dest,start,len);  (*dest)[len]=0;t  }""",2,"cwe120,cweother"
"ooktrack(char *input, char **vars)  {    char line[BIG_LINE];    if((vars[0] != NULL) && (vars[1] != NULL))  {        PR_snprintf(line, sizeof(line), ""<a href=index?0>""                      ""<img src=""%s"" hspace=8 align=%s alt=""""></a>"",                       (input[0] - '0') ? vars[0] : vars[1],                       (vars[2] != NULL) ? vars[2] : ""none"");        output(line);    }}",2,"cwe119,cwe120"
"trace_ddns_input_read(trace_type_t *ttype, unsigned length,tttt  char *buf){tu_int32_t old_result;tchar old_pointer[TRACE_PTR_LEN];tdns_clientupdateevent_t *eventp;tvoid *new_pointer;tdhcp_ddns_map_t *ddns_map_ptr;tif (length < (sizeof(old_result) + TRACE_PTR_LEN)) {ttlog_error(""trace_ddns_input_read: data too short"");ttreturn;t}tmemcpy(&old_result, buf, sizeof(old_result));tmemcpy(old_pointer, buf + sizeof(old_result), TRACE_PTR_LEN);t tfor (ddns_map_ptr = ddns_map;t     ddns_map_ptr != NULL;t     ddns_map_ptr = ddns_map_ptr->next) {ttif ((ddns_map_ptr->new_pointer != NULL) &&tt    memcmp(ddns_map_ptr->old_pointer,ttt   old_pointer, TRACE_PTR_LEN) == 0) {tttnew_pointer = ddns_map_ptr->new_pointer;tttddns_map_ptr->new_pointer = NULL;tttmemset(ddns_map_ptr->old_pointer, 0, TRACE_PTR_LEN);tttbreak;tt}t}tif (ddns_map_ptr == NULL) {ttlog_error(""trace_dns_input_read: unable to map cb pointer"");ttreturn;t}ttteventp = (dns_clientupdateevent_t *)ttisc_event_allocate(dhcp_gbl_ctx.mctx,tttt   dhcp_gbl_ctx.task,tttt   0,tttt   ddns_interlude,tttt   new_pointer,tttt   sizeof(dns_clientupdateevent_t));tif (eventp == NULL) {ttlog_error(""trace_ddns_input_read: unable to allocate event"");ttreturn;t}teventp->result = ntohl(old_result);tddns_interlude(dhcp_gbl_ctx.task, (isc_event_t *)eventp);treturn;}",2,"cwe119,cwe120"
"get_area(FILE * fd, struct Categories *labels){    int x, y;    int px, py;    int x0, y0;    int any;    char east[256], north[256];    instructions(0);    x = y = -9999;    any = 0;    while (get_point(&x, &y, east, north)) {tif (!any) {t    fprintf(fd, ""AREA"");t    any = 1;t    x0 = x;t    y0 = y;t}telse {t    black_and_white_line(px, py, x, y);t    R_flush();t}tpx = x;tpy = y;tfprintf(fd, "" %s %s"", east, north);    }    black_and_white_line(x0, y0, x, y);    R_flush();    get_category(fd, ""area"", labels);    return any;}",3,"cwe119,cwe120,cweother"
"com_dir(char * arg){tif (!arg)ttarg = """";tstruct afp_file_info *filebase = NULL, *p;tif (server==NULL) {ttprintf(""You're not connected yet to a volume"");ttgoto error;t}tif (strlen(url.volumename)==0) {ttchar names[1024];ttafp_list_volnames(server,names,1024);ttprintf(""You're not connected to a volume, choose from %s"",tttnames);ttgoto out;t}ttif (ml_readdir(vol,curdir,&filebase)) goto error;tif (filebase==NULL) goto out;tfor (p=filebase;p;p=p->next) {ttprint_file_details(p);t}tafp_ml_filebase_free(&filebase);out:ttreturn 0;error:treturn -1;}",2,"cwe119,cwe120"
"Find_Include(section **Section, char* String, const char *FileName, int Flags){tchar *sPtr;tsection *Ptr = NULL;tchar Help1[SHORT_STRING_SIZE];tchar Help2[SHORT_STRING_SIZE] = """";tstrcpy(Help1,String);tKill_Blanks(Help1);tif (!strncasecmp(S_KEY_INCLUDE,Help1,strlen(S_KEY_INCLUDE)) &&t    Help1[strlen(S_KEY_INCLUDE)] == C_BEGIN_INCLUDE         &&t    Help1[strlen(Help1)-1]       == C_END_INCLUDE             )t{ttPtr = *Section;ttif (Ptr != NULL)tttwhile (Ptr->next != NULL)ttttPtr = Ptr->next;ttif (*(Help1+strlen(S_KEY_INCLUDE)+1) != C_SLASH)tt{tttif ((sPtr = strrchr(Help2,C_SLASH)) != NULL)ttt{ttttstrcpy(Help2,FileName);ttttsPtr[1] = '0';ttt}tt}ttHelp1[strlen(Help1)-1] = '0';ttstrcat(Help2,Help1+strlen(S_KEY_INCLUDE)+1);ttif ((Ptr = read_file(Ptr,Help2,Flags & ~C_NO_WARN_FILE)) == NULL)tttreturn -1;ttelsetttif (*Section == NULL)tttt*Section = Ptr;ttreturn 0;t}treturn -1;}",2,"cwe119,cwe120"
"dat_check_if_dat_file(FILE *in){   char version[6];   memset(version, 0, sizeof(version));   fseek(in, 0, SEEK_SET);       fread(version, 4, 1, in);   fseek(in, 0, SEEK_SET);   jp_logf(JP_LOG_DEBUG, ""dat_check_if_dat_file(): version = [%c%c%d%d]"", version[3],version[2],version[1],version[0]);   if ((version[3]=='D') && (version[2]=='B') &&       (version[1]==1) && (version[0]==0)) {      return DAT_DATEBOOK_FILE;   }   if ((version[3]=='A') && (version[2]=='B') &&       (version[1]==1) && (version[0]==0)) {      return DAT_ADDRESS_FILE;   }   if ((version[3]=='T') && (version[2]=='D') &&       (version[1]==1) && (version[0]==0)) {      return DAT_TODO_FILE;   }   if ((version[3]=='M') && (version[2]=='P') &&       (version[1]==1) && (version[0]==0)) {      return DAT_MEMO_FILE;   }   return EXIT_SUCCESS;}",2,"cwe119,cwe120"
"split_maildir(const char *maildir, const char *dir,tint nr_prec, int skip){tchar file[PATH_MAX];tchar name[PATH_MAX];tint ret = -1;tint i;tstruct string_list list = STRING_LIST_INIT_DUP;tif (populate_maildir_list(&list, maildir) < 0)ttgoto out;tfor (i = 0; i < list.nr; i++) {ttFILE *f;ttsnprintf(file, sizeof(file), ""%s/%s"", maildir, list.items[i].string);ttf = fopen(file, ""r"");ttif (!f) {ttterror(""cannot open mail %s (%s)"", file, strerror(errno));tttgoto out;tt}ttif (strbuf_getwholeline(&buf, f, '')) {ttterror(""cannot read mail %s (%s)"", file, strerror(errno));tttgoto out;tt}ttsprintf(name, ""%s/%0*d"", dir, nr_prec, ++skip);ttsplit_one(f, name, 1);ttfclose(f);t}tret = skip;out:tstring_list_clear(&list, 1);treturn ret;}",3,"cwe119,cwe120,cweother"
"get_event_list(sge_evc_class_t *thiz, int sync, lList **report_list, int *commlib_error ){   int tag;   bool ret = true;   sge_pack_buffer pb;   int help;   sge_gdi_ctx_class_t * sge_gdi_ctx = thiz->get_gdi_ctx(thiz);   char rhost[CL_MAXHOSTLEN+1] = """";   char commproc[CL_MAXHOSTLEN+1] = """";   u_short id = 0;   DENTER(EVC_LAYER, ""get_event_list"");   PROF_START_MEASUREMENT(SGE_PROF_EVENTCLIENT);          tag = TAG_REPORT_REQUEST;   id = 1;   DPRINTF((""try to get request from %s, id %d"",(char*)prognames[QMASTER], id ));   if ( (help=sge_gdi2_get_any_request(sge_gdi_ctx, rhost, commproc, &id, &pb, &tag, sync,0,NULL)) != CL_RETVAL_OK) {      if (help == CL_RETVAL_NO_MESSAGE || help == CL_RETVAL_SYNC_RECEIVE_TIMEOUT) {         DEBUG((SGE_EVENT, ""commlib returns %s"", cl_get_error_text(help)));      } else {         WARNING((SGE_EVENT, ""commlib returns %s"", cl_get_error_text(help)));       }      ret = false;   } else {      if (cull_unpack_list(&pb, report_list)) {         ERROR((SGE_EVENT, MSG_LIST_FAILEDINCULLUNPACKREPORT ));         ret = false;      }      clear_packbuffer(&pb);   }   if ( commlib_error != NULL) {      *commlib_error = help;   }   PROF_STOP_MEASUREMENT(SGE_PROF_EVENTCLIENT);   DRETURN(ret);}",2,"cwe119,cwe120"
"channel_send_eof(LIBSSH2_CHANNEL *channel){    LIBSSH2_SESSION *session = channel->session;    unsigned char packet[5];         int rc;    _libssh2_debug(session, LIBSSH2_TRACE_CONN, ""Sending EOF on channel %lu/%lu"",                   channel->local.id, channel->remote.id);    packet[0] = SSH_MSG_CHANNEL_EOF;    _libssh2_htonu32(packet + 1, channel->remote.id);    rc = _libssh2_transport_send(session, packet, 5, NULL, 0);    if (rc == LIBSSH2_ERROR_EAGAIN) {        _libssh2_error(session, rc,                       ""Would block sending EOF"");        return rc;    }    else if (rc) {        return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_SEND,                              ""Unable to send EOF on channel"");    }    channel->local.eof = 1;    return 0;}",2,"cwe119,cwe120"
"TabbingNextCell(char *cell_start, char **cell_end) {    char *end=NULL, *dup, *dup2, *next_cell=NULL, *p;    TabbingNextCellEnd(cell_start, &end, &next_cell);    if (end < cell_start)        end = cell_start;    dup = my_strndup(cell_start, (size_t) (end - cell_start));    if (*next_cell == '0')        *cell_end = NULL;    else        *cell_end = next_cell;         while (((p = strstr(dup, ""+"")) != NULL) || ((p = strstr(dup, ""-"")) != NULL)) {        *p = ' ';        p++;        *p = ' ';    }    dup2 = strdup_noendblanks(dup);    free(dup);    diagnostics(5,""next cell = [[%s]]"", dup);    return dup2;}",2,"cwe469,cweother"
"Get_Input_CommandLine_AA(option *input, int argc, char **argv){  char* p;  Get_Input_CommandLine_Common(input, argc, argv);  input->mod->datatype         = 1;  p = argv[N_MODELNAME];  strcpy(input->modelname, p);  if      (!strcmp(p,""Dayhoff"")) input->mod->whichmodel = 11;  else if (!strcmp(p,""JTT""))     input->mod->whichmodel = 12;  else if (!strcmp(p,""MtREV""))   input->mod->whichmodel = 13;  else if (!strcmp(p,""WAG""))     input->mod->whichmodel = 14;  else if (!strcmp(p,""DCMut""))   input->mod->whichmodel = 15;  else if (!strcmp(p,""RtREV""))   input->mod->whichmodel = 16;  else if (!strcmp(p,""CpREV""))   input->mod->whichmodel = 17;  else if (!strcmp(p,""VT""))      input->mod->whichmodel = 18;  else if (!strcmp(p,""Blosum62""))input->mod->whichmodel = 19;  else if (!strcmp(p,""MtMam""))   input->mod->whichmodel = 20;  else Exit(""Unknown model name"");  input->mod->ns = 20;  if(input->mod->whichmodel != 6) input->mod->s_opt->opt_lambda = 0;}",2,"cwe120,cwe469"
"prep_ok_file(krb5_context context, char *file_name, int *fd){    static char ok[] = "".dump_ok"";    krb5_error_code retval;    char *file_ok;    if (asprintf(&file_ok, ""%s%s"", file_name, ok) < 0) {        com_err(progname, ENOMEM, _(""while allocating dump_ok filename""));        exit_status++;        return 0;    }    *fd = open(file_ok, O_WRONLY | O_CREAT | O_TRUNC, 0600);    if (*fd == -1) {        com_err(progname, errno, _(""while creating 'ok' file, '%s'""), file_ok);        exit_status++;        free(file_ok);        return 0;    }    retval = krb5_lock_file(context, *fd, KRB5_LOCKMODE_EXCLUSIVE);    if (retval) {        com_err(progname, retval, _(""while locking 'ok' file, '%s'""), file_ok);        return 0;    }    return 1;}",2,"cwe469,cweother"
"print_name_only (Sym *self){  const char *name = self->name;  const char *filename;  char *demangled = 0;  char buf[PATH_MAX];  int size = 0;  if (name)    {      if (!bsd_style_output && demangle)t{t  demangled = bfd_demangle (core_bfd, name, DMGL_ANSI | DMGL_PARAMS);t  if (demangled)t    name = demangled;t}      printf (""%s"", name);      size = strlen (name);      if (line_granularity && self->file)t{t  filename = self->file->name;t  if (!print_path)t    {t      filename = strrchr (filename, '/');t      if (filename)tt{tt  ++filename;tt}t      elsett{tt  filename = self->file->name;tt}t    }t  sprintf (buf, "" (%s:%d @ %lx)"", filename, self->line_num,tt   (unsigned long) self->addr);t  printf (""%s"", buf);t  size += strlen (buf);t}      if (demangled)t{t  free (demangled);t}      DBG (DFNDEBUG, printf (""{%d} "", self->cg.top_order));      DBG (PROPDEBUG, printf (""%4.0f%% "", 100.0 * self->cg.prop.fract));    }  return size;}",2,"cwe119,cwe120"
"tod2str(struct tm* tod){  static char str[7] = """";  if (snprintf(str, 7, ""%02u%02u%02u"", tod->tm_hour, tod->tm_min, tod->tm_sec) != 6) {    fatal(MYNAME "": Bad time of day format '%s'"", str);  }  return str;}",2,"cwe119,cwe120"
"""process_section(FILE *f, int *lnptr, ttt    masterconf_process *func, void *rock){    struct entry e;    char buf[4096];    int lineno = *lnptr;    while (fgets(buf, sizeof(buf), f)) {tchar *p, *q;tlineno++;t/* remove EOL character */tif (buf[strlen(buf)-1] == '') buf[strlen(buf)-1] = '0';t/* remove starting whitespace */tfor (p = buf; *p && Uisspace(*p); p++);tt/* remove comments */tq = strchr(p, '#');tif (q) *q = '0';t/* skip empty lines or all comment lines */tif (!*p) continue;tif (*p == '}') break;tfor (q = p; Uisalnum(*q); q++) ;tif (*q) { *q = '0'; q++; }ttif (q - p > 0) {t    /* there's a value on this line */t    e.line = q;t    e.lineno = lineno;t    func(p, &e, rock);t}t/* end of section? */tif (strchr(q, '}')) break;    }    *lnptr = lineno;}""",2,"cwe119,cwe120"
"remote_netdump_init(void){        char sendbuf[BUFSIZE];        char recvbuf[BUFSIZE];        char *p1, *p2;tulong panic_task;        BZERO(sendbuf, BUFSIZE);        BZERO(recvbuf, BUFSIZE);        sprintf(sendbuf, ""NETDUMP_INIT %d %s"", pc->rmfd, pc->server_memsrc);        send(pc->sockfd, sendbuf, strlen(sendbuf), 0);        recv(pc->sockfd, recvbuf, BUFSIZE-1, 0);        if (strstr(recvbuf, ""<FAIL>""))                return FALSE;        p1 = strstr(recvbuf, ""panic_task: "");        if (p1) {                p1 += strlen(""panic_task: "");                p2 = strstr(p1, """");                *p2 = NULLCHAR;                panic_task = htol(p1, FAULT_ON_ERROR, NULL);tttt->panic_task = panic_task;                   if (CRASHDEBUG(1))                        fprintf(fp, ""panic_task: %lx"", tt->panic_task);        }        return TRUE;}",3,"cwe119,cwe120,cwe469"
"__ecereMethod___ecereNameSpace__ecere__net__FileServerConnection_OnReceive(struct __ecereNameSpace__ecere__com__Instance * this, const unsigned char * buffer, unsigned int count){struct __ecereNameSpace__ecere__net__FileServerConnection * __ecerePointer___ecereNameSpace__ecere__net__FileServerConnection = (struct __ecereNameSpace__ecere__net__FileServerConnection *)(this ? (((char *)this) + __ecereClass___ecereNameSpace__ecere__net__FileServerConnection->offset) : 0);struct __ecereNameSpace__ecere__net__Request * request;unsigned int bytesProcessed = 0;__ecereMethod___ecereNameSpace__ecere__sys__Mutex_Wait(__ecerePointer___ecereNameSpace__ecere__net__FileServerConnection->mutex);while((request = __ecerePointer___ecereNameSpace__ecere__net__FileServerConnection->requests.first)){unsigned int numBytes = request->numBytes;if(count - bytesProcessed < numBytes)break;__ecereMethod___ecereNameSpace__ecere__sys__OldList_Remove(&__ecerePointer___ecereNameSpace__ecere__net__FileServerConnection->requests, request);__ecereMethod___ecereNameSpace__ecere__sys__Mutex_Release(__ecerePointer___ecereNameSpace__ecere__net__FileServerConnection->mutex);request->CallBack(request, buffer + bytesProcessed);bytesProcessed += numBytes;__ecereMethod___ecereNameSpace__ecere__sys__Mutex_Wait(__ecerePointer___ecereNameSpace__ecere__net__FileServerConnection->mutex);}__ecereMethod___ecereNameSpace__ecere__sys__Mutex_Release(__ecerePointer___ecereNameSpace__ecere__net__FileServerConnection->mutex);return bytesProcessed;}",2,"cwe120,cwe476"
"GetIPTCProperty(const Image *image,const char *key){  char    *attribute,    *message;  const StringInfo    *profile;  long    count,    dataset,    record;  register ssize_t    i;  size_t    length;  profile=GetImageProfile(image,""iptc"");  if (profile == (StringInfo *) NULL)    profile=GetImageProfile(image,""8bim"");  if (profile == (StringInfo *) NULL)    return(MagickFalse);  count=sscanf(key,""IPTC:%ld:%ld"",&dataset,&record);  if (count != 2)    return(MagickFalse);  attribute=(char *) NULL;  for (i=0; i < (ssize_t) GetStringInfoLength(profile); i+=(ssize_t) length)  {    length=1;    if ((ssize_t) GetStringInfoDatum(profile)[i] != 0x1c)      continue;    length=(size_t) (GetStringInfoDatum(profile)[i+3] << 8);    length|=GetStringInfoDatum(profile)[i+4];    if (((long) GetStringInfoDatum(profile)[i+1] == dataset) &&        ((long) GetStringInfoDatum(profile)[i+2] == record))      {        message=(char *) NULL;        if (~length >= 1)          message=(char *) AcquireQuantumMemory(length+1UL,sizeof(*message));        if (message != (char *) NULL)          {            (void) CopyMagickString(message,(char *) GetStringInfoDatum(              profile)+i+5,length+1);            (void) ConcatenateString(&attribute,message);            (void) ConcatenateString(&attribute,"";"");            message=DestroyString(message);          }      }    i+=5;  }  if ((attribute == (char *) NULL) || (*attribute == ';'))    {      if (attribute != (char *) NULL)        attribute=DestroyString(attribute);      return(MagickFalse);    }  attribute[strlen(attribute)-1]='0';  (void) SetImageProperty((Image *) image,key,(const char *) attribute);  attribute=DestroyString(attribute);  return(MagickTrue);}",2,"cwe119,cwe120"
"sock_read_from_client(ClientSocketMap *clientSocketMap){tchar buffer[MAXMSG];tint nbytes;tdebug(RPT_DEBUG, ""%s()"", __FUNCTION__);terrno = 0;tnbytes = sock_recv(clientSocketMap->socket, buffer, MAXMSG);twhile (nbytes > 0) {tt ttint fr;ttchar *str;ttdebug(RPT_DEBUG, ""%s: received %4d bytes"", __FUNCTION__, nbytes);tt ttsring_write(messageRing, buffer, nbytes);tt ttdo {tttstr = sring_read_string(messageRing);tttif (clientSocketMap->client) {ttttclient_add_message(clientSocketMap->client, str);ttt} else {ttttreport(RPT_DEBUG, ""%s: Can't find client %d"",ttttt__FUNCTION__, clientSocketMap->socket);ttt}tt} while (str != NULL);tt ttfr = sring_getMaxWrite(messageRing);ttif (fr == 0)tttreport(RPT_WARNING, ""%s: Message buffer full"", __FUNCTION__);ttnbytes = sock_recv(clientSocketMap->socket, buffer, min(MAXMSG, fr));t}tif (sring_getMaxRead(messageRing) > 0) {ttreport(RPT_WARNING, ""%s: left over bytes in message buffer"",ttt__FUNCTION__);ttsring_clear(messageRing);t}tif (nbytes < 0 && errno == EAGAIN)ttreturn 0;tt treturn -1;ttt }",2,"cwe119,cwe120"
"main (){  unsigned char str[] =""00:01:02:03:04:05"";  unsigned char * pch;  unsigned char mac[6];  int i=0;  printf (""Splitting string ""%s"" into tokens:"",str);  pch = strtok (str,"":"");  while (pch != NULL)  {    mac[i]=atoi(pch);    pch = strtok (NULL, "":"");    i++;  }  for(i=0 ; i<6; i++)      printf(""%02x:"",mac[i]);  printf("""");  return 0;}",3,"cwe119,cwe120,cweother"
"get_index_from_uri(const char *uri){tuint32 idx = 0;tif (uri) {ttconst char *endptr;ttendptr = is_strprefix(uri, ""/get/"");ttif (endptr) {tttint error;ttt tttidx = parse_uint32(endptr, &endptr, 10, &error);tttif (tttterror ||tttt'/' != endptr[0] ||tttt'0' == endptr[1] ||ttttNULL != strchr(&endptr[1], '/')ttt) {ttttidx = 0;ttt}tt}t}treturn idx;}",2,"cwe119,cwe120"
"update_uidpwd(AdmldapInfo admInfo) {tFILE *f;tchar *uid=NULL, *pw=NULL, *col=NULL;tchar *newuid=NULL, *newpw=NULL;tstatic char filename[BIG_LINE];tstatic char inbuf[BIG_LINE];tchar *tmpfile = admldapGetAdmpwFilePath(admInfo);tPR_snprintf(filename, sizeof(filename), tmpfile);tPL_strfree(tmpfile);tnewuid = get_cgi_var(""admpw.uid"",NULL, NULL);tnewpw  = get_cgi_var(""admpw.pw"",NULL, NULL);tif (newuid==NULL && newpw==NULL) {ttrpt_err(INCORRECT_USAGE, i18nMsg(DBT_NO_PARAM, ""No parameters to set""), NULL, NULL);t}tlogMsg(""newuid=%s, newpw=%s"", newuid ? newuid:"""", newpw ? newpw : """");tif ((f=fopen(filename, ""r""))==NULL) {ttrpt_err(SYSTEM_ERROR, i18nMsg(DBT_OPEN_ADMPW,""Can not open admpw file""), NULL, NULL);t}tif (fgets(inbuf, sizeof(inbuf), f) == NULL) {ttfclose(f);ttrpt_err(SYSTEM_ERROR, i18nMsg(DBT_READ_ADMPW, ""Can not read admpw file""), NULL, NULL);t}tlogMsg(""line=%s@"", inbuf);tfclose(f);tcol = strchr(inbuf, ':');tif (col == NULL) {ttrpt_err(SYSTEM_ERROR, i18nMsg(DBT_ADMPW_CORRUPTED,""admpw file corrupted""), NULL, NULL);t}ttuid = inbuf; *col=0; pw=col+1;tlogMsg(""uid=%s, pw=%s"", uid, pw);ttif (newuid == NULL) {ttnewuid = uid;t}tif (newpw != NULL) {        char *configdir = util_get_conf_dir();        char *secdir = util_get_security_dir();ttint errorCode = ADMSSL_InitSimple(configdir, secdir, 1  );ttif (errorCode) {tttrpt_err(APP_ERROR,tttti18nMsg(DBT_SECURITY_INIT, ""Security Initialization Failed""),ttttNULL, NULL);tt}ttupdate_admpwd(newuid, sha1_pw_enc(newpw), filename);t}telse {ttupdate_admpwd(newuid, pw, filename);t}trpt_success(NULL);}",5,"cwe119,cwe120,cwe476,cwe469,cweother"
"get_template_script( const tConf* pConfig ){  static char buffer[1024] = { 0x00 };  FILE* f_test;           if( buffer[0] == 0x00 )  {    pal_snprintf( buffer, sizeof buffer, ""%s%c%s.%s"", ScriptDir, DirSeparator, pConfig->template, ScriptExtension);    f_test = fopen( buffer, ""r"" );    if( f_test == NULL )    {      Display( LOG_LEVEL_1, ELError, ""tspSetupInterface"", GOGO_STR_TEMPLATE_NOT_FOUND, buffer );      return NULL;    }         fclose( f_test );    memset( buffer, 0, sizeof buffer );         if( ScriptInterpretor != NULL )    {      pal_snprintf( buffer, sizeof buffer,               ""%s ""%s%c%s.%s"""",               ScriptInterpretor, ScriptDir, DirSeparator, pConfig->template, ScriptExtension);    }    else    {      pal_snprintf( buffer, sizeof buffer,                """"%s%c%s.%s"""",                ScriptDir, DirSeparator, pConfig->template, ScriptExtension);    }  }  return buffer;}",3,"cwe119,cwe120,cweother"
"test_ev_readfd_cb(void *up G_GNUC_UNUSED){    char buf[1024];    int len;         tu_dbg(""reader: callback executing"");    len = read(cb_fd, buf, sizeof(buf));    if (len == 0) {ttu_dbg(""reader: callback returning"");    } else if (len < 0) {ttu_dbg(""reader: read() returned %d: %s"", len, strerror(errno));t     } else {ttu_dbg(""reader: read %d bytes"", len);tglobal -= len;t tif (global <= 0) {t    close(cb_fd);t    event_release(hdl[0]);t}    }}",3,"cwe119,cwe120,cweother"
"connection_or_get_state_description(or_connection_t *orconn,                                    char *buf, size_t buflen){  connection_t *conn = TO_CONN(orconn);  const char *conn_state;  char tls_state[256];  tor_assert(conn->type == CONN_TYPE_OR);  conn_state = conn_state_to_string(conn->type, conn->state);  tor_tls_get_state_description(orconn->tls, tls_state, sizeof(tls_state));  tor_snprintf(buf, buflen, ""%s with SSL state %s"", conn_state, tls_state);}",2,"cwe119,cwe120"
"print_unique_ids (gnutls_buffer_st * str, const gnutls_x509_crt_t cert){  int result;  char buf[256];                   size_t buf_size = 256;  result = gnutls_x509_crt_get_issuer_unique_id (cert, buf, &buf_size);  if (result >= 0)    {      addf (str, (""ttIssuer Unique ID:""));      hexdump (str, buf, buf_size, ""ttt"");      if (buf_size == 16)        {                                  guiddump (str, buf, buf_size, ""ttt"");        }    }  buf_size = 256;  result = gnutls_x509_crt_get_subject_unique_id (cert, buf, &buf_size);  if (result >= 0)    {      addf (str, (""ttSubject Unique ID:""));      hexdump (str, buf, buf_size, ""ttt"");      if (buf_size == 16)        {                                  guiddump (str, buf, buf_size, ""ttt"");        }    }}",2,"cwe119,cwe120"
"xsh_extract(cpl_frame * rec_frame, cpl_frame* loc_frame,    xsh_instrument* instrument, xsh_extract_param* extract_par,    cpl_frame** res_frame_ext, const char* rec_prefix) {  cpl_frame *res_frame = NULL;  char tag[256];  sprintf(tag, ""%s_%s"", rec_prefix,  XSH_GET_TAG_FROM_ARM( XSH_ORDER1D, instrument));  check( res_frame = xsh_extract_with_tag( rec_frame, loc_frame, instrument,          extract_par, tag,res_frame_ext ) );  xsh_add_temporary_file(cpl_frame_get_filename(res_frame));  cleanup: return res_frame;}",2,"cwe119,cwe120"
"setArgusPortNum(int value, char *bindIP){   char errbuf[MAXSTRLEN];   int retn = 0;   if ((ArgusPortNum = value)) {      if ((retn = ArgusEstablishListen (value, bindIP, errbuf)) < 0)         ArgusLog (LOG_ERR, ""%s"", errbuf);   }#ifdef ARGUSDEBUG   ArgusDebug (2, ""setArgusPortNum(%d) returning"", value);#endif}",2,"cwe119,cwe120"
"GetHostBits(){int hostBits = (sizeof(uintptr_t) == 8) ? 64 : 32;char * hostType = getenv(""HOSTTYPE"");char host[256];if(!hostType){struct __ecereNameSpace__ecere__com__Instance * f = __ecereFunction___ecereNameSpace__ecere__sys__DualPipeOpen((((unsigned int)(0x1))), ""uname -m"");if(f){if(__ecereMethod___ecereNameSpace__ecere__sys__File_GetLine(f, host, sizeof host))hostType = host;(__ecereNameSpace__ecere__com__eInstance_DecRef(f), f = 0);}}if(hostType){if(!strcmp(hostType, ""x86_64""))hostBits = 64;else if(!strcmp(hostType, ""i386"") || !strcmp(hostType, ""i686""))hostBits = 32;}return hostBits;}",3,"cwe119,cwe120,cweother"
"add_diskdump_data(char* name){#define DDL_SIZE 16tint i;tint sz = sizeof(void*);tstruct diskdump_data *ddp;tif (dd_list == NULL) {ttdd_list = calloc(DDL_SIZE, sz);ttnum_dd = DDL_SIZE;t} else {ttfor (i = 0; i < num_dumpfiles; i++) {tttddp = dd_list[i];                tif (same_file(ddp->filename, name))tttterror(FATAL, tttt    ""split dumpfiles are identical:""tttt    ""  %s  %s"",tttttddp->filename, name);tttif (memcmp(ddp->header, dd->header,ttt    sizeof(struct disk_dump_header)))tttterror(FATAL, tttt    ""split dumpfiles derived from different vmcores:""tttt    ""  %s  %s"",tttttddp->filename, name);tt}t}tif (num_dumpfiles == num_dd) {tt ttstruct diskdump_data **tmp;tttmp = calloc(num_dd*2, sz);ttmemcpy(tmp, dd_list, sz*num_dd);ttfree(dd_list);ttdd_list = tmp;ttnum_dd *= 2;t}tdd_list[num_dumpfiles] = dd;tdd->flags |= DUMPFILE_SPLIT;tdd->filename = name;tif (CRASHDEBUG(1))ttfprintf(fp, ""%s: start_pfn=%llu, end_pfn=%llu"", name,tttdd->sub_header_kdump->start_pfn_64,tttdd->sub_header_kdump->end_pfn_64);}",2,"cwe120,cweother"
"xsh_frameset_mflat_divide(cpl_frameset* input, cpl_frame* mflat,    xsh_instrument* instrument) {  int nraw = 0;  int i = 0;  cpl_frame * divided = NULL;  cpl_frame * frm = NULL;  char  arm_str[16] ;  char ftag[256];  char fname[256];  cpl_frameset* output = NULL;  xsh_msg(""apply flat field"");  nraw = cpl_frameset_get_size(input);  output = cpl_frameset_new();  sprintf( arm_str, ""%s"",  xsh_instrument_arm_tostring(instrument) ) ;  for (i = 0; i < nraw; i++) {    frm = cpl_frameset_get_frame(input, i);    sprintf(ftag, ""FF_%d_SLIT_OFFSET_%s"", i,arm_str);    sprintf(fname, ""%s.fits"", ftag);        divided = xsh_divide_flat( frm,mflat, ftag, instrument );    xsh_add_temporary_file(fname);    cpl_frameset_insert(output, divided );    xsh_free_frame(&frm);  }  return output;}",2,"cwe119,cwe120"
"io_date (void) {  char b[256];  char *s = luaL_opt_string(1, ""%c"");  struct tm *tm;  time_t t;  time(&t); tm = localtime(&t);  if (strftime(b,sizeof(b),s,tm))    lua_pushstring(b);  else    lua_error(""invalid `date' format"");}",2,"cwe119,cwe120"
"print_error (char *format, ...){  char buf[1024];  va_list msg;  va_start(msg, format);  vsprintf(buf, format, msg);  va_end(msg);  fprintf(stderr, ""%s: %s: %s"", program_name, buf, strerror(errno));  if (flags.logging == TRUE)  {    sprintf(buf, ""%s: %s: %s"", program_name, buf, strerror(errno));    add_to_log(buf);  }}",3,"cwe119,cwe120,cweother"
"load_24bit_bmp( FL_IMAGE * im,                SPEC     * sp ){    FILE *fp = im->fpin;    int i,        j;    unsigned char *red,                  *green,                  *blue;    for ( i = im->h - 1; ! feof( fp ) && i >= 0; i--, im->completed++ )    {        red   = im->red[ i ];        green = im->green[ i ];        blue  = im->blue[ i ];        for ( j = 0; j < im->w; j++ )        {            blue[ j ]  = getc( fp );            green[ j ] = getc( fp );            red[ j ]   = getc( fp );        }        for ( j = 0; j < sp->pad; j++ )            getc( fp );        if ( ! ( im->completed & FLIMAGE_REPFREQ ) )            im->visual_cue( im, ""Reading 24bit BMP"" );    }    return ( i < im->h / 2 ) ? 1 : -1;}",2,"cwe120,cweother"
"run_gpg_verify(const char *buf, unsigned long size, int verbose){tstruct child_process gpg;tconst char *args_gpg[] = {""gpg"", ""--verify"", ""FILE"", ""-"", NULL};tchar path[PATH_MAX];tsize_t len;tint fd, ret;tfd = git_mkstemp(path, PATH_MAX, "".git_vtag_tmpXXXXXX"");tif (fd < 0)ttreturn error(""could not create temporary file '%s': %s"",ttttttpath, strerror(errno));tif (write_in_full(fd, buf, size) < 0)ttreturn error(""failed writing temporary file '%s': %s"",ttttttpath, strerror(errno));tclose(fd);t tlen = parse_signature(buf, size);tif (verbose)ttwrite_in_full(1, buf, len);tmemset(&gpg, 0, sizeof(gpg));tgpg.argv = args_gpg;tgpg.in = -1;targs_gpg[2] = path;tif (start_command(&gpg)) {ttunlink(path);ttreturn error(""could not run gpg."");t}twrite_in_full(gpg.in, buf, len);tclose(gpg.in);tret = finish_command(&gpg);tunlink_or_warn(path);treturn ret;}",2,"cwe119,cwe120"
"static_scale (FILE *fp, double scale, double *center, gamgi_bool *error){char string[GAMGI_ENGINE_LINE];if (fabs (scale - 1.0) > GAMGI_MATH_TOLERANCE)  {  sprintf (string, ""<Transform translation=""%.*f %.*f %.*f"">"",  gamgi->gamgi->length, center[0],   gamgi->gamgi->length, center[1],   gamgi->gamgi->length, center[2]);  gamgi_io_file_fprintf (fp, string, error);  sprintf (string, ""<Transform scale=""%.*f %.*f %.*f"">"",   GAMGI_MATH_DECIMAL_SCALE, scale,  GAMGI_MATH_DECIMAL_SCALE, scale,  GAMGI_MATH_DECIMAL_SCALE, scale);  gamgi_io_file_fprintf (fp, string, error);  sprintf (string, ""<Transform translation=""%.*f %.*f %.*f"">"",  gamgi->gamgi->length, -center[0],  gamgi->gamgi->length, -center[1],  gamgi->gamgi->length, -center[2]);  gamgi_io_file_fprintf (fp, string, error);  }}",2,"cwe119,cwe120"
"u_GFileModifyableDir(const unichar_t *file) {    char buffer[1024], *pt;    u2def_strncpy(buffer,file,sizeof(buffer));    pt = strrchr(buffer,'/');    if ( pt==NULL )tstrcpy(buffer,""."");    elset*pt='0';return( GFileModifyable(buffer));}",2,"cwe119,cwe120"
"gui_show_doing(char *title, char *text){tchar rtext[256];tsnprintf(rtext, sizeof(rtext),""GAstMan: %s"", title);tif (!doingw) {ttdoingw = gtk_dialog_new();ttdtext = gtk_label_new(text);ttgtk_widget_show(dtext);ttgtk_box_pack_start(GTK_BOX(GTK_DIALOG(doingw)->vbox), dtext, TRUE, TRUE, 5);ttgtk_window_position(GTK_WINDOW(doingw), GTK_WIN_POS_CENTER);ttgtk_container_set_border_width(GTK_CONTAINER(GTK_DIALOG(doingw)->vbox), 10);t} else {ttgtk_label_set_text(GTK_LABEL(dtext), text);t}tgtk_window_set_title(GTK_WINDOW(doingw), rtext);tif (window)ttgtk_widget_set_sensitive(window, FALSE);tgtk_widget_show_all(doingw);twhile(!gtk_main_iteration_do(0));treturn 0;}",2,"cwe119,cwe120"
"add_element(const char *elem, const char *desc){    int n;    int nelem;    if (*desc == 0)tdesc = elem;    n = nlist - 1;    nelem = list[n].nelem++;    list[n].element =t(char **)G_realloc(list[n].element, (nelem + 1) * sizeof(char *));    list[n].element[nelem] = G_store(elem);    list[n].desc =t(char **)G_realloc(list[n].desc, (nelem + 1) * sizeof(char *));    list[n].desc[nelem] = G_store(desc);    return 0;}",2,"cwe119,cwe120"
"do_curses_cb(void *priv, const struct VSC_point * const sp){tstruct pt *pt;tchar buf[128];t(void)priv;tassert(!strcmp(sp->fmt, ""uint64_t""));tpt = calloc(sizeof *pt, 1);tAN(pt);tVTAILQ_INSERT_TAIL(&pthead, pt, next);tpt->ptr = sp->ptr;tpt->ref = *pt->ptr;tpt->type = sp->flag;t*buf = '0';tif (strcmp(sp->class, """")) {ttstrcat(buf, sp->class);ttstrcat(buf, ""."");t}tif (strcmp(sp->ident, """")) {ttstrcat(buf, sp->ident);ttstrcat(buf, ""."");t}tstrcat(buf, sp->name);tstrcat(buf, "" - "");tstrcat(buf, sp->desc);tpt->name = strdup(buf);tAN(pt->name);treturn (0);}",2,"cwe119,cwe120"
"Alg1to2(Term t)t{tTerm t1,ret=0;tint alen, acur;tchar buf[40];tif(t==0)ttreturn 0;tttttif(setjmp(alg2_jmp_buf)!=0)ttreturn 0;tttttif(!is_empty_list(CompoundArg2(t)))tt{ttErrorInfo(324);ttprintf(""non-scalar lagrangian term"");ttFreeAtomic(t);ttreturn 0;tt}tt1=ConsumeCompoundArg(t,1);tFreeAtomic(t); tt=t1;talen=ListLength(t);tacur=0;ttwhile(!is_empty_list(t))tt{ttTerm t2,y,auxt=0;ttacur++;ttsprintf(buf,""mterm_to_2: %d of %d"",acur,alen);ttRegisterLine(buf);ttttt2=ListFirst(t);tttty=alg2_mterm_to_2(t2);t        tttttttif(!y)tt{tttt=ListTail(t);tttUnregisterLine();tttcontinue;tt}ttttttRedSqrt2(y);ttif(TexOutput || FAOutput) auxt=alg2_rem_lambdaf(y);ttelse auxt=0;ttttalg2_norm(y);ttttif(auxt) alg2_norm(auxt);tttret=AppendFirst(ret,y);ttif(auxt) ret=AppendFirst(ret,auxt);ttttt=ListTail(t);ttUnregisterLine();tt}tRemoveList(t1); tttreturn ret;t}",2,"cwe119,cwe120"
"setenv_oldpers(int oldpers) {    static char oldpers_str[sizeof(oldpers)*8+1];    int i = sizeof(oldpers_str);    oldpers_str[--i] = '0';    while (i >= 0) {      oldpers_str[i--] = ((oldpers & 1) ? '1' : '0');      oldpers = oldpers >> 1;    }    return setPersonalityEnv(""MTCP_OLDPERS"", oldpers_str);}",2,"cwe119,cwe120"
"""GXactLoadSubxactData(GlobalTransaction gxact, int nsubxacts,ttttt TransactionId *children){tPGPROCt   *proc = &ProcGlobal->allProcs[gxact->pgprocno];tPGXACTt   *pgxact = &ProcGlobal->allPgXact[gxact->pgprocno];t/* We need no extra lock since the GXACT isn't valid yet */tif (nsubxacts > PGPROC_MAX_CACHED_SUBXIDS)t{ttpgxact->overflowed = true;ttnsubxacts = PGPROC_MAX_CACHED_SUBXIDS;t}tif (nsubxacts > 0)t{ttmemcpy(proc->subxids.xids, children,ttt   nsubxacts * sizeof(TransactionId));ttpgxact->nxids = nsubxacts;t}}""",2,"cwe120,cwe469"
"read_matrix(){tstatic char userfile[FILENAMELEN+1];ttwhile(TRUE)t{ttfprintf(stdout,"""");ttfprintf(stdout,"" ********* PROTEIN WEIGHT MATRIX MENU *********"");ttfprintf(stdout,"""");ttttttfprintf(stdout,""     1. %s"",pam_matrix_name[0]);ttfprintf(stdout,""     2. %s"",pam_matrix_name[1]);ttfprintf(stdout,""     3. %s"",pam_matrix_name[2]);ttfprintf(stdout,""     4. %s"",pam_matrix_name[3]);ttfprintf(stdout,""     H. HELP"");ttfprintf(stdout,""     -- Current matrix is the %s "",pam_matrix_name[matnum-1]);ttif(matnum == 4) fprintf(stdout,""(file = %s)"",userfile);ttfprintf(stdout,""--"");tttttttgetstr(""Enter number (or [RETURN] to exit)"",lin2);ttif(*lin2 == EOS) return;ttswitch(toupper(*lin2))  {tttcase '1':ttttmatptr=pam100mt;ttttmake_pamo(0);ttttprot_gap_open   = 13;ttttprot_gap_extend = 13;ttttmatnum=1;ttttbreak;tttcase '2':ttttmatptr=pam250mt;ttttmake_pamo(0);ttttprot_gap_open   = 10;ttttprot_gap_extend = 10;ttttmatnum=2;ttttbreak;tttcase '3':ttttmatptr=idmat;ttttmake_pamo(0);ttttprot_gap_open   = 10;ttttprot_gap_extend = 10;ttttmatnum=3;ttttbreak;tttcase '4':ttttif(user_mat(userfile)) matnum=4;ttttbreak;tttcase '?':tttcase 'H':ttttget_help(8);ttttbreak;tttdefault:ttttfprintf(stderr,""Unrecognised Command"");ttttbreak;tt}t}}",2,"cwe119,cwe120"
"key2s(datum db){tchar *buf;tchar *p1, *p2;tbuf = (char *) malloc((db.dsize + 1) * sizeof(char));tif (!buf)t    oops(""cannot get memory"");tfor (p1 = buf, p2 = db.dptr; *p2 != '0'; *p1++ = *p2++);t*p1 = '0';treturn buf;}",2,"cwe120,cwe476"
"read_map(const char *filename){tconst int HASH_SIZE = 1000;t tFILE *map_file = fopen(filename, ""r"");tif (NULL == map_file) { perror(NULL); exit(EXIT_FAILURE); }tstruct hash *map = create_hash(HASH_SIZE);tif (NULL == map) { perror(NULL); exit(EXIT_FAILURE); }tchar *line;twhile (NULL != (line = read_line(map_file))) {tt ttif ('#' == line[0] || is_all_whitespace(line)) {tttfree(line);tttcontinue;tt}ttchar *key, *value;ttstruct word_tokenizer *wtok = create_word_tokenizer(line);ttif (NULL == wtok) { perror(NULL); exit(EXIT_FAILURE); }ttkey = wt_next(wtok);t ttif (NULL == key) {tttfprintf (stderr,tttt""Wrong format in line '%s' - aborting."",ttttline);tttexit(EXIT_FAILURE);tt}ttvalue = wt_next(wtok);ttif (NULL == value) {ttt tttvalue = strdup("""");tt}ttif (! hash_set(map, key, (void *) value)) {tttperror(NULL);tttexit(EXIT_FAILURE);tt}ttdestroy_word_tokenizer(wtok);ttfree(key);  ttfree(line);t}treturn map;}",2,"cwe469,cweother"
"gst_ring_buffer_close_device (GstRingBuffer * buf){  gboolean res = TRUE;  GstRingBufferClass *rclass;  g_return_val_if_fail (GST_IS_RING_BUFFER (buf), FALSE);  GST_DEBUG_OBJECT (buf, ""closing device"");  GST_OBJECT_LOCK (buf);  if (G_UNLIKELY (!buf->open))    goto was_closed;  if (G_UNLIKELY (buf->acquired))    goto was_acquired;  buf->open = FALSE;  rclass = GST_RING_BUFFER_GET_CLASS (buf);  if (G_LIKELY (rclass->close_device))    res = rclass->close_device (buf);  if (G_UNLIKELY (!res))    goto close_error;  GST_DEBUG_OBJECT (buf, ""closed device"");done:  GST_OBJECT_UNLOCK (buf);  return res;   was_closed:  {    GST_DEBUG_OBJECT (buf, ""Device for ring buffer already closed"");    g_warning (""Device for ring buffer %p already closed, fix your code"", buf);    res = TRUE;    goto done;  }was_acquired:  {    GST_DEBUG_OBJECT (buf, ""Resources for ring buffer still acquired"");    g_critical (""Resources for ring buffer %p still acquired"", buf);    res = FALSE;    goto done;  }close_error:  {    buf->open = TRUE;    GST_DEBUG_OBJECT (buf, ""error closing device"");    goto done;  }}",2,"cwe476,cweother"
"c_value_read (GtsObject ** o, GtsFile * fp){  GfsBcValue * bc = GFS_BC_VALUE (*o);  if (GTS_OBJECT_CLASS (gfs_bc_value_class ())->parent_class->read)    (* GTS_OBJECT_CLASS (gfs_bc_value_class ())->parent_class->read)       (o, fp);  if (fp->type == GTS_ERROR)    return;  gfs_function_read (GFS_BC_VALUE (*o)->val, gfs_box_domain (GFS_BC (bc)->b->box), fp);}",2,"cwe120,cweother"
"String_DstNet(master_record_t *r, char *string) {char tmp_str[IP_STRING_LEN];tApplyNetMaskBits(r, 2);ttmp_str[0] = 0;tif ( (r->flags & FLAG_IPV6_ADDR ) != 0 ) {  ttuint64_ttip[2];ttip[0] = htonll(r->v6.dstaddr[0]);ttip[1] = htonll(r->v6.dstaddr[1]);ttinet_ntop(AF_INET6, ip, tmp_str, sizeof(tmp_str));ttif ( ! long_v6 ) {tttcondense_v6(tmp_str);tt}t} else {t ttuint32_ttip;ttip = htonl(r->v4.dstaddr);ttinet_ntop(AF_INET, &ip, tmp_str, sizeof(tmp_str));t}ttmp_str[IP_STRING_LEN-1] = 0;tif ( long_v6 ) ttsnprintf(string, MAX_STRING_LENGTH-1, ""%s%39s/%-2u"", tag_string, tmp_str, r->dst_mask );telsettsnprintf(string, MAX_STRING_LENGTH-1, ""%s%16s/%-2u"", tag_string, tmp_str, r->dst_mask );tstring[MAX_STRING_LENGTH-1] = 0;}",2,"cwe119,cwe120"
"decode_dot_code(T_BOOL key,double ticklen,int cwcodeset,tttT_BOOL reset_decoder){  static double evtlen=0;  static double ditlen=0;  static T_BOOL keyprev=0;  static int dotcount=0;  static char cwbuf[CW_BUF_MAX_SIZE]="""";  char decoded_char[CW_SYMBOL_MAX+1]="""";  int i;     if(reset_decoder)  {    evtlen=0;    ditlen=0;    keyprev=0;    dotcount=0;    cwbuf[0]=0;    decoded_char[0]=0;    return;  }     if(key!=keyprev)  {    if(!key)t     {      if(dotcount<9)        dotcount++;t              ditlen=(ditlen*(DECODER_INERTIA-1)+evtlen)/DECODER_INERTIA;    }    evtlen=0;  }     if(!key && !keyprev && evtlen>ditlen*2 && dotcount &&t(i=strlen(cwbuf))<CW_BUF_MAX_SIZE-1)  {    cwbuf[i]='0'+dotcount;    cwbuf[i+1]=0;    dotcount=0;  }     if(evtlen>ditlen*5 && cwbuf[0])  {         decode_cw_sequence(cwcodeset,cwbuf,decoded_char);         cwbuf[0]=0;  }     if(decoded_char[0])  {         insert_character_in_decoder_buffer(decoded_char,0);    decoded_char[0]=0;         if(ditlen>0)      sharedmem->decoded_msg_wpm=600/ditlen;t     else      sharedmem->decoded_msg_wpm=WPM_UNKNOWN_WPM;         sharedmem->decoded_msg_updated=1;  }  keyprev=key;  evtlen+=ticklen;}",2,"cwe119,cwe120"
"find_type_value( int          cln,                 const char * tyname ){    int i,        jmax = find_class_maxtype( cln ),        j;    for ( i = 0; i < cnumb; i++ )        if ( classes[ i ].cn == cln )            for ( j = 0; j < jmax; j++ )                if (    ! strcmp( classes[ i ].types[ j ].tname, tyname )                     || (    ! strncmp( tyname, ""FL_"", 3 )                          && ! strcmp( classes[ i ].types[ j ].tname,                                       tyname + 3 ) ) )                    return j;    M_err( ""TypeValue"", ""type %s is unknown"", tyname );    return -1;}",2,"cwe119,cwe120"
"main(int argc, char **argv){   int status = EXIT_SUCCESS;   struct gl_context local_ctx;   struct gl_context *ctx = &local_ctx;   int c;   int idx = 0;   while ((c = getopt_long(argc, argv, """", compiler_opts, &idx)) != -1)        ;   if (argc <= optind)      usage_fail(argv[0]);   initialize_context(ctx, (glsl_es) ? API_OPENGLES2 : API_OPENGL);   struct gl_shader_program *whole_program;   whole_program = rzalloc (NULL, struct gl_shader_program);   assert(whole_program != NULL);   whole_program->InfoLog = ralloc_strdup(whole_program, """");   for ( ; argc > optind; optind++) {      whole_program->Shaders =t reralloc(whole_program, whole_program->Shaders,tt  struct gl_shader *, whole_program->NumShaders + 1);      assert(whole_program->Shaders != NULL);      struct gl_shader *shader = rzalloc(whole_program, gl_shader);      whole_program->Shaders[whole_program->NumShaders] = shader;      whole_program->NumShaders++;      const unsigned len = strlen(argv[optind]);      if (len < 6)t usage_fail(argv[0]);      const char *const ext = & argv[optind][len - 5];      if (strncmp("".vert"", ext, 5) == 0)t shader->Type = GL_VERTEX_SHADER;      else if (strncmp("".geom"", ext, 5) == 0)t shader->Type = GL_GEOMETRY_SHADER;      else if (strncmp("".frag"", ext, 5) == 0)t shader->Type = GL_FRAGMENT_SHADER;      elset usage_fail(argv[0]);      shader->Source = load_text_file(whole_program, argv[optind]);      if (shader->Source == NULL) {t printf(""File ""%s"" does not exist."", argv[optind]);t exit(EXIT_FAILURE);      }      compile_shader(ctx, shader);      if (!shader->CompileStatus) {t printf(""Info log for %s:%s"", argv[optind], shader->InfoLog);t status = EXIT_FAILURE;t break;      }   }   if ((status == EXIT_SUCCESS) && do_link)  {      link_shaders(ctx, whole_program);      status = (whole_program->LinkStatus) ? EXIT_SUCCESS : EXIT_FAILURE;      if (strlen(whole_program->InfoLog) > 0)t printf(""Info log for linking:%s"", whole_program->InfoLog);   }   for (unsigned i = 0; i < MESA_SHADER_TYPES; i++)      ralloc_free(whole_program->_LinkedShaders[i]);   ralloc_free(whole_program);   _mesa_glsl_release_types();   _mesa_glsl_release_functions();   return status;}",2,"cwe120,cweother"
"""create_matrix(int lines, int columns) {tMatrix *a = malloc(sizeof(struct Matrix));tif(a == NULL) {ttreturn NULL;t}t// set matrix atributesta->lines       = lines;ta->columns     = columns;ta->determinant = 0.0;ta->trace       = 0.0;ta->inverse     = NULL;t// set matrix's valueta->value = malloc(lines * sizeof(double));tif(a->value == NULL) {ttreturn NULL;t} tfor(int i = 0; i < lines; i++) {tta->value[i] = calloc(columns, sizeof(double));ttif(a->value == NULL) {tttreturn NULL;tt}t}treturn a;}""",2,"cwe120,cweother"
"line_get(char *tmp, size_t len, char **textp){  char *s, c;  tmp[0] = '0';  if (*textp == NULL)    return 0;  s = strchr(*textp, '');  if(s != NULL){     *s = '0';     if(*(s-1) == 'r')t*(s-1) = '0';     if(strlen(*textp) < len - 1)tstrcpy(tmp, *textp);     elsetreturn 0;     strcat(tmp, """");     *textp = s+1;  }  else     return 0;  return 1;}",3,"cwe119,cwe120,cweother"
"set_dicts(char* optargs){tint len;tchar *optarg;topt.nbdict = 0;toptarg = strsep(&optargs, "","");tfor(len=0; len<MAX_DICTS; len++)t{ttopt.dicts[len] = NULL;t}twhile(optarg != NULL && opt.nbdict<MAX_DICTS)t{ttlen = strlen(optarg)+1;ttopt.dicts[opt.nbdict] = (char*)malloc(len * sizeof(char));ttif(opt.dicts[opt.nbdict] == NULL)tt{tttperror(""allocation failed!"");tttreturn( FAILURE );tt}ttif(strncasecmp(optarg, ""h:"", 2) == 0)tt{tttstrncpy(opt.dicts[opt.nbdict], optarg+2, len-2);tttopt.hexdict[opt.nbdict] = 1;tt}ttelsett{tttstrncpy(opt.dicts[opt.nbdict], optarg, len);tttopt.hexdict[opt.nbdict] = 0;tt}ttoptarg = strsep(&optargs, "","");ttopt.nbdict++;t}tnext_dict(0);twhile(next_dict(opt.nbdict+1) == 0) {}tnext_dict(0);treturn 0;}",2,"cwe120,cwe469"
"cmd_webcatch(){turlrect*u;tinttcount = 0, num = 0;tchartwhen[TIMESHORTLEN], url[SERVERLEN], pre[20];tcontext;tif(!cmdinfo.isparam)ttnum = 20;tcontext;tif(!URL->num_urls)t{ttsay(""No URL's caught yet.  Try again later!"");ttreturn;t}tcontext;tif(!isanumber(cmdinfo.tok1))t{ttsay(""Usage: webcatch [# hits]"");ttsayf(2,0,""Use this command to display the last n web catches made."");ttreturn;t}tcontext;tif(!num)t{ttnum = atoi(cmdinfo.tok1);ttif(num <= 0)tt{tttsay(""Invalid number.  Please use POSITIVE numbers only, thanks."");tttreturn;tt}t}tsay(""When  Nick      URL (%d URL%s caught)"",URL->num_urls,URL->num_urls==1?"""":""'s"");tsay(""----- --------- -------------------------------------------------"");tcontext;tfor(u=URL->urllist; u!=NULL; u=u->next)t{ttcount++;tttimet_to_time_short(u->time_caught,when);ttstrcpy(url,u->url);ttif(strlen(url) > 145)ttturl[145] = 0;ttsprintf(pre,""%-5s %-9s "",when,u->nick);ttsayi(pre,""%s"",url);ttif(count == num)tttbreak;t}tsay(""----- --------- -------------------------------------------------"");}",3,"cwe119,cwe120,cweother"
"add_sc(struct gfs2_sbd *sdp){tint fd;tchar new_name[256];tint error;ttfd = create_new_inode(sdp);tt{ttstruct gfs2_statfs_change sc;ttmake_jdata(fd, ""set"");ttmemset(&sc, 0, sizeof(struct gfs2_statfs_change));ttif (write(fd, (void*)&sc, sizeof(struct gfs2_statfs_change)) !=tt    sizeof(struct gfs2_statfs_change)) {tttperror(""add_sc"");tttexit(EXIT_FAILURE);tt}t}tclose(fd);ttsprintf(new_name, ""statfs_change%u"", sdp->md.journals);terror = rename2system(sdp, ""per_node"", new_name);tif (error < 0 && errno != EEXIST){ttperror(""add_sc rename2system"");ttexit(EXIT_FAILURE);t}}",2,"cwe119,cwe120"
"read_closure_free (gpointer data){tReadClosure *read = data;tg_free (read->alias);tif (read->collection)ttg_object_unref (read->collection);tif (read->cancellable)ttg_object_unref (read->cancellable);tg_slice_free (ReadClosure, read);}",2,"cwe120,cweother"
"""hvc_console_print(struct console *co, const char *b,ttt      unsigned count){tchar c[N_OUTBUF] __ALIGNED__;tunsigned i = 0, n = 0;tint r, donecr = 0, index = co->index;t/* Console access attempt outside of acceptable console range. */tif (index >= MAX_NR_HVC_CONSOLES)ttreturn;t/* This console adapter was removed so it is not usable. */tif (vtermnos[index] == -1)ttreturn;twhile (count > 0 || i > 0) {ttif (count > 0 && i < sizeof(c)) {tttif (b[n] == '' && !donecr) {ttttc[i++] = 'r';ttttdonecr = 1;ttt} else {ttttc[i++] = b[n++];ttttdonecr = 0;tttt--count;ttt}tt} else {tttr = cons_ops[index]->put_chars(vtermnos[index], c, i);tttif (r <= 0) {tttt/* throw away characters on errortttt * but spin in case of -EAGAIN */ttttif (r != -EAGAIN)ttttti = 0;ttt} else if (r > 0) {tttti -= r;ttttif (i > 0)tttttmemmove(c, c+r, i);ttt}tt}t}}""",2,"cwe119,cwe120"
"XLogFileReadAnyTLI(XLogSegNo segno, int emode, int source){tcharttpath[MAXPGPATH];tListCell   *cell;tinttttfd;tListt   *tles;t tif (expectedTLEs)tttles = expectedTLEs;telsetttles = readTimeLineHistory(recoveryTargetTLI);tforeach(cell, tles)t{ttTimeLineIDttli = ((TimeLineHistoryEntry *) lfirst(cell))->tli;ttif (tli < curFileTLI)tttbreak;tttt ttif (source == XLOG_FROM_ANY || source == XLOG_FROM_ARCHIVE)tt{tttfd = XLogFileRead(segno, emode, tli,ttttttt  XLOG_FROM_ARCHIVE, true);tttif (fd != -1)ttt{ttttelog(DEBUG1, ""got WAL segment from archive"");ttttif (!expectedTLEs)tttttexpectedTLEs = tles;ttttreturn fd;ttt}tt}ttif (source == XLOG_FROM_ANY || source == XLOG_FROM_PG_XLOG)tt{tttfd = XLogFileRead(segno, emode, tli,ttttttt  XLOG_FROM_PG_XLOG, true);tttif (fd != -1)ttt{ttttif (!expectedTLEs)tttttexpectedTLEs = tles;ttttreturn fd;ttt}tt}t}t tXLogFilePath(path, recoveryTargetTLI, segno);terrno = ENOENT;tereport(emode,ttt(errcode_for_file_access(),ttt errmsg(""could not open file ""%s"": %m"", path)));treturn -1;}",2,"cwe119,cwe120"
"SelectExecRegexMatch(char *filename,char *crit,char *prog){ char line[CF_BUFSIZE];  FILE *pp;  char buf[CF_MAXVARSIZE];  ReplaceStr(prog,buf,sizeof(buf),""$(this.promiser)"",filename);ReplaceStr(prog,buf,sizeof(buf),""${this.promiser}"",filename);if ((pp = cf_popen(buf,""r"")) == NULL)   {   CfOut(cf_error,""cf_popen"",""Couldn't open pipe to command %s"",buf);   return false;   }while (!feof(pp))   {   line[0] = '0';   CfReadLine(line,CF_BUFSIZE,pp);      if (FullTextMatch(crit,line))      {      cf_pclose(pp);       return true;      }   }cf_pclose(pp); return false;      }",2,"cwe119,cwe120"
"find_tuple(uint64 x, KmerPos *a, int n){ int l, r, m;     l = 0;  r = n;  while (l < r)    { m = ((l+r) >> 1);      if (a[m].code < x)        l = m+1;      else        r = m;    }  return (l);}",2,"cwe120,cweother"
"cdf_read_header(const cdf_info_t *info, cdf_header_t *h){tchar buf[512];t(void)memcpy(cdf_bo.s, ""01020304"", 4);tif (cdf_read(info, (off_t)0, buf, sizeof(buf)) == -1)ttreturn -1;tcdf_unpack_header(h, buf);tcdf_swap_header(h);tif (h->h_magic != CDF_MAGIC) {ttDPRINTF((""Bad magic 0x%"" INT64_T_FORMAT ""x != 0x%""tt    INT64_T_FORMAT ""x"",tt    (unsigned long long)h->h_magic,tt    (unsigned long long)CDF_MAGIC));ttgoto out;t}tif (h->h_sec_size_p2 > 20) {ttDPRINTF((""Bad sector size 0x%u"", h->h_sec_size_p2));ttgoto out;t}tif (h->h_short_sec_size_p2 > 20) {ttDPRINTF((""Bad short sector size 0x%u"",tt    h->h_short_sec_size_p2));ttgoto out;t}treturn 0;out:terrno = EFTYPE;treturn -1;}",2,"cwe119,cwe120"
"scc_socket_open_outgoing(int port, double dcycs){tScct*scc_ptr;tstruct sockaddr_in sa_in;tstruct hostent *hostentptr;tintton;tinttret;tSOCKETtsockfd;tscc_ptr = &(scc_stat[port]);tprintf(""scc socket close being called from socket_open_out"");tscc_socket_close(port, 0, dcycs);tscc_ptr->socket_state = 0;tmemset(scc_ptr->host_handle, 0, scc_ptr->host_aux1);tsockfd = socket(AF_INET, SOCK_STREAM, 0);tprintf(""sockfd ret: %d"", sockfd);tif(sockfd == -1) {ttprintf(""socket ret: %d, errno: %d"", sockfd, errno);ttscc_socket_close(port, 1, dcycs);ttreturn;t}t ton = 1;tret = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR,ttttt(char *)&on, sizeof(on));tif(ret < 0) {ttprintf(""setsockopt REUSEADDR ret: %d, err:%d"",tttret, errno);ttscc_socket_close(port, 1, dcycs);ttreturn;t}tmemset(&sa_in, 0, sizeof(sa_in));tsa_in.sin_family = AF_INET;tsa_in.sin_port = htons(23);thostentptr = gethostbyname(&scc_ptr->modem_cmd_str[0]);tif(hostentptr == 0) {#ifdef _WIN32ttfatal_printf(""Lookup host %s failed"",tttttt&scc_ptr->modem_cmd_str[0]);#elsettfatal_printf(""Lookup host %s failed, herrno: %d"",ttttt&scc_ptr->modem_cmd_str[0], h_errno);#endifttclose(sockfd);ttscc_socket_close(port, 1, dcycs);ttx_show_alert(0, 0);ttreturn;t}tmemcpy(&sa_in.sin_addr.s_addr, hostentptr->h_addr,ttttttthostentptr->h_length);t t tret = connect(sockfd, (struct sockaddr *)&sa_in, sizeof(sa_in));tif(ret < 0) {ttprintf(""connect ret: %d, errno: %d"", ret, errno);ttclose(sockfd);ttscc_socket_close(port, 1, dcycs);ttreturn;t}tscc_socket_modem_connect(port, dcycs);tscc_ptr->dcd = 1;tt tscc_ptr->socket_state = 1;t tscc_ptr->socket_num_rings = 0;tprintf(""SCC port %d is now outgoing to %s"", port,tttttt&scc_ptr->modem_cmd_str[0]);tscc_ptr->sockfd = sockfd;tscc_ptr->state = 1;tt tscc_socket_make_nonblock(port, dcycs);tscc_ptr->rdwrfd = scc_ptr->sockfd;}",2,"cwe120,cwe469"
"gf100_gr_trap_mp(struct gf100_gr *gr, int gpc, int tpc){tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;tstruct nvkm_device *device = subdev->device;tu32 werr = nvkm_rd32(device, TPC_UNIT(gpc, tpc, 0x648));tu32 gerr = nvkm_rd32(device, TPC_UNIT(gpc, tpc, 0x650));tconst struct nvkm_enum *warp;tchar glob[128];tnvkm_snprintbf(glob, sizeof(glob), gf100_mp_global_error, gerr);twarp = nvkm_enum_find(gf100_mp_warp_error, werr & 0xffff);tnvkm_error(subdev, ""GPC%i/TPC%i/MP trap: ""ttt   ""global %08x [%s] warp %04x [%s]"",tt   gpc, tpc, gerr, glob, werr, warp ? warp->name : """");tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x648), 0x00000000);tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x650), gerr);}",2,"cwe119,cwe120"
"readData(t_Data *ptData, t_Params *ptParams){  FILE *ifp = NULL;  char szLine[MAX_LINE_LENGTH];  int  nPos = 0, i = 0, j = 0, nSequences = 0;  char *szBrk;    char *szRet;     ptData->nSeq    = 0;  ptData->nMaxLen = 0;    ifp = fopen(ptParams->szInputFile, ""r"");  if(ifp){    while(fgets(szLine, MAX_LINE_LENGTH, ifp)){      if(szLine[0] == '>'){tif(nPos > ptData->nMaxLen){t  ptData->nMaxLen = nPos;t}ttptData->nSeq++;tnPos = 0;      }      else{t tif(! ptData->nSeq)t{t    fprintf(stderr, ""File %s does not appear to be in FASTA format."", ptParams->szInputFile);t    exit(EXIT_FAILURE);t}ti = 0;twhile(strrchr(szSequence,szLine[i]) != NULL){t  i++;t  nPos++;t}      }    }         if(nPos > ptData->nMaxLen){      ptData->nMaxLen = nPos;    }    fclose(ifp);  }  else{    fprintf(stderr, ""Can't open input file %s"", ptParams->szInputFile);    exit(EXIT_FAILURE);  }  ptData->aszID        = (char **) malloc(ptData->nSeq*sizeof(char *));  ptData->aacSequences = (char **) malloc(ptData->nSeq*sizeof(char *));  ptData->anLen        = (int *)   malloc(ptData->nSeq*sizeof(int));  ifp = fopen(ptParams->szInputFile, ""r"");  if(ifp){    while(szRet = fgets(szLine, MAX_LINE_LENGTH, ifp)){      if(szLine[0] == '>'){tif(nSequences > 0){t  ptData->anLen[nSequences - 1] = nPos;t}tptData->aacSequences[nSequences] = (char *) malloc(ptData->nMaxLen*sizeof(char));tszBrk = strpbrk(szLine, "" "");t(*szBrk) = '0';tptData->aszID[nSequences] = strdup(szLine + 1);tnPos = 0;tnSequences++;      }          i = 0;      while(szLine[i] != '0' && strrchr(szSequence,szLine[i]) != NULL){tptData->aacSequences[nSequences - 1][nPos] = szLine[i];tnPos++; i++;      }    }    ptData->anLen[nSequences - 1] = nPos;    fclose(ifp);  }  else{    fprintf(stderr, ""Can't open input file %s"", ptParams->szInputFile);    exit(EXIT_FAILURE);  }}",5,"cwe119,cwe120,cwe476,cwe469,cweother"
"showmsgrfc2369_header(struct msg2html_info *info, const char *p){tstructtrfc822t *rfcp;tstruct  rfc822a *rfca;tintti;tstruct showmsgrfc2369_buflist *buflist=NULL;trfcp=rfc822t_alloc_new(p, NULL, NULL);tif (!rfcp)ttreturn;trfca=rfc822a_alloc(rfcp);tif (!rfca)t{ttrfc822t_free(rfcp);ttreturn;t}tfor (i=0; i<rfca->naddrs; i++)t{ttchart*p=rfc822_getaddr(rfca, i);ttchart*q=info->get_textlink ?ttt(*info->get_textlink)(p, info->arg):NULL;ttstruct showmsgrfc2369_buflist *next;ttif (q)tt{tttnext=malloc(sizeof(struct showmsgrfc2369_buflist));tttif (!next)ttt{ttttfree(q);ttttq=NULL;ttt}tttelsettt{ttttnext->next=buflist;ttttbuflist=next;ttttnext->p=q;ttt}tt}ttif (q && rfca->addrs[i].tokens)tt{tttrfca->addrs[i].tokens->token=0;tttif (*q)ttttfree(p);tttelsettt{tttstructtbuf b;ttttbuf_init(&b);ttttfree(q);ttttfor (q=p; *q; q++)tttt{ttttchartc[2];tttttswitch (*q)t{tttttcase '<':ttttttbuf_cat(&b, ""&lt;"");ttttttbreak;tttttcase '>':ttttttbuf_cat(&b, ""&gt;"");ttttttbreak;tttttcase '&':ttttttbuf_cat(&b, ""&amp;"");ttttttbreak;tttttcase ' ':ttttttbuf_cat(&b, ""&nbsp;"");ttttttbreak;tttttdefault:ttttttc[1]=0;ttttttc[0]=*q;ttttttbuf_cat(&b, c);ttttttbreak;ttttt}tttt}ttttfree(p);ttttq=strdup(b.ptr ? b.ptr:"""");ttttbuf_free(&b);ttttnext->p=q;ttt}tttrfca->addrs[i].tokens->ptr=q;tttrfca->addrs[i].tokens->len=q ? strlen(q):0;tttrfca->addrs[i].tokens->next=0;tt}ttelsetttfree(p);t}trfc822_print(rfca, showrfc2369_printheader,ttttshowaddressheader_printsep_plain, NULL);twhile (buflist)t{ttstruct showmsgrfc2369_buflist *next=buflist;ttbuflist=next->next;ttfree(next->p);ttfree(next);t}trfc822a_free(rfca);trfc822t_free(rfcp);}",2,"cwe119,cwe120"
"setkey_private(struct sched *sp, const char *key){    register int    i, j, k;    int             t;         for (i = 0; i < 28; i++) {        sp->C[i] = key[PC1_C[i] - 1];        sp->D[i] = key[PC1_D[i] - 1];    }         for (i = 0; i < 16; i++) {                 for (k = 0; k < shifts[i]; k++) {            t = sp->C[0];            for (j = 0; j < 28 - 1; j++)                sp->C[j] = sp->C[j + 1];            sp->C[27] = t;            t = sp->D[0];            for (j = 0; j < 28 - 1; j++)                sp->D[j] = sp->D[j + 1];            sp->D[27] = t;        }                 for (j = 0; j < 24; j++) {            sp->KS[i][j] = sp->C[PC2_C[j] - 1];            sp->KS[i][j + 24] = sp->D[PC2_D[j] - 28 - 1];        }    }    for (i = 0; i < 48; i++)        sp->E[i] = e[i];}",2,"cwe119,cwe120"
"dumbfile_getnc(char *ptr, long n, DUMBFILE *f){tlong rv;tASSERT(f);tASSERT(n >= 0);tif (f->pos < 0)ttreturn -1;tif (f->dfs->getnc) {ttrv = (*f->dfs->getnc)(ptr, n, f->file);ttif (rv < n) {tttf->pos = -1;tttreturn MAX(rv, 0);tt}t} else {ttfor (rv = 0; rv < n; rv++) {tttint c = (*f->dfs->getc)(f->file);tttif (c < 0) {ttttf->pos = -1;ttttreturn rv;ttt}ttt*ptr++ = c;tt}t}tf->pos += rv;treturn rv;}",2,"cwe120,cweother"
"cl_int_chk(struct clause *c){  struct literal *lit;  printf(""checking clause, address:%p "" , (void *) c);  print_clause(stdout, c);  lit = c->first_lit;  while (lit) {    printf(""    literal, address:%p sign:%d type:%d; atom:"", (void *) lit, lit->sign, lit->atom->varnum);    print_term(stdout, lit->atom); printf("""");    printf(""    cont_cl:%p, atom container:%p"", (void *) lit->container, (void *) lit->atom->occ.lit);    lit = lit->next_lit;  }}",2,"cwe119,cwe120"
"""ReadFromPty2( UInt stream, Char *buf, Int maxlen, UInt block){  /* read at most maxlen bytes from stream, into buf.    If block is non-zero then wait for at least one byte    to be available. Otherwise don't. Return the number of    bytes read, or -1 for error. A blocking return having read zero bytes    definitely indicates an end of file */  Int nread = 0;  int ret;    while (maxlen > 0)    {#if HAVE_SELECT      if (!block || nread > 0)      {        fd_set set;        struct timeval tv;        do {          FD_ZERO( &set);          FD_SET( PtyIOStreams[stream].ptyFD, &set );          tv.tv_sec = 0;          tv.tv_usec = 0;          ret =  select( PtyIOStreams[stream].ptyFD + 1, &set, NULL, NULL, &tv);        } while (ret == -1 && errno == EAGAIN);        if (ret == -1 && nread == 0)          return -1;        if (ret < 1)          return nread ? nread : -1;      }#endif      do {        ret = read(PtyIOStreams[stream].ptyFD, buf, maxlen);      } while (ret == -1 && errno == EAGAIN);      if (ret == -1 && nread == 0)        return -1;      if (ret < 1)        return nread;      nread += ret;      buf += ret;      maxlen -= ret;    }  return nread;}""",2,"cwe120,cweother"
"LoadDefaultCollection(default_collection_t *collection){    default_t *def;    FILE *f;    char defname[80];    char strparm[100];    char *s;    int intparm;         f = fopen(collection->filename, ""r"");    if (f == NULL)    {                          return;    }        while (!feof(f))    {        if (fscanf (f, ""%79s %[^]"", defname, strparm) != 2)        {                                   continue;        }                          while (strlen(strparm) > 0 && !isprint(strparm[strlen(strparm)-1]))        {            strparm[strlen(strparm)-1] = '0';        }                                def = SearchCollection(collection, defname);        if (def == NULL || !def->bound)        {                                      continue;        }                 switch (def->type)        {            case DEFAULT_STRING:                s = strdup(strparm + 1);                s[strlen(s) - 1] = '0';                * (char **) def->location = s;                break;            case DEFAULT_INT:            case DEFAULT_INT_HEX:                * (int *) def->location = ParseIntParameter(strparm);                break;            case DEFAULT_KEY:                                                  intparm = ParseIntParameter(strparm);                def->untranslated = intparm;                if (intparm >= 0 && intparm < 128)                {                    intparm = scantokey[intparm];                }                else                {                    intparm = 0;                }                def->original_translated = intparm;                * (int *) def->location = intparm;                break;            case DEFAULT_FLOAT:                * (float *) def->location = (float) atof(strparm);                break;        }    }                fclose (f);}",3,"cwe119,cwe120,cweother"
"__ecereDestructor___ecereNameSpace__ecere__ConnectionsHolder(struct __ecereNameSpace__ecere__com__Instance * this){struct __ecereNameSpace__ecere__ConnectionsHolder * __ecerePointer___ecereNameSpace__ecere__ConnectionsHolder = (struct __ecereNameSpace__ecere__ConnectionsHolder *)(this ? (((char *)this) + __ecereClass___ecereNameSpace__ecere__ConnectionsHolder->offset) : 0);{struct __ecereNameSpace__ecere__com__Instance * c;while((c = (__extension__ ({struct __ecereNameSpace__ecere__com__Iterator __internalIterator = {__ecerePointer___ecereNameSpace__ecere__ConnectionsHolder->connections, 0};__ecereMethod___ecereNameSpace__ecere__com__Iterator_Index(&__internalIterator, (uint64)(((uint64)(0))), 0x0);((struct __ecereNameSpace__ecere__com__Instance *)__ecereProp___ecereNameSpace__ecere__com__Iterator_Get_data(&__internalIterator));}))))(__ecereNameSpace__ecere__com__eInstance_DecRef(c), c = 0);}(__ecereNameSpace__ecere__com__eInstance_DecRef(__ecerePointer___ecereNameSpace__ecere__ConnectionsHolder->connections), __ecerePointer___ecereNameSpace__ecere__ConnectionsHolder->connections = 0);}",3,"cwe119,cwe120,cwe476"
"read_header(const char *path, struct bundle_header *header) {tchar buffer[1024];tint fd = open(path, O_RDONLY);tif (fd < 0)ttreturn error(""could not open '%s'"", path);tif (read_string(fd, buffer, sizeof(buffer)) < 0 ||tttstrcmp(buffer, bundle_signature)) {ttclose(fd);ttreturn error(""'%s' does not look like a v2 bundle file"", path);t}twhile (read_string(fd, buffer, sizeof(buffer)) > 0ttt&& buffer[0] != '') {ttint is_prereq = buffer[0] == '-';ttint offset = is_prereq ? 1 : 0;ttint len = strlen(buffer);ttunsigned char sha1[20];ttstruct ref_list *list = is_prereq ? &header->prerequisitesttt: &header->references;ttchar delim;ttif (buffer[len - 1] == '')tttbuffer[len - 1] = '0';ttif (get_sha1_hex(buffer + offset, sha1)) {tttwarning(""unrecognized header: %s"", buffer);tttcontinue;tt}ttdelim = buffer[40 + offset];ttif (!isspace(delim) && (delim != '0' || !is_prereq))tttdie (""invalid header: %s"", buffer);ttadd_to_ref_list(sha1, isspace(delim) ?ttttbuffer + 41 + offset : """", list);t}treturn fd;}",3,"cwe119,cwe120,cweother"
"sighandler( int signum){tssize_t unused;    int card=0;    signal( signum, sighandler );    if( signum == SIGUSR1 )    {ttunused = read( G.cd_pipe[0], &card, sizeof(int) );        if(G.freqoption)            unused = read( G.ch_pipe[0], &(G.frequency[card]), sizeof( int ) );        else            unused = read( G.ch_pipe[0], &(G.channel[card]), sizeof( int ) );    }    if( signum == SIGUSR2 )        unused = read( G.gc_pipe[0], &G.gps_loc, sizeof( float ) * 5 );    if( signum == SIGINT || signum == SIGTERM )    {treset_term();        alarm( 1 );        G.do_exit = 1;        signal( SIGALRM, sighandler );        printf( """" );    }    if( signum == SIGSEGV )    {        fprintf( stderr, ""Caught signal 11 (SIGSEGV). Please""                         "" contact the author!33[?25h"" );        fflush( stdout );        exit( 1 );    }    if( signum == SIGALRM )    {        fprintf( stderr, ""Caught signal 14 (SIGALRM). Please""                         "" contact the author!33[?25h"" );        fflush( stdout );        exit( 1 );    }    if( signum == SIGCHLD )        wait( NULL );    if( signum == SIGWINCH )    {        fprintf( stderr, ""33[2J"" );        fflush( stdout );    }}",2,"cwe120,cweother"
"main(int argc, char *argv[]){    int i;    int nkeys;    struct pma *pma;    key_t *values;    srandom(10);    for (nkeys=(1<<8); nkeys <= MAX_KEYS; nkeys <<= 1)    {        pma = pma_new(nkeys);        values = malloc(nkeys * sizeof(key_t));        for (i=0; i < nkeys; i++)        {            values[i] = random() % 1000;            if (values[i] == 0) {                i--;                continue;            }            pma_insert(pma, values[i]);                     }        fprintf(stderr, ""%d keys"", nkeys);        permute_array(values, nkeys);        u64 search_time = runprof(pma, values, nkeys, NTRIALS);        printf(""%d %g"", nkeys,                search_time / 1000000.);        fflush(stdout);        pma_free(pma);    }    return 0;}",2,"cwe120,cweother"
"Unpickler_traverse(UnpicklerObject *self, visitproc visit, void *arg){    Py_VISIT(self->readline);    Py_VISIT(self->read);    Py_VISIT(self->peek);    Py_VISIT(self->stack);    Py_VISIT(self->pers_func);    return 0;}",2,"cwe120,cweother"
"rend_mid_establish_rendezvous(or_circuit_t *circ, const uint8_t *request,                              size_t request_len){  char hexid[9];  int reason = END_CIRC_REASON_TORPROTOCOL;  log_info(LD_REND, ""Received an ESTABLISH_RENDEZVOUS request on circuit %d"",           circ->p_circ_id);  if (circ->_base.purpose != CIRCUIT_PURPOSE_OR || circ->_base.n_conn) {    log_warn(LD_PROTOCOL,             ""Tried to establish rendezvous on non-OR or non-edge circuit."");    goto err;  }  if (request_len != REND_COOKIE_LEN) {    log_warn(LD_PROTOCOL, ""Invalid length on ESTABLISH_RENDEZVOUS."");    goto err;  }  if (circuit_get_rendezvous((char*)request)) {    log_warn(LD_PROTOCOL,             ""Duplicate rendezvous cookie in ESTABLISH_RENDEZVOUS."");    goto err;  }     if (relay_send_command_from_edge(0,TO_CIRCUIT(circ),                                   RELAY_COMMAND_RENDEZVOUS_ESTABLISHED,                                   """", 0, NULL)<0) {    log_warn(LD_PROTOCOL, ""Couldn't send RENDEZVOUS_ESTABLISHED cell."");    reason = END_CIRC_REASON_INTERNAL;    goto err;  }  circuit_change_purpose(TO_CIRCUIT(circ), CIRCUIT_PURPOSE_REND_POINT_WAITING);  memcpy(circ->rend_token, request, REND_COOKIE_LEN);  base16_encode(hexid,9,(char*)request,4);  log_info(LD_REND,           ""Established rendezvous point on circuit %d for cookie %s"",           circ->p_circ_id, hexid);  return 0; err:  circuit_mark_for_close(TO_CIRCUIT(circ), reason);  return -1;}",2,"cwe119,cwe120"
"show_debug_helper(int fd, const char *context, const char *exten, struct dialplan_counters *dpc, struct ast_include *rinclude, int includecount, const char *includes[]){tstruct ast_context *c = NULL;tint res = 0, old_total_exten = dpc->total_exten;tast_cli(fd,""     In-mem exten Trie for Fast Extension Pattern Matching:"");tast_cli(fd,""           Explanation: Node Contents Format = <char(s) to match>:<pattern?>:<specif>:[matched extension]"");tast_cli(fd,    ""                        Where <char(s) to match> is a set of chars, any one of which should match the current character"");tast_cli(fd,    ""                              <pattern?>: Y if this a pattern match (eg. _XZN[5-7]), N otherwise"");tast_cli(fd,    ""                              <specif>: an assigned 'exactness' number for this matching char. The lower the number, the more exact the match"");tast_cli(fd,    ""                              [matched exten]: If all chars matched to this point, which extension this matches. In form: EXTEN:<exten string>"");tast_cli(fd,    ""                        In general, you match a trie node to a string character, from left to right. All possible matching chars"");tast_cli(fd,    ""                        are in a string vertically, separated by an unbroken string of '+' characters."");tast_rdlock_contexts();t twhile ( (c = ast_walk_contexts(c)) ) {ttint context_info_printed = 0;ttif (context && strcmp(ast_get_context_name(c), context))tttcontinue;t ttdpc->context_existence = 1;ttif (!c->pattern_tree) {ttt tttast_exists_extension(NULL, c->name, ""s"", 1, """");  tt}ttast_rdlock_context(c);ttdpc->total_context++;ttast_cli(fd, ""[ Context '%s' created by '%s' ]"",tttast_get_context_name(c), ast_get_context_registrar(c));ttcontext_info_printed = 1;ttif (c->pattern_tree)tt{tttcli_match_char_tree(c->pattern_tree, "" "", fd);tt} else {tttast_cli(fd,""     No Pattern Trie present. Perhaps the context is empty...or there is trouble..."");tt}ttast_unlock_context(c);tt ttif (context_info_printed)tttast_cli(fd, """");t}tast_unlock_contexts();treturn (dpc->total_exten == old_total_exten) ? -1 : res;}",2,"cwe119,cwe120"
"MtxOrb_set_contrast (Driver *drvthis, int promille){tPrivateData *p = drvthis->private_data;tint real_contrast = (int) ((long) promille * 255 / 1000);t tif ((promille < 0) || (promille > 1000))ttreturn;t tp->contrast = promille;t tif (IS_LCD_DISPLAY || IS_LKD_DISPLAY) {ttunsigned char out[4] = { 'xFE', 'P', 0 };ttout[2] = (unsigned char) real_contrast;ttwrite(p->fd, out, 3);ttreport(RPT_DEBUG, ""%s: contrast set to %d"",ttttdrvthis->name, real_contrast);t} else {ttreport(RPT_DEBUG, ""%s: contrast not set to %d - not LCD or LKD display"",ttttdrvthis->name, real_contrast);t}}",2,"cwe119,cwe120"
"get_win_height(void){tstruct winsize win;t tint rows = 3600 * 24;tif (ioctl(STDOUT_FILENO, TIOCGWINSZ, &win) != -1) {ttif (win.ws_row > 2) {tttrows = win.ws_row - 2;tt}t}treturn rows;}",2,"cwe119,cwe120"
"dns_txt_packet(stralloc *out,const char *buf,unsigned int len){  unsigned int pos;  char header[12];  uint16 numanswers;  uint16 datalen;  char ch;  unsigned int txtlen;  int i;  if (!stralloc_copys(out,"""")) return -1;  pos = dns_packet_copy(buf,len,0,header,12); if (!pos) return -1;  uint16_unpack_big(header + 6,&numanswers);  pos = dns_packet_skipname(buf,len,pos); if (!pos) return -1;  pos += 4;  while (numanswers--) {    pos = dns_packet_skipname(buf,len,pos); if (!pos) return -1;    pos = dns_packet_copy(buf,len,pos,header,10); if (!pos) return -1;    uint16_unpack_big(header + 8,&datalen);    if (byte_equal(header,2,DNS_T_TXT))      if (byte_equal(header + 2,2,DNS_C_IN)) {tif (pos + datalen > len) { errno = EINVAL; return -1; }ttxtlen = 0;tfor (i = 0;i < datalen;++i) {t  ch = buf[pos + i];t  if (!txtlen)t    txtlen = (unsigned char) ch;t  else {t    --txtlen;t    if (ch < 32) ch = '?';t    if (ch > 126) ch = '?';t    if (!stralloc_append(out,&ch)) return -1;t  }t}      }    pos += datalen;  }  return 0;}",2,"cwe119,cwe120"
"IsITUFax(const Image* image){  size_t    profile_length;    const unsigned char    *profile;    MagickBool    status;    status=MagickFalse;  if ((profile=GetImageProfile(image,""APP1"",&profile_length)) &&      (profile_length >= 5))    {      if (profile[0] == 0x47 &&t  profile[1] == 0x33 &&t  profile[2] == 0x46 &&t  profile[3] == 0x41 &&t  profile[4] == 0x58)      status=MagickTrue;    }    return status;}",2,"cwe119,cwe120"
"uild_old_prefix(aClient *orig, char *imsg, aClient *dest,tchar *dname){tif (oldplen != 0)t{ttreturn;t}tif (dname == NULL)t{ttdname = dest->name;t}toldplen = sprintf(oldprefixbuf, "":%s %s %s"", orig->name, imsg, dname);tif (oldplen > maxplen)t{ttmaxplen = oldplen;t}}",2,"cwe120,cwe476"
"zd1201_set_multicast(struct net_device *dev){tstruct zd1201 *zd = netdev_priv(dev);tstruct netdev_hw_addr *ha;tunsigned char reqbuf[ETH_ALEN*ZD1201_MAXMULTI];tint i;tif (netdev_mc_count(dev) > ZD1201_MAXMULTI)ttreturn;ti = 0;tnetdev_for_each_mc_addr(ha, dev)ttmemcpy(reqbuf + i++ * ETH_ALEN, ha->addr, ETH_ALEN);tzd1201_setconfig(zd, ZD1201_RID_CNFGROUPADDRESS, reqbuf,ttt netdev_mc_count(dev) * ETH_ALEN, 0);}",2,"cwe119,cwe120"
"new_filename (const char* filename){ttime_t t = time (NULL);tint pid = process_id ();tchar pid_buf [16];tchar time_buf [16];tchar *res, *d;tconst char *p;tint count_dates = 0;tint count_pids = 0;tint s_date, s_pid;tstruct tm *ts;tfor (p = filename; *p; p++) {ttif (*p != '%')tttcontinue;ttp++;ttif (*p == 't')tttcount_dates++;ttelse if (*p == 'p')tttcount_pids++;ttelse if (*p == 0)tttbreak;t}tif (!count_dates && !count_pids)ttreturn pstrdup (filename);tsnprintf (pid_buf, sizeof (pid_buf), ""%d"", pid);tts = gmtime (&t);tsnprintf (time_buf, sizeof (time_buf), ""%d%02d%02d%02d%02d%02d"",tt1900 + ts->tm_year, 1 + ts->tm_mon, ts->tm_mday, ts->tm_hour, ts->tm_min, ts->tm_sec);ts_date = strlen (time_buf);ts_pid = strlen (pid_buf);td = res = (char *)malloc (strlen (filename) + s_date * count_dates + s_pid * count_pids);tfor (p = filename; *p; p++) {ttif (*p != '%') {ttt*d++ = *p;tttcontinue;tt}ttp++;ttif (*p == 't') {tttstrcpy (d, time_buf);tttd += s_date;tttcontinue;tt} else if (*p == 'p') {tttstrcpy (d, pid_buf);tttd += s_pid;tttcontinue;tt} else if (*p == '%') {ttt*d++ = '%';tttcontinue;tt} else if (*p == 0)tttbreak;tt*d++ = '%';tt*d++ = *p;t}t*d = 0;treturn res;}",2,"cwe119,cwe120"
"write_blockwise(int fd, const void *orig_buf, size_t count){tvoid *hangover_buf, *hangover_buf_base = NULL;tvoid *buf, *buf_base = NULL;tint r, hangover, solid, bsize, alignment;tssize_t ret = -1;tif ((bsize = sector_size(fd)) < 0)ttreturn bsize;thangover = count % bsize;tsolid = count - hangover;talignment = get_alignment(fd);tif ((long)orig_buf & (alignment - 1)) {ttbuf = aligned_malloc(&buf_base, count, alignment);ttif (!buf)tttgoto out;ttmemcpy(buf, orig_buf, count);t} elsettbuf = (void *)orig_buf;tr = write(fd, buf, solid);tif (r < 0 || r != solid)ttgoto out;tif (hangover) {tthangover_buf = aligned_malloc(&hangover_buf_base, bsize, alignment);ttif (!hangover_buf)tttgoto out;ttr = read(fd, hangover_buf, bsize);ttif(r < 0 || r != bsize) goto out;ttr = lseek(fd, -bsize, SEEK_CUR);ttif (r < 0)tttgoto out;ttmemcpy(hangover_buf, buf + solid, hangover);ttr = write(fd, hangover_buf, bsize);ttif(r < 0 || r != bsize) goto out;ttfree(hangover_buf_base);t}tret = count; out:tif (buf != orig_buf)ttfree(buf_base);treturn ret;}",2,"cwe120,cweother"
"slurm_cred_copy(slurm_cred_t *cred){tslurm_cred_t *rcred = NULL;txassert(cred != NULL);tslurm_mutex_lock(&cred->mutex);trcred = _slurm_cred_alloc();tslurm_mutex_lock(&rcred->mutex);txassert(rcred->magic == CRED_MAGIC);trcred->jobid  = cred->jobid;trcred->stepid = cred->stepid;trcred->uid    = cred->uid;trcred->job_gres_list  = gres_plugin_job_state_dup(cred->job_gres_list);trcred->step_gres_list = gres_plugin_step_state_dup(cred->step_gres_list);trcred->job_mem_limit  = cred->job_mem_limit;trcred->step_mem_limit = cred->step_mem_limit;trcred->step_hostlist  = xstrdup(cred->step_hostlist);#ifndef HAVE_BGtrcred->job_core_bitmap  = bit_copy(cred->job_core_bitmap);trcred->step_core_bitmap = bit_copy(cred->step_core_bitmap);trcred->core_array_size  = cred->core_array_size;trcred->cores_per_socket = xmalloc(sizeof(uint16_t) *ttttt  rcred->core_array_size);tmemcpy(rcred->cores_per_socket, cred->cores_per_socket,t       (sizeof(uint16_t) * rcred->core_array_size));trcred->sockets_per_node = xmalloc(sizeof(uint16_t) *ttttt  rcred->core_array_size);tmemcpy(rcred->sockets_per_node, cred->sockets_per_node,t       (sizeof(uint16_t) * rcred->core_array_size));tcred->sock_core_rep_count = xmalloc(sizeof(uint32_t) *ttttt    rcred->core_array_size);tmemcpy(rcred->sock_core_rep_count, cred->sock_core_rep_count,t       (sizeof(uint32_t) * rcred->core_array_size));trcred->job_nhosts = cred->job_nhosts;trcred->job_hostlist = xstrdup(cred->job_hostlist);#endiftrcred->ctime  = cred->ctime;trcred->siglen = cred->siglen;t trcred->signature = xstrdup(cred->signature);tslurm_mutex_unlock(&cred->mutex);tslurm_mutex_unlock(&rcred->mutex);treturn rcred;}",2,"cwe120,cweother"
"read_be_long(const PureDB * const db,                        const puredb_u32_t offset,                        puredb_u32_t * const result){    unsigned char mapoffsetbuf[4];            unsigned char *mapoffset;    #ifdef USE_MAPPED_IO    if (db->map != NULL) {        mapoffset = db->map + offset;            } else #endif    {        if (lseek(db->fd, offset, SEEK_SET) == (off_t) -1) {            return -1;        }                if (safe_read(db->fd, mapoffsetbuf, sizeof mapoffsetbuf) !=             (ssize_t) sizeof mapoffsetbuf) {            return -1;        }        mapoffset = mapoffsetbuf;    }    *result = mapoffset[0] << 24 | mapoffset[1] << 16 |         mapoffset[2] << 8 | mapoffset[3];        return 0;}",2,"cwe119,cwe120"
"""init_sasl(isieve_t *obj,t      int ssf,t      sasl_callback_t *callbacks){  static int sasl_started = 0;  int saslresult = SASL_OK;  sasl_security_properties_t *secprops=NULL;  socklen_t addrsize=sizeof(struct sockaddr_storage);  struct sockaddr_storage saddr_l, saddr_r;  char localip[60], remoteip[60];  /* attempt to start sasl */  if(!sasl_started) {      saslresult=sasl_client_init(NULL);      obj->conn = NULL;      sasl_started = 1;  }  /* Save the callbacks array */  obj->callbacks = callbacks;  if (saslresult!=SASL_OK) return -1;  addrsize=sizeof(struct sockaddr_storage);  if (getpeername(obj->sock,(struct sockaddr *)&saddr_r,&addrsize)!=0)      return -1;    addrsize=sizeof(struct sockaddr_storage);  if (getsockname(obj->sock,(struct sockaddr *)&saddr_l,&addrsize)!=0)      return -1;#if 0  /* XXX  The following line causes problems with KERBEROS_V4 decoding.   * We're not sure why its an issue, but this code isn't used in any of    * our other client code (imtest.c, backend.c), so we're removing it.   */  /* set the port manually since getsockname is stupid and doesn't */  ((struct sockaddr_in *)&saddr_l)->sin_port = htons(obj->port);#endif  if (iptostring((struct sockaddr *)&saddr_r, addrsize, remoteip, 60))      return -1;  if (iptostring((struct sockaddr *)&saddr_l, addrsize, localip, 60))      return -1;  if(obj->conn) sasl_dispose(&obj->conn);  /* client new connection */  saslresult=sasl_client_new(SIEVE_SERVICE_NAME,ttt     obj->serverFQDN,ttt     localip, remoteip,ttt     callbacks,ttt     SASL_SUCCESS_DATA,ttt     &obj->conn);  if (saslresult!=SASL_OK) return -1;  /* create a security structure and give it to sasl */  secprops = make_secprops(0, ssf);  if (secprops != NULL)  {    sasl_setprop(obj->conn, SASL_SEC_PROPS, secprops);    free(secprops);  }  return 0;}""",2,"cwe119,cwe120"
"proc_detach(VALUE obj, VALUE pid){    rb_secure(2);    return rb_detach_process(NUM2INT(pid));}",2,"cwe120,cweother"
"""restdamage(int fd, bool ghostly){    int counter;    struct damage *tmp_dam;    mread(fd, (void *) &counter, sizeof(counter));    if (!counter)            return;    tmp_dam = (struct damage *)alloc(sizeof(struct damage));    while (--counter >= 0)    {        char damaged_shops[5], *shp = (char *)0;        mread(fd, (void *) tmp_dam, sizeof(*tmp_dam));        if (ghostly)                tmp_dam->when += (monstermoves - omoves);        strcpy(damaged_shops,               in_rooms(tmp_dam->place.x, tmp_dam->place.y, SHOPBASE));        if (u.uz.dlevel)        {            /* when restoring, there are two passes over the current             * level.  the first time, u.uz isn't set, so neither is             * shop_keeper().  just wait and process the damage on             * the second pass.             */            for (shp = damaged_shops; *shp; shp++)            {                struct monst *shkp = shop_keeper(*shp);                if (shkp && inhishop(shkp) &&                    repair_damage(shkp, tmp_dam, true))                        break;            }        }        if (!shp || !*shp)        {            tmp_dam->next = level.damagelist;            level.damagelist = tmp_dam;            tmp_dam = (struct damage *)alloc(sizeof(*tmp_dam));        }    }    free((void *)tmp_dam);}""",2,"cwe119,cwe120"
"xsh_nod_rectify_and_shift_with_key(const char* nod_name,                                   const char* qual_name,                                   const char* rec_prefix,                                   cpl_frame* frame2D,                                   cpl_frame* order_tab_edges,                                   cpl_frame* wave_tab,                                   cpl_frame* model_config_frame,                                   cpl_frame* spectral_format,                                   cpl_frame* disp_tab_frame,                                   xsh_instrument* instrument,                                   const int corr_sky,                                   xsh_rectify_param *rectify_par,tttt   double** ref_ra,tttt   double** ref_dec,                                   cpl_frame **shift2_frame,                                   cpl_frame **shift1_frame){      char file_name[256];   cpl_frame * rec2_frame = NULL ;     cpl_frame * rec2eso_frame = NULL ;   cpl_frame * rec2tab_frame = NULL ;   cpl_frame *shift2eso_frame = NULL;   cpl_frame * rec1_frame = NULL ;   cpl_frame *shift1eso_frame = NULL;   cpl_frame * rec2_frame_median_correct=NULL;       sprintf(file_name,""REC2_%s_%s"",qual_name,nod_name);   check(rec2_frame = xsh_rectify( frame2D,order_tab_edges,                                   wave_tab,model_config_frame,instrument,                                    rectify_par,spectral_format,disp_tab_frame,                                   file_name,&rec2eso_frame,&rec2tab_frame,                                   rec_prefix));   xsh_add_temporary_file(file_name);   sprintf(file_name,""SHIFT2_%s_%s"",qual_name,nod_name);   if(corr_sky) {     rec2_frame_median_correct=xsh_nod_median_correct_list_per_wavelength(rec2_frame,instrument);        check( *shift2_frame = shift_with_kw( rec2_frame_median_correct, instrument,rectify_par,ttttt   file_name, &shift2eso_frame, ttttt   ref_ra,ref_dec, 0));     xsh_add_temporary_file(file_name);     sprintf(file_name,""REC1_FAST_%s_%s"",qual_name,nod_name);     check( rec1_frame = xsh_rec_list_frame_invert( rec2_frame_median_correct, file_name,tttttt    instrument));     xsh_add_temporary_file(cpl_frame_get_filename(rec1_frame));   } else {     check( *shift2_frame = shift_with_kw( rec2_frame, instrument,rectify_par,ttttt   file_name, &shift2eso_frame, ttttt   ref_ra,ref_dec, 0));     xsh_add_temporary_file(file_name);     sprintf(file_name,""REC1_FAST_%s_%s"",qual_name,nod_name);     check( rec1_frame = xsh_rec_list_frame_invert( rec2_frame, file_name,tttttt    instrument));     xsh_add_temporary_file(cpl_frame_get_filename(rec1_frame));   }   sprintf(file_name,""SHIFT1_FAST_%s_%s"",qual_name,nod_name);   check( *shift1_frame = shift_with_kw( rec1_frame, instrument,                                        rectify_par, file_name,                                         &shift1eso_frame, ref_ra,                                        ref_dec, 1));   xsh_add_temporary_file(file_name);  cleanup:    xsh_free_frame( &rec1_frame);    xsh_free_frame( &rec2_frame);    xsh_free_frame( &shift1eso_frame);    xsh_free_frame( &shift2eso_frame);    xsh_free_frame( &rec2eso_frame);    xsh_free_frame( &rec2tab_frame);    xsh_free_frame( &rec2_frame_median_correct);   return cpl_error_get_code();}",2,"cwe119,cwe120"
"NSC_SetPIN(CK_SESSION_HANDLE hSession, CK_CHAR_PTR pOldPin,    CK_ULONG ulOldLen, CK_CHAR_PTR pNewPin, CK_ULONG ulNewLen){    SFTKSession *sp = NULL;    SFTKSlot *slot;    SFTKDBHandle *handle = NULL;    char newPinStr[SFTK_MAX_PIN+1],oldPinStr[SFTK_MAX_PIN+1];    SECStatus rv;    CK_RV crv = CKR_SESSION_HANDLE_INVALID;    PRBool tokenRemoved = PR_FALSE;    CHECK_FORK();        sp = sftk_SessionFromHandle(hSession);    if (sp == NULL) {tgoto loser;    }    slot = sftk_SlotFromSession(sp);    if (!slot) {tgoto loser;    }    handle = sftk_getKeyDB(slot);    if (handle == NULL) {tsftk_FreeSession(sp);treturn CKR_PIN_LEN_RANGE;      }    if (slot->needLogin && sp->info.state != CKS_RW_USER_FUNCTIONS) {tcrv = CKR_USER_NOT_LOGGED_IN;tgoto loser;    }    sftk_FreeSession(sp);    sp = NULL;         if ((ulNewLen > SFTK_MAX_PIN) || (ulOldLen > SFTK_MAX_PIN)) {tcrv = CKR_PIN_LEN_RANGE;tgoto loser;    }    if (ulNewLen < (CK_ULONG)slot->minimumPinLen) {tcrv = CKR_PIN_LEN_RANGE;tgoto loser;    }         PORT_Memcpy(newPinStr,pNewPin,ulNewLen);    newPinStr[ulNewLen] = 0;     PORT_Memcpy(oldPinStr,pOldPin,ulOldLen);    oldPinStr[ulOldLen] = 0;          PR_Lock(slot->pwCheckLock);    rv = sftkdb_ChangePassword(handle, oldPinStr, newPinStr, &tokenRemoved);    if (tokenRemoved) {tsftk_CloseAllSessions(slot, PR_FALSE);    }    if ((rv != SECSuccess) && (slot->slotID == FIPS_SLOT_ID)) {tPR_Sleep(loginWaitTime);    }    PR_Unlock(slot->pwCheckLock);         if (rv == SECSuccess) {tslot->needLogin = (PRBool)(ulNewLen != 0);                 if (ulNewLen == 0) {            PRBool tokenRemoved = PR_FALSE;            PZ_Lock(slot->slotLock);            slot->isLoggedIn = PR_FALSE;            slot->ssoLoggedIn = PR_FALSE;            PZ_Unlock(slot->slotLock);            rv = sftkdb_CheckPassword(handle, """", &tokenRemoved);            if (tokenRemoved) {                sftk_CloseAllSessions(slot, PR_FALSE);            }        }        sftk_update_all_states(slot);        sftk_freeDB(handle);treturn CKR_OK;    }    crv = CKR_PIN_INCORRECT;loser:    if (sp) {tsftk_FreeSession(sp);    }    if (handle) {tsftk_freeDB(handle);    }    return crv;}",2,"cwe119,cwe120"
"sell_pack(void){    object *obj;    short row = 2, val;    char buf[80];    obj = rogue.pack.next_object;    clear();    mvaddstr_rogue(1, 0, mesg[198]);    while (obj) {tif (obj->what_is != FOOD) {t    obj->identified = 1;t    val = get_value(obj);t    rogue.gold += val;t    if (row < ROGUE_LINES) {ttsprintf(buf, ""%5d      "", val);ttget_desc(obj, buf + 11, 1);ttmvaddstr_rogue(row++, 0, buf);t    }t}tobj = obj->next_object;    }    refresh();    if (rogue.gold > MAX_GOLD) {trogue.gold = MAX_GOLD;    }    message("""", 0);}",2,"cwe119,cwe120"
"_dxf_gi_OpenFile(char *name, FILE **fp, int infofile){  int i;  char *outname, *f;  static char infopath[256];t       outname = NULL;  if (!infofile && (strlen(infopath) > 0)) {      if (!(*fp = _dxfopen_dxfile(name,infopath,&outname,"".general"")))t goto error;  }  else{      if (!(*fp = _dxfopen_dxfile(name,NULL,&outname,"".general"")))t goto error;             if (infofile) {tif (strchr(outname,'/'))  {t    strcpy(infopath,outname);t    for (i=strlen(outname)-1 ; i>=0 ; i--) {ttif (infopath[i] == '/') {tt    infopath[i+1] = '0';tt    break;ttt}t    }t} elset    infopath[0] = '0';      }    }   DXFree(outname);   return OK;error:  if (outname) DXFree(outname);  infopath[0] = '0';  if (infofile)tf = ""general import file"";  elsetf = ""data file"";  DXSetError(ERROR_BAD_PARAMETER, ""#10903"", f, name);  return ERROR;}",2,"cwe119,cwe120"
"do_disk_statistics(cputime_t itv){tFILE *fp;tint rc;tint i = 0;tchar buf[128];tunsigned major, minor;tunsigned long wr_ops, dummy;  tunsigned long long rd_sec_or_wr_ops;tunsigned long long rd_sec_or_dummy, wr_sec_or_dummy, wr_sec;tstruct stats_dev sd;tfp = xfopen_for_read(""/proc/diskstats"");t twhile (fgets(buf, sizeof(buf), fp)) {ttrc = sscanf(buf, ""%u %u %s %lu %llu %llu %llu %lu %lu %llu %lu %lu %lu %lu"",ttt&major, &minor, sd.dname, &sd.rd_ops,ttt&rd_sec_or_dummy, &rd_sec_or_wr_ops, &wr_sec_or_dummy,ttt&wr_ops, &dummy, &wr_sec, &dummy, &dummy, &dummy, &dummy);ttswitch (rc) {ttcase 14:tttsd.wr_ops = wr_ops;tttsd.rd_sectors = rd_sec_or_wr_ops;tttsd.wr_sectors = wr_sec;tttbreak;ttcase 7:tttsd.rd_sectors = rd_sec_or_dummy;tttsd.wr_ops = (unsigned long)rd_sec_or_wr_ops;tttsd.wr_sectors = wr_sec_or_dummy;tttbreak;ttdefault:tttbreak;tt}ttif (!G.devlist_i && !is_partition(sd.dname)) {ttt tttif (!G.show_all && !sd.rd_ops && !sd.wr_ops) {tttt ttttcontinue;ttt}tttprint_stats_dev_struct(&G.saved_stats_dev[i], &sd, itv);tttG.saved_stats_dev[i] = sd;ttti++;tt} else {ttt tttif (is_dev_in_dlist(sd.dname)) {tttt ttttprint_stats_dev_struct(&G.saved_stats_dev[i], &sd, itv);ttttG.saved_stats_dev[i] = sd;tttti++;ttt} elsettttcontinue;tt}t}tfclose(fp);}",3,"cwe119,cwe120,cweother"
"sms_assembly_store(struct sms_assembly *assembly,ttttstruct sms_assembly_node *node,ttttconst struct sms *sms, guint8 seq){tunsigned char buf[177];tint len;tchar straddr[25];tif (!assembly->imsi)ttreturn FALSE;tif (sms_assembly_encode_address(&node->addr, straddr) == FALSE)ttreturn FALSE;tlen = sms_serialize(buf, sms);tif (write_file(buf, len, SMS_BACKUP_MODE,ttttSMS_BACKUP_PATH_FILE, assembly->imsi, straddr,ttttnode->ref, node->max_fragments, seq) != len)ttreturn FALSE;treturn TRUE;}",2,"cwe119,cwe120"
"get_nsldapagt_pid(pid_t *pid){   char *SLAPD_ROOT;   char path[PATH_MAX];   FILE *fp;   *pid = -1;   SLAPD_ROOT = ds_get_instance_dir();   PR_snprintf(path, sizeof(path), ""%s/logs/%s"", SLAPD_ROOT, NSLDAPAGT_PID);   if (!ds_file_exists(path)) {      return(-1);   }   if ((fp = fopen(path, ""r"")) != (FILE *) NULL) {      if ((fscanf(fp, ""%d"", (int *) pid)) != -1) {t    (void) fclose(fp);t    return(0);      }      (void) fclose(fp);   }   return(-1);}",3,"cwe119,cwe120,cweother"
"_ilist_cb_selected(void *data){   E_Config_Dialog_Data *cfdata;   const char *cur_profile;   unsigned char v;   Efreet_Desktop *desk = NULL;   char *pdir, buf[PATH_MAX];   const char *name;   cfdata = data;   if (!cfdata) return;   cur_profile = e_config_profile_get();   v = (strcmp(cur_profile, cfdata->sel_profile) == 0);   e_widget_disabled_set(cfdata->o_delete, v);   e_config_dialog_changed_set(cfdata->cfd, !v);   pdir = e_config_profile_dir_get(cfdata->sel_profile);   snprintf(buf, sizeof(buf), ""%s/profile.desktop"", pdir);   desk = efreet_desktop_new(buf);   if (desk)     {                 e_prefix_data_snprintf(buf, sizeof(buf), ""data/config/%s/"", e_config_profile_get());        if (ecore_file_is_dir(buf))          e_widget_disabled_set(cfdata->o_reset, 0);        else          e_widget_disabled_set(cfdata->o_reset, 1);     }   else     {        e_prefix_data_snprintf(buf, sizeof(buf), ""data/config/%s/"", cfdata->sel_profile);        if (ecore_file_is_dir(buf))          e_widget_disabled_set(cfdata->o_reset, 0);        else          e_widget_disabled_set(cfdata->o_reset, 1);        free(pdir);        pdir = strdup(buf);        if (pdir)          {             snprintf(buf, sizeof(buf), ""%s/profile.desktop"", pdir);             desk = efreet_desktop_new(buf);          }     }   if ((desk) && (desk->name))     name = desk->name;   else     name = cur_profile;   snprintf(buf, sizeof(buf), _(""Selected profile: %s""), name);   e_widget_label_text_set(cfdata->o_textlabel, buf);   if (desk)     e_widget_textblock_markup_set(cfdata->o_text, desk->comment);   else     e_widget_textblock_markup_set(cfdata->o_text, _(""Unknown""));   if (desk) efreet_desktop_free(desk);   free(pdir);}",2,"cwe119,cwe120"
"party_leave(object *op) {    char buf[MAX_BUF];    if (op->contr->party == NULL) {        return;    }    draw_ext_info_format(NDI_UNIQUE, 0, op, MSG_TYPE_COMMAND, MSG_TYPE_COMMAND_SUCCESS,                         ""You leave party %s."",                         op->contr->party->partyname);    snprintf(buf, sizeof(buf), ""%s leaves party %s."", op->name, op->contr->party->partyname);    party_send_message(op, buf);         if (op->contr->party != NULL) {        int party_found;        player *pl;        party_found = 0;        for (pl = first_player; pl != NULL; pl = pl->next) {            if (pl != op->contr && pl->party == op->contr->party) {                party_found = 1;                break;            }        }        if (!party_found)            party_remove(op->contr->party);    }    op->contr->party = NULL;}",2,"cwe119,cwe120"
"sgf_trace_semeai(const char *func, int str1, int str2, int move, tt int result1, int result2, const char *message){  char buf[100];  sprintf(buf, ""%s %c%d %c%d: "", func,t  J(str1) + 'A' + (J(str1) >= 8), board_size - I(str1),t  J(str2) + 'A' + (J(str2) >= 8), board_size - I(str2));    if (ON_BOARD(move))    sprintf(buf + strlen(buf), ""%s %s %c%d"",t    result_to_string(result1), result_to_string(result2),t    J(move) + 'A' + (J(move) >= 8), board_size - I(move));  else if (is_pass(move))    sprintf(buf + strlen(buf), ""%s %s PASS"",t    result_to_string(result1), result_to_string(result2));  else    sprintf(buf + strlen(buf), ""%s %s [%d]"",t    result_to_string(result1), result_to_string(result2),t    move);  if (message)    sprintf(buf + strlen(buf), "" (%s)"", message);    sgftreeAddComment(sgf_dumptree, buf);}",2,"cwe119,cwe120"
"ipaddrlabel_modify(int cmd, int argc, char **argv){tstruct {ttstruct nlmsghdr tn;ttstruct ifaddrlblmsgtifal;ttchar   tttbuf[1024];t} req;tinet_prefix prefix;tuint32_t label = 0xffffffffUL;tchar *p = NULL;tchar *l = NULL;        tmemset(&req, 0, sizeof(req));tmemset(&prefix, 0, sizeof(prefix));treq.n.nlmsg_type = cmd;treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifaddrlblmsg));treq.n.nlmsg_flags = NLM_F_REQUEST;treq.ifal.ifal_family = preferred_family;treq.ifal.ifal_prefixlen = 0;treq.ifal.ifal_index = 0;tif (cmd == RTM_NEWADDRLABEL) {ttreq.n.nlmsg_flags |= NLM_F_CREATE|NLM_F_EXCL;t}twhile (argc > 0) {ttif (strcmp(*argv, ""prefix"") == 0) {tttNEXT_ARG();tttp = *argv;tttget_prefix(&prefix, *argv, preferred_family);tt} else if (strcmp(*argv, ""dev"") == 0) {tttNEXT_ARG();tttif ((req.ifal.ifal_index = ll_name_to_index(*argv)) == 0)ttttinvarg(""dev is invalid"", *argv);tt} else if (strcmp(*argv, ""label"") == 0) {tttNEXT_ARG();tttl = *argv;tttif (get_u32(&label, *argv, 0) || label == 0xffffffffUL)ttttinvarg(""label is invalid"", *argv);tt}ttargc--;ttargv++;t}tif (p == NULL) {ttfprintf(stderr, ""Not enough information: ""prefix"" argument is required."");ttreturn -1;t}tif (l == NULL) {ttfprintf(stderr, ""Not enough information: ""label"" argument is required."");ttreturn -1;t}taddattr32(&req.n, sizeof(req), IFAL_LABEL, label);taddattr_l(&req.n, sizeof(req), IFAL_ADDRESS, &prefix.data, prefix.bytelen);treq.ifal.ifal_prefixlen = prefix.bitlen;tif (req.ifal.ifal_family == AF_UNSPEC)ttreq.ifal.ifal_family = AF_INET6;tif (rtnl_talk(&rth, &req.n, 0, 0, NULL) < 0)ttreturn 2;treturn 0;}",3,"cwe119,cwe120,cwe469"
"append_fd_suffix( const char * fn ){    size_t l = strlen( fn );    char *fname = fl_malloc( l + 4 );    strcpy( fname, fn );    if ( l < 3 || strcmp( fname + l - 3, "".fd"" ) )        strcat( fname, "".fd"" );    return fname;}",2,"cwe120,cwe469"
"nw_rewind(struct irs_nw *this) {tstruct pvt *pvt = (struct pvt *)this->private;ttif (pvt->fp) {ttif (fseek(pvt->fp, 0L, SEEK_SET) == 0)tttreturn;tt(void)fclose(pvt->fp);t}tif (!(pvt->fp = fopen(_PATH_NETWORKS, ""r"")))ttreturn;tif (fcntl(fileno(pvt->fp), F_SETFD, 1) < 0) {tt(void)fclose(pvt->fp);ttpvt->fp = NULL;t}}",2,"cwe120,cweother"
"repack_without_ref(const char *refname){tstruct ref_list *list, *packed_ref_list;tint fd;tint found = 0;tpacked_ref_list = get_packed_refs();tfor (list = packed_ref_list; list; list = list->next) {ttif (!strcmp(refname, list->name)) {tttfound = 1;tttbreak;tt}t}tif (!found)ttreturn 0;tfd = hold_lock_file_for_update(&packlock, git_path(""packed-refs""), 0);tif (fd < 0) {ttunable_to_lock_error(git_path(""packed-refs""), errno);ttreturn error(""cannot delete '%s' from packed refs"", refname);t}tfor (list = packed_ref_list; list; list = list->next) {ttchar line[PATH_MAX + 100];ttint len;ttif (!strcmp(refname, list->name))tttcontinue;ttlen = snprintf(line, sizeof(line), ""%s %s"",ttt       sha1_to_hex(list->sha1), list->name);tt ttif (len > sizeof(line))tttdie(""too long a refname '%s'"", list->name);ttwrite_or_die(fd, line, len);t}treturn commit_lock_file(&packlock);}",2,"cwe119,cwe120"
"insert_into_proxy_hash(REQUEST *request){tchar buf[128];tint rcode, tries;tvoid *proxy_listener;trad_assert(request->proxy != NULL);trad_assert(proxy_list != NULL);ttries = 1;retry:tPTHREAD_MUTEX_LOCK(&proxy_mutex);trcode = fr_packet_list_id_alloc(proxy_list,tttttrequest->home_server->proto,tttttrequest->proxy, &proxy_listener);trequest->num_proxied_requests = 1;trequest->num_proxied_responses = 0;tPTHREAD_MUTEX_UNLOCK(&proxy_mutex);ttif (!rcode) {#ifdef HAVE_PTHREAD_Httif (proxy_no_new_sockets) return 0;#endiftt ttif (!proxy_new_listener(request->home_server, 0)) {tttradlog(L_ERR, ""Failed to create a new socket for proxying requests."");tttreturn 0;tt}ttrequest->proxy->src_port = 0;  tttries++;ttif (tries > 2) {tttRDEBUG2(""ERROR: Failed allocating Id for new socket when proxying requests."");tttreturn 0;tt}ttttgoto retry;t}trequest->proxy_listener = proxy_listener;tPTHREAD_MUTEX_LOCK(&proxy_mutex);tif (!fr_packet_list_insert(proxy_list, &request->proxy)) {ttfr_packet_list_id_free(proxy_list, request->proxy);ttPTHREAD_MUTEX_UNLOCK(&proxy_mutex);ttradlog_request(L_PROXY, 0, request, ""Failed to insert entry into proxy list."");ttreturn 0;t}trequest->in_proxy_hash = TRUE;t tif (request->home_server) {ttrequest->home_server->currently_outstanding++;t}#ifdef WITH_TCPtrequest->proxy_listener->count++;#endiftPTHREAD_MUTEX_UNLOCK(&proxy_mutex);tRDEBUG3("" proxy: allocating destination %s port %d - Id %d"",t       inet_ntop(request->proxy->dst_ipaddr.af,ttt &request->proxy->dst_ipaddr.ipaddr, buf, sizeof(buf)),t       request->proxy->dst_port,t       request->proxy->id);treturn 1;}",3,"cwe119,cwe120,cweother"
"_AuSendClientPrefix (     AuServer *aud,     auConnClientPrefix *client,t      char *auth_proto,      char *auth_stringt      ){    int auth_length = client->nbytesAuthProto;    int auth_strlen = client->nbytesAuthString;    char padbuf[3];ttt     int pad;    struct iovec iovarray[5], *iov = iovarray;    int niov = 0;    int len = 0;#define add_to_iov(b,l)   { iov->iov_base = (b); iov->iov_len = (l); iov++, niov++; len += (l); }    add_to_iov ((caddr_t) client, SIZEOF(auConnClientPrefix));         if (auth_length > 0) {tadd_to_iov (auth_proto, auth_length);tpad = padlength [auth_length & 3];tif (pad) add_to_iov (padbuf, pad);    }    if (auth_strlen > 0) {tadd_to_iov (auth_string, auth_strlen);tpad = padlength [auth_strlen & 3];tif (pad) add_to_iov (padbuf, pad);    }#undef add_to_iov#ifndef _MINIX    len -= WritevToServer (aud->fd, iovarray, niov);#else    len -= MNX_WritevToServer (aud, iovarray, niov);#endif#if !defined(AMOEBA) && !defined(_MINIX) && !defined(WIN32)          #if defined(O_NONBLOCK) && (!defined(SCO) && !defined(ultrix) && !defined(hpux) && !defined(AIXV3) && !defined(uniosu))    (void) fcntl (aud->fd, F_SETFL, O_NONBLOCK);#else#ifdef FIOSNBIO    {tint arg = 1;tioctl (aud->fd, FIOSNBIO, &arg);    }#else#if (defined(AIXV3) || defined(uniosu)) && defined(FIONBIO)    {tint arg;targ = 1;tioctl(aud->fd, FIONBIO, &arg);    }#else    (void) fcntl (aud->fd, F_SETFL, FNDELAY);#endif#endif#endif#else  #ifdef _MINIX    {tint flags, r;tflags= fcntl(dpy->fd, F_GETFD);tif (flags == -1)t    return 0;tflags |= FD_ASYNCHIO;tr= fcntl(dpy->fd, F_SETFD, flags);tif (r == -1)t    return 0;    }#endif  #endif      return len == 0;}",2,"cwe119,cwe120"
"module_run(const CONF *cnf, char *name, char *value,tt      unsigned long flags)t{tCONF_MODULE *md;tint ret;tmd = module_find(name);t tif (!md && !(flags & CONF_MFLAGS_NO_DSO))ttmd = module_load_dso(cnf, name, value, flags);tif (!md)tt{ttif (!(flags & CONF_MFLAGS_SILENT))ttt{tttCONFerr(CONF_F_MODULE_RUN, CONF_R_UNKNOWN_MODULE_NAME);tttERR_add_error_data(2, ""module="", name);ttt}ttreturn -1;tt}tret = module_init(md, name, value, cnf);tif (ret <= 0)tt{ttif (!(flags & CONF_MFLAGS_SILENT))ttt{tttchar rcode[DECIMAL_SIZE(ret)+1];tttCONFerr(CONF_F_MODULE_RUN, CONF_R_MODULE_INITIALIZATION_ERROR);tttBIO_snprintf(rcode, sizeof rcode, ""%-8d"", ret);tttERR_add_error_data(6, ""module="", name, "", value="", value, "", retcode="", rcode);ttt}tt}treturn ret;t}",2,"cwe119,cwe120"
"register_characteristic(gpointer data, gpointer user_data){tstruct characteristic *chr = data;tDBusConnection *conn = chr->gatt->conn;tconst char *gatt_path = user_data;tchr->path = g_strdup_printf(""%s/characteristic%04x"", gatt_path,ttttttttchr->handle);tg_dbus_register_interface(conn, chr->path, CHAR_INTERFACE,tttttchar_methods, NULL, NULL, chr, NULL);tDBG(""Registered: %s"", chr->path);}",2,"cwe120,cweother"
"PKCS12_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,ttASN1_TYPE *param, const EVP_CIPHER *cipher, const EVP_MD *md, int en_de){tPBEPARAM *pbe;tint saltlen, iter, ret;tunsigned char *salt;tconst unsigned char *pbuf;tunsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];t tif (param == NULL || param->type != V_ASN1_SEQUENCE ||t    param->value.sequence == NULL) {ttPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN,PKCS12_R_DECODE_ERROR);ttreturn 0;t}tpbuf = param->value.sequence->data;tif (!(pbe = d2i_PBEPARAM(NULL, &pbuf, param->value.sequence->length))) {ttPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN,PKCS12_R_DECODE_ERROR);ttreturn 0;t}tif (!pbe->iter) iter = 1;telse iter = ASN1_INTEGER_get (pbe->iter);tsalt = pbe->salt->data;tsaltlen = pbe->salt->length;tif (!PKCS12_key_gen (pass, passlen, salt, saltlen, PKCS12_KEY_ID,ttt     iter, EVP_CIPHER_key_length(cipher), key, md)) {ttPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN,PKCS12_R_KEY_GEN_ERROR);ttPBEPARAM_free(pbe);ttreturn 0;t}tif (!PKCS12_key_gen (pass, passlen, salt, saltlen, PKCS12_IV_ID,ttttiter, EVP_CIPHER_iv_length(cipher), iv, md)) {ttPKCS12err(PKCS12_F_PKCS12_PBE_KEYIVGEN,PKCS12_R_IV_GEN_ERROR);ttPBEPARAM_free(pbe);ttreturn 0;t}tPBEPARAM_free(pbe);tret = EVP_CipherInit_ex(ctx, cipher, NULL, key, iv, en_de);tOPENSSL_cleanse(key, EVP_MAX_KEY_LENGTH);tOPENSSL_cleanse(iv, EVP_MAX_IV_LENGTH);treturn ret;}",2,"cwe119,cwe120"
"directory_get_from_hs_dir(const char *desc_id, const rend_data_t *rend_query){  smartlist_t *responsible_dirs = smartlist_new();  routerstatus_t *hs_dir;  char desc_id_base32[REND_DESC_ID_V2_LEN_BASE32 + 1];  time_t now = time(NULL);  char descriptor_cookie_base64[3*REND_DESC_COOKIE_LEN_BASE64];  int tor2web_mode = get_options()->Tor2webMode;  tor_assert(desc_id);  tor_assert(rend_query);     hid_serv_get_responsible_directories(responsible_dirs, desc_id);  base32_encode(desc_id_base32, sizeof(desc_id_base32),                desc_id, DIGEST_LEN);        directory_clean_last_hid_serv_requests(now);  SMARTLIST_FOREACH(responsible_dirs, routerstatus_t *, dir, {      time_t last = lookup_last_hid_serv_request(                            dir, desc_id_base32, rend_query, 0, 0);      const node_t *node = node_get_by_id(dir->identity_digest);      if (last + REND_HID_SERV_DIR_REQUERY_PERIOD >= now ||          !node || !node_has_descriptor(node))      SMARTLIST_DEL_CURRENT(responsible_dirs, dir);  });  hs_dir = smartlist_choose(responsible_dirs);  smartlist_free(responsible_dirs);  if (!hs_dir) {    log_info(LD_REND, ""Could not pick one of the responsible hidden ""                      ""service directories, because we requested them all ""                      ""recently without success."");    return 0;  }     lookup_last_hid_serv_request(hs_dir, desc_id_base32, rend_query, now, 1);     if (rend_query->auth_type != REND_NO_AUTH) {    if (base64_encode(descriptor_cookie_base64,                      sizeof(descriptor_cookie_base64),                      rend_query->descriptor_cookie, REND_DESC_COOKIE_LEN)<0) {      log_warn(LD_BUG, ""Could not base64-encode descriptor cookie."");      return 0;    }         descriptor_cookie_base64[strlen(descriptor_cookie_base64)-3] = '0';  } else {    strlcpy(descriptor_cookie_base64, ""(none)"",            sizeof(descriptor_cookie_base64));  }     directory_initiate_command_routerstatus_rend(hs_dir,                                          DIR_PURPOSE_FETCH_RENDDESC_V2,                                          ROUTER_PURPOSE_GENERAL,                                          !tor2web_mode, desc_id_base32,                                          NULL, 0, 0,                                          rend_query);  log_info(LD_REND, ""Sending fetch request for v2 descriptor for ""                    ""service '%s' with descriptor ID '%s', auth type %d, ""                    ""and descriptor cookie '%s' to hidden service ""                    ""directory %s"",           rend_query->onion_address, desc_id_base32,           rend_query->auth_type,           (rend_query->auth_type == REND_NO_AUTH ? ""[none]"" :            escaped_safe_str_client(descriptor_cookie_base64)),           routerstatus_describe(hs_dir));  return 1;}",2,"cwe119,cwe120"
"_range_compare(const void *a, const void *b) {tconst asn1cnst_range_t *ra = *(const asn1cnst_range_t * const *)a;tconst asn1cnst_range_t *rb = *(const asn1cnst_range_t * const *)b;tint ret;tret = _edge_compare(&ra->left, &rb->left);tif(!ret) {ttret = _edge_compare(&ra->right, &rb->right);t}treturn ret;}",3,"cwe119,cwe120,cweother"
"fits_unshuffle_8bytes(char *heap, LONGLONG length, int *status) {    LONGLONG ii;    char *ptr, *cptr, *heapptr;        ptr = malloc((size_t) (length * 8));    heapptr = heap + (8 * length) - 1;    cptr = ptr + (8 * length)  -1;        for (ii = 0; ii < length; ii++) {       *cptr = *heapptr;       cptr--;       *cptr = *(heapptr - length);       cptr--;       *cptr = *(heapptr - (2 * length));       cptr--;       *cptr = *(heapptr - (3 * length));       cptr--;       *cptr = *(heapptr - (4 * length));       cptr--;       *cptr = *(heapptr - (5 * length));       cptr--;       *cptr = *(heapptr - (6 * length));       cptr--;       *cptr = *(heapptr - (7 * length));       cptr--;       heapptr--;    }           memcpy(heap, ptr, (size_t) (length * 8));    free(ptr);    return(*status);}",2,"cwe469,cweother"
"writeExitCode(int myExitCode, int programExitCode) {      int exitCode;   char exitCode_str[20];   char *tmpdir = NULL;   char *taskid = NULL;   int  file;   char fileName[SGE_PATH_MAX];   if(myExitCode != EXIT_SUCCESS) {      exitCode = MAKEEXITSTATUS(myExitCode);   } else {      exitCode = programExitCode;   }   if((tmpdir = search_conf_val(""qrsh_tmpdir"")) == NULL) {      qrsh_error(MSG_CONF_NOCONFVALUE_S, ""qrsh_tmpdir"");      return EXIT_FAILURE;   }     taskid = get_conf_val(""pe_task_id"");      if(taskid != NULL) {      snprintf(fileName, SGE_PATH_MAX, ""%s/qrsh_exit_code.%s"", tmpdir, taskid);   } else {      snprintf(fileName, SGE_PATH_MAX, ""%s/qrsh_exit_code"", tmpdir);   }   if((file = SGE_OPEN3(fileName, O_WRONLY | O_APPEND | O_CREAT, 00744)) == -1) {      qrsh_error(MSG_QRSH_STARTER_CANNOTOPENFILE_SS, fileName, strerror(errno));      return EXIT_FAILURE;   }    snprintf(exitCode_str, 20, ""%d"", exitCode);   write(file, exitCode_str, strlen(exitCode_str));   SGE_CLOSE(file);      return EXIT_SUCCESS;}",3,"cwe119,cwe120,cwe469"
"multi_split(BIO *bio, char *bound, STACK_OF(BIO) **ret){tchar linebuf[MAX_SMLEN];tint len, blen;tint eol = 0, next_eol = 0;tBIO *bpart = NULL;tSTACK_OF(BIO) *parts;tchar state, part, first;tblen = strlen(bound);tpart = 0;tstate = 0;tfirst = 1;tparts = sk_BIO_new_null();t*ret = parts;twhile ((len = BIO_gets(bio, linebuf, MAX_SMLEN)) > 0) {ttstate = mime_bound_check(linebuf, len, bound, blen);ttif(state == 1) {tttfirst = 1;tttpart++;tt} else if(state == 2) {tttsk_BIO_push(parts, bpart);tttreturn 1;tt} else if(part) {ttt tttnext_eol = strip_eol(linebuf, &len);tttif(first) {ttttfirst = 0;ttttif(bpart) sk_BIO_push(parts, bpart);ttttbpart = BIO_new(BIO_s_mem());ttttBIO_set_mem_eof_return(bpart, 0);ttt} else if (eol)ttttBIO_write(bpart, ""r"", 2);ttteol = next_eol;tttif (len)ttttBIO_write(bpart, linebuf, len);tt}t}treturn 0;}",3,"cwe119,cwe120,cwe469"
"lc_ctype_is_c(void){t tstatic inttresult = -1;tchart   *localeptr;tif (result >= 0)ttreturn (bool) result;tlocaleptr = setlocale(LC_CTYPE, NULL);tif (!localeptr)ttelog(ERROR, ""invalid LC_CTYPE setting"");tif (strcmp(localeptr, ""C"") == 0)ttresult = true;telse if (strcmp(localeptr, ""POSIX"") == 0)ttresult = true;telsettresult = false;treturn (bool) result;}",3,"cwe476,cwe469,cweother"
"""load_font_by_name(term_data *td, const char *font_name){ttPangoFontDescription *temp_font;tchar buf[80];tunsigned int i, j = 0;tmy_strcpy(td->font.name, font_name, sizeof(td->font.name));tfor (i = 0; i < strlen(font_name); i++)ttif (font_name[i] == ' ') tttj = i;ttfor (i = j; i < strlen(font_name); i++)ttbuf[i - j] = font_name[i];ttemp_font = pango_font_description_from_string(font_name);tmy_strcpy(td->font.family, pango_font_description_get_family(temp_font), sizeof(td->font.family));ttd->font.size = atof(buf);tif (td->font.size == 0) td->font.size = 12;tget_font_size(&td->font);tttd->actual.w = td->font.w * tile_width;ttd->actual.h = td->font.h;tttd->size.w = td->cols * td->font.w;ttd->size.h = td->rows * td->font.h;ttif ((td->initialized == TRUE) && (td->win != NULL)  && (td->visible))t{tt/* Get a matrix set up to scale the graphics. */ttset_term_matrix(td);ttttgtk_widget_hide(td->win);ttset_window_size(td);ttgtk_widget_show(td->win);ttttterm_data_redraw(td);t}}""",3,"cwe119,cwe120,cweother"
"""StringToInteger(const char *buf,int *dest,int maxcnt,char separator){  int cnt = 0;  char *ptr1 = (char *)buf, *ptr2;  if (!buf[0]) return 0;  do {    ptr2 = strchr(ptr1,separator);    if (ptr2) ptr2[0] = '0';    dest[cnt++] = atoi(ptr1);    if (ptr2) ptr1 = ptr2+1;  } while (cnt < maxcnt && ptr2 != NULL);  return cnt;}""",3,"cwe119,cwe120,cweother"
"verify_callback(int ok, X509_STORE_CTX * ctx){    char    buf[256];    X509   *err_cert;    int     err;    int     depth;    syslog(L_NOTICE,""Doing a peer verify"");    err_cert = X509_STORE_CTX_get_current_cert(ctx);    err = X509_STORE_CTX_get_error(ctx);    depth = X509_STORE_CTX_get_error_depth(ctx);    X509_NAME_oneline(X509_get_subject_name(err_cert), buf, sizeof(buf));    if ((tls_serveractive) && (tls_loglevel >= 1))      Printf(""Peer cert verify depth=%d %s"", depth, buf);    if (ok==0)    {      syslog(L_NOTICE, ""verify error:num=%d:%s"", err,t     X509_verify_cert_error_string(err));      tif (verify_depth >= depth) {t    ok = 1;t    verify_error = X509_V_OK;t} else {t    ok = 0;t    verify_error = X509_V_ERR_CERT_CHAIN_TOO_LONG;t}    }    switch (ctx->error) {    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:tX509_NAME_oneline(X509_get_issuer_name(ctx->current_cert), buf, sizeof(buf));tsyslog(L_NOTICE, ""issuer= %s"", buf);tbreak;    case X509_V_ERR_CERT_NOT_YET_VALID:    case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:tsyslog(L_NOTICE, ""cert not yet valid"");tbreak;    case X509_V_ERR_CERT_HAS_EXPIRED:    case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:tsyslog(L_NOTICE, ""cert has expired"");tbreak;    }    if ((tls_serveractive) && (tls_loglevel >= 1))      Printf(""verify return:%d"", ok);    return (ok);}",2,"cwe119,cwe120"
"php_xmlreader_set_relaxng_schema(INTERNAL_FUNCTION_PARAMETERS, int type) {#ifdef LIBXML_SCHEMAS_ENABLEDtzval *id;tint source_len = 0, retval = -1;txmlreader_object *intern;txmlRelaxNGPtr schema = NULL;tchar *source;tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s!"", &source, &source_len) == FAILURE) {ttreturn;t}tif (source != NULL && !source_len) {ttphp_error_docref(NULL TSRMLS_CC, E_WARNING, ""Schema data source is required"");ttRETURN_FALSE;t}tid = getThis();tintern = (xmlreader_object *)zend_object_store_get_object(id TSRMLS_CC);tif (intern && intern->ptr) {ttif (source) {tttschema =  _xmlreader_get_relaxNG(source, source_len, type, NULL, NULL TSRMLS_CC);tttif (schema) {ttttretval = xmlTextReaderRelaxNGSetSchema(intern->ptr, schema);ttt}tt} else {ttt tttretval = xmlTextReaderRelaxNGSetSchema(intern->ptr, NULL);tt}ttif (retval == 0) {tttif (intern->schema) {ttttxmlRelaxNGFree((xmlRelaxNGPtr) intern->schema);ttt}tttintern->schema = schema;tttRETURN_TRUE;tt}t}ttphp_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to set schema. This must be set prior to reading or schema contains errors."");tRETURN_FALSE;#elsetphp_error_docref(NULL TSRMLS_CC, E_WARNING, ""No Schema support built into libxml."");tRETURN_FALSE;#endif}",3,"cwe119,cwe120,cweother"
"H5Pset_fapl_split(hid_t fapl, const char *meta_ext, hid_t meta_plist_id,tt  const char *raw_ext, hid_t raw_plist_id){    H5FD_mem_tttmemb_map[H5FD_MEM_NTYPES];    hid_tttmemb_fapl[H5FD_MEM_NTYPES];    const chartt*memb_name[H5FD_MEM_NTYPES];    charttmeta_name[H5FD_MULT_MAX_FILE_NAME_LEN], raw_name[H5FD_MULT_MAX_FILE_NAME_LEN];    haddr_tttmemb_addr[H5FD_MEM_NTYPES];              H5Eclear2(H5E_DEFAULT);         ALL_MEMBERS(mt) {t tmemb_map[mt] = ((mt == H5FD_MEM_DRAW || mt == H5FD_MEM_GHEAP) ? H5FD_MEM_DRAW : H5FD_MEM_SUPER);tmemb_fapl[mt] = -1;tmemb_name[mt] = NULL;tmemb_addr[mt] = HADDR_UNDEF;    } END_MEMBERS;         memb_fapl[H5FD_MEM_SUPER] = meta_plist_id;    memb_fapl[H5FD_MEM_DRAW] = raw_plist_id;              if(meta_ext) {tif(strstr(meta_ext, ""%s"")) {             t    strncpy(meta_name, meta_ext, sizeof(meta_name));            meta_name[sizeof(meta_name) - 1] = '0';        }telset    sprintf(meta_name, ""%%s%s"", meta_ext);    }    else {tstrncpy(meta_name, ""%s.meta"", sizeof(meta_name));        meta_name[sizeof(meta_name) - 1] = '0';    }    memb_name[H5FD_MEM_SUPER] = meta_name;         if(raw_ext) {tif(strstr(raw_ext, ""%s"")) {             t    strncpy(raw_name, raw_ext, sizeof(raw_name));            raw_name[sizeof(raw_name) - 1] = '0';        }telset    sprintf(raw_name, ""%%s%s"", raw_ext);    }    else {tstrncpy(raw_name, ""%s.raw"", sizeof(raw_name));        raw_name[sizeof(raw_name) - 1] = '0';    }    memb_name[H5FD_MEM_DRAW] = raw_name;         memb_addr[H5FD_MEM_SUPER] = 0;    memb_addr[H5FD_MEM_DRAW] = HADDR_MAX/2;    return H5Pset_fapl_multi(fapl, memb_map, memb_fapl, memb_name, memb_addr, TRUE);}",2,"cwe119,cwe120"
"gamgi_io_x3d_render_lines (FILE *fp, int *lines, double *points, gamgi_bool *error){char string[GAMGI_ENGINE_LINE];int i, n_lines;n_lines = lines[0];if (n_lines == 0) return;gamgi_io_file_fprintf(fp, ""<IndexedLineSet coordIndex='"", error);tfor (i = 0; i <n_lines; i++)  {  sprintf (string, ""%d %d -1"", i*2, i*2+1);  gamgi_io_file_fprintf (fp, string, error);  if (i != n_lines - 1)    gamgi_io_file_fprintf (fp, "" "", error);  }tgamgi_io_file_fprintf(fp, ""'><Coordinate point='"", error);ti = 1;while (n_lines-- > 0)  {  sprintf (string, ""%f %f %f, "",   points[3*lines[i]], points[3*lines[i]+1], points[3*lines[i]+2]);  gamgi_io_file_fprintf(fp, string, error);  i++;  sprintf (string, ""%f %f %f"",   points[3*lines[i]], points[3*lines[i]+1], points[3*lines[i]+2]);  gamgi_io_file_fprintf(fp, string, error);  i++;  if (n_lines>0)  gamgi_io_file_fprintf(fp, "", "", error);  }gamgi_io_file_fprintf(fp, ""'/></IndexedLineSet>"", error);}",2,"cwe119,cwe120"
"tgdb_initialize_logger_interface(struct tgdb *tgdb, char *config_dir){         const char *tgdb_log_file = ""tgdb_log.txt"";    char tgdb_log_path[FSUTIL_PATH_MAX];    fs_util_get_path(config_dir, tgdb_log_file, tgdb_log_path);         if (num_loggers == 0) {        logger = logger_create();        if (!logger) {            printf(""Error: Could not create log file"");            return -1;        }    }    ++num_loggers;    if (logger_set_file(logger, tgdb_log_path) == -1) {        printf(""Error: Could not open log file"");        return -1;    }    return 0;}",2,"cwe119,cwe120"
"w5300_write_indirect(struct w5300_priv *priv, u16 addr, u16 data){tunsigned long flags;tspin_lock_irqsave(&priv->reg_lock, flags);tw5300_write_direct(priv, W5300_IDM_AR, addr);tmmiowb();tw5300_write_direct(priv, W5300_IDM_DR, data);tmmiowb();tspin_unlock_irqrestore(&priv->reg_lock, flags);}",2,"cwe120,cweother"
"FileCopy (const char *fileIn, const char *fileOut){   FILE *ifp;               FILE *ofp;               int c;                   if ((ifp = fopen (fileIn, ""rb"")) == NULL) {#ifdef DEBUG      printf (""Couldn't open %s for read"", fileIn);#endif      return 1;   }   if ((ofp = fopen (fileOut, ""wb"")) == NULL) {#ifdef DEBUG      printf (""Couldn't open %s for write"", fileOut);#endif      fclose (ifp);      return 2;   }   while ((c = getc (ifp)) != EOF) {      putc (c, ofp);   }   fclose (ifp);   fclose (ofp);   return 0;}",2,"cwe120,cweother"
"OpFopen(){   fah_fopen_ot in ;   fah_fopen_it out ;   status=system(""clear"") ;   printf(""FAH_OP_FOPEN"") ;   printf(""------------"") ;tttt    printf(""Enter file-path : "") ;   status=scanf(""%s"", out.path) ;   printf(""Enter mode : "") ;   status=scanf(""%s"", out.mode) ;tttt    printf(""To FAH :"") ;   printf(""path : %s"", out.path) ;   printf(""mode : %s"", out.mode) ;tttt    if (!writen(fahsock, (char *)&out, sizeof(out)))    {       printf(""OpFopen::writen"") ;       getchar() ; getchar() ;       return ;    }tttt    if (!readn(fahsock, (char *)&in, sizeof(in)))    {       printf(""OpFopen::readn"") ;       getchar() ; getchar() ;       return ;    }tttt    printf(""From FAH :"") ;   printf(""status : %d"", ntohs(in.status)) ;   printf(""error : %d"", ntohs(in.error)) ;   printf(""fid : %d"", ntohs(in.fid)) ;   getchar() ;  getchar() ;}",2,"cwe120,cweother"
"get_number_of_devices(void){tFILE *fp;tchar buf[128];tint rv;tunsigned n = 0;tunsigned long rd_ops, wr_ops;tchar dname[MAX_DEVICE_NAME];tfp = xfopen_for_read(""/proc/diskstats"");twhile (fgets(buf, sizeof(buf), fp)) {ttrv = sscanf(buf, ""%*d %*d %s %lu %*u %*u %*u %lu"",ttttdname, &rd_ops, &wr_ops);ttif (rv == 2 || is_partition(dname))ttt tttcontinue;ttif (!rd_ops && !wr_ops) {ttt tttif (!G.show_all)ttttcontinue;tt}ttn++;t}tfclose(fp);treturn n;}",3,"cwe119,cwe120,cweother"
"RChostname(const CHANNEL *cp){    static chartbuff[INET6_ADDRSTRLEN];    REMOTEHOSTt*rp;    inttti;    for (rp = RCpeerlist, i = RCnpeerlist; --i >= 0; rp++)tif (network_sockaddr_equal((struct sockaddr *) &cp->Address,                                   (struct sockaddr *) &rp->Address))t    return rp->Name;    network_sockaddr_sprint(buff, sizeof(buff),                            (struct sockaddr *) &cp->Address);    return buff;}",2,"cwe119,cwe120"
"roll_file(const char *filename, off_t *size){tchar buf[BUFSIZ];tint fd;tstruct stat st;toff_t pos;tfd = open(filename, O_RDONLY);tif (fd < 0)tterr(EXIT_FAILURE, _(""cannot open ""%s"" for read""), filename);tif (fstat(fd, &st) == -1)tterr(EXIT_FAILURE, _(""cannot stat ""%s""""), filename);tif (st.st_size == *size) {ttclose(fd);ttreturn;t}tif (lseek(fd, *size, SEEK_SET) != (off_t)-1) {ttssize_t rc, wc;ttwhile ((rc = read(fd, buf, sizeof(buf))) > 0) {tttwc = write(STDOUT_FILENO, buf, rc);tttif (rc != wc)ttttwarnx(_(""incomplete write to ""%s"" (written %zd, expected %zd)""),tttttfilename, wc, rc);tt}ttfflush(stdout);t}tpos = lseek(fd, 0, SEEK_CUR);t t*size = (pos != -1 && pos != *size) ? pos : st.st_size;tclose(fd);}",3,"cwe119,cwe120,cweother"
"domain_name_cache_canonical(const char *name_or_addr, char *cname){tchar addr[DOMAIN_NAME_MAX];treturn domain_name_cache_lookup(name_or_addr, addr) && domain_name_cache_lookup_reverse(addr, cname);}",2,"cwe119,cwe120"
"glp_set_row_name(glp_prob *lp, int i, const char *name){     glp_tree *tree = lp->tree;      GLPROW *row;      if (!(1 <= i && i <= lp->m))         xerror(""glp_set_row_name: i = %d; row number out of range"",            i);      row = lp->row[i];      if (tree != NULL && tree->reason != 0)      {  xassert(tree->curr != NULL);         xassert(row->level == tree->curr->level);      }      if (row->name != NULL)      {  if (row->node != NULL)         {  xassert(lp->r_tree != NULL);            avl_delete_node(lp->r_tree, row->node);            row->node = NULL;         }         dmp_free_atom(lp->pool, row->name, strlen(row->name)+1);         row->name = NULL;      }      if (!(name == NULL || name[0] == '0'))      {  int k;         for (k = 0; name[k] != '0'; k++)         {  if (k == 256)               xerror(""glp_set_row_name: i = %d; row name too long"",                  i);            if (iscntrl((unsigned char)name[k]))               xerror(""glp_set_row_name: i = %d: row name contains inva""                  ""lid character(s)"", i);         }         row->name = dmp_get_atom(lp->pool, strlen(name)+1);         strcpy(row->name, name);         if (lp->r_tree != NULL)         {  xassert(row->node == NULL);            row->node = avl_insert_node(lp->r_tree, row->name);            avl_set_node_link(row->node, row);         }      }      return;}",2,"cwe120,cwe476"
"msg ( char *fmt, ... ) {   static int init=0 ;  static FILE *logfile [ NLOG ] ;  static char msgbuf [ NLOG ] [ MAXMSGBUF ] ;  static time_t logtime [ NLOG ] = { 0, 0 } ;  static int atcol1 [ NLOG ] = { 1, 1 } ;    int err=0, i, flags=0 ;  char *p ;    if ( ! init ) {    logfile[0] = stderr ;    logfile[1] = stdout ;    for ( i=0 ; i<NLOG ; i++ )      setvbuf ( logfile[i], msgbuf[i], _IOFBF, MAXMSGBUF ) ;    cname ( 0 ) ;    init = 1 ;  }    for ( i=0 ; i<NLOG ; i++ ) {       va_list ap ;       va_start ( ap, fmt ) ;    for ( p=fmt ; *p ; p++ ) {      switch ( *p ) {      case ' ': p++ ; goto print ;      case 'E': flags |= E ; break ;      case 'W': flags |= W ; break ;      case 'S': flags |= S ; break ;      case '+': flags |= NOLF ; break ;      case '-': flags |= NOFLSH ; break ;      default: tif ( isdigit ( *p ) ) {t  err = *p - '0' ; t} else if ( ! isupper ( *p ) ) {t  goto print ;t}      }    }          print:    if ( strchr ( verb[i], tolower ( *fmt ) ) ) {            if ( atcol1[i] ) {tfprintf ( logfile[i], ""%s: "", argv0 ) ;tlogtime[i] = tstamp ( logtime[i], logfile[i] ) ; tfputs ( ( flags & E ) ? "" Error: "" : tt( flags & W ) ? "" Warning: "" : tt"" "",ttlogfile[i] ) ;      }      vfprintf( logfile[i], p, ap ) ;      if ( flags & S ) fprintf ( logfile[i], "" %s"", strerror ( errno ) ) ;      if ( ! ( flags & NOLF ) ) fputs ( """", logfile[i] ) ;      atcol1[i] = flags & NOLF ? 0 : 1 ;      if ( ! ( flags & NOFLSH ) ) fflush ( logfile[i] ) ;          }    va_end ( ap ) ;  }      return err ;}",3,"cwe119,cwe120,cweother"
"GWEN_Text_DumpString2Buffer(const char *s, unsigned int l,                                 GWEN_BUFFER *mbuf,                                 unsigned int insert) {  unsigned int i;  unsigned int j;  unsigned int pos;  unsigned k;  char numbuf[32];  pos=0;  for (k=0; k<insert; k++)    GWEN_Buffer_AppendByte(mbuf, ' ');  GWEN_Buffer_AppendString(mbuf,""String size is "");  snprintf(numbuf, sizeof(numbuf), ""%d"", l);  GWEN_Buffer_AppendString(mbuf, numbuf);  GWEN_Buffer_AppendByte(mbuf, '');  while(pos<l) {    for (k=0; k<insert; k++)      GWEN_Buffer_AppendByte(mbuf, ' ');    snprintf(numbuf, sizeof(numbuf),""%04x: "",pos);    GWEN_Buffer_AppendString(mbuf, numbuf);    j=pos+16;    if (j>=l)      j=l;         for (i=pos; i<j; i++) {      snprintf(numbuf, sizeof(numbuf),""%02x "", (unsigned char)s[i]);      GWEN_Buffer_AppendString(mbuf, numbuf);    }    if (j-pos<16)      for (i=0; i<16-(j-pos); i++)        GWEN_Buffer_AppendString(mbuf, ""   "");         for (i=pos; i<j; i++) {      if (s[i]<32)        GWEN_Buffer_AppendByte(mbuf, '.');      else        GWEN_Buffer_AppendByte(mbuf, s[i]);    }    GWEN_Buffer_AppendByte(mbuf, '');    pos+=16;  }}",2,"cwe119,cwe120"
"create_DS1_char_datasets(hid_t fid, const char *dsidx, int rankds, hsize_t *s_dim, char *s_wbuf, char *s1_wbuf){    char name[32];    HDstrcpy(name, DS_1_NAME);    HDstrcat(name, dsidx);         if(H5LTmake_dataset_char(fid, name, rankds, s_dim, s_wbuf) < 0)        return FAIL;    if(s1_wbuf!=NULL) {        HDstrcpy(name, DS_11_NAME);        HDstrcat(name, dsidx);                 if(H5LTmake_dataset_char(fid, name, rankds, s_dim, s1_wbuf) < 0)            return FAIL;    }    return SUCCEED;}",2,"cwe119,cwe120"
"prop_get_bool_or(const char *name, int default_value){tconst char *prop = prop_get(name);tchar buf[128];tint val;tif (!prop)ttreturn default_value;tif (sscanf(prop, "" %d "", &val))ttreturn val;tif (sscanf(prop, "" %s "", buf))t{ttif ((buf[0] == 't' || buf[0] == 'T') &&ttt(buf[1] == 'r' || buf[1] == 'R') &&ttt(buf[2] == 'u' || buf[2] == 'U') &&ttt(buf[3] == 'e' || buf[3] == 'E') &&ttt(buf[4] == nul))tttreturn 1;ttif ((buf[0] == 'f' || buf[0] == 'F') &&ttt(buf[1] == 'a' || buf[1] == 'A') &&ttt(buf[2] == 'l' || buf[2] == 'L') &&ttt(buf[3] == 's' || buf[3] == 'S') &&ttt(buf[4] == 'e' || buf[4] == 'E') &&ttt(buf[5] == nul))tttreturn 0;ttif ((buf[0] == 'y' || buf[0] == 'Y') &&ttt(buf[1] == 'e' || buf[1] == 'E') &&ttt(buf[2] == 's' || buf[2] == 'S') &&ttt(buf[3] == nul))tttreturn 1;ttif ((buf[0] == 'n' || buf[0] == 'N') &&ttt(buf[1] == 'o' || buf[1] == 'O') &&ttt(buf[2] == nul))tttreturn 0;ttif ((buf[0] == 'o' || buf[0] == 'O') &&ttt(buf[1] == 'n' || buf[1] == 'N') &&ttt(buf[2] == nul))tttreturn 1;ttif ((buf[0] == 'o' || buf[0] == 'O') &&ttt(buf[1] == 'f' || buf[1] == 'F') &&ttt(buf[2] == 'f' || buf[2] == 'F') &&ttt(buf[3] == nul))tttreturn 0;t}treturn default_value;}",3,"cwe119,cwe120,cweother"
"__pv_vpi_terr(int32 id_num, char *s, ...){ va_list va, va2, va3; int32 slen; char vpis1[IDLEN], vpis2[4*IDLEN], *vpichp;  if (__vpierr_cb_active && !__iact_state)  {       __errorcb_suppress_msg = FALSE;   sprintf(vpis1, ""**FATAL ERROR** [%d] "", id_num);   va_start(va, s);   vsprintf(vpis2, s, va);   va_end(va);      slen = strlen(vpis1) + strlen(vpis2) + 1;   vpichp = __my_malloc(slen);   strcpy(vpichp, vpis1);   strcat(vpichp, vpis2);   __my_free(vpichp, slen);        if (__errorcb_suppress_msg)    { __errorcb_suppress_msg = FALSE; __my_exit(1, TRUE); }  } __my_fprintf(stdout, ""**FATAL ERROR** [%d] "", id_num);   va_start(va2, s); va_start(va3, s); __my_vfprintf(stdout, s, va2, va3); va_end(va2); va_end(va3); my_putc_('', stdout); __my_exit(1, TRUE);}",3,"cwe119,cwe120,cweother"
"gf_odf_hevc_cfg_read_bs(GF_BitStream *bs){tu32 i, count;tGF_HEVCConfig *cfg = gf_odf_hevc_cfg_new();tcfg->configurationVersion = gf_bs_read_int(bs, 8);tcfg->profile_space = gf_bs_read_int(bs, 3);tcfg->profile_idc = gf_bs_read_int(bs, 5);tcfg->constraint_indicator_flags = gf_bs_read_int(bs, 16);tcfg->level_idc = gf_bs_read_int(bs, 8);tcfg->profile_compatibility_indications = gf_bs_read_int(bs, 32);tgf_bs_read_int(bs, 6);tcfg->chromaFormat = gf_bs_read_int(bs, 2);tgf_bs_read_int(bs, 5);tcfg->luma_bit_depth = 8 + gf_bs_read_int(bs, 3);tgf_bs_read_int(bs, 5);tcfg->chroma_bit_depth = 8 + gf_bs_read_int(bs, 3);tcfg->avgFrameRate = gf_bs_read_int(bs, 16);tcfg->constantFrameRate = gf_bs_read_int(bs, 2);tcfg->numTemporalLayers = gf_bs_read_int(bs, 3);tgf_bs_read_int(bs, 1);tcfg->nal_unit_size = 1 + gf_bs_read_int(bs, 2);tcount = gf_bs_read_int(bs, 8);tfor (i=0; i<count; i++) {ttu32 nalucount, j;ttGF_HEVCParamArray *ar;ttGF_SAFEALLOC(ar, GF_HEVCParamArray);ttar->nalus = gf_list_new();ttgf_list_add(cfg->param_array, ar);ttttar->array_completeness = gf_bs_read_int(bs, 1);ttgf_bs_read_int(bs, 1);ttar->type = gf_bs_read_int(bs, 6);ttnalucount = gf_bs_read_int(bs, 16);ttfor (j=0; j<nalucount; j++) {tttGF_AVCConfigSlot *sl;tttGF_SAFEALLOC(sl, GF_AVCConfigSlot );tttsl->size = gf_bs_read_int(bs, 16);tttsl->data = (char *)gf_malloc(sizeof(char) * sl->size);tttgf_bs_read_data(bs, sl->data, sl->size);tttgf_list_add(ar->nalus, sl);tt}t}treturn cfg;}",2,"cwe120,cwe476"
"_output_manufacturer_id (ipmi_sensors_state_data_t *state_data,                         const void *sdr_record,                         unsigned int sdr_record_len){  uint32_t manufacturer_id;  char iana_buf[IPMI_SENSORS_IANA_LEN + 1];  int ret;  assert (state_data);  assert (sdr_record);  assert (sdr_record_len);  assert (state_data->prog_data->args->verbose_count >= 2);  if (ipmi_sdr_parse_manufacturer_id (state_data->sdr_parse_ctx,                                      sdr_record,                                      sdr_record_len,                                      &manufacturer_id) < 0)    {      pstdout_fprintf (state_data->pstate,                       stderr,                       ""ipmi_sdr_parse_manufacturer_id: %s"",                       ipmi_sdr_parse_ctx_errormsg (state_data->sdr_parse_ctx));      return (-1);    }  memset (iana_buf, '0', IPMI_SENSORS_IANA_LEN + 1);     ret = ipmi_iana_enterprise_numbers_string (manufacturer_id,                                             iana_buf,                                             IPMI_SENSORS_IANA_LEN);  if (ret > 0)    pstdout_printf (state_data->pstate,                    ""Manufacturer ID: %s (%Xh)"",                    iana_buf,                    manufacturer_id);  else    pstdout_printf (state_data->pstate,                    ""Manufacturer ID: %Xh"",                    manufacturer_id);    return (0);}",2,"cwe119,cwe120"
"parse_munge(int *argc_p, char ***argv_p,struct tc_pedit_sel *sel){tstruct tc_pedit_key tkey;tint argc = *argc_p;tchar **argv = *argv_p;tint res = -1;tif (argc <= 0)ttreturn -1;tmemset(&tkey, 0, sizeof(tkey));tif (matches(*argv, ""offset"") == 0) {ttNEXT_ARG();ttres = parse_offset(&argc, &argv,sel,&tkey);ttgoto done;t} else {ttchar k[16];ttstruct m_pedit_util *p = NULL;ttstrncpy(k, *argv, sizeof (k) - 1);ttif (argc > 0 ) {tttp = get_pedit_kind(k);tttif (NULL == p)ttttgoto bad_val;tttres = p->parse_peopt(&argc, &argv, sel,&tkey);tttif (res < 0) {ttttfprintf(stderr,""bad pedit parsing"");ttttgoto bad_val;ttt}tttgoto done;tt}t}bad_val:treturn -1;done:t*argc_p = argc;t*argv_p = argv;treturn res;}",2,"cwe119,cwe120"
"client3_1_symlink (call_frame_t *frame, xlator_t *this,                   void *data){        clnt_local_t     *local    = NULL;        clnt_conf_t      *conf     = NULL;        clnt_args_t      *args     = NULL;        gfs3_symlink_req  req      = {{0,},};        int               ret      = 0;        int               op_errno = ESTALE;        if (!frame || !this || !data)                goto unwind;        args = data;        local = mem_get0 (this->local_pool);        if (!local) {                op_errno = ENOMEM;                goto unwind;        }        frame->local = local;        if (!(args->loc && args->loc->parent))                goto unwind;        loc_copy (&local->loc, args->loc);        if (!uuid_is_null (args->loc->parent->gfid))                memcpy (req.pargfid,  args->loc->parent->gfid, 16);        else                memcpy (req.pargfid, args->loc->pargfid, 16);        GF_ASSERT_AND_GOTO_WITH_ERROR (this->name,                                       !uuid_is_null (*((uuid_t*)req.pargfid)),                                       unwind, op_errno, EINVAL);        req.linkname = (char *)args->linkname;        req.bname    = (char *)args->loc->name;        req.umask = args->umask;        conf = this->private;        GF_PROTOCOL_DICT_SERIALIZE (this, args->xdata, (&req.xdata.xdata_val),                                    req.xdata.xdata_len, op_errno, unwind);        ret = client_submit_request (this, &req, frame, conf->fops,                                     GFS3_OP_SYMLINK, client3_1_symlink_cbk,                                     NULL,  NULL, 0, NULL,                                     0, NULL, (xdrproc_t)xdr_gfs3_symlink_req);        if (ret) {                gf_log (this->name, GF_LOG_WARNING, ""failed to send the fop"");        }        if (req.xdata.xdata_val)                GF_FREE (req.xdata.xdata_val);        return 0;unwind:        CLIENT_STACK_UNWIND (symlink, frame, -1, op_errno, NULL, NULL, NULL,                             NULL, NULL);        if (req.xdata.xdata_val)                GF_FREE (req.xdata.xdata_val);        return 0;}",3,"cwe120,cwe469,cweother"
"freeptrtab(unsigned char **ptrtab,int tot) {    int i,j;    for ( i=0; i<tot; ++i )tif ( ptrtab[i]!=NULL ) {t    for ( j=i+1; j<tot; ++j )ttif ( ptrtab[j]==ptrtab[i] )tt    ptrtab[j] = NULL;t    gfree(ptrtab[i]);t}}",2,"cwe120,cweother"
"SPF_record_compile_macro(SPF_server_t *spf_server,ttttttttSPF_response_t *spf_response, ttttttttSPF_macro_t **spf_macrop,ttttttttconst char *record){ALIGN_DECL(tcharttt buf[sizeof(SPF_macro_t) + SPF_MAX_MOD_LEN];);tSPF_macro_ttt*spf_macro = (SPF_macro_t *)ALIGNED_DECL(buf);tSPF_data_ttt*data;tSPF_errcode_tt err;tsize_tttt size;ttdata = SPF_macro_data(spf_macro);tspf_macro->macro_len = 0;terr = SPF_c_parse_macro(spf_server, spf_response,tttttdata, &spf_macro->macro_len, SPF_MAX_MOD_LEN,tttttrecord, strlen(record),tttttSPF_E_BIG_MOD, TRUE);tif (err != SPF_E_SUCCESS)ttreturn err;t tsize = sizeof(SPF_macro_t) + spf_macro->macro_len;t*spf_macrop = (SPF_macro_t *)malloc(size);tif (!*spf_macrop)ttreturn SPF_E_NO_MEMORY;tmemcpy(*spf_macrop, ALIGNED_DECL(buf), size);treturn SPF_E_SUCCESS;}",2,"cwe119,cwe120"
"_dbus_sha_final (DBusSHAContext   *context,                 DBusString       *results){  unsigned char digest[20];  sha_finish (context, digest);  if (!_dbus_string_append_len (results, digest, 20))    return FALSE;     _DBUS_ZERO(*context);  return TRUE;}",2,"cwe119,cwe120"
"GTIFGetUOMAngleInfo( int nUOMAngleCode,                         char **ppszUOMName,                         double * pdfInDegrees ){    const chart*pszUOMName = NULL;    doubletdfInDegrees = 1.0;    const char *pszFilename;    chartszSearchKey[24];    switch( nUOMAngleCode )    {      case 9101:        pszUOMName = ""radian"";        dfInDegrees = 180.0 / PI;        break;      case 9102:      case 9107:      case 9108:      case 9110:      case 9122:        pszUOMName = ""degree"";        dfInDegrees = 1.0;        break;      case 9103:        pszUOMName = ""arc-minute"";        dfInDegrees = 1 / 60.0;        break;      case 9104:        pszUOMName = ""arc-second"";        dfInDegrees = 1 / 3600.0;        break;      case 9105:        pszUOMName = ""grad"";        dfInDegrees = 180.0 / 200.0;        break;      case 9106:        pszUOMName = ""gon"";        dfInDegrees = 180.0 / 200.0;        break;      case 9109:        pszUOMName = ""microradian"";        dfInDegrees = 180.0 / (PI * 1000000.0);        break;      default:        break;    }        if (pszUOMName)    {        if( ppszUOMName != NULL )        {            if( pszUOMName != NULL )                *ppszUOMName = CPLStrdup( pszUOMName );            else                *ppszUOMName = NULL;        }        if( pdfInDegrees != NULL )            *pdfInDegrees = dfInDegrees;        return TRUE;    }    pszFilename = CSVFilename( ""unit_of_measure.csv"" );    sprintf( szSearchKey, ""%d"", nUOMAngleCode );    pszUOMName = CSVGetField( pszFilename,                              ""UOM_CODE"", szSearchKey, CC_Integer,                              ""UNIT_OF_MEAS_NAME"" );          if( pszUOMName != NULL )    {        double dfFactorB, dfFactorC, dfInRadians;                dfFactorB =             GTIFAtof(CSVGetField( pszFilename,                              ""UOM_CODE"", szSearchKey, CC_Integer,                              ""FACTOR_B"" ));                dfFactorC =             GTIFAtof(CSVGetField( pszFilename,                              ""UOM_CODE"", szSearchKey, CC_Integer,                              ""FACTOR_C"" ));        if( dfFactorC != 0.0 )        {            dfInRadians = (dfFactorB / dfFactorC);            dfInDegrees = dfInRadians * 180.0 / PI;        }    }    else    {        return FALSE;    }       if( ppszUOMName != NULL )    {        if( pszUOMName != NULL )            *ppszUOMName = CPLStrdup( pszUOMName );        else            *ppszUOMName = NULL;    }    if( pdfInDegrees != NULL )        *pdfInDegrees = dfInDegrees;    return( TRUE );}",2,"cwe119,cwe120"
"main(int argc, char** argv){tFILE* pFile;tFILE* pOut;tchar* pstrBuffer;tchar pstrFilename[32];tint iCurrentPos = 0;tint i, iRead, iTotal;tint iNMLL = 0, iTMLL = 0;tint aFiles[10000];tunsigned int iTmp;tif (2 != argc) {ttfprintf(stderr, ""Usage: %s file.fpb"", argv[0]);ttreturn 2;t}tpFile = fopen(argv[1], ""rb"");tif (pFile == NULL)ttreturn -1;tiTotal = 0;twhile (1) {ttfseek(pFile, iCurrentPos, SEEK_SET);ttiRead = fread(&iTmp, sizeof(unsigned int), 1, pFile);ttif (iRead <= 0)tttbreak;ttif (iTmp == NBL_ID_NMLL || iTmp == NBL_ID_NMLB) {tttaFiles[iTotal] = iCurrentPos;tttiTotal++;tt}ttiCurrentPos += 4;t}tfseek(pFile, 0, SEEK_END);taFiles[iTotal] = ftell(pFile);tfor (i = 0; i < iTotal; i++) {ttfseek(pFile, aFiles[i], SEEK_SET);ttpstrBuffer = malloc(aFiles[i + 1] - aFiles[i]);ttiRead = fread(pstrBuffer, 1, aFiles[i + 1] - aFiles[i], pFile);ttif (iRead > 0) {tttif (pstrBuffer[5])ttttsprintf(pstrFilename, ""nmll-%d-new-format.nbl"", iNMLL++);tttelsettttsprintf(pstrFilename, ""nmll-%d.nbl"", iNMLL++);tttpOut = fopen(pstrFilename, ""wb"");tttfwrite(pstrBuffer, 1, aFiles[i + 1] - aFiles[i], pOut);tttfclose(pOut);tt}ttfree(pstrBuffer);t}tfclose(pFile);treturn 0;}",3,"cwe119,cwe120,cweother"
"read_dev_kmem(ulong vaddr, char *bufptr, long cnt){tssize_t readcnt;tif (pc->kfd < 0) {ttif ((pc->kfd = open(""/dev/kmem"", O_RDONLY)) < 0)tttreturn 0; t}tif (lseek(pc->kfd, vaddr, SEEK_SET) == -1) ttreturn 0;treadcnt = read(pc->kfd, bufptr, cnt);tif (readcnt != cnt)ttreadcnt = 0;treturn readcnt;}",3,"cwe120,cwe476,cweother"
"iIsValidHdr(){tchartHead[10];tILinttRead;tRead = iread(Head, 1, 10);tiseek(-Read, IL_SEEK_CUR);   tif (Read != 10)ttreturn IL_FALSE;treturnttstrnicmp(Head, ""#?RADIANCE"", 10) == 0tt|| strnicmp(Head, ""#?RGBE"", 6) == 0;}",2,"cwe119,cwe120"
"split_ec(const char *src, char **ext, char ** const ctx, char ** const cid){tchar *i, *c, *e = ast_strdup(src);  tif (e == NULL)ttreturn -1;t t t*ext = e;tc = strchr(e, '@');tif (c == NULL)t tt*ctx = """";t telse {t tt*c++ = '0';tt*ctx = c;ttif (strchr(c, '@')) {  tttfree(e);tttreturn -1;tt}t}tif (cid && (i = strchr(e, '/'))) {tt*i++ = '0';tt*cid = i;t} else if (cid) {tt tt*cid = NULL;t}treturn 0;}",3,"cwe119,cwe120,cweother"
"IoFile_create(IoFile *self){tFILE *fp = fopen(CSTRING(DATA(self)->path), ""w"");tif (fp)t{ttfclose(fp);ttreturn 1;t}treturn 0;}",2,"cwe120,cweother"
"iks_sha_hash (iksha *sha, const unsigned char *data, size_t len, int finish){tunsigned char pad[8];tunsigned char padc;tif (data && len != 0) sha_buffer (sha, data, len);tif (!finish) return;tpad[0] = (unsigned char)((sha->lenhi >> 24) & 0xff);tpad[1] = (unsigned char)((sha->lenhi >> 16) & 0xff);tpad[2] = (unsigned char)((sha->lenhi >> 8) & 0xff);tpad[3] = (unsigned char)(sha->lenhi & 0xff);tpad[4] = (unsigned char)((sha->lenlo >> 24) & 0xff);tpad[5] = (unsigned char)((sha->lenlo >> 16) & 0xff);tpad[6] = (unsigned char)((sha->lenlo >> 8) & 0xff);tpad[7] = (unsigned char)(sha->lenlo & 255);tpadc = 0x80;tsha_buffer (sha, &padc, 1);tpadc = 0x00;twhile (sha->blen != 56)ttsha_buffer (sha, &padc, 1);tsha_buffer (sha, pad, 8);}",2,"cwe119,cwe120"
"mg_printf_data(struct mg_connection *c, const char *fmt, ...) {  struct connection *conn = MG_CONN_2_CONN(c);  va_list ap;  int len;  char mem[IOBUF_SIZE], *buf = mem;  terminate_headers(c);  va_start(ap, fmt);  len = ns_avprintf(&buf, sizeof(mem), fmt, ap);  va_end(ap);  if (len >= 0) {    write_chunk((struct connection *) conn, buf, len);  }  if (buf != mem && buf != NULL) {    NS_FREE(buf);  }  return conn->ns_conn->send_iobuf.len;}",2,"cwe119,cwe120"
"NCmode(CHANNEL *cp){    char buff[SMBUF];    HANDOFF h;    cp->Start = cp->Next;    if (strcasecmp(cp->av[1], ""READER"") == 0 && !innconf->noreader) {                 syslog(L_NOTICE, ""%s NCmode ""MODE READER"" received"",               CHANname(cp));        if (!cp->CanAuthenticate) {                         snprintf(buff, sizeof(buff), ""%d Already authenticated as a feeder"",                     NNTP_ERR_ACCESS);            NCwritereply(cp, buff);            return;        }        if (NNRPReason != NULL && !innconf->readerswhenstopped) {                         snprintf(buff, sizeof(buff), ""%d %s"", NNTP_FAIL_ACTION, NNRPReason);            NCwritereply(cp, buff);            return;        } else {                         h = HOnnrpd;        }    } else if (strcasecmp(cp->av[1], ""STREAM"") == 0 &&               (!StreamingOff && cp->Streaming)) {                 snprintf(buff, sizeof(buff), ""%d Streaming permitted"", NNTP_OK_STREAM);tNCwritereply(cp, buff);tsyslog(L_NOTICE, ""%s NCmode ""MODE STREAM"" received"",               CHANname(cp));        return;    } else if (strcasecmp(cp->av[1], ""CANCEL"") == 0 && cp->privileged) {                 cp->State = CScancel;        snprintf(buff, sizeof(buff), ""%d Cancels permitted"", NNTP_OK_MODE_CANCEL);        NCwritereply(cp, buff);        syslog(L_NOTICE, ""%s NCmode ""MODE CANCEL"" received"",                CHANname(cp));        return;    } else {                 snprintf(buff, sizeof(buff), ""%d Unknown MODE variant"", NNTP_ERR_SYNTAX);        NCwritereply(cp, buff);        syslog(L_NOTICE, ""%s bad_command MODE %s"", CHANname(cp),               MaxLength(cp->av[1], cp->av[1]));        return;    }         RChandoff(cp->fd, h);    if (NCcount > 0)        NCcount--;    CHANclose(cp, CHANname(cp));}",2,"cwe119,cwe120"
"_gcry_twofish_cbc_dec(void *context, unsigned char *iv, void *outbuf_arg,tt      const void *inbuf_arg, size_t nblocks){  TWOFISH_context *ctx = context;  unsigned char *outbuf = outbuf_arg;  const unsigned char *inbuf = inbuf_arg;  unsigned char savebuf[TWOFISH_BLOCKSIZE];  unsigned int burn, burn_stack_depth = 0;#ifdef USE_AMD64_ASM  {         while (nblocks >= 3)      {        _gcry_twofish_amd64_cbc_dec(ctx, outbuf, inbuf, iv);        nblocks -= 3;        outbuf += 3 * TWOFISH_BLOCKSIZE;        inbuf += 3 * TWOFISH_BLOCKSIZE;        burn = 9 * sizeof(void*);        if (burn > burn_stack_depth)          burn_stack_depth = burn;      }       }#endif  for ( ;nblocks; nblocks-- )    {             burn = twofish_decrypt (ctx, savebuf, inbuf);      if (burn > burn_stack_depth)        burn_stack_depth = burn;      buf_xor_n_copy_2(outbuf, savebuf, iv, inbuf, TWOFISH_BLOCKSIZE);      inbuf += TWOFISH_BLOCKSIZE;      outbuf += TWOFISH_BLOCKSIZE;    }  wipememory(savebuf, sizeof(savebuf));  _gcry_burn_stack(burn_stack_depth);}",2,"cwe119,cwe120"
"count_mh_files( struct mbox_struct * mb ) {        DIR           *dir        = NULL;tFILE          *f          = NULL;tchar           line[MAX_INPUT_LENGTH+1]  = """";tchar           fname[MAX_INPUT_LENGTH+1] = """";tint            ctotal     = 0;tint            cnew       = 0;tstruct dirent *dir_entry  = NULL;t tif ((dir = opendir(mb->file)) == NULL) t        return(-1);t twhile ((dir_entry = readdir(dir)) != NULL) {t         t        if (dir_entry->d_name[0] != '.' && dir_entry->d_name[0] != ',') {tt        strcpy(fname, mb->file);ttt tttif (fname[strlen(fname) - 1] != '/')ttt        strncat(fname, ""/"",tttttMAX_INPUT_LENGTH - strlen(fname));tt        strncat(fname, dir_entry->d_name,ttttMAX_INPUT_LENGTH - strlen(fname));tt        fname[MAX_INPUT_LENGTH] = '0';tttif ( (f = fopen(fname, ""r"")) == NULL ) {ttt        return(-1);ttt}tttttt++ctotal;ttt++cnew;tttwhile ( fgets(line, MAX_INPUT_LENGTH, f) ) {ttt        switch (line[0]) {tt   ttttcase 'S':tttt        if ( !strncmp(line, ""Status: "", 8) ) {ttttt      if (mb->flags & FLAG_UNREAD_AS_NEW) {tttttt      if (!strncmp(line, ""Status: RO"", 10))ttttttt      --cnew;ttttt      } else if (!strncmp(line, ""Status: R"", 9)) {tttttt      --cnew; ttttt      }ttttt       ttttt      goto close;ttttt}tttttbreak;tttt}tttttt}ttclose:tttfclose(f);tt}t}tclosedir(dir);ttif ( (mb->cnew != cnew) && (cnew != 0) ) {t        pthread_mutex_lock(&mb->mutex);ttmb->flags |= FLAG_ARRIVED;ttpthread_mutex_unlock(&mb->mutex);t}tmb->ctotal = ctotal;tmb->cnew   = cnew;ttreturn(cnew);}",3,"cwe119,cwe120,cweother"
"do_unuser(struct dlist *kin){    struct sync_name_list *list = sync_name_list_create();    struct sync_name *item;    const char *userid = kin->sval;    char buf[MAX_MAILBOX_NAME];    int r = 0;         mboxlist_allsubs(userid, addmbox_sub, list);         for (item = list->head; item; item = item->next) {        mboxlist_changesub(item->name, userid, sync_authstate, 0, 0);    }    sync_name_list_free(&list);         list = sync_name_list_create();    (sync_namespacep->mboxname_tointernal)(sync_namespacep, ""INBOX"",ttttt   userid, buf);    strlcat(buf, "".*"", sizeof(buf));    r = (sync_namespacep->mboxlist_findall)(sync_namespacep, buf,ttttt    sync_userisadmin,ttttt    sync_userid, sync_authstate,ttttt    addmbox, (void *)list);    if (r) goto fail;    for (item = list->head; item; item = item->next) {        r = mboxlist_deletemailbox(item->name, sync_userisadmin,tttt   sync_userid, sync_authstate, 0, 0, 1);        if (r) goto fail;    }         (sync_namespacep->mboxname_tointernal)(sync_namespacep, ""INBOX"",ttttt   userid, buf);    r = mboxlist_deletemailbox(buf, sync_userisadmin, sync_userid,ttt       sync_authstate, 0, 0, 1);    if (r && (r != IMAP_MAILBOX_NONEXISTENT)) goto fail;    r = user_deletedata((char *)userid, sync_userid, sync_authstate, 1); fail:    sync_name_list_free(&list);    return r;}",2,"cwe119,cwe120"
"fuse_readpages_end(struct fuse_conn *fc, struct fuse_req *req){tint i;tsize_t count = req->misc.read.in.size;tsize_t num_read = req->out.args[0].size;tstruct address_space *mapping = NULL;tfor (i = 0; mapping == NULL && i < req->num_pages; i++)ttmapping = req->pages[i]->mapping;tif (mapping) {ttstruct inode *inode = mapping->host;tt ttif (!req->out.h.error && num_read < count)tttfuse_short_read(req, inode, req->misc.read.attr_ver);ttfuse_invalidate_atime(inode);t}tfor (i = 0; i < req->num_pages; i++) {ttstruct page *page = req->pages[i];ttif (!req->out.h.error)tttSetPageUptodate(page);ttelsetttSetPageError(page);ttunlock_page(page);ttpage_cache_release(page);t}tif (req->ff)ttfuse_file_put(req->ff, false);}",2,"cwe120,cweother"
"hip_decode1_headersB(hip_t hip, unsigned char *buffer,                      size_t len,                      short pcm_l[], short pcm_r[], mp3data_struct * mp3data,                      int *enc_delay, int *enc_padding){    static char out[OUTSIZE_CLIPPED];    if (hip) {        return decode1_headersB_clipchoice(hip, buffer, len, (char *) pcm_l, (char *) pcm_r, mp3data,                                           enc_delay, enc_padding, out, OUTSIZE_CLIPPED,                                           sizeof(short), decodeMP3);    }    return -1;}",2,"cwe119,cwe120"
"init_cups(list_t *arglist, dstr_t *filelist, jobparams_t *job){    char path [1024] = """";    char cups_jobid [128];    char cups_user [128];    char cups_jobtitle [128];    char cups_copies [128];    int cups_options_len;    char *cups_options;    char cups_filename [256];    char texttopspath[PATH_MAX];    if (getenv(""CUPS_FONTPATH""))        strcpy(path, getenv(""CUPS_FONTPATH""));    else if (getenv(""CUPS_DATADIR"")) {        strcpy(path, getenv(""CUPS_DATADIR""));        strcat(path, ""/fonts"");    }    if (getenv(""GS_LIB"")) {        strcat(path, "":"");        strcat(path, getenv(""GS_LIB""));    }    setenv(""GS_LIB"", path, 1);         strncpy_omit(cups_jobid, arglist_get(arglist, 0), 128, omit_shellescapes);    strncpy_omit(cups_user, arglist_get(arglist, 1), 128, omit_shellescapes);    strncpy_omit(cups_jobtitle, arglist_get(arglist, 2), 128, omit_shellescapes);    strncpy_omit(cups_copies, arglist_get(arglist, 3), 128, omit_shellescapes);    cups_options_len = strlen(arglist_get(arglist, 4));    cups_options = malloc(cups_options_len + 1);    strncpy_omit(cups_options, arglist_get(arglist, 4), cups_options_len + 1, omit_shellescapes);         strcpy(job->id, cups_jobid);    strcpy(job->title, cups_jobtitle);    strcpy(job->user, cups_user);    strcpy(job->copies, cups_copies);    dstrcatf(job->optstr, "" %s"", cups_options);         if (list_item_count(arglist) > 4) {        strncpy_omit(cups_filename, arglist_get(arglist, 5), 256, omit_shellescapes);        if (cups_filename[0] != '-') {                         dstrcatf(filelist, ""%s "", cups_filename);            _log(""Getting input from file %s"", cups_filename);        }    }    accounting_prolog = accounting_prolog_code;         file_basename(job->printer, job->ppdfile, 256);         if (isempty(fileconverter)) {        if (find_in_path(""texttops"", cupsfilterpath, texttopspath)) {            snprintf(fileconverter, PATH_MAX, ""%s/texttops '%s' '%s' '%s' '%s' ""                    ""page-top=36 page-bottom=36 page-left=36 page-right=36 ""                    ""nolandscape cpi=12 lpi=7 columns=1 wrap %s'""                    ""| %s/pstops  '%s' '%s' '%s' '%s' '%s'"",                    texttopspath, cups_jobid, cups_user, cups_jobtitle, cups_copies, cups_options,                    texttopspath, cups_jobid, cups_user, cups_jobtitle, cups_copies, cups_options);        }    }    free(cups_options);}",3,"cwe119,cwe120,cweother"
"print_tailhead(const char* type, struct text_object *obj, char *p, int p_max_size) {tint fd, i, endofstring = 0, linescounted = 0;tFILE *fp;tstruct stat st;tstruct headtail *ht = obj->data.opaque;tif (!ht)ttreturn;t tif(ht->buffer && ht->current_use >= ht->max_uses - 1) {ttfree(ht->buffer);ttht->buffer = NULL;ttht->current_use = 0;t}t tif(ht->buffer) {ttstrcpy(p, ht->buffer);ttht->current_use++;t}else{t ttif(stat(ht->logfile, &st) == 0) {tttif (S_ISFIFO(st.st_mode)) {ttttfd = open_fifo(ht->logfile, &ht->reported);ttttif(fd != -1) {tttttif(strcmp(type, ""head"") == 0) {ttttttfor(i = 0; linescounted < ht->wantedlines; i++) {tttttttread(fd, p + i, 1);tttttttif(p[i] == '') {ttttttttlinescounted++;ttttttt}tttttt}ttttttp[i] = 0;ttttt} else if(strcmp(type, ""tail"") == 0) {tttttti = read(fd, p, p_max_size - 1);tttttttailstring(p, i, ht->wantedlines);ttttt} else {ttttttCRIT_ERR(NULL, NULL, ""If you are seeing this then there is a bug in the code, report it !"");ttttt}tttt}ttttclose(fd);ttt} else {ttttfp = open_file(ht->logfile, &ht->reported);ttttif(fp != NULL) {tttttif(strcmp(type, ""head"") == 0) {ttttttfor(i = 0; i < ht->wantedlines; i++) {tttttttfgets(p + endofstring, p_max_size - endofstring, fp);tttttttendofstring = strlen(p);tttttt}ttttt} else if(strcmp(type, ""tail"") == 0) {ttttttfseek(fp, - p_max_size, SEEK_END);tttttti = fread(p, 1, p_max_size - 1, fp);tttttttailstring(p, i, ht->wantedlines);ttttt} else {ttttttCRIT_ERR(NULL, NULL, ""If you are seeing this then there is a bug in the code, report it !"");ttttt}tttttfclose(fp);tttt}ttt}tttht->buffer = strdup(p);tt} else {tttCRIT_ERR(NULL, NULL, ""$%s can't find information about %s"", type, ht->logfile);tt}t}treturn;}",3,"cwe120,cwe476,cweother"
"reply_quote_str(ENVELOPE *env){    char *prefix, *repl, *p, buf[MAX_PREFIX+1], pbf[MAX_SUBSTITUTION+1];    strncpy(buf, ps_global->VAR_REPLY_STRING, sizeof(buf)-1);    buf[sizeof(buf)-1] = '0';         if((p = strstr(buf, from_token)) != NULL){trepl = (env && env->from && env->from->mailbox) ? env->from->mailboxttttttt: """";tstrncpy(pbf, repl, sizeof(pbf)-1);tpbf[sizeof(pbf)-1] = '0';;trplstr(p, sizeof(buf)-(p-buf), strlen(from_token), pbf);    }        if((p = strstr(buf, nick_token)) != NULL){trepl = (env &&ttenv->from &&ttenv->from &&ttget_nickname_from_addr(env->from, tmp_20k_buf, 1000))tt ? tmp_20k_buf : """";tstrncpy(pbf, repl, sizeof(pbf)-1);tpbf[sizeof(pbf)-1] = '0';;trplstr(p, sizeof(buf)-(p-buf), strlen(nick_token), pbf);    }    if((p = strstr(buf, init_token)) != NULL){tchar *q = NULL;tchar  buftmp[MAILTMPLEN];tsnprintf(buftmp, sizeof(buftmp), ""%.200s"",t (env && env->from && env->from->personal) ? env->from->personal : """");tbuftmp[sizeof(buftmp)-1] = '0';trepl = (env && env->from && env->from->personal)tt ? reply_quote_initials(q = cpystr((char *)rfc1522_decode_to_utf8(tttttt(unsigned char *)tmp_20k_buf, ttttttSIZEOF_20KBUF, buftmp)))tt : """";tistrncpy(pbf, repl, sizeof(pbf)-1);tpbf[sizeof(pbf)-1] = '0';;trplstr(p, sizeof(buf)-(p-buf), strlen(init_token), pbf);tif(q)t  fs_give((void **)&q);    }        prefix = removing_quotes(cpystr(buf));    return(prefix);}",3,"cwe119,cwe120,cweother"
"main(int argc,char *argv[]){     std::ios::sync_with_stdio(false);  #ifdef FORMATDIR    char env[BUFF_SIZE];    snprintf(env, BUFF_SIZE, ""BABEL_LIBDIR=%s"", FORMATDIR);    putenv(env);  #endif  if (argc != 1)    {      cout << ""Usage: cansmih"";      cout << ""   Tests Open Babel canonical SMILES generation."" << endl;      return 0;    }    cout << endl << ""# Testing Canonical SMILES Generation ...  "";    std::ifstream mifs(smilestypes_file.c_str());  if (!mifs)    {      cout << ""Bail out! Cannot read test data "" << smilestypes_file << endl;      return -1;      }  OBConversion conv(&mifs, &cout);  if (! conv.SetInAndOutFormats(""SMI"",""CAN""))    {      cout << ""Bail out! SMILES format is not loaded"" << endl;      return -1;    }  unsigned int currentMol = 0;  OBMol mol, mol2;  string buffer;     while (getline(mifs, buffer))    {      mol.Clear();      if (!conv.ReadString(&mol, buffer)) {        cout << ""not ok "" << ++currentMol << "" # SMILES read failed""             << "" buffer was "" << buffer << """";        continue;      }      if (mol.Empty())        continue;      buffer = conv.WriteString(&mol);      mol2.Clear();      if (!conv.ReadString(&mol2, buffer)) {        cout << ""not ok "" << ++currentMol << "" # SMARTS did not match""             << "" for molecule "" << buffer << """";        continue;      }             if (mol.NumHvyAtoms() == mol2.NumHvyAtoms())        cout << ""ok "" << ++currentMol << "" # number of heavy atoms match"";      else        cout << ""not ok "" << ++currentMol << "" # number of heavy atoms wrong""             << "" for molecule "" << buffer << """";    }     cout << ""1.."" << currentMol << endl;     return 0;}",2,"cwe119,cwe120"
"spif_mbuff_prepend_from_ptr(spif_mbuff_t self, spif_byteptr_t other, spif_memidx_t len){    ASSERT_RVAL(!SPIF_MBUFF_ISNULL(self), FALSE);    REQUIRE_RVAL((other != SPIF_NULL_TYPE(byteptr)), FALSE);    if (len) {        self->size += len;        self->buff = SPIF_CAST(byteptr) REALLOC(self->buff, self->size);        memmove(self->buff + len, self->buff, self->len);        memcpy(self->buff, other, len);        self->len += len;    }    return TRUE;}",2,"cwe120,cweother"
"dns_config_find_zone(int *exact, char *name, int klass){    int znlen, buflen, match_len = -1;    char buf[DNS_NAME_MAX];    dns_config_root_t *root;    dns_config_zone_t *zone, *candidate = NULL;    if ((root = ConfigRoot) == NULL)        return NULL;    if (exact != NULL)        *exact = 0;    STRLCPY(buf, name, sizeof(buf));    STRLOWER(buf);    buflen = strlen(buf);    zone = DNS_CONFIG_ZONE_LIST_HEAD(&root->r_zone);    while (zone != NULL) {        if (zone->z_class != klass && klass != DNS_CLASS_ANY)            goto next;        znlen = strlen(zone->z_name);        if (znlen > buflen || znlen <= match_len)            goto next;        if (znlen == buflen || znlen == 0 || buf[buflen - znlen - 1] == '.') {            if (strcmp(&buf[buflen - znlen], zone->z_name) == 0) {                if (znlen == buflen) {                    if (exact != NULL)                        *exact = 1;                    plog(LOG_DEBUG, ""%s: found zone ""%s"" (exact match)"", MODULE, zone->z_name);                    return zone;                } else {                    candidate = zone;                    match_len = znlen;                }            }        }    next:        zone = DNS_CONFIG_ZONE_LIST_NEXT(&root->r_zone, zone);    }    if (candidate == NULL)        plog(LOG_DEBUG, ""%s: no zone found"", MODULE);    else        plog(LOG_DEBUG, ""%s: found zone ""%s"""", MODULE, candidate->z_name);    return candidate;}",2,"cwe119,cwe120"
"umount_multi_triggers(struct autofs_point *ap, struct mapent *me, char *root, const char *base){tchar path[PATH_MAX + 1];tchar *offset;tstruct mapent *oe;tstruct list_head *mm_root, *pos;tconst char o_root[] = ""/"";tconst char *mm_base;tint left, start;tleft = 0;tstart = strlen(root);tmm_root = &me->multi->multi_list;tif (!base)ttmm_base = o_root;telsettmm_base = base;tpos = NULL;toffset = path;twhile ((offset = cache_get_offset(mm_base, offset, start, mm_root, &pos))) {ttchar *oe_base;ttoe = cache_lookup_offset(mm_base, offset, start, &me->multi_list);tt ttif (!oe || !oe->mapent || (strlen(oe->key) - start) == 1)tttcontinue;tt ttoe_base = oe->key + strlen(root);ttleft += umount_multi_triggers(ap, oe, root, oe_base);ttif (oe->ioctlfd != -1 ||tt    is_mounted(_PROC_MOUNTS, oe->key, MNTS_REAL)) {tttleft++;tttcontinue;tt}ttdebug(ap->logopt, ""umount offset %s"", oe->key);ttif (umount_autofs_offset(ap, oe)) {tttwarn(ap->logopt, ""failed to umount offset"");tttleft++;tt} else {tttstruct stat st;tttint ret;tttif (!(oe->flags & MOUNT_FLAG_DIR_CREATED))ttttcontinue;ttt tttret = rmdir_path_offset(ap, oe);tttif (ret == -1 && !stat(oe->key, &st)) {ttttret = do_mount_autofs_offset(ap, oe, root, offset);ttttif (ret)tttttleft++;tttt ttttoe->flags |= MOUNT_FLAG_DIR_CREATED;ttt}tt}t}tif (!left && me->multi == me) {ttstruct mapent_cache *mc = me->mc;ttint status;tt ttif (is_mounted(_PATH_MOUNTED, root, MNTS_REAL)) {tttinfo(ap->logopt, ""unmounting dir = %s"", root);tttif (umount_ent(ap, root)) {ttttif (mount_multi_triggers(ap, me, root, strlen(root), ""/"") < 0)tttttwarn(ap->logopt,ttttt     ""failed to remount offset triggers"");ttttreturn left++;ttt}tt}tt ttstatus = cache_delete_offset_list(mc, me->key);ttif (status != CHE_OK)tttwarn(ap->logopt, ""couldn't delete offset list"");t}treturn left;}",2,"cwe119,cwe120"
"test_refs_revparse__try_to_retrieve_sha_before_branch(void){tgit_repository *repo;tgit_reference *branch;tgit_object *target;tchar sha[GIT_OID_HEXSZ + 1];trepo = cl_git_sandbox_init(""testrepo.git"");ttest_object_inrepo(""a65fedf39aefe402d3bb6e24df4d4f5fe4547750"", ""a65fedf39aefe402d3bb6e24df4d4f5fe4547750"", repo);tcl_git_pass(git_revparse_single(&target, repo, ""HEAD~3""));tcl_git_pass(git_branch_create(&branch, repo, ""a65fedf39aefe402d3bb6e24df4d4f5fe4547750"", (git_commit *)target, 0, NULL, NULL));tgit_oid_tostr(sha, GIT_OID_HEXSZ + 1, git_object_id(target));ttest_object_inrepo(""a65fedf39aefe402d3bb6e24df4d4f5fe4547750"", ""a65fedf39aefe402d3bb6e24df4d4f5fe4547750"", repo);ttest_object_inrepo(""heads/a65fedf39aefe402d3bb6e24df4d4f5fe4547750"", sha, repo);tgit_reference_free(branch);tgit_object_free(target);tcl_git_sandbox_cleanup();}",2,"cwe119,cwe120"
"tok_point_lookup(struct tok_point *out, const char *ptr,tttconst struct token_list *tl) {tsize_t line_count = tl->olines_size;ttmemset(out, 0, sizeof(*out));tif (!tl)ttreturn 0;ttif (ptr >= tl->txt && ptr <= tl->txt+tl->txt_size) {ttout->txt = ptr;ttout->line = find_line(ptr, tl->tlines, line_count);ttif (out->line < line_count) {tttout->col = ptr - tl->tlines[out->line];tttout->orig = tl->olines[out->line] + out->col;tt} else {tttout->col = 0;tttout->orig = tl->orig + tl->orig_size;tt}ttreturn 1;t} else if (ptr >= tl->orig && ptr <= tl->orig+tl->orig_size) {ttout->orig = ptr;ttout->line = find_line(ptr, tl->olines, line_count);ttif (out->line < line_count) {tttconst char *tline_start = tl->tlines[out->line];tttconst char *tline_end = out->line+1 < line_count ?tttttl->tlines[out->line+1] :tttttl->txt + tl->txt_size;ttttttout->col = ptr - tl->olines[out->line];tttout->txt = tline_start + out->col;ttttttif (out->txt > tline_end)ttttout->txt = tline_end;tt} else {tttout->col = 0;tttout->txt = tl->txt + tl->txt_size;tt}ttreturn 1;t} else {ttreturn 0;t}}",2,"cwe119,cwe120"
"""wtype_str_len(const char *str){  int i;  for (i = 0; str[i] && str[i]!= ' '; i++);  return i;}""",2,"cwe120,cweother"
"write_letter (struct file_info *finfo, int letter){    if (!really_quiet)    {tchar *tag = NULL;t tchar buf[80];tswitch (letter)t{t    case 'U':tttag = ""updated"";ttbreak;t    default:tt ttbreak;t}tif (tag != NULL)t{t    sprintf (buf, ""+%s"", tag);t    cvs_output_tagged (buf, NULL);t}tbuf[0] = letter;tbuf[1] = ' ';tbuf[2] = '0';tcvs_output_tagged (""text"", buf);tcvs_output_tagged (""fname"", finfo->fullname);tcvs_output_tagged (""newline"", NULL);tif (tag != NULL)t{t    sprintf (buf, ""-%s"", tag);t    cvs_output_tagged (buf, NULL);t}    }    return;}",2,"cwe119,cwe120"
"EasySymbolInput( int key, ChewingData *pgdata ){tint rtn, loop, _index;tchar wordbuf[ 8 ];tint nSpecial = EASY_SYMBOL_KEY_TAB_LEN;t_index = FindEasySymbolIndex( key );tif ( -1 != _index ) {ttfor ( loop = 0; loop < pgdata->static_data.g_easy_symbol_num[ _index ]; ++loop ) {tttueStrNCpy( wordbuf,ttttueStrSeek( pgdata->static_data.g_easy_symbol_value[ _index ],tttttloop),tttt1, 1 );tttrtn = _Inner_InternalSpecialSymbol(tttttkey, pgdata, key, wordbuf );tt}ttreturn SYMBOL_KEY_OK;t}trtn = InternalSpecialSymbol(tttkey, pgdata, nSpecial,tttG_EASY_SYMBOL_KEY, (const char **) pgdata->static_data.g_easy_symbol_value );tif ( rtn == ZUIN_IGNORE )ttrtn = SpecialSymbolInput( key, pgdata );treturn ( rtn == ZUIN_IGNORE ? SYMBOL_KEY_ERROR : SYMBOL_KEY_OK );}",2,"cwe119,cwe120"
"main(int argc, char *argv[]){    int instamp = 0;    int c;    const char *file;    FILE *fp;    time_t date;    struct tm *tm;    char timestamp[42];            if (argc != 2) {        usage();        return 1;    }    #ifdef HAVE_SETLOCALE# ifdef LC_MESSAGES    (void) setlocale(LC_MESSAGES, """");# endif# ifdef LC_CTYPE    (void) setlocale(LC_CTYPE, """");# endif# ifdef LC_COLLATE    (void) setlocale(LC_COLLATE, """");# endif#endif                    file = argv[1];    if (*file == '-' && file[1] == 0) {        fp = stdin;    } else {        if ((fp = fopen(file, ""r"")) == NULL) {            perror(""Can't open file: "");            return -1;        }    }    while ((c = getc(fp)) != EOF) {        if (instamp >= 0) {            if (isdigit(c)) {                if (instamp < (int) (sizeof timestamp - 1U)) {                    timestamp[instamp] = (char) c;                    instamp++;                }            } else {                timestamp[instamp] = 0;                instamp = -1;                date = (time_t) strtoul(timestamp, NULL, 10);                tm = localtime(&date);                printf(""%d/%02d/%02d %02d:%02d:%02d "",                       tm->tm_year + 1900,                       tm->tm_mon + 1,                       tm->tm_mday,                       tm->tm_hour,                       tm->tm_min,                       tm->tm_sec);            }        } else {            putchar(c);        }        if (c == '') {            fflush(fp);            instamp = 0;        }            }        return 0;}",3,"cwe119,cwe120,cweother"
"ReadMessageFile(struct MessageFile *fileptr){tstruct stat sb;tstruct tm *localtm;tFILE *fptr;tchar buffer[MESSAGELINELEN + 1];tchar *ch;tchar *final;tstruct MessageFileLine *NewLine,tttt*CurrentLine;tassert(fileptr != 0);tassert(fileptr->filename != 0);t tif (stat(fileptr->filename, &sb) < 0)ttreturn 0;  tlocaltm = localtime(&sb.st_mtime);tif (localtm)ttircsprintf(fileptr->DateLastChanged, ""%d/%d/%d %02d:%02d"",tt           localtm->tm_mday, localtm->tm_mon + 1, 1900 + localtm->tm_year,tt           localtm->tm_hour, localtm->tm_min);t twhile (fileptr->Contents != NULL)t{ttCurrentLine = fileptr->Contents->next;ttMyFree(fileptr->Contents->line);ttMyFree(fileptr->Contents);ttfileptr->Contents = CurrentLine;t}tif ((fptr = fopen(fileptr->filename, ""r"")) == NULL)ttreturn 0;tCurrentLine = NULL;twhile (fgets(buffer, sizeof(buffer), fptr))t{ttif ((ch = strchr(buffer, '')) != NULL)ttt*ch = '0';ttNewLine = MyMalloc(sizeof(struct MessageFileLine));ttif (*buffer != '0')tt{tttfinal = Substitute(NULL, buffer, NODCC);tttif (final && (final != (char *) -1))ttttNewLine->line = final;tttelsettttNewLine->line = MyStrdup("" "");tt}ttelsetttNewLine->line = MyStrdup("" "");ttNewLine->next = NULL;ttif (fileptr->Contents)tt{tttif (CurrentLine)ttttCurrentLine->next = NewLine;tttCurrentLine = NewLine;tt}ttelsett{tttfileptr->Contents = NewLine;tttCurrentLine = NewLine;tt}t}tfclose(fptr);treturn 1;}",3,"cwe119,cwe120,cweother"
"channel_member_names(struct Client *source_p, struct Channel *chptr,                     int show_eon){  struct Client *target_p = NULL;  struct Membership *ms = NULL;  struct Membership *source_ms = NULL;  dlink_node *ptr = NULL;  char lbuf[IRCD_BUFSIZE + 1];  char *t = NULL, *start = NULL;  int tlen = 0;  int is_member = IsMember(source_p, chptr);  int multi_prefix = HasCap(source_p, CAP_MULTI_PREFIX) != 0;  if ((chptr->mode.mode & MODE_AUDITORIUM) && !is_member)  {    sendto_one(source_p, form_str(RPL_ENDOFNAMES),               me.name, source_p->name, chptr->chname);    return;  }  if (PubChannel(chptr) || is_member)  {    t = lbuf + ircsprintf(lbuf, form_str(RPL_NAMREPLY),                          me.name, source_p->name,                          channel_pub_or_secret(chptr),                          chptr->chname);    start = t;    if (is_member) { source_ms = find_channel_link(source_p, chptr); }    DLINK_FOREACH(ptr, chptr->members.head)    {      ms       = ptr->data;      target_p = ms->client_p;      if (IsInvisible(target_p) && !is_member && !IsOper(source_p))      {        continue;      }      if (is_member)      {tif ((chptr->mode.mode & MODE_AUDITORIUM) && !(ms->flags & (CHFL_CHANOP | CHFL_HALFOP | CHFL_VOICE)) && !(source_ms->flags & (CHFL_CHANOP | CHFL_HALFOP | CHFL_VOICE)))t{t  continue;t}      }      tlen = strlen(target_p->name) + 1;         if (!multi_prefix)      {        if (ms->flags & (CHFL_CHANOP | CHFL_HALFOP | CHFL_VOICE))          ++tlen;      }      else      {        if (ms->flags & CHFL_CHANOP)          ++tlen;        if (ms->flags & CHFL_HALFOP)          ++tlen;        if (ms->flags & CHFL_VOICE)          ++tlen;      }      if (t + tlen - lbuf > IRCD_BUFSIZE - 2)      {        *(t - 1) = '0';        sendto_one(source_p, ""%s"", lbuf);        t = start;      }      t += ircsprintf(t, ""%s%s "", get_member_status(ms, multi_prefix),                      target_p->name);    }    if (tlen != 0)    {      *(t - 1) = '0';      sendto_one(source_p, ""%s"", lbuf);    }  }  if (show_eon)    sendto_one(source_p, form_str(RPL_ENDOFNAMES),               me.name, source_p->name, chptr->chname);}",2,"cwe119,cwe120"
"lj_debug_shortname(char *out, GCstr *str){  const char *src = strdata(str);  if (*src == '=') {    strncpy(out, src+1, LUA_IDSIZE);       out[LUA_IDSIZE-1] = '0';     } else if (*src == '@') {       size_t len = str->len-1;    src++;       if (len >= LUA_IDSIZE) {      src += len-(LUA_IDSIZE-4);         *out++ = '.'; *out++ = '.'; *out++ = '.';    }    strcpy(out, src);  } else {       size_t len;       for (len = 0; len < LUA_IDSIZE-12; len++)      if (((const unsigned char *)src)[len] < ' ') break;    strcpy(out, ""[string """"); out += 9;    if (src[len] != '0') {  /* Must truncate? */      if (len > LUA_IDSIZE-15) len = LUA_IDSIZE-15;      strncpy(out, src, len); out += len;      strcpy(out, ""...""); out += 3;    } else {      strcpy(out, src); out += len;    }    strcpy(out, """"]"");  }}",2,"cwe119,cwe120"
"parseAtPath(const char *url, char **path){tPRStatus status = PR_SUCCESS;tchar *dir = ""%s%s""; t*path = (char *)PR_Calloc(1, strlen(dir) + strlen(url) + 2);tif (!*path) {tt ttstatus = PR_FAILURE;ttgoto out;t}t tif ('/' != *url) {ttsprintf(*path, dir, ""/"", url);t} else {ttstrcpy(*path, url);t}out:treturn status;}",2,"cwe120,cweother"
"syslog_rotate(void){tchar tmp_name[MAX_PATH_SIZE];tint fd;tif( initflag == 0)ttreturn;t tif (log_file == NULL)ttreturn;#if defined(COMPILE_DEBUG)tdebug(2, ""rotating log file '%.*s'"",t         MAX_PATH_SIZE, log_name);#endiftsyslog_write(T_INF, ""rotating log file '%.*s'"",t                    MAX_PATH_SIZE, log_name);tfclose(log_file);tlog_file = NULL;tif(syslog_rename(tmp_name, log_name, sizeof(tmp_name))<0) {ttmisc_die(FL, ""can't rotate logfile '%.*s'"",tttMAX_PATH_SIZE, log_name);t}tif ((fd = open(log_name, O_RDWR | O_CREAT | O_EXCL,tttttt0640)) < 0) {ttmisc_die(FL, ""can't open logfile '%.*s'"",tttttMAX_PATH_SIZE, log_name);t}tif ((log_file = fdopen(fd, ""w"")) == NULL) {ttmisc_die(FL, ""can't open logfile '%.*s'"",tttttMAX_PATH_SIZE, log_name);t}}",3,"cwe119,cwe120,cweother"
"dump_initialize( char *prefix ){    int i=0;    FILE *f;    char ofn[1024];    struct pcap_file_header pfh;    if ( prefix == NULL) {        return( 0 );    }         if( strlen( prefix ) >= sizeof( ofn ) - 10 )        prefix[sizeof( ofn ) - 10] = '0';         memset( ofn, 0, sizeof( ofn ) );    opt.f_index = 1;    do    {        snprintf( ofn,  sizeof( ofn ) - 1, ""%s-%02d.%s"",                    prefix, opt.f_index, ""cap"" );        if( ( f = fopen( ofn, ""rb+"" ) ) != NULL )        {            fclose( f );            opt.f_index++;            continue;        }        i++;    }    while( i < 1 );    opt.prefix = (char*) malloc(strlen(prefix)+2);    snprintf(opt.prefix, strlen(prefix)+1, ""%s"", prefix);         snprintf( ofn,  sizeof( ofn ) - 1, ""%s-%02d.cap"",                prefix, opt.f_index );    if( ( opt.f_cap = fopen( ofn, ""wb+"" ) ) == NULL )    {        perror( ""fopen failed"" );        fprintf( stderr, ""Could not create ""%s""."", ofn );        return( 1 );    }    opt.f_cap_name = (char*) malloc(128);    snprintf(opt.f_cap_name, 127, ""%s"",ofn);    pfh.magic           = TCPDUMP_MAGIC;    pfh.version_major   = PCAP_VERSION_MAJOR;    pfh.version_minor   = PCAP_VERSION_MINOR;    pfh.thiszone        = 0;    pfh.sigfigs         = 0;    pfh.snaplen         = 65535;    pfh.linktype        = LINKTYPE_IEEE802_11;    if( fwrite( &pfh, 1, sizeof( pfh ), opt.f_cap ) !=                (size_t) sizeof( pfh ) )    {        perror( ""fwrite(pcap file header) failed"" );        return( 1 );    }    if(!opt.quiet)    {        PCT; printf(""Created capture file ""%s""."", ofn);    }    return( 0 );}",3,"cwe119,cwe120,cweother"
"gt_strgraph_load(GtStrgraph *strgraph, GtFile *infp){  GT_UNUSED int read;  GtStrgraphVnum n_vertices;  read = gt_file_xread(infp, (void*)&n_vertices, sizeof (GtStrgraphVnum));  gt_assert(read == (int)sizeof (GtStrgraphVnum));  GT_STRGRAPH_SET_NOFVERTICES(strgraph, n_vertices);  GT_STRGRAPH_ALLOC_VERTICES(strgraph);  GT_STRGRAPH_DESERIALIZE_VERTICES(strgraph, infp);  GT_STRGRAPH_ALLOC_EDGES(strgraph);  GT_STRGRAPH_DESERIALIZE_EDGES(strgraph, infp);}",2,"cwe120,cweother"
"html_load_file(struct html_output *output, int fd){tfilestat_t sb;tsize_t size = 0;tvoid *p = MAP_FAILED;tchar *buf = NULL;tint ret = -1;tif (fstat(fd, &sb)) {ttperror(""open"");ttgoto error;t}tif (!S_ISREG(sb.st_mode)) {ttg_warning(""not a regular file"");ttgoto error;t}tif (sb.st_size < 0 || UNSIGNED(sb.st_size) >= (size_t)-1) {ttg_warning(""file is too large"");ttgoto error;t}tsize = sb.st_size;#ifdef HAS_MMAPt tp = vmm_mmap(0, size, PROT_READ, MAP_PRIVATE, fd, 0);tif (MAP_FAILED == p) {ttperror(""open"");ttgoto error;t}tfd_forget_and_close(&fd);#elset{ttsize_t left = size;ttbuf = g_malloc(size);ttp = buf;ttwhile (left > 0) {tttssize_t n = read(fd, &buf[size - left], left);tttif ((ssize_t) -1 == n || 0 == n)ttttgoto error;tttleft -= n;tt}t}#endiftret = html_load_memory(output, array_init(p, size));error:tfd_forget_and_close(&fd);tG_FREE_NULL(buf);#ifdef HAS_MMAPtif (MAP_FAILED != p) {ttvmm_munmap(p, size);t}#endift treturn ret;}",2,"cwe120,cweother"
"""getreal()   {   double n;   register int c, d, e;   int esign;   register char *s, *ep;   char cbuf[128];   s = cbuf;   d = 0;   while ((c = getc(infile)) == '0')      ;   while (c >= '0' && c <= '9') {      *s++ = c;      d++;      c = getc(infile);      }   if (c == '.') {      if (s == cbuf)         *s++ = '0';      *s++ = c;      while ((c = getc(infile)) >= '0' && c <= '9')         *s++ = c;      }   ep = s;   if (c == 'e' || c == 'E') {      *s++ = c;      if ((c = getc(infile)) == '+' || c == '-') {         esign = (c == '-');         *s++ = c;         c = getc(infile);         }      else         esign = 0;      e = 0;      while (c >= '0' && c <= '9') {         e = e * 10 + c - '0';         *s++ = c;         c = getc(infile);         }      if (esign) e = -e;      e += d - 1;      if (abs(e) >= LogHuge)         *ep = '0';      }   *s = '0';   n = atof(cbuf);   nlflag = (c == '');   return n;   }""",3,"cwe119,cwe120,cweother"
"open_log(int log_num, int flags){  char buf[FILENAME_MAX];  time_t now;  struct tm *tmptr;  char log_buffer[ALIVE_BUFFSIZ+1];  int lfd;     sn_printf(buf, sizeof(buf), ""%s/%s%d"",t    log_dir, LOG_STUBNAME, next_log(log_num));  unlink(buf);     sn_printf(buf, sizeof(buf), ""%s/%s%d"", log_dir, LOG_STUBNAME, log_num);  if((lfd = sf_open(buf, flags, LOG_PERM))<0){      ERRNO_ERR1(LOG_ERR,""Can't open log file '%s'."", buf);    exit(1);  }     time(&now);  if (log_alive_in_gmt) {      tmptr = gmtime(&now);  } else {      tmptr = localtime(&now);  }  if (!strftime(log_buffer, ALIVE_BUFFSIZ, log_alive_format,tttmptr)) {      strn_cpy(log_buffer, sizeof(log_buffer),t      ""(could not format time in 256 positions ""t      ""with current format string.)"");  }  log_buffer[ALIVE_BUFFSIZ] = '0';  sn_printf(buf, sizeof(buf), ""========== LOGGING STARTED %s====="",t    log_buffer);  if (write_all(lfd, buf, strlen(buf)) < 0)      status(""Error in writing to log."");#if USE_FSYNC  fsync(lfd);#endif  return lfd;}",2,"cwe119,cwe120"
"xsh_get_xcorrel_peak(cpl_vector* wcorr, cpl_vector* fcorr,XSH_GAUSSIAN_FIT* gfit,const double range,const int ext){  int size_x;  cpl_table* tab = NULL;  cpl_table* ext_tab;  char fname[256];  cpl_vector* wave=NULL;  cpl_vector* flux=NULL;  size_x=cpl_vector_get_size(wcorr);  tab = cpl_table_new(size_x);  cpl_table_wrap_double(tab, cpl_vector_get_data(wcorr), ""logwave"");  cpl_table_wrap_double(tab, cpl_vector_get_data(fcorr), ""flux"");  sprintf(fname, ""fcorr_org.fits"");     cpl_table_and_selected_double(tab, ""logwave"", CPL_GREATER_THAN,      (*gfit).peakpos - range);  cpl_table_and_selected_double(tab, ""logwave"", CPL_LESS_THAN,      (*gfit).peakpos + range);  ext_tab = cpl_table_extract_selected(tab);  xsh_free_table(&tab);  sprintf(fname, ""fcorr_ext.fits"");     int next = 0;  next = cpl_table_get_nrow(ext_tab);  sprintf(fname, ""fcorr_tab.fits"");     double peakpos=0;  double sigma=0;      double area=0;      double offset=0;      double mse=0;  wave = cpl_vector_wrap(next, cpl_table_get_data_double(ext_tab, ""logwave""));  flux = cpl_vector_wrap(next, cpl_table_get_data_double(ext_tab, ""flux""));     cpl_vector_fit_gaussian( wave, NULL, flux,NULL, CPL_FIT_ALL,       &peakpos, &sigma,&area, &offset, &mse,NULL,NULL);     cpl_vector_fit_gaussian( wave, NULL, flux,NULL, CPL_FIT_ALL,      &gfit->peakpos, &gfit->sigma,&gfit->area, &gfit->offset, &gfit->mse,NULL,NULL);        cleanup:  cpl_vector_unwrap(wave);  cpl_vector_unwrap(flux);           xsh_free_table(&ext_tab);  return cpl_error_get_code();}",2,"cwe119,cwe120"
"ast_mktime(struct ast_tm *tmp, const char *zone){tconst struct state *sp;tif (!(sp = ast_tzset(zone)))ttreturn WRONG;treturn time1(tmp, localsub, 0L, sp);}",2,"cwe119,cwe120"
"explain_buffer_errno_select_explanation(explain_string_buffer_t *sb,    int errnum, const char *syscall_name, int nfds, fd_set *readfds,    fd_set *writefds, fd_set *exceptfds, struct timeval *timeout){         switch (errnum)    {    case EBADF:        {            int             fildes;            for (fildes = 0; fildes < nfds; ++fildes)            {                if                (                    (                        (readfds && FD_ISSET(fildes, readfds))                    ||                        (writefds && FD_ISSET(fildes, writefds))                    ||                        (exceptfds && FD_ISSET(fildes, exceptfds))                    )                &&                    !file_descriptor_is_open(fildes)                )                    break;            }            if (fildes < nfds)            {                char            caption[40];                snprintf(caption, sizeof(caption), ""fildes %d"", fildes);                explain_buffer_ebadf(sb, fildes, caption);            }            else            {                explain_string_buffer_puts                (                    sb,                    ""an invalid file descriptor was given in one of the sets; ""                    ""perhaps a file descriptor that was already closed, or one ""                    ""on which an error has occurred""                );            }        }        break;    case EFAULT:        if (readfds && explain_is_efault_pointer(readfds, sizeof(*readfds)))        {            explain_buffer_efault(sb, ""readfds"");            break;        }        if        (            writefds        &&            explain_is_efault_pointer(writefds, sizeof(*writefds))        )        {            explain_buffer_efault(sb, ""writefds"");            break;        }        if        (            exceptfds        &&            explain_is_efault_pointer(exceptfds, sizeof(*exceptfds))        )        {            explain_buffer_efault(sb, ""exceptfds"");            break;        }        if (timeout && explain_is_efault_pointer(timeout, sizeof(*timeout)))        {            explain_buffer_efault(sb, ""timeout"");            break;        }        break;    case EINTR:        explain_buffer_eintr(sb, syscall_name);        break;    case EINVAL:        if (nfds < 0)        {            explain_string_buffer_puts(sb, ""nfds is negative"");            break;        }        if ((unsigned)nfds > (unsigned)FD_SETSIZE)        {            explain_string_buffer_puts            (                sb,                ""nfds is greater than FD_SETSIZE""            );            if (explain_option_dialect_specific())                explain_string_buffer_printf(sb, "" (%d)"", FD_SETSIZE);            break;        }        if (timeout && (timeout->tv_sec < 0 || timeout->tv_usec < 0))        {            explain_string_buffer_puts(sb, ""timeout is invalid"");            break;        }        break;    case ENOMEM:        explain_buffer_enomem_kernel(sb);        break;    default:        explain_buffer_errno_generic(sb, errnum, syscall_name);        break;    }}",2,"cwe119,cwe120"
"InsertFileAfter (struct Item **filestart,struct Item *ptr,char *string){ struct Item *ip;  char *sp;  FILE *fp;  char linebuf[CF_BUFSIZE];EditVerbose(""Edit: Inserting file %s "",string);if ((fp=fopen(string,""r"")) == NULL)   {   Verbose(""Could not open file %s"",string);   return;   }while(!feof(fp) && ReadLine(linebuf,CF_BUFSIZE,fp))   {   if ((ip = (struct Item *)malloc(sizeof(struct Item))) == NULL)      {      CfLog(cferror,"""",""Can't allocate memory in InsertItemAfter()"");      FatalError("""");      }      if ((sp = malloc(strlen(linebuf)+1)) == NULL)      {      CfLog(cferror,"""",""Can't allocate memory in InsertItemAfter()"");      FatalError("""");      }   if (CURRENTLINEPTR == NULL)      {      if (*filestart == NULL)         {         *filestart = ip;         ip->next = NULL;         }      else         {         ip->next = (*filestart)->next;         (*filestart)->next = ip;              }            strcpy(sp,linebuf);      ip->name = sp;      ip->classes = NULL;      CURRENTLINEPTR = ip;      CURRENTLINENUMBER = 1;      }    else      {      ip->next = CURRENTLINEPTR->next;      CURRENTLINEPTR->next = ip;      CURRENTLINEPTR=ip;      CURRENTLINENUMBER++;      strcpy(sp,linebuf);      ip->name = sp;      ip->classes = NULL;      }   }NUMBEROFEDITS++;fclose(fp); return;}",4,"cwe119,cwe120,cwe469,cweother"
"shell_version_string (){  static char tt[32] = { '0' };  if (tt[0] == '0')    {      if (release_status)#if defined (HAVE_SNPRINTF)tsnprintf (tt, sizeof (tt), ""%s.%d(%d)-%s"", dist_version, patch_level, build_version, release_status);#elsetsprintf (tt, ""%s.%d(%d)-%s"", dist_version, patch_level, build_version, release_status);#endif      else#if defined (HAVE_SNPRINTF)tsnprintf (tt, sizeof (tt), ""%s.%d(%d)"", dist_version, patch_level, build_version);#elsetsprintf (tt, ""%s.%d(%d)"", dist_version, patch_level, build_version);#endif    }  return tt;}",2,"cwe119,cwe120"
"str_n_from_c(const char *s, size_t length){    str_hash_ty     hash;    str_hash_ty     idx;    string_ty       *p;    hash = hash_generate(s, length);#ifdef DEBUG    if (!hash_table)        fatal_raw(""you must call str_initialize early in main()"");#endif    idx = hash & hash_mask;    assert(idx < hash_modulus);    for (p = hash_table[idx]; p; p = p->str_next)    {        if        (            p->str_hash == hash        &&            p->str_length == length        &&            0 == memcmp(p->str_text, s, length)        )        {            p->str_references++;            return p;        }    }    p = mem_alloc(sizeof(string_ty) + length);    p->str_hash = hash;    p->str_length = length;    p->str_references = 1;    p->str_next = hash_table[idx];    hash_table[idx] = p;#if 0         {                         size_t n = sizeof(string_ty) - offsetof(string_ty, str_text);            memset(p->str_text, 0, n);    }#endif    memcpy(p->str_text, s, length);    p->str_text[length] = 0;    hash_load++;    if (hash_load * 10 > hash_modulus * 8)        split();    return p;}",2,"cwe120,cweother"
"krb5_DES_random_to_key(krb5_context context,tt       krb5_keyblock *key,tt       const void *data,tt       size_t size){    DES_cblock *k = key->keyvalue.data;    memcpy(k, data, key->keyvalue.length);    DES_set_odd_parity(k);    if(DES_is_weak_key(k))t_krb5_xor(k, (const unsigned char*)""0000000xf0"");}",2,"cwe120,cweother"
"jtagmkII_write_SABaddr(PROGRAMMER * pgm, unsigned long addr,                                  unsigned int prefix, unsigned long val){  unsigned char buf[10], *resp;  int status;  buf[0] = CMND_WRITE_SAB;  buf[1] = prefix;  u32_to_b4r(&buf[2], addr);  u32_to_b4r(&buf[6], val);  if(jtagmkII_send(pgm, buf, 10) < 0)    return -1;  status = jtagmkII_recv(pgm, &resp);  if(status <= 0 || resp[0] != RSP_OK) {    if (verbose >= 2)      putc('', stderr);    fprintf(stderr,t      ""%s: jtagmkII_write_SABaddr(): ""t      ""timeout/error communicating with programmer (status %d)"",t      progname, status);    return -1;  }  if (verbose) {    if (verbose >= 2)      putc('', stderr);    fprintf(stderr,t      ""%s: jtagmkII_write_SABaddr(): ""t      ""OCD Register %lx -> %4.4lx"",t      progname, addr, val);  }  return 0;}",2,"cwe119,cwe120"
"SendChatMessage(void){    char buffer[sizeof(outgoing_chat)+sizeof(simplemsg)+sizeof(network_player->playername)+2];    simplemsg *m=(simplemsg *)buffer;    short l;    if(!*outgoing_chat)        return;    memcpy(m->hdr,SERVER_HEADER,4);    m->type=MSG_CHAT;    sprintf(buffer+sizeof(simplemsg),""%s: %s"",network_player->playername,outgoing_chat);    l=strlen(buffer+sizeof(simplemsg));    m->size=htons(l);    SockWrite(network_player->socket,buffer,sizeof(simplemsg)+l);    *outgoing_chat=0;}",2,"cwe119,cwe120"
"export_msg_att(long int msgno, ATTACH_S *a){    char      filename[MAXPATH+1], full_filename[MAXPATH+1], *err;    intt      rv, rflags = GER_NONE, i = 1;    ATTACH_S *ap = a;    STORE_S  *store;    static HISTORY_S *history = NULL;    static ESCKEY_S opts[] = {t{ctrl('T'), 10, ""^T"", N_(""To Files"")},t{-1, 0, NULL, NULL},t{-1, 0, NULL, NULL}};    if(F_ON(F_ENABLE_TAB_COMPLETE,ps_global)){topts[i].ch    =  ctrl('I');topts[i].rval  = 11;topts[i].name  = ""TAB"";topts[i].label = N_(""Complete"");    }    filename[0] = full_filename[0] = '0';    rv = get_export_filename(ps_global, filename, NULL, full_filename,ttt     sizeof(filename), ""msg attachment"",ttt      ttt     _(""MSG ATTACHMENT""), opts,ttt     &rflags, -FOOTER_ROWS(ps_global),ttt     GE_IS_EXPORT | GE_SEQ_SENSITIVE, &history);    if(rv < 0){tswitch(rv){t  case -1:t    cmd_cancelled(""Export"");t    break;t  case -2:t    q_status_message1(SM_ORDER, 0, 2,ttt      _(""Can't export to file outside of %s""),ttt      ps_global->VAR_OPER_DIR);t    break;t}treturn;    }         if((store = so_get(FileStar, full_filename, WRITE_ACCESS)) != NULL){tif((err = write_attached_msg(msgno, &ap, store, !(rflags & GER_APPEND))) != NULL)t  q_status_message(SM_ORDER | SM_DING, 3, 4, err);telse          q_status_message3(SM_ORDER, 0, 4,ttt  _(""Attached message (part %s) %s to ""%s""""),ttt    a->number, ttt    rflags & GER_OVERttt      ? _(""overwritten"")ttt      : rflags & GER_APPEND ? _(""appended"") : _(""written""),ttt    full_filename);tif(so_give(&store))t  q_status_message2(SM_ORDER | SM_DING, 3, 4,ttt   _(""Error writing %s: %s""),ttt   full_filename, error_description(errno));    }    else      q_status_message2(SM_ORDER | SM_DING, 3, 4,tt     tt    _(""Error opening file ""%s"" to export message: %s""),tttfull_filename, error_description(errno));}",2,"cwe119,cwe120"
"stream_read (GMimeStream *stream, char *buf, size_t len){tGMimeStreamFs *fs = (GMimeStreamFs *) stream;tssize_t nread;ttif (fs->fd == -1) {tterrno = EBADF;ttreturn -1;t}ttif (stream->bound_end != -1 && stream->position >= stream->bound_end) {tterrno = EINVAL;ttreturn -1;t}ttif (stream->bound_end != -1)ttlen = (size_t) MIN (stream->bound_end - stream->position, (gint64) len);tt tlseek (fs->fd, (off_t) stream->position, SEEK_SET);ttdo {ttnread = read (fs->fd, buf, len);t} while (nread == -1 && errno == EINTR);ttif (nread > 0) {ttstream->position += nread;t} else if (nread == 0) {ttfs->eos = TRUE;t}ttreturn nread;}",2,"cwe120,cweother"
"safe_fread(void *ptr, size_t nmemb, FILE *stream){tsize_t ret;tchar *p = (char*)ptr;tdo {ttclearerr(stream);tterrno = 0;ttret = fread(p, 1, nmemb, stream);ttp += ret;ttnmemb -= ret;t} while (nmemb && ferror(stream) && errno == EINTR);treturn p - (char*)ptr;}",2,"cwe119,cwe120"
"main ( int argc, char** argv ){    FILE* fp = NULL;    void *yyscanner=0;    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;    #ifdef TEST_IS_REENTRANT    test_opt_r_CFlex_init(&yyscanner);#endif#ifdef TEST_HAS_TABLES_EXTERNAL    if((fp  = fopen(argv[1],""r""))== NULL)        yy_fatal_error(""could not open tables file for reading"" , yyscanner);    if(yytables_fload(fp , yyscanner) < 0)        yy_fatal_error(""yytables_fload returned < 0"" , yyscanner);    if(0)        exit(0);#endif        if(argc > 2){        if((fp  = fopen(argv[2],""r""))== NULL)            yy_fatal_error(""could not open input file for reading"" , yyscanner);        yyin = fp;    }    while(test_opt_r_CFlex(yyscanner) != 0)        ;        #ifdef TEST_HAS_TABLES_EXTERNAL    yytables_destroy(yyscanner);#endif    test_opt_r_CFlex_destroy(yyscanner);    if(argc < 0)          yyscanner = (void*)fp;    return 0;}",2,"cwe476,cweother"
"start_vboxtoau(int samplemode, int samplerate){tvaheader_ttheader;tintt      compression;tint t      result;tvboxtmpfile = NULL;ttsignal(SIGINT , leave_vboxtoau);tsignal(SIGQUIT, leave_vboxtoau);tsignal(SIGTERM, leave_vboxtoau);tsignal(SIGHUP , leave_vboxtoau);tsignal(SIGPIPE, leave_vboxtoau);ttif (!(vboxtmpfile = tmpfile()))t{ttsprintf(perrormsg, ""%s: can't create tmpfile"", vbasename);ttperror(perrormsg);ttleave_vboxtoau(255);t}tif (fread(&header, sizeof(vaheader_t), 1, stdin) != 1)t{ttsprintf(perrormsg, ""%s: can't read vbox audio header"", vbasename);ttperror(perrormsg);ttleave_vboxtoau(255);t}tif (strncmp(header.magic, VAH_MAGIC, VAH_MAX_MAGIC) != 0)t{ttfprintf(stderr, ""%s: sample contains no vbox audio header."", vbasename);ttttleave_vboxtoau(255);t}tcompression = (int)ntohl(header.compression);tresult = 255;tswitch (compression)t{ttcase 2:ttcase 3:ttcase 4:tttresult = convert_adpcm_to_pvf(compression, stdin, vboxtmpfile);tttbreak;ttcase 6:tttresult = convert_ulaw_to_pvf(stdin, vboxtmpfile);tttbreak;ttdefault:tttfprintf(stderr, ""%s: unknown/unsupported compression %d."", vbasename, compression);tttbreak;t}tif (result == 0)t{ttresult = convert_pvf_to_au(samplemode, samplerate, vboxtmpfile, stdout);t}tleave_vboxtoau(result);}",2,"cwe120,cweother"
"emitXSessC(struct display *di, struct display *d, void *ctx){    const char *dname;    char *bp;    char cbuf[1024];    bp = cbuf;    *bp++ = 't';    dname = displayName(di);    strCatL(&bp, dname, sizeof(cbuf) / 2);    *bp++ = ',';#ifdef HAVE_VTS    if (di->serverVT)        bp += sprintf(bp, ""vt%d"", di->serverVT);#endif    *bp++ = ',';#ifdef XDMCP    if (di->status == remoteLogin) {        *bp++ = ',';        strCatL(&bp, di->remoteHost, sizeof(cbuf) / 3);    } else#endif    {        if (di->userName)            strCatL(&bp, di->userName, sizeof(cbuf) / 5);        *bp++ = ',';        if (di->sessName)            strCatL(&bp, di->sessName, sizeof(cbuf) / 5);    }    *bp++ = ',';    if (di == d)        *bp++ = '*';    if (di->userSess >= 0 &&        (d ? (d->userSess != di->userSess &&              (d->allowNuke == SHUT_NONE ||               (d->allowNuke == SHUT_ROOT && d->userSess))) :             !fifoAllowNuke))        *bp++ = '!';    writer((int)(long)ctx, cbuf, bp - cbuf);}",2,"cwe119,cwe120"
"may_unmount(const char *mnt, int quiet){tstruct mntent *entp;tFILE *fp;tconst char *user = NULL;tchar uidstr[32];tunsigned uidlen = 0;tint found;tconst char *mtab = _PATH_MOUNTED;tuser = get_user_name();tif (user == NULL)ttreturn -1;tfp = setmntent(mtab, ""r"");tif (fp == NULL) {ttfprintf(stderr, ""%s: failed to open %s: %s"", progname, mtab,tttstrerror(errno));ttreturn -1;t}tuidlen = sprintf(uidstr, ""%u"", getuid());tfound = 0;twhile ((entp = getmntent(fp)) != NULL) {ttif (!found && strcmp(entp->mnt_dir, mnt) == 0 &&tt    (strcmp(entp->mnt_type, ""fuse"") == 0 ||tt     strcmp(entp->mnt_type, ""fuseblk"") == 0 ||tt     strncmp(entp->mnt_type, ""fuse."", 5) == 0 ||tt     strncmp(entp->mnt_type, ""fuseblk."", 8) == 0)) {tttchar *p = strstr(entp->mnt_opts, ""user="");tttif (p &&ttt    (p == entp->mnt_opts || *(p-1) == ',') &&ttt    strcmp(p + 5, user) == 0) {ttttfound = 1;ttttbreak;ttt}ttt tttelse if ((p =tttt  strstr(entp->mnt_opts, ""user_id="")) &&tttt (p == entp->mnt_opts ||tttt  *(p-1) == ',') &&tttt strncmp(p + 8, uidstr, uidlen) == 0 &&tttt (*(p+8+uidlen) == ',' ||tttt  *(p+8+uidlen) == '0')) {ttttfound = 1;ttttbreak;ttt}tt}t}tendmntent(fp);tif (!found) {ttif (!quiet)tttfprintf(stderr,tttt""%s: entry for %s not found in %s"",ttttprogname, mnt, mtab);ttreturn -1;t}treturn 0;}",2,"cwe119,cwe120"
"hash_driver_work(struct thr_info *mythr){tstruct timeval tv_start = {0, 0}, tv_end;tstruct cgpu_info *cgpu = mythr->cgpu;tstruct device_drv *drv = cgpu->drv;tconst int thr_id = mythr->id;tint64_t hashes_done = 0;twhile (likely(!cgpu->shutdown)) {ttstruct timeval diff;ttint64_t hashes;#ifndef USE_AVALON2ttmythr->work_update = false;#endiftthashes = drv->scanwork(mythr);#ifndef USE_AVALON2tt ttmythr->work_restart = false;#endifttif (unlikely(hashes == -1 )) {tttapplog(LOG_ERR, ""%s %d failure, disabling!"", drv->name, cgpu->device_id);tttcgpu->deven = DEV_DISABLED;tttdev_error(cgpu, REASON_THREAD_ZERO_HASH);tttbreak;tt}tthashes_done += hashes;ttcgtime(&tv_end);tttimersub(&tv_end, &tv_start, &diff);tt ttif ((hashes_done && (diff.tv_sec > 0 || diff.tv_usec > 200000)) ||tt    diff.tv_sec >= opt_log_interval) {ttthashmeter(thr_id, hashes_done);ttthashes_done = 0;tttcopy_time(&tv_start, &tv_end);tt}ttif (unlikely(mythr->pause || cgpu->deven != DEV_ENABLED))tttmt_disable(mythr, thr_id, drv);ttif (mythr->work_update)tttdrv->update_work(cgpu);t}tcgpu->deven = DEV_DISABLED;}",2,"cwe119,cwe120"
"element_getattro(ElementObject* self, PyObject* nameobj){    PyObject* res;    char *name = """";    if (PyUnicode_Check(nameobj))        name = _PyUnicode_AsString(nameobj);    if (name == NULL)        return NULL;         if (strcmp(name, ""tag"") == 0) {        res = self->tag;        Py_INCREF(res);        return res;    } else if (strcmp(name, ""text"") == 0) {        res = element_get_text(self);        Py_XINCREF(res);        return res;    }         res = PyObject_GenericGetAttr((PyObject*) self, nameobj);    if (res)        return res;         if (strcmp(name, ""tail"") == 0) {        PyErr_Clear();        res = element_get_tail(self);    } else if (strcmp(name, ""attrib"") == 0) {        PyErr_Clear();        if (!self->extra) {            if (create_extra(self, NULL) < 0)                return NULL;        }        res = element_get_attrib(self);    }    if (!res)        return NULL;    Py_INCREF(res);    return res;}",2,"cwe469,cweother"
"redisLog(int level, const char *fmt, ...) {    va_list ap;    FILE *fp;    fp = (server.logfile == NULL) ? stdout : fopen(server.logfile,""a"");    if (!fp) return;    va_start(ap, fmt);    if (level >= server.verbosity) {        char *c = "".-*"";        char buf[64];        time_t now;        now = time(NULL);        strftime(buf,64,""%d %b %H:%M:%S"",localtime(&now));        fprintf(fp,""%s %c "",buf,c[level]);        vfprintf(fp, fmt, ap);        fprintf(fp,"""");        fflush(fp);    }    va_end(ap);    if (server.logfile) fclose(fp);}",3,"cwe119,cwe120,cweother"
"process_args(int argc, char **argv, int multi){  int total_length, i, ret, quit;  char *line;  total_length = 0;  for(i=0; i<argc; i++) {    total_length += strlen(argv[i]) + 1;  }  line = (char *) malloc((2 + total_length) * sizeof(char));  for (i = 0; i < argc; i++) {    line[0] = '0';    if (multi) {      strcat(line, argv[i]);    } else {      for (; i < argc; i++) {        strcat(line, argv[i]);        if (i + 1 < argc)          strcat(line, "" "");      }    }    ret = process_line(line, &quit);    if (!ret || quit)      break;  }  free(line);  return ret;}",2,"cwe120,cwe469"
"led_classdev_register(struct device *parent, struct led_classdev *led_cdev){tchar name[64];tint ret;tret = led_classdev_next_name(led_cdev->name, name, sizeof(name));tif (ret < 0)ttreturn ret;tled_cdev->dev = device_create_with_groups(leds_class, parent, 0,ttttled_cdev, led_cdev->groups, ""%s"", name);tif (IS_ERR(led_cdev->dev))ttreturn PTR_ERR(led_cdev->dev);tif (ret)ttdev_warn(parent, ""Led %s renamed to %s due to name collision"",ttttled_cdev->name, dev_name(led_cdev->dev));#ifdef CONFIG_LEDS_TRIGGERStinit_rwsem(&led_cdev->trigger_lock);#endiftmutex_init(&led_cdev->led_access);t tdown_write(&leds_list_lock);tlist_add_tail(&led_cdev->node, &leds_list);tup_write(&leds_list_lock);tif (!led_cdev->max_brightness)ttled_cdev->max_brightness = LED_FULL;tled_cdev->flags |= SET_BRIGHTNESS_ASYNC;tled_update_brightness(led_cdev);tled_init_core(led_cdev);#ifdef CONFIG_LEDS_TRIGGERStled_trigger_set_default(led_cdev);#endiftdev_dbg(parent, ""Registered led device: %s"",tttled_cdev->name);treturn 0;}",2,"cwe119,cwe120"
"module_register(char *name, Function *funcs, int major, int minor){  module_entry *p;  for (p = module_list; p && p->name; p = p->next) {    if (!egg_strcasecmp(name, p->name)) {      p->major = major;      p->minor = minor;      p->funcs = funcs;      return 1;    }  }  return 0;}",3,"cwe119,cwe120,cweother"
"IsClone(struct Luser *lptr){tint hashv;tchar uhost[UHOSTLEN + 2];tstruct Luser *tmp;tif (!lptr)ttreturn (0);t tif (lptr->server == Me.sptr)ttreturn (0);tircsprintf(uhost, ""%s@%s"",t           (lptr->username[0] == '~') ? lptr->username + 1 : lptr->username,t           lptr->hostname);thashv = HashUhost(uhost);tfor (tmp = cloneTable[hashv].list; tmp; tmp = tmp->cnext)t{ttif (lptr == tmp)tttcontinue;ttif (CloneMatch(lptr, tmp))tttreturn (1);t}t treturn (0);}",2,"cwe119,cwe120"
"tar_extract_blockdev(TAR *t, char *realname){  mode_t mode;  unsigned long devmaj, devmin;  char *filename;  char buf[T_BLOCKSIZE];  char *pathname = 0;  if (!TH_ISBLK(t))  {    errno = EINVAL;    return -1;  }  if (realname)    {    filename = realname;    }  else    {    pathname = th_get_pathname(t);    filename = pathname;    }  mode = th_get_mode(t);  devmaj = th_get_devmajor(t);  devmin = th_get_devminor(t);     strncpy(buf, filename, sizeof(buf)-1);  buf[sizeof(buf)-1] = 0;  if (mkdirhier(dirname(buf)) == -1)    {    if (pathname)      {      free(pathname);      }    return -1;    }#ifdef DEBUG  printf(""  ==> extracting: %s (block device %ld,%ld)"",         filename, devmaj, devmin);#endif#ifndef WIN32  if (mknod(filename, mode | S_IFBLK,      compat_makedev(devmaj, devmin)) == -1)#else  (void)devmin;  (void)devmaj;  (void)mode;#endif  {#ifdef DEBUG    perror(""mknod()"");#endif    if (pathname)      {      free(pathname);      }    return -1;  }#ifndef WIN32  if (pathname)    {    free(pathname);    }  return 0;#endif}",2,"cwe119,cwe120"
"NegateClassesFromString(char *classlist,struct Item **heap){ char *sp, currentitem[CF_MAXVARSIZE],local[CF_MAXVARSIZE];if ((classlist == NULL) || strlen(classlist) == 0)   {   return;   }memset(local,0,CF_MAXVARSIZE);strncpy(local,classlist,CF_MAXVARSIZE-1);for (sp = local; *sp != '0'; sp++)   {   memset(currentitem,0,CF_MAXVARSIZE);   sscanf(sp,""%250[^,]"",currentitem);   sp += strlen(currentitem);   if (IsHardClass(currentitem))      { char err[CF_BUFSIZE];      sprintf (err,""Cannot negate the reserved class [%s]"",currentitem);      FatalError(err);      }   AppendItem(heap,currentitem,NULL);   }}",2,"cwe119,cwe120"
"redeclare_class_template (tree type, tree parms){  tree tmpl;  tree tmpl_parms;  int i;  if (!TYPE_TEMPLATE_INFO (type))    {      error (""%qT is not a template type"", type);      return false;    }  tmpl = TYPE_TI_TEMPLATE (type);  if (!PRIMARY_TEMPLATE_P (tmpl))         return true;  if (!parms)    {      error (""template specifiers not specified in declaration of %qD"",t     tmpl);      return false;    }  parms = INNERMOST_TEMPLATE_PARMS (parms);  tmpl_parms = DECL_INNERMOST_TEMPLATE_PARMS (tmpl);  if (TREE_VEC_LENGTH (parms) != TREE_VEC_LENGTH (tmpl_parms))    {      error_n (input_location, TREE_VEC_LENGTH (parms),               ""redeclared with %d template parameter"",               ""redeclared with %d template parameters"",               TREE_VEC_LENGTH (parms));      inform_n (input_location, TREE_VEC_LENGTH (tmpl_parms),                ""previous declaration %q+D used %d template parameter"",                ""previous declaration %q+D used %d template parameters"",                tmpl, TREE_VEC_LENGTH (tmpl_parms));      return false;    }  for (i = 0; i < TREE_VEC_LENGTH (tmpl_parms); ++i)    {      tree tmpl_parm;      tree parm;      tree tmpl_default;      tree parm_default;      if (TREE_VEC_ELT (tmpl_parms, i) == error_mark_node          || TREE_VEC_ELT (parms, i) == error_mark_node)        continue;      tmpl_parm = TREE_VALUE (TREE_VEC_ELT (tmpl_parms, i));      if (tmpl_parm == error_mark_node)treturn false;      parm = TREE_VALUE (TREE_VEC_ELT (parms, i));      tmpl_default = TREE_PURPOSE (TREE_VEC_ELT (tmpl_parms, i));      parm_default = TREE_PURPOSE (TREE_VEC_ELT (parms, i));             if (TREE_CODE (tmpl_parm) != TREE_CODE (parm)t  || (TREE_CODE (tmpl_parm) != TYPE_DECLt      && !same_type_p (TREE_TYPE (tmpl_parm), TREE_TYPE (parm)))t  || (TREE_CODE (tmpl_parm) != PARM_DECLt      && (TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (tmpl_parm))tt  != TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (parm))))t  || (TREE_CODE (tmpl_parm) == PARM_DECLt      && (TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (tmpl_parm))tt  != TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)))))t{t  error (""template parameter %q+#D"", tmpl_parm);t  error (""redeclared here as %q#D"", parm);t  return false;t}      if (tmpl_default != NULL_TREE && parm_default != NULL_TREE)t{t   t  error_at (input_location, ""redefinition of default argument for %q#D"", parm);t  inform (DECL_SOURCE_LOCATION (tmpl_parm),tt  ""original definition appeared here"");t  return false;t}      if (parm_default != NULL_TREE)t tTREE_PURPOSE (TREE_VEC_ELT (tmpl_parms, i)) = parm_default;      else if (tmpl_default != NULL_TREE)t tTREE_PURPOSE (TREE_VEC_ELT (parms, i)) = tmpl_default;    }    return true;}",2,"cwe476,cweother"
"kill_nojobfiles(void){tintttfd1, fd2;tunsignedtcnt, errs = 0;tstructtjob_savet*jp;tstructtspqtinj;tstructtstattsbuf;tfor  (cnt = 0;  cnt < HASHMOD;  cnt++)ttfor  (jp = hashtab[cnt];  jp;  jp = jp->next)tttif  (jp->in_jfile  &&  !jp->job_path)tttterrs++;tif  (errs == 0  &&  dupjoblist == 0)ttreturn;tif  (errs != 0)ttfprintf(stderr, ""There are %u job(s) in the job list with no file"", errs);tif  (dupjoblist != 0)ttfprintf(stderr, ""There are %d job(s) in the job list pointing to the same file"", errs);tif  (!Ask(""Rewrite job list""))ttreturn;tif  ((fd1 = open(JFILE, O_RDONLY)) < 0)ttreturn;tif  ((fd2 = open(REBUILDJNAM, O_WRONLY|O_CREAT|O_TRUNC, 0666)) < 0)  {ttclose(fd1);ttreturn;t}twhile  (read(fd1,  (char *) &inj, sizeof(inj)) == sizeof(inj))  {ttif  (!((jp = find_hash(inj.spq_job))  &&  jp->job_path))tttcontinue;ttif  (jp->in_jfile > 1)tttcontinue;ttjp->in_jfile = 2;t ttwrite(fd2, (char *) &inj, sizeof(inj));t}tfstat(fd1, &sbuf);#ifdeftHAVE_FCHOWNtfchown(fd2, sbuf.st_uid, sbuf.st_gid);#elsetchown(REBUILDJNAM, sbuf.st_uid, sbuf.st_gid);#endiftclose(fd1);tclose(fd2);#ifdeftHAVE_RENAMEtrename(REBUILDJNAM, JFILE);#elsetunlink(JFILE);tlink(REBUILDJNAM, JFILE);tunlink(REBUILDJNAM);#endif}",2,"cwe120,cweother"
"set_juman_port(char *port){    if ((juman_port = atoi(port)) <= 0)      fprintf(stderr, ""Illegal port No: %s"", port);}",2,"cwe120,cweother"
"GrowPartition(Pointer ptr){    HashTable ht;    Field     partition;    int       nRings;    Object    attr;    char      *str;    char      *components[256];    Pointer   fill;    Array     compArray;    ht t        = ((struct regGrowTask *)ptr)->hashTable;    partition   = ((struct regGrowTask *)ptr)->partition;    nRings      = ((struct regGrowTask *)ptr)->nRings;    compArray   = ((struct regGrowTask *)ptr)->compArray;    fill        = ((struct regGrowTask *)ptr)->fill;    if (compArray)    {tchar *s;tint i, nComponents, len;tDXGetArrayInfo(compArray, &nComponents, NULL, NULL, NULL, &len);ts = (char *)DXGetArrayData(compArray);tfor (i = 0; i < nComponents; i++)t{t    components[i] = s;t    s += len;t}tcomponents[i] = NULL;    }    elsetcomponents[0] = NULL;    if (DXEmptyField(partition))treturn OK;    attr = DXGetComponentAttribute(partition, ""connections"", ""element type"");    if (! attr)    {tDXSetError(ERROR_MISSING_DATA, ""no element type specified"");tgoto error;    }    str = DXGetString((String)attr);    if (! str)    {tDXSetError(ERROR_DATA_INVALID, ""bad element type specification"");tgoto error;    }    if (! strcmp(str, ""lines""))    {tif (! GrowPartition1(ht, partition, nRings, components, fill))t    goto error;    }    else if (! strcmp(str, ""quads""))    {tif (! GrowPartition2(ht, partition, nRings, components, fill))t    goto error;    }    else if (! strcmp(str, ""cubes""))    {tif (! GrowPartition3(ht, partition, nRings, components, fill))t    goto error;    }    else    {tDXSetError(ERROR_NOT_IMPLEMENTED, t    ""Cannot grow regular connections of element type %s"", str);tgoto error;    }    if (! _dxf_RemoveDupReferences(partition))tgoto error;        if (! DXEndField(partition))tgoto error;    return OK;error:    return ERROR;}",2,"cwe119,cwe120"
"exec_simple_command (const char *command){  char *av[1024];  int ac = 0;  char *token = strtok (strdup(command), "" t"");  while (token)    {      av[ac++] = token;      token = strtok(0, "" t"");    }  av[ac] = 0;  execvp (av[0], av);t }",3,"cwe119,cwe120,cweother"
"""get_alpine_revision_number(char *buf, size_t nbuf){    char ourbuf[100], *p;    char *rev = NULL;    buf[0] = '0';    ourbuf[0] = '0';    /* HelpType (the type of h_revision) is assumed to be char ** */    if(h_revision && h_revision[0] && h_revision[0][0]){tstrncpy(ourbuf, h_revision[0], sizeof(ourbuf)-1);tourbuf[sizeof(ourbuf)-1] = '0';    }    if(ourbuf[0]){t/* move to revision number */tfor(p = ourbuf; *p && !isdigit((unsigned char) (*p)); p++)t  ;tif(*p)t  rev = p;tif(rev){t    /* skip to following space */t    for(; *p && !isspace((unsigned char) (*p)); p++)t      ;t    strncpy(buf, rev, MIN(p-rev, nbuf-1));t    buf[MIN(p-rev,nbuf-1)] = '0';t}    }    return(buf);}""",2,"cwe119,cwe120"
"scan_dir(char *dirname, dev_t device, struct dir_list **list,tt    char **ret_path){tDIRt*dir;tstruct dirent *dp;tchartpath[1024], *cp;tinttdirlen;tstruct stat st;tdirlen = strlen(dirname);tif ((dir = opendir(dirname)) == NULL)ttreturn errno;tdp = readdir(dir);twhile (dp) {ttif (dirlen + strlen(dp->d_name) + 2 >= sizeof(path))tttgoto skip_to_next;ttif (dp->d_name[0] == '.' &&tt    ((dp->d_name[1] == 0) ||tt     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))tttgoto skip_to_next;ttsprintf(path, ""%s/%s"", dirname, dp->d_name);ttif (stat(path, &st) < 0)tttgoto skip_to_next;ttif (S_ISDIR(st.st_mode))tttadd_to_dirlist(path, list);ttif (S_ISBLK(st.st_mode) && st.st_rdev == device) {tttcp = malloc(strlen(path)+1);tttif (!cp) {ttttclosedir(dir);ttttreturn ENOMEM;ttt}tttstrcpy(cp, path);ttt*ret_path = cp;tttgoto success;tt}tskip_to_next:ttdp = readdir(dir);t}success:tclosedir(dir);treturn 0;}",2,"cwe119,cwe120"
pick_animal(){tif (!animal_list) mon_animal_list(TRUE);treturn animal_list[rn2(animal_list_count)];},2,"cwe119,cwe120"
"adsi_load_session(struct ast_channel *chan, unsigned char *app, int ver, int data){tunsigned char dsp[256] = """";tint bytes = 0, res;tchar resp[2];t tbytes += adsi_connect_session(dsp + bytes, app, ver);tif (data) {ttbytes += adsi_data_mode(dsp + bytes);t}t tif (adsi_transmit_message_full(chan, dsp, bytes, ADSI_MSG_DISPLAY, 0)) {ttreturn -1;t}tif (app) {ttif ((res = ast_readstring(chan, resp, 1, 1200, 1200, """")) < 0) {tttreturn -1;tt}ttif (res) {tttast_debug(1, ""No response from CPE about version.  Assuming not there."");tttreturn 0;tt}ttif (!strcmp(resp, ""B"")) {tttast_debug(1, ""CPE has script '%s' version %d already loaded"", app, ver);tttreturn 1;tt} else if (!strcmp(resp, ""A"")) {tttast_debug(1, ""CPE hasn't script '%s' version %d already loaded"", app, ver);tt} else {tttast_log(LOG_WARNING, ""Unexpected CPE response to script query: %s"", resp);tt}t} elsettreturn 1;treturn 0;}",2,"cwe119,cwe120"
"""readline_restart(FILE *ibuf, char **linebuf, size_t *linesize, size_t n){tlong sz;tclearerr(ibuf);t/*t * Interrupts will cause trouble if we are inside a stdio call. Ast * this is only relevant if input comes from a terminal, we can simplyt * bypass it by read() then.t */tif (fileno(ibuf) == 0 && is_a_tty[0]) {ttif (*linebuf == NULL || *linesize < LINESIZE + n + 1)ttt*linebuf = srealloc(*linebuf,ttttt*linesize = LINESIZE + n + 1);ttfor (;;) {tttif (n >= *linesize - 128)tttt*linebuf = srealloc(*linebuf, *linesize += 256);again:tttsz = read(0, *linebuf + n, *linesize - n - 1);tttif (sz > 0) {ttttn += sz;tttt(*linebuf)[n] = '0';ttttif (n > 0 && (*linebuf)[n - 1] == '')tttttbreak;ttt} else {ttttif (sz < 0 && errno == EINTR)tttttgoto again;ttttif (n > 0) {tttttif ((*linebuf)[n - 1] != '') {tttttt(*linebuf)[n++] = '';tttttt(*linebuf)[n] = '0';ttttt}tttttbreak;tttt} elsetttttreturn -1;ttt}tt}t} else {tt/*tt * Not reading from standard input or standard input nottt * a terminal. We read one char at a time as it is thett * only way to get lines with embedded NUL characters intt * standard stdio.tt */ttif (fgetline_byone(linebuf, linesize, &n, ibuf, 1, n) == NULL)tttreturn -1;t}tif (n > 0 && (*linebuf)[n - 1] == '')tt(*linebuf)[--n] = '0';treturn n;}""",2,"cwe120,cweother"
"""TXT_SetLabel(txt_label_t *label, char *value){    char *p;    unsigned int y;    // Free back the old label    free(label->label);    free(label->lines);    // Set the new value    label->label = strdup(value);    // Work out how many lines in this label    label->h = 1;    for (p = value; *p != '0'; ++p)    {        if (*p == '')        {            ++label->h;        }    }    // Split into lines    label->lines = malloc(sizeof(char *) * label->h);    label->lines[0] = label->label;    y = 1;    for (p = label->label; *p != '0'; ++p)    {        if (*p == '')        {            label->lines[y] = p + 1;            *p = '0';            ++y;        }    }    label->w = 0;    for (y=0; y<label->h; ++y)    {        unsigned int line_len;        line_len = TXT_UTF8_Strlen(label->lines[y]);        if (line_len > label->w)            label->w = line_len;    }}""",2,"cwe120,cweother"
"get_exag_guess(int id, int type, Tcl_Interp * interp){    char exag[256];    float guess;    if (type != SURF) {tTcl_SetResult(interp,tt      ""Error: map object must be a surface in order to use get_exag_guess"",tt      TCL_VOLATILE);treturn (TCL_ERROR);    }    if (0 > GS_get_exag_guess(id, &guess))treturn (TCL_ERROR);    sprintf(exag, ""%f"", guess);    Tcl_SetResult(interp, exag, TCL_VOLATILE);    return (TCL_OK);}",2,"cwe119,cwe120"
"""read_word(FILE *in, int *lineno, size_t len, char *word){tint ch, i, comment = 0;tch = fgetc(in);twhile (1) {ttif (ch == EOF)tttreturn FALSE;ttif (ch == '#')tttcomment = 1;ttif (!comment && !isspace(ch))tttbreak;ttif (ch == '') {ttt(*lineno)++;tttcomment = 0;tt}ttch = fgetc(in);t}tfor (i = 0; i < len-1 && !isspace(ch); i++) {ttword[i] = ch;ttch = fgetc(in);ttif (ch == EOF)tttbreak;ttif (ch == '')ttt(*lineno)++;t}tword[i] = 0;treturn TRUE;}""",2,"cwe120,cweother"
"dwim_ref(const char *str, int len, unsigned char *sha1, char **ref){tchar *last_branch = substitute_branch_name(&str, &len);tconst char **p, *r;tint refs_found = 0;t*ref = NULL;tfor (p = ref_rev_parse_rules; *p; p++) {ttchar fullref[PATH_MAX];ttunsigned char sha1_from_ref[20];ttunsigned char *this_result;ttint flag;ttthis_result = refs_found ? sha1_from_ref : sha1;ttmksnpath(fullref, sizeof(fullref), *p, len, str);ttr = resolve_ref(fullref, this_result, 1, &flag);ttif (r) {tttif (!refs_found++)tttt*ref = xstrdup(r);tttif (!warn_ambiguous_refs)ttttbreak;tt} else if ((flag & REF_ISSYMREF) && strcmp(fullref, ""HEAD""))tttwarning(""ignoring dangling symref %s."", fullref);t}tfree(last_branch);treturn refs_found;}",3,"cwe119,cwe120,cwe469"
"SV_LoadGame(int slot){    int i;    char fileName[100];    player_t playerBackup[MAXPLAYERS];    mobj_t *mobj;         if (slot != BASE_SLOT)    {        ClearSaveSlot(BASE_SLOT);        CopySaveSlot(slot, BASE_SLOT);    }         sprintf(fileName, ""%shex6.hxs"", SavePath);         M_ReadFile(fileName, &SaveBuffer);         SavePtr.b = SaveBuffer + HXS_DESCRIPTION_LENGTH;         if (strcmp((char *) SavePtr.b, HXS_VERSION_TEXT))    {                                    return;    }    SavePtr.b += HXS_VERSION_TEXT_LENGTH;    AssertSegment(ASEG_GAME_HEADER);    gameepisode = 1;    gamemap = GET_BYTE;    gameskill = GET_BYTE;         for (i = 0; i < MAX_ACS_WORLD_VARS; ++i)    {        WorldVars[i] = GET_LONG;    }    for (i = 0; i < MAX_ACS_STORE + 1; ++i)    {        StreamIn_acsstore_t(&ACSStore[i]);    }         UnarchivePlayers();    AssertSegment(ASEG_END);    Z_Free(SaveBuffer);         for (i = 0; i < MAXPLAYERS; i++)    {        playerBackup[i] = players[i];    }         SV_LoadMap();         Z_Free(TargetPlayerAddrs);         inv_ptr = 0;    curpos = 0;    for (i = 0; i < MAXPLAYERS; i++)    {        mobj = players[i].mo;        players[i] = playerBackup[i];        players[i].mo = mobj;        if (i == consoleplayer)        {            players[i].readyArtifact = players[i].inventory[inv_ptr].type;        }    }}",3,"cwe119,cwe120,cwe469"
"expand_hier_files(struct cfglib_t *lbp, struct libel_t *lbep, struct xpndfile_t *xfp_hd){ char dirstr[RECLEN]; char bpath[RECLEN]; char tmp[RECLEN]; int32 first;     if (xfp_hd->wildcard)   {   find_hier(lbep, xfp_hd, NULL, NULL);   return;  } first = TRUE;   getcwd(dirstr, RECLEN);  strcpy(bpath, """"); while (!xfp_hd->wildcard && xfp_hd->incall != TRUE)   {   if (chdir(xfp_hd->fpat) < 0)    {     if (first)      {       __pv_ferr(3564, ""config library %s no such directory %s"",       lbp->lbname, xfp_hd->fpat);       }     else      {       __pv_ferr(3564, ""config library %s no such directory %s/%s"",        lbp->lbname, bpath, xfp_hd->fpat);       chdir(dirstr);       return;      }    }       if (first)    {     strcpy(bpath, xfp_hd->fpat);     first = FALSE;    }   else    {     strcpy(tmp, bpath);     sprintf(bpath, ""%s/%s"", tmp, xfp_hd->fpat);    }   xfp_hd = xfp_hd->xpfnxt;  }   find_hier(lbep, xfp_hd, bpath, NULL);   chdir(dirstr);}",2,"cwe119,cwe120"
"main(int argc, const char *const argv[]){    clock_t time_taken = clock();    int i;    int rv;    int list_provided = 0;    tst_suite *suite = NULL;    sub_suite *subsuite;    setprogname(""Ferret Test"");    for (i = 1; i < argc; i++) {        if (!strcmp(argv[i], ""-v"")) {            verbose = true;            continue;        }        if (!strcmp(argv[i], ""-x"")) {            exclude = true;            continue;        }        if (!strcmp(argv[i], ""-l"")) {            list_tests = true;            continue;        }        if (!strcmp(argv[i], ""-f"")) {            force = true;            continue;        }        if (!strcmp(argv[i], ""-q"")) {            quiet = true;            continue;        }        if (argv[i][0] == '-') {            fprintf(stderr, USAGE, argv[i]);            exit(1);        }        list_provided = 1;    }    if (list_provided) {                 testlist = calloc(argc + 1, sizeof(char *));        for (i = 1; i < argc; i++) {            testlist[i - 1] = (char *) argv[i];        }    }    for (i = 0; i < (int)NELEMS(all_tests); i++) {        suite = all_tests[i].func(suite);    }         rv = report(suite);    printf(""Finished in %0.3f seconds"",           (double) (clock() - time_taken) / CLOCKS_PER_SEC);         while ((subsuite = suite->head) != NULL) {        suite->head = subsuite->next;        free(subsuite->name);        free(subsuite);    }    free(suite);    free(testlist);    do_clean_up();    return rv;}",3,"cwe119,cwe120,cweother"
file_not_found (){  const char *error = 0;  LT_DLMUTEX_GETERROR (error);  if (error == LT_DLSTRERROR (FILE_NOT_FOUND))    return 1;  return 0;},3,"cwe119,cwe120,cweother"
"create_home_directory()  {tgchar *path;tstruct stat s;#ifndef WIN32tpath = g_strconcat( getenv(""HOME""), ""/"", ""."", PACKAGE, ""/"", NULL);#elsetHKEY hKey;tTCHAR home[PATH_MAX];tDWORD size = PATH_MAX;tif (RegOpenKeyEx(HKEY_CURRENT_USER,tt""SoftwareMicrosoftWindowsCurrentVersionExplorerShell Folders"",tt0, KEY_READ, &hKey) != ERROR_SUCCESS ||ttRegQueryValueEx(hKey, ""Personal"", NULL, NULL, (LPBYTE)home, &size) != ERROR_SUCCESS ||ttRegCloseKey(hKey) != ERROR_SUCCESS) {tttpath = g_strconcat(PACKAGE, ""/"", NULL);t} else {ttpath = g_strconcat(home, ""/"", PACKAGE, ""/"", NULL);t}#endif  tglobal->path_home = g_strdup(path);tif(stat(path, &s) < 0)  {ttmkdir(path, 0777);ttif(stat(path, &s) < 0)  {tttg_free(path);tttreturn FALSE;tt}t}tg_free(path);tpath = g_strconcat( global->path_home, ""themes/"", NULL);tif(stat(path, &s) < 0)  {ttmkdir(path, 0777);ttif(stat(path, &s) < 0)  {tttg_free(path);tttreturn FALSE;tt}t}tg_free(path);treturn TRUE;}",3,"cwe119,cwe120,cweother"
"normalize_device(const void* item, void* xtra) {tdevicedef_t* device = (devicedef_t*)item;tnormalizer_t* normalizer = (normalizer_t*)xtra;tif(device->user_agent!=NULL) {ttchar tmp[8 * 1024];ttnormalizer_apply(normalizer, tmp, device->user_agent);ttif(strcmp(tmp, device->user_agent)!=0) {tttfree(device->user_agent);tttdevice->user_agent = strdup(tmp);tt}t}treturn false;}",2,"cwe119,cwe120"
"remote_file_open(struct remote_file *rfp){tchar sendbuf[BUFSIZE];tchar recvbuf[BUFSIZE];tchar *p1;tBZERO(sendbuf, BUFSIZE);tBZERO(recvbuf, BUFSIZE);       tsprintf(sendbuf, ""OPEN %s"", rfp->filename);        send(pc->sockfd, sendbuf, strlen(sendbuf), 0);        recv(pc->sockfd, recvbuf, BUFSIZE-1, 0);        if (CRASHDEBUG(1))                fprintf(fp, ""remote_file_open: [%s]"", recvbuf);        if (strstr(recvbuf, ""O_RDWR"") || strstr(recvbuf, ""O_RDONLY"")) {                p1 = strtok(recvbuf, "" "");                   p1 = strtok(NULL, "" "");                      p1 = strtok(NULL, "" "");                      rfp->fd = atoi(p1);                p1 = strtok(NULL, "" "");                      if (STREQ(p1, ""O_RDWR""))tttrfp->flags |= O_RDWR;ttelse if (STREQ(p1, ""O_RDONLY""))tttrfp->flags |= O_RDONLY;                p1 = strtok(NULL, "" "");      ttrfp->size = atoi(p1);ttreturn TRUE;        } else ttreturn FALSE;}",4,"cwe119,cwe120,cwe476,cweother"
"writeopen(fc_type fc, filetype ft, tt  file_id_type *pfileid, char **errstr){  char *name;  genfile f;  *errstr=NULL;  name=NULL;#ifdef UNIX  if (fc->special) {       f=try_open_pipe(fc,ft,1);    if (f==NULL && errno==0) {      *errstr=rstrdup(""Invalid pipe request."");      return f;    }    if (f==NULL)         name=rstrdup(fc->gamename);  } else#endif    {      name=assemble_filename(FC(fc)->path,FC(fc)->shortname,extname[ft]);      f=fopen(name,filetype_info(ft,1));    }  if (f==NULL) {    const char *s;    s=strerror(errno);    *errstr=rmalloc(30+strlen(name)+strlen(s));    sprintf(*errstr,""Cannot open file %s: %s."",name,s);  }  if (pfileid==NULL)    rfree(name);  else     *pfileid=(void*)name;  return f;}",2,"cwe120,cweother"
"_TIFFPrettyPrintField(TIFF* tif, const TIFFField *fip, FILE* fd, uint32 tag,          uint32 value_count, void *raw_data){        (void) tif;     if (strncmp(fip->field_name,""Tag "", 4) == 0) {    return 0;  }  switch (tag)  {    case TIFFTAG_INKSET:      if (value_count == 2 && fip->field_type == TIFF_SHORT) {        fprintf(fd, ""  Ink Set: "");        switch (*((uint16*)raw_data)) {        case INKSET_CMYK:          fprintf(fd, ""CMYK"");          break;        default:          fprintf(fd, ""%u (0x%x)"",            *((uint16*)raw_data),            *((uint16*)raw_data));          break;        }        return 1;      }      return 0;    case TIFFTAG_DOTRANGE:      if (value_count == 2 && fip->field_type == TIFF_SHORT) {        fprintf(fd, ""  Dot Range: %u-%u"",          ((uint16*)raw_data)[0], ((uint16*)raw_data)[1]);        return 1;      }      return 0;    case TIFFTAG_WHITEPOINT:      if (value_count == 2 && fip->field_type == TIFF_RATIONAL) {        fprintf(fd, ""  White Point: %g-%g"",          ((float *)raw_data)[0], ((float *)raw_data)[1]);        return 1;      }      return 0;    case TIFFTAG_XMLPACKET:    {      uint32 i;      fprintf(fd, ""  XMLPacket (XMP Metadata):"" );      for(i = 0; i < value_count; i++)        fputc(((char *)raw_data)[i], fd);      fprintf( fd, """" );      return 1;    }    case TIFFTAG_RICHTIFFIPTC:             fprintf(fd,          ""  RichTIFFIPTC Data: <present>, %lu bytes"",          (unsigned long) value_count * 4);      return 1;    case TIFFTAG_PHOTOSHOP:      fprintf(fd, ""  Photoshop Data: <present>, %lu bytes"",          (unsigned long) value_count);      return 1;    case TIFFTAG_ICCPROFILE:      fprintf(fd, ""  ICC Profile: <present>, %lu bytes"",          (unsigned long) value_count);      return 1;    case TIFFTAG_STONITS:      if (value_count == 1 && fip->field_type == TIFF_DOUBLE) {        fprintf(fd,          ""  Sample to Nits conversion factor: %.4e"",          *((double*)raw_data));        return 1;      }      return 0;  }  return 0;}",2,"cwe119,cwe120"
"proto_hull(struct isl_set *set, int *is_hull){tstruct isl_basic_set *hull;tunsigned n_ineq;tint i;tn_ineq = 1;tfor (i = 0; i < set->n; ++i) {ttn_ineq += set->p[i]->n_eq;ttn_ineq += set->p[i]->n_ineq;t}thull = isl_basic_set_alloc_space(isl_space_copy(set->dim), 0, 0, n_ineq);thull = isl_basic_set_set_rational(hull);tif (!hull)ttreturn NULL;treturn common_constraints(hull, set, is_hull);}",2,"cwe476,cweother"
"identification_create_from_data(chunk_t data){tchar buf[data.len + 1];tif (is_asn1(data))t{ttreturn identification_create_from_encoding(ID_DER_ASN1_DN, data);t}telset{tt ttsnprintf(buf, sizeof(buf), ""%.*s"", (int)data.len, data.ptr);ttreturn identification_create_from_string(buf);t}}",2,"cwe119,cwe120"
"log_reopen(enum log_file which){tbool success = TRUE;tFILE *f;tstruct logfile *lf;tint fd = -1;tlog_file_check(which);tg_assert(logfile[which].path != NULL);t tlf = &logfile[which];tf = lf->f;tg_assert(f != NULL);t tif (LOG_STDERR == which)ttfd = dup(fileno(f));tif (freopen(lf->path, ""a"", f)) {ttsetvbuf(f, NULL, _IOLBF, 0);ttlf->disabled = 0 == strcmp(lf->path, DEV_NULL);ttlf->otime = tm_time();ttlf->changed = FALSE;t} else {ttif (LOG_STDERR == which) {tttDECLARE_STR(8);tttchar time_buf[18];tttcrash_time(time_buf, sizeof time_buf);tttprint_str(time_buf);t tttprint_str("" (CRITICAL): cannot freopen() stderr to "");  tttprint_str(lf->path);t tttprint_str("": "");tt tttprint_str(symbolic_errno(errno));t tttprint_str("" ("");tt tttprint_str(g_strerror(errno));tt tttprint_str("")"");tt tttflush_str(fd);tttlog_flush_out();tt} else {ttts_critical(""freopen(""%s"", ""a"", ...) failed: %m"", lf->path);tt}ttlf->disabled = TRUE;ttlf->otime = 0;ttsuccess = FALSE;t}tif (LOG_STDERR == which && is_valid_fd(fd))ttclose(fd);treturn success;}",2,"cwe119,cwe120"
"swf_report(SWFReader *read, GF_Err e, char *format, ...){#ifndef GPAC_DISABLE_LOGtif (gf_log_tool_level_on(GF_LOG_PARSER, e ? GF_LOG_ERROR : GF_LOG_WARNING)) {ttchar szMsg[2048];ttva_list args;ttva_start(args, format);ttvsprintf(szMsg, format, args);ttva_end(args);ttGF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_PARSER, (""[SWF Parsing] %s (frame %d)"", szMsg, read->current_frame+1) );t}#endif}",3,"cwe119,cwe120,cweother"
"ind_command(char *arg, struct session *ses){    char left[BUFFER_SIZE], right[BUFFER_SIZE];    if (!ui_keyboard)    {        tintin_eprintf(ses, ""#UI: no access to keyboard => no keybindings"");        return;    }    arg = get_arg_in_braces(arg, left, 0);    arg = get_arg_in_braces(arg, right, 1);    if (*left && *right)    {        set_hash(ses->binds, left, right);        if (ses->mesvar[8])            tintin_printf(ses,""#Ok. {%s} is now bound to {%s}."", left, right);        bindnum++;        return;    }    show_hashlist(ses, ses->binds, left,        ""#Bound keys:"",        ""#No match(es) found for {%s}"");}",2,"cwe119,cwe120"
"chirp_client_llistxattr(struct chirp_client * c, const char *path, char *list, size_t size, time_t stoptime){tchar safepath[CHIRP_LINE_MAX];turl_encode(path, safepath, sizeof(safepath));tINT64_T result = send_command(c, stoptime, ""llistxattr %s"", safepath);tif(result < 0)ttreturn result;tresult = get_result(c, stoptime);tif(result < 0)ttreturn result;tif(result > (int) size) {ttlink_soak(c->link, result, stoptime);tterrno = ERANGE;ttreturn result;t}tif(!link_read(c->link, list, result, stoptime)) {ttreturn -1;t}treturn result;}",2,"cwe119,cwe120"
"verify_slab_v2(struct meminfo *si, ulong last, int s){tchar slab_buf[BUFSIZE];tstruct kernel_list_head *list_head;tunsigned int inuse;tulong s_mem;tchar *list;tint errcnt;tlist = slab_chain_name_v2[s];terrcnt = 0;        if (!readmem(si->slab, KVADDR, slab_buf,            SIZE(slab), ""slab buffer"", QUIET|RETURN_ON_ERROR)) {                error(INFO, ""%s: %s list: bad slab pointer: %lx"",                        si->curname, list, si->slab);ttreturn FALSE;        }                                list_head = (struct kernel_list_head *)(slab_buf + OFFSET(slab_list));tif (!IS_KVADDR((ulong)list_head->next) || t    !accessible((ulong)list_head->next)) {                error(INFO, ""%s: %s list: slab: %lx  bad next pointer: %lx"",                        si->curname, list, si->slab,ttt(ulong)list_head->next);tterrcnt++;t}tif (last && (last != (ulong)list_head->prev)) {                error(INFO, ""%s: %s list: slab: %lx  bad prev pointer: %lx"",                        si->curname, list, si->slab,                        (ulong)list_head->prev);tterrcnt++;t}tinuse = UINT(slab_buf + OFFSET(slab_inuse));tif (inuse > si->c_num) {                error(INFO, ""%s: %s list: slab: %lx  bad inuse counter: %ld"",                        si->curname, list, si->slab, inuse);tterrcnt++;t}tif (!last)ttgoto no_inuse_check_v2;tswitch (s) t{tcase 0:                  if ((inuse == 0) || (inuse == si->c_num)) {                terror(INFO, tt t    ""%s: %s list: slab: %lx  bad inuse counter: %ld"",                        tsi->curname, list, si->slab, inuse);ttterrcnt++;tt}ttbreak;tcase 1:  ttif (inuse != si->c_num) {                terror(INFO, tt t    ""%s: %s list: slab: %lx  bad inuse counter: %ld"",                        tsi->curname, list, si->slab, inuse);ttterrcnt++;tt}ttbreak;tcase 2:  ttif (inuse > 0) {                terror(INFO, tt t    ""%s: %s list: slab: %lx  bad inuse counter: %ld"",                        tsi->curname, list, si->slab, inuse);ttterrcnt++;tt}ttbreak;t}no_inuse_check_v2:ts_mem = ULONG(slab_buf + OFFSET(slab_s_mem));tif (!IS_KVADDR(s_mem) || !accessible(s_mem)) {                error(INFO, ""%s: %s list: slab: %lx  bad s_mem pointer: %lx"",                        si->curname, list, si->slab, s_mem);tterrcnt++;t}tsi->errors += errcnt;treturn(errcnt ? FALSE : TRUE);}",2,"cwe119,cwe120"
"ssl_init(void){tstatic Boolean ssl_initted = False;tif (!ssl_initted) {ttSSL_load_error_strings();ttSSL_library_init();ttssl_initted = True;ttssl_ctx = SSL_CTX_new(SSLv23_method());ttif (ssl_ctx == NULL) {tttpopup_an_error(""SSL_CTX_new failed"");tttssl_host = False;tttreturn;tt}ttSSL_CTX_set_options(ssl_ctx, SSL_OP_ALL);t}tssl_con = SSL_new(ssl_ctx);tif (ssl_con == NULL) {ttpopup_an_error(""SSL_new failed"");ttssl_host = False;t}tSSL_set_verify(ssl_con, 0 , NULL);tSSL_CTX_set_info_callback(ssl_ctx, client_info_callback);t tif (appres.cert_file) {ttif (!(SSL_CTX_use_certificate_chain_file(ssl_ctx,ttttttappres.cert_file))) {tttunsigned long e;tttchar err_buf[120];ttte = ERR_get_error();ttt(void) ERR_error_string(e, err_buf);tttpopup_an_error(""SSL_CTX_use_certificate_chain_file(""ttttt""""%s"") failed:%s"",tttttappres.cert_file, err_buf);tt}t}tSSL_CTX_set_default_verify_paths(ssl_ctx);}",2,"cwe119,cwe120"
"mod_usertrack_patch_connection(server *srv, connection *con, plugin_data *p) {tsize_t i, j;tplugin_config *s = p->config_storage[0];tPATCH(cookie_name);tPATCH(cookie_domain);tPATCH(cookie_max_age);t tfor (i = 1; i < srv->config_context->used; i++) {ttdata_config *dc = (data_config *)srv->config_context->data[i];tts = p->config_storage[i];tt ttif (!config_check_cond(srv, con, dc)) continue;tt ttfor (j = 0; j < dc->value->used; j++) {tttdata_unset *du = dc->value->data[j];tttif (buffer_is_equal_string(du->key, CONST_STR_LEN(""usertrack.cookie-name""))) {ttttPATCH(cookie_name);ttt} else if (buffer_is_equal_string(du->key, CONST_STR_LEN(""usertrack.cookie-max-age""))) {ttttPATCH(cookie_max_age);ttt} else if (buffer_is_equal_string(du->key, CONST_STR_LEN(""usertrack.cookie-domain""))) {ttttPATCH(cookie_domain);ttt}tt}t}treturn 0;}",2,"cwe119,cwe120"
"symbol_to_expression(char * expr_id, char * parent, char * sym_id, Expression * expr) {#if ENABLE_Symbols    Symbol * sym = NULL;    Symbol * type = NULL;    char * name = NULL;    int sym_class = 0;    int type_class = 0;    ContextAddress size = 0;    static char script[256];    memset(expr, 0, sizeof(Expression));    strlcpy(expr->id, expr_id, sizeof(expr->id));    strlcpy(expr->parent, parent, sizeof(expr->parent));    if (id2symbol(sym_id, &sym) < 0) return -1;    if (get_symbol_name(sym, &name) < 0) return -1;    if (name != NULL) {        strlcpy(script, name, sizeof(script));        expr->script = script;    }    if (get_symbol_class(sym, &sym_class) == 0) {        expr->can_assign = sym_class == SYM_CLASS_REFERENCE;    }    if (get_symbol_type_class(sym, &type_class) == 0) {        expr->type_class = type_class;    }    if (get_symbol_type(sym, &type) == 0 && type != NULL) {        strlcpy(expr->type, symbol2id(type), sizeof(expr->type));    }    if (get_symbol_size(sym, &size) == 0) {        expr->size = size;    }    return 0;#else    memset(expr, 0, sizeof(Expression));    errno = ERR_UNSUPPORTED;    return -1;#endif}",2,"cwe119,cwe120"
"gg_file_hash_sha1(int fd, uint8_t *result){tunsigned char buf[4096];tSHA_CTX ctx;toff_t pos, len;tint res;tif ((pos = lseek(fd, 0, SEEK_CUR)) == (off_t) -1)ttreturn -1;tif ((len = lseek(fd, 0, SEEK_END)) == (off_t) -1)ttreturn -1;tif (lseek(fd, 0, SEEK_SET) == (off_t) -1)ttreturn -1;tSHA1_Init(&ctx);tif (len <= 10485760) {ttwhile ((res = read(fd, buf, sizeof(buf))) > 0)tttSHA1_Update(&ctx, buf, res);t} else {ttint i;ttfor (i = 0; i < 9; i++) {tttint j;tttif (lseek(fd, (len - 1048576) / 9 * i, SEEK_SET) == (off_t) - 1)ttttreturn -1;tttfor (j = 0; j < 1048576 / sizeof(buf); j++) {ttttif ((res = read(fd, buf, sizeof(buf))) != sizeof(buf)) {tttttres = -1;tttttbreak;tttt}ttttSHA1_Update(&ctx, buf, res);ttt}tttif (res == -1)ttttbreak;tt}t}tif (res == -1)ttreturn -1;tSHA1_Final(result, &ctx);tif (lseek(fd, pos, SEEK_SET) == (off_t) -1)ttreturn -1;treturn 0;}",3,"cwe119,cwe120,cweother"
"main_parse_opts(struct config *config, int argc, char** argv){tint c;topterr = 0;twhile ((c = getopt(argc, argv, ""c:p:aofrd"")) != -1) {ttswitch (c) {ttcase 'c':tt        free(config->configfile);tttconfig->configfile = strdup(optarg);tttbreak;                case 'p':                        free(config->pidfile);                        config->pidfile = strdup(optarg);                        break;ttcase 'a':  ttcase 'o':tttconfig->daemonmode = false;tttconfig->oneshot = true;tttbreak;ttcase 'f':  ttcase 'r':tttconfig->daemonmode = false;tttconfig->oneshot = false;tttbreak;ttcase 'd':tttconfig->daemonmode = true;tttconfig->oneshot = false;tttbreak;ttdefault:tttusage();tt}t}}",2,"cwe120,cweother"
"logger(int priority, const char *function, const char *format, ...) {        va_list targ_list;        char    tbuffer[1024];tstatic intthave_syslog = 0;        va_start(arg_list, format);        vsnprintf(buffer, 1023, format, arg_list);tva_end(arg_list);        buffer[1023] = '0';        if (flags & LOG_USE_STDERR)                fprintf(stderr, L_STDERR_FORMAT, getpid(), function, buffer);        if (flags & LOG_USE_SYSLOG) {ttif (!have_syslog) {tttopenlog(""saslauthd"", LOG_PID|LOG_NDELAY, LOG_AUTH);ttthave_syslog = 1;tt}                syslog(priority, ""%-16s: %s"", function, buffer);t}}",3,"cwe119,cwe120,cweother"
"tp_ps2_disable_data (int fd) {  struct timeval tv;  fd_set rfds;  unsigned char status;  byte cmd = PS2_DISABLE_DATA;    FD_ZERO(&rfds);  FD_SET (fd, &rfds);  tv.tv_sec = 0;  tv.tv_usec = 0;  write(fd,&cmd,1);  usleep (50000);    while (select (fd+1, &rfds, NULL, NULL, &tv) == 1) {    read (fd, &status, 1);#if DEBUG_RESET    gpm_report (GPM_PR_INFO,""PS/2 device disable data flush: %02X"", status);#endif    FD_ZERO(&rfds);    FD_SET (fd, &rfds);    tv.tv_sec = 0;    tv.tv_usec = 0;  }  if (status != PS2_ACK)    gpm_report (GPM_PR_ERR,""Invalid ACK to disable stream command, got %02X"",status);}",2,"cwe120,cweother"
"twl_aen_drain_queue(TW_Device_Extension *tw_dev, int no_check_reset){tint request_id = 0;tchar cdb[TW_MAX_CDB_LEN];tTW_SG_Entry_ISO sglist[1];tint finished = 0, count = 0;tTW_Command_Full *full_command_packet;tTW_Command_Apache_Header *header;tunsigned short aen;tint first_reset = 0, queue = 0, retval = 1;tif (no_check_reset)ttfirst_reset = 0;telsettfirst_reset = 1;tfull_command_packet = tw_dev->command_packet_virt[request_id];tmemset(full_command_packet, 0, sizeof(TW_Command_Full));t tmemset(&cdb, 0, TW_MAX_CDB_LEN);tcdb[0] = REQUEST_SENSE;  tcdb[4] = TW_ALLOCATION_LENGTH;  t tmemset(&sglist, 0, sizeof(TW_SG_Entry_ISO));tsglist[0].length = TW_SECTOR_SIZE;tsglist[0].address = tw_dev->generic_buffer_phys[request_id];t ttw_dev->srb[request_id] = NULL;tdo {tt ttif (twl_scsiop_execute_scsi(tw_dev, request_id, cdb, 1, sglist)) {tttTW_PRINTK(tw_dev->host, TW_DRIVER, 0x3, ""Error posting request sense"");tttgoto out;tt}tt ttif (twl_poll_response(tw_dev, request_id, 30)) {tttTW_PRINTK(tw_dev->host, TW_DRIVER, 0x4, ""No valid response while draining AEN queue"");ttttw_dev->posted_request_count--;tttgoto out;tt}tttw_dev->posted_request_count--;ttheader = (TW_Command_Apache_Header *)tw_dev->generic_buffer_virt[request_id];ttaen = le16_to_cpu(header->status_block.error);ttqueue = 0;ttcount++;ttswitch (aen) {ttcase TW_AEN_QUEUE_EMPTY:tttif (first_reset != 1)ttttgoto out;tttelsettttfinished = 1;tttbreak;ttcase TW_AEN_SOFT_RESET:tttif (first_reset == 0)ttttfirst_reset = 1;tttelsettttqueue = 1;tttbreak;ttcase TW_AEN_SYNC_TIME_WITH_HOST:tttbreak;ttdefault:tttqueue = 1;tt}tt ttif (queue)ttttwl_aen_queue_event(tw_dev, header);t} while ((finished == 0) && (count < TW_MAX_AEN_DRAIN));tif (count == TW_MAX_AEN_DRAIN)ttgoto out;tretval = 0;out:ttw_dev->state[request_id] = TW_S_INITIAL;treturn retval;}",2,"cwe119,cwe120"
"pkt_writable_disc(struct pktcdvd_device *pd, disc_information *di){tswitch (pd->mmc3_profile) {ttcase 0x0a:  ttcase 0xffff:  tttbreak;ttcase 0x1a:  ttcase 0x13:  ttcase 0x12:  tttreturn 1;ttdefault:tttpkt_dbg(2, pd, ""Wrong disc profile (%x)"",ttttpd->mmc3_profile);tttreturn 0;t}t tif (di->disc_type == 0xff) {ttpkt_notice(pd, ""unknown disc - no track?"");ttreturn 0;t}tif (di->disc_type != 0x20 && di->disc_type != 0) {ttpkt_err(pd, ""wrong disc type (%x)"", di->disc_type);ttreturn 0;t}tif (di->erasable == 0) {ttpkt_notice(pd, ""disc not erasable"");ttreturn 0;t}tif (di->border_status == PACKET_SESSION_RESERVED) {ttpkt_err(pd, ""can't write to last track (reserved)"");ttreturn 0;t}treturn 1;}",2,"cwe119,cwe120"
"cgi_handle_scgi_request(void){  char *zHdr;  char *zToFree;  int nHdr = 0;  int nRead;  int n, m;  char c;  while( (c = fgetc(g.httpIn))!=EOF && fossil_isdigit(c) ){    nHdr = nHdr*10 + c - '0';  }  if( nHdr<16 ) malformed_request(""SCGI header too short"");  zToFree = zHdr = fossil_malloc(nHdr);  nRead = (int)fread(zHdr, 1, nHdr, g.httpIn);  if( nRead<nHdr ) malformed_request(""cannot read entire SCGI header"");  nHdr = nRead;  while( nHdr ){    for(n=0; n<nHdr && zHdr[n]; n++){}    for(m=n+1; m<nHdr && zHdr[m]; m++){}    if( m>=nHdr ) malformed_request(""SCGI header formatting error"");    cgi_set_parameter(zHdr, zHdr+n+1);    zHdr += m+1;    nHdr -= m+1;  }  fossil_free(zToFree);  fgetc(g.httpIn);     cgi_init();}",2,"cwe120,cweother"
"expr_eval(stab_t stab, const char *text, address_t *addr){tconst char *text_save = text;tint last_cc = 1;tchar token_buf[64];tint token_len = 0;tstruct addr_exp_state s = {0};ts.last_operator = '(';tfor (;;) {ttint cc;tt ttif (*text == '+' || *text == '-' ||tt    *text == '*' || *text == '/' ||tt    *text == '%' || *text == '(' ||tt    *text == ')')tttcc = 1;ttelse if (!*text || isspace(*text))tttcc = 2;ttelse if (isalnum(*text) || *text == '.' || *text == '_' ||ttt *text == '$' || *text == ':')tttcc = 3;ttelse {tttprintc_err(""illegal character in expression: %c"",tttt*text);tttreturn -1;tt}tt ttif (cc == 3) {tttif (token_len + 1 < sizeof(token_buf))tttttoken_buf[token_len++] = *text;tt} else if (token_len) {ttttoken_buf[token_len] = 0;ttttoken_len = 0;tttif (addr_exp_data(stab, &s, token_buf) < 0)ttttgoto fail;tt}tt ttif (cc == 1) {tttif (addr_exp_op(&s, *text) < 0)ttttgoto fail;tt}ttif (!*text)tttbreak;ttlast_cc = cc;tttext++;t}tif (addr_exp_finish(&s, addr) < 0)ttgoto fail;treturn 0; fail:tprintc_err(""bad address expression: %s"", text_save);treturn -1;}",2,"cwe119,cwe120"
"""wc_match(const char *pattern, const char *text){    const char *p = pattern, *t = text, *xt;     /* include '0' as we need to match empty string */    const char *text_last = t + strlen(t);    for (;; p++, t++) {        /* end of text so make sure end of pattern doesn't matter */        if (*t == '0') {            while (*p) {                if (*p != WILD_STRING) {                    return false;                }                p++;            }            return true;        }        /* If we've gone past the end of the pattern, return false. */        if (*p == '0') {            return false;        }        /* Match a single character, so continue. */        if (*p == WILD_CHAR) {            continue;        }        if (*p == WILD_STRING) {            /* Look at the character beyond the '*'. */            p++;            /* Examine the string, starting at the last character. */            for (xt = text_last; xt >= t; xt--) {                if (wc_match(p, xt)) return true;            }            return false;        }        if (*p != *t) {            return false;        }    }    return false;}""",2,"cwe119,cwe120"
"newsnntp_xhdr_range(newsnntp * f, const char * header,ttt uint32_t rangeinf, uint32_t rangesup,ttt clist ** result){  char command[NNTP_STRING_SIZE];  int r;  snprintf(command, NNTP_STRING_SIZE, ""XHDR %s %i-%ir"", header,t   rangeinf, rangesup);  r = send_command(f, command);  if (r == -1)    return NEWSNNTP_ERROR_STREAM;  return newsnntp_xhdr_resp(f, result);}",2,"cwe119,cwe120"
"python_init(apr_pool_t *p, apr_pool_t *ptemp,                        apr_pool_t *plog, server_rec *s){    char buff[255];    void *data;    py_global_config *glb;    const char *userdata_key = ""python_init"";    apr_status_t rc;    const char *py_compile_version = PY_VERSION;    const char *py_dynamic_version = 0;         static int initialized = 0;#ifdef WIN32         if (!getenv(""AP_PARENT_PID""))        return OK;#endif      apr_pool_userdata_get(&data, userdata_key, s->process->pool);    if (!data) {        apr_pool_userdata_set((const void *)1, userdata_key,                              apr_pool_cleanup_null, s->process->pool);        return OK;    }         ap_add_version_component(p, VERSION_COMPONENT);    py_dynamic_version = strtok((char *)Py_GetVersion(), "" "");    if (strcmp(py_compile_version, py_dynamic_version) != 0) {        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, s,                     ""python_init: Python version mismatch, expected '%s', found '%s'."",                     py_compile_version, py_dynamic_version);        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, s,                     ""python_init: Python executable found '%s'."",                     Py_GetProgramFullPath());        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, s,                     ""python_init: Python path being used '%s'."",                     Py_GetPath());    }         sprintf(buff, ""Python/%.200s"", py_dynamic_version);    ap_add_version_component(p, buff);         main_server = s;         glb = python_create_global_config(s);    if ((rc = init_mutexes(s, p, glb)) != APR_SUCCESS) {        return rc;    }         if (initialized == 0 || !Py_IsInitialized())     {        initialized = 1;                         Py_Initialize();#if APR_HAS_THREADS        apr_thread_mutex_create(&interpreters_lock, APR_THREAD_MUTEX_UNNESTED, p);#endif#ifdef WITH_THREAD                 PyEval_InitThreads();#endif                 interpreters = PyDict_New();        if (! interpreters) {            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, 0, s,                         ""python_init: PyDict_New() failed! No more memory?"");            exit(1);        }#ifdef WITH_THREAD                 PyEval_ReleaseLock();#endif    }    APR_REGISTER_OPTIONAL_FN(mp_acquire_interpreter);    APR_REGISTER_OPTIONAL_FN(mp_release_interpreter);    APR_REGISTER_OPTIONAL_FN(mp_get_request_object);    APR_REGISTER_OPTIONAL_FN(mp_get_server_object);    APR_REGISTER_OPTIONAL_FN(mp_get_connection_object);    return OK;}",3,"cwe119,cwe120,cweother"
"git_path_find_dir(git_buf *dir, const char *path, const char *base){tint error;tif (base != NULL && git_path_root(path) < 0)tterror = git_buf_joinpath(dir, base, path);telsetterror = git_buf_sets(dir, path);tif (!error) {ttchar buf[GIT_PATH_MAX];ttif (p_realpath(dir->ptr, buf) != NULL)ttterror = git_buf_sets(dir, buf);t}t tif (!error && git_path_isdir(dir->ptr) == false)tterror = git_path_dirname_r(dir, dir->ptr);tif (!error)tterror = git_path_to_dir(dir);treturn error;}",2,"cwe119,cwe120"
"entry_guard_set_status(entry_guard_t *e, const node_t *node,                       time_t now, const or_options_t *options,                       const char **reason){  char buf[HEX_DIGEST_LEN+1];  int changed = 0;  *reason = NULL;     if (!node)    *reason = ""unlisted"";  else if (!node->is_running)    *reason = ""down"";  else if (options->UseBridges && (!node->ri ||                                   node->ri->purpose != ROUTER_PURPOSE_BRIDGE))    *reason = ""not a bridge"";  else if (options->UseBridges && !node_is_a_configured_bridge(node))    *reason = ""not a configured bridge"";  else if (!options->UseBridges && !node->is_possible_guard &&           !routerset_contains_node(options->EntryNodes,node))    *reason = ""not recommended as a guard"";  else if (routerset_contains_node(options->ExcludeNodes, node))    *reason = ""excluded"";  if (*reason && ! e->bad_since) {         base16_encode(buf, sizeof(buf), e->identity, DIGEST_LEN);    log_info(LD_CIRC, ""Entry guard %s (%s) is %s: marking as unusable."",             e->nickname, buf, *reason);    e->bad_since = now;    control_event_guard(e->nickname, e->identity, ""BAD"");    changed = 1;  } else if (!*reason && e->bad_since) {         base16_encode(buf, sizeof(buf), e->identity, DIGEST_LEN);    log_info(LD_CIRC, ""Entry guard %s (%s) is no longer unusable: ""             ""marking as ok."", e->nickname, buf);    e->bad_since = 0;    control_event_guard(e->nickname, e->identity, ""GOOD"");    changed = 1;  }  return changed;}",2,"cwe119,cwe120"
"""cram_seek(cram_fd *fd, off_t offset, int whence) {    char buf[65536];    if (hseek(fd->fp, offset, whence) == 0)treturn 0;    if (!(whence == SEEK_CUR && offset >= 0))treturn -1;    /* Couldn't fseek, but we're in SEEK_CUR mode so read instead */    while (offset > 0) {tint len = MIN(65536, offset);tif (len != hread(fd->fp, buf, len))t    return -1;toffset -= len;    }    return 0;}""",2,"cwe119,cwe120"
"var_extensible_pass(struct variable *vp,                    oid * name,                    size_t * length,                    int exact,                    size_t * var_len, WriteMethod ** write_method){    oid             newname[MAX_OID_LEN];    int             i, rtest, fd, newlen;    char            buf[SNMP_MAXBUF];    static char     buf2[SNMP_MAXBUF];    struct extensible *passthru;    FILE           *file;    for (i = 1; i <= numpassthrus; i++) {        passthru = get_exten_instance(passthrus, i);        rtest = snmp_oidtree_compare(name, *length,                                     passthru->miboid, passthru->miblen);        if ((exact && rtest == 0) || (!exact && rtest <= 0)) {                         if (passthru->miblen >= *length || rtest < 0)                sprint_mib_oid(buf, passthru->miboid, passthru->miblen);            else                sprint_mib_oid(buf, name, *length);            if (exact)                snprintf(passthru->command, sizeof(passthru->command),                         ""%s -g %s"", passthru->name, buf);            else                snprintf(passthru->command, sizeof(passthru->command),                         ""%s -n %s"", passthru->name, buf);            passthru->command[ sizeof(passthru->command)-1 ] = 0;            DEBUGMSGTL((""ucd-snmp/pass"", ""pass-running:  %s"",                        passthru->command));                         if ((fd = get_exec_output(passthru)) != -1) {                file = fdopen(fd, ""r"");                if (fgets(buf, sizeof(buf), file) == NULL) {                    fclose(file);                    wait_on_exec(passthru);                    if (exact) {                                                 *write_method = setPass;                        *var_len = 0;                        return (NULL);                    }                    continue;                }                newlen = parse_miboid(buf, newname);                                 memcpy((char *) name, (char *) newname,                       (int) newlen * sizeof(oid));                *length = newlen;                                 *write_method = setPass;                if (newlen == 0 || fgets(buf, sizeof(buf), file) == NULL                    || fgets(buf2, sizeof(buf2), file) == NULL) {                    *var_len = 0;                    fclose(file);                    wait_on_exec(passthru);                    return (NULL);                }                fclose(file);                wait_on_exec(passthru);                return netsnmp_internal_pass_parse(buf, buf2, var_len, vp);            }            *var_len = 0;            return (NULL);        }    }    if (var_len)        *var_len = 0;    *write_method = NULL;    return (NULL);}",2,"cwe119,cwe120"
"zxid_put_invite(zxid_conf* cf, struct zxid_invite* inv){  char buf[ZXID_MAX_USER];  char invid_c[ZXID_MAX_USER];  char* perms = zxid_render_perms(cf, inv->perms);  memcpy(invid_c, inv->invid->s, MIN(inv->invid->len, sizeof(invid_c)-1));  invid_c[sizeof(invid_c)-1] = 0;  write_all_path_fmt(""put_inv"", ZXID_MAX_USER, buf,tt     ""%s"" ZXID_INV_DIR ""%s"", cf->path, invid_c,tt     ""dn: invid=%.*sinvid: %.*suid: %sdesc: %.*spsobj: %.*sps2spredir: %.*smaxusage: %dusage: %dstarts: %sexpires: %s%s"",tt     inv->invid->len, inv->invid->s,tt     inv->invid->len, inv->invid->s,tt     inv->uid,tt     inv->desc?inv->desc->len:0, inv->desc?inv->desc->s:"""",tt     inv->psobj?inv->psobj->len:0, inv->psobj?inv->psobj->s:"""",tt     inv->ps2spredir?inv->ps2spredir->len:0, inv->ps2spredir?inv->ps2spredir->s:"""",tt     inv->maxusage,tt     inv->usage,tt     zxid_date_time(cf, inv->starts),tt     zxid_date_time(cf, inv->expires),tt     STRNULLCHK(perms));  D(""PUT INVITATION invid(%s)"", invid_c);  return 1;}",2,"cwe119,cwe120"
"CallCursorCallbacks(tdmInteractor I, int reason, int cursor_num,tt    double screen_x, double screen_y, double screen_z,tt    tdmInteractorReturn *R){  DEFDATA(I,CursorData) ;  DEFPORT(I_PORT_HANDLE) ;  char text[256] ;     ENTRY((""CallCursorCallbacks(0x%x, %d, %d, %f, %f, %f, 0x%x)"",t I, reason, cursor_num, screen_x, screen_y, screen_z, R));  R->change = 1 ;  R->reason = reason ;  R->id = cursor_num ;  if (reason == tdmCURSOR_DELETE) {    EXIT((""""));    return ;  }     XFORM_COORDS(PDATA(PureWItrans),t       screen_x, screen_y, screen_z, R->x, R->y, R->z) ;  if (reason == tdmCURSOR_CREATE) {    EXIT((""""));    return ;  }     _dxf_WRITE_BUFFER (PORT_CTX,tt    PDATA(coord_llx), PDATA(coord_lly),tt    PDATA(coord_urx), PDATA(coord_ury),tt    (void *)PDATA(coord_saveunder)) ;  if (reason == tdmCURSOR_MOVE) {    EXIT((""""));    return ;  }  sprintf (text, ""( %8g, %8g, %8g )"", R->x, R->y, R->z) ;  _dxf_DRAW_CURSOR_COORDS(I, text) ;  EXIT((""""));}",2,"cwe119,cwe120"
"scan_dir(POP *p, int new){    char tmp[MAXPATHLEN];    DIR *dir;    struct dirent *dent;    MsgInfoList *mp = p->mlp;    int n_mp = p->msg_count;    int e;    make_path(p, NULL, new, tmp, sizeof(tmp));    mkdir(tmp, 0700);    dir = opendir(tmp);    while((dent = readdir(dir)) != NULL) {tif(strcmp(dent->d_name, ""."") == 0 || strcmp(dent->d_name, "".."") == 0)t    continue;tmp = realloc(mp, (n_mp + 1) * sizeof(*mp));tif(mp == NULL) {t    p->msg_count = 0;t    return pop_msg (p, POP_FAILURE,ttt    ""Can't build message list for '%s': Out of memory"",                            p->user);t}tmemset(mp + n_mp, 0, sizeof(*mp));tmp[n_mp].name = strdup(dent->d_name);tif(mp[n_mp].name == NULL) {t    p->msg_count = 0;t    return pop_msg (p, POP_FAILURE,ttt    ""Can't build message list for '%s': Out of memory"",                            p->user);t}tmp[n_mp].number = n_mp + 1;tmp[n_mp].flags = 0;tif(new)t    mp[n_mp].flags |= NEW_FLAG;te = scan_file(p, &mp[n_mp]);tif(e != POP_SUCCESS)t    return e;        p->drop_size += mp[n_mp].length;tn_mp++;    }    closedir(dir);    p->mlp = mp;    p->msg_count = n_mp;    return POP_SUCCESS;}",3,"cwe119,cwe120,cwe469"
"main(int argc, char *argv[]){  const char *user = NULL, *password = NULL;  const char *realm = NULL, *service = NULL, *path = NULL;  int c;  int flag_error = 0;  unsigned passlen, verifylen;  const char *errstr = NULL;  int result;  char *user_domain = NULL;  int repeat = 0;  while ((c = getopt(argc, argv, ""p:u:r:s:f:R:"")) != EOF)      switch (c) {      case 'R':t  repeat = atoi(optarg);t  break;      case 'f':t  path = optarg;t  break;      case 's':t  service = optarg;t  break;      case 'r':t  realm = optarg;t  break;      case 'u':t  user = optarg;t  break;      case 'p':t  password = optarg;t  break;      default:t  flag_error = 1;t  break;    }  if (!user || !password)    flag_error = 1;  if (flag_error) {    (void)fprintf(stderr,tt  ""%s: usage: %s -u username -p password""tt  ""              [-r realm] [-s servicename]""tt  ""              [-f socket path] [-R repeatnum]"",tt  argv[0], argv[0]);    exit(1);  }  if (!repeat) repeat = 1;  for (c = 0; c < repeat; c++) {             printf(""%d: "", c);      result = saslauthd_verify_password(path, user, password, service, realm);  }  return result;}",2,"cwe120,cweother"
"AssignSkin (edict_t * ent, const char *s, qboolean nickChanged){tint playernum = ent - g_edicts - 1;tchar *p;tchar t[MAX_SKINLEN], skin[64] = ""0"";tif (ctf->value && !matchmode->value)t{ttQ_strncpyz(t, s, sizeof(t));tt ttif(ctf_model->string[0]) {ttt tttstrncpy(t, ctf_model->string, MAX_SKINLEN-strlen(CTF_TEAM1_SKIN)-2);tttstrcat(t, ""/"");tt}ttif ((p = strrchr (t, '/')) != NULL)tttp[1] = 0;ttelsetttstrcpy (t, ""male/"");ttswitch (ent->client->resp.team)tt{ttcase TEAM1:tttCom_sprintf(skin, sizeof(skin), ""%s%s%s"", ent->client->pers.netname, t, CTF_TEAM1_SKIN);tttbreak;ttcase TEAM2:tttCom_sprintf(skin, sizeof(skin), ""%s%s%s"", ent->client->pers.netname, t, CTF_TEAM2_SKIN);tttbreak;ttdefault:tttCom_sprintf(skin, sizeof(skin), ""%s%s"", ent->client->pers.netname, s);tttbreak;tt}t}telset{ttswitch (ent->client->resp.team)tt{ttcase TEAM1:ttcase TEAM2:ttcase TEAM3:tttCom_sprintf(skin, sizeof(skin), ""%s%s"", ent->client->pers.netname, teams[ent->client->resp.team].skin);tttbreak;ttdefault:tttCom_sprintf(skin, sizeof(skin), ""%s%s"", ent->client->pers.netname, s);tttbreak;tt}t}tgi.configstring(CS_PLAYERSKINS + playernum, skin);}",2,"cwe119,cwe120"
"ogg_sync_pageseek(ogg_sync_state *oy,ogg_page *og){  unsigned char *page=oy->data+oy->returned;  unsigned char *next;  s32 bytes=oy->fill-oy->returned;    if(oy->headerbytes==0){    s32 headerbytes,i;    if(bytes<27)return(0);               if(memcmp(page,""OggS"",4))goto sync_fail;        headerbytes=page[26]+27;    if(bytes<headerbytes)return(0);                   for(i=0;i<page[26];i++)      oy->bodybytes+=page[27+i];    oy->headerbytes=headerbytes;  }    if(oy->bodybytes+oy->headerbytes>bytes)return(0);       {         char chksum[4];    ogg_page log;        memcpy(chksum,page+22,4);    memset(page+22,0,4);             log.header=page;    log.header_len=oy->headerbytes;    log.body=page+oy->headerbytes;    log.body_len=oy->bodybytes;    ogg_page_checksum_set(&log);             if(memcmp(chksum,page+22,4)){                    memcpy(page+22,chksum,4);                   goto sync_fail;    }  }       {    unsigned char *page=oy->data+oy->returned;    s32 bytes;    if(og){      og->header=page;      og->header_len=oy->headerbytes;      og->body=page+oy->headerbytes;      og->body_len=oy->bodybytes;    }    oy->unsynced=0;    oy->returned+=(bytes=oy->headerbytes+oy->bodybytes);    oy->headerbytes=0;    oy->bodybytes=0;    return(bytes);  }   sync_fail:    oy->headerbytes=0;  oy->bodybytes=0;       next = (unsigned char *)memchr(page+1,'O',bytes-1);  if(!next)    next=oy->data+oy->fill;  oy->returned=next-oy->data;  return(-(next-page));}",2,"cwe119,cwe120"
"__sgfterr(int32 id_num, char *s, ...){ va_list va, va2, va3; int32 slen; char vpis1[IDLEN], vpis2[4*IDLEN], *vpichp;  char s1[RECLEN], s2[RECLEN]; if (__run_state == SS_SIM)   sprintf(s1, "" now %s"", __to_timstr(s2, &__simtime));  else strcpy(s1, """"); if (__vpierr_cb_active && !__iact_state)  {       __errorcb_suppress_msg = FALSE;   sprintf(vpis1, ""**%s(%d) FATAL ERROR**%s [%d] "", __in_fils[__sfnam_ind],    __slin_cnt, s1, id_num);   va_start(va, s);   vsprintf(vpis2, s, va);   va_end(va);      slen = strlen(vpis1) + strlen(vpis2) + 1;   vpichp = __my_malloc(slen);   strcpy(vpichp, vpis1);   strcat(vpichp, vpis2);   __cberror_fill_einfo(FATAL, id_num, vpichp, __in_fils[__sfnam_ind],    __slin_cnt);   __vpi_error_trycall();   __my_free(vpichp, slen);        if (__errorcb_suppress_msg)    { __errorcb_suppress_msg = FALSE; __my_exit(2, TRUE); }  } __my_fprintf(stdout, ""**%s(%d) FATAL ERROR**%s [%d] "",  __in_fils[__sfnam_ind], __slin_cnt, s1, id_num);   va_start(va2, s); va_start(va3, s); __my_vfprintf(stdout, s, va2, va3); va_end(va2); va_end(va3); my_putc_('', stdout); __my_exit(2, TRUE);}",3,"cwe119,cwe120,cweother"
"named_function (char *name){  register int i;  for (i = 0; function_doc_array[i].func; i++)    if (strcmp (function_doc_array[i].func_name, name) == 0)      break;  return DocInfoCmd(&function_doc_array[i]);}",2,"cwe119,cwe120"
"pem_decrypt(const char *where, const char *end,                        const char *password, SSLObjLoader *ssl_obj){    int ret = -1;    int is_aes_256 = 0;    char *start = NULL;    uint8_t iv[IV_SIZE];    int i, pem_size;    MD5_CTX md5_ctx;    AES_CTX aes_ctx;    uint8_t key[32];             if (password == NULL || strlen(password) == 0)    {#ifdef CONFIG_SSL_FULL_MODE        printf(""Error: Need a password for this PEM file""); TTY_FLUSH();#endif        goto error;    }    if ((start = strstr((const char *)where, aes_str[0])))              {        start += strlen(aes_str[0]);    }    else if ((start = strstr((const char *)where, aes_str[1])))         {        is_aes_256 = 1;        start += strlen(aes_str[1]);    }    else     {#ifdef CONFIG_SSL_FULL_MODE        printf(""Error: Unsupported password cipher""); TTY_FLUSH();#endif        goto error;    }         for (i = 0; i < IV_SIZE; i++)    {        char c = *start++ - '0';        iv[i] = (c > 9 ? c + '0' - 'A' + 10 : c) << 4;        c = *start++ - '0';        iv[i] += (c > 9 ? c + '0' - 'A' + 10 : c);    }    while (*start == 'r' || *start == '')        start++;         pem_size = (int)(end-start);    if (base64_decode(start, pem_size, ssl_obj->buf, &ssl_obj->len) != 0)        goto error;         MD5_Init(&md5_ctx);    MD5_Update(&md5_ctx, (const uint8_t *)password, strlen(password));    MD5_Update(&md5_ctx, iv, SALT_SIZE);    MD5_Final(key, &md5_ctx);    if (is_aes_256)    {        MD5_Init(&md5_ctx);        MD5_Update(&md5_ctx, key, MD5_SIZE);        MD5_Update(&md5_ctx, (const uint8_t *)password, strlen(password));        MD5_Update(&md5_ctx, iv, SALT_SIZE);        MD5_Final(&key[MD5_SIZE], &md5_ctx);    }         AES_set_key(&aes_ctx, key, iv, is_aes_256 ? AES_MODE_256 : AES_MODE_128);    AES_convert_key(&aes_ctx);    AES_cbc_decrypt(&aes_ctx, ssl_obj->buf, ssl_obj->buf, ssl_obj->len);    ret = 0;error:    return ret; }",2,"cwe119,cwe120"
"plug_pdr_0400(const char *ifname, u8 *pdr){tint ram16 = -1, pci = -1, len;tchar fname[256], buf[1024], *pos, *pos2, *end;tFILE *f;tsnprintf(fname, sizeof(fname), ""/proc/net/hostap/%s/debug"", ifname);tf = fopen(fname, ""r"");tif (f == NULL) {ttprintf(""Failed to open '%s' for reading."", fname);ttreturn -1;t}tlen = fread(buf, 1, sizeof(buf) - 1, f);tif (len < 0) {ttprintf(""Failed to read '%s' for reading."", fname);ttreturn -1;t}tbuf[len] = '0';tpos = buf;tend = buf + len;twhile (pos < end) {ttpos2 = strchr(pos, '');ttif (pos2)ttt*pos2 = '0';ttif (strncmp(pos, ""pci="", 4) == 0) {tttpci = atoi(pos + 4);tt} else if (strncmp(pos, ""sram_type="", 10) == 0) {tttram16 = atoi(pos + 10) == 0 ? 0 : 1;tt}ttif (pos2 == NULL)tttbreak;ttpos = pos2 + 1;t}tif (pci == -1 || ram16 == -1) {ttprintf(""Failed to parse 'pci' or 'sram_type' from %s."",tt       fname);ttreturn -1;t}tpdr[0] = (pci ? BIT(2) : 0) | (ram16 ? BIT(1) : 0) | BIT(0);tpdr[1] = 0x00;tprintf(""Plugging PDR 0400 (NIC configuration): ram16=%d ""t       ""pci=%d (%02x %02x)"", ram16, pci, pdr[0], pdr[1]);treturn 0;}",3,"cwe119,cwe120,cweother"
"folder_config_screen(struct pine *ps, int edit_exceptions){    CONT_SCR_S css;    char title[50], htitle[50];    dprint((1, ""=== folder_config_screen called ====""));    mailcap_free();      if(edit_exceptions){      snprintf(title, sizeof(title), _(""SETUP EXCEPTIONS COLLECTION LIST""));      snprintf(htitle, sizeof(htitle), _(""HELP FOR SETUP EXCEPTIONS COLLECTIONS""));    }    else{      snprintf(title, sizeof(title), _(""SETUP COLLECTION LIST""));      snprintf(htitle, sizeof(htitle), _(""HELP FOR SETUP COLLECTIONS""));    }    memset(&css, 0, sizeof(CONT_SCR_S));    css.titlet     = title;       css.print_string = _(""contexts"");    css.contexts     = &ps_global->context_list;    css.help.text    = h_collection_maint;    css.help.title   = htitle;    css.keymenut     = &c_cfg_km;    css.editt     = 1;         context_config_screen(ps_global, &css, edit_exceptions);}",2,"cwe119,cwe120"
"fill_inbuf(){tintttlen;tif (inbufcount >= INBUFLEN)tt ttreturn;tlen = read(0, inbuf + inbufcount, (long)(INBUFLEN - inbufcount));tif (len <= 0)t t{#if defined(__CYGWIN__)ttif (do_resize)tt{tttset_winsize(0, 0, FALSE);tttdo_resize = FALSE;tttreturn;tt}#endifttfprintf(stderr, ""Vim: Error reading input, exiting..."");ttexit(1);t}twhile (len-- > 0)t{tt ttif (inbuf[inbufcount] == 3)tt{ttt tttmemmove((char *)inbuf, (char *)inbuf + inbufcount, len + 1);tttinbufcount = 0;tttgot_int = TRUE;tt}tt++inbufcount;t}}",2,"cwe120,cweother"
"dag_node_clean(struct dag *d, struct dag_node *n){tstruct dag_file *f;tlist_first_item(n->target_files);twhile((f = list_next_item(n->target_files))) {ttfile_clean(f->filename, 0);tt ttchar *name = (char *) hash_table_lookup(n->remote_names_inv, f->filename);ttif(name)tttfile_clean(name, 0);tthash_table_remove(d->completed_files, f->filename);t}t tif(n->nested_job) {ttchar *command = xxmalloc(sizeof(char) * (strlen(n->command) + 4));ttsprintf(command, ""%s -c"", n->command);tt ttdag_export_variables(d, n);ttsystem(command);ttfree(command);t}}",2,"cwe120,cweother"
"string_metric_parse(const char *str){tINT64_T result, factor;tchar prefix;tint fields;tfields = sscanf(str, INT64_FORMAT ""%c"", &result, &prefix);tif(fields == 1)ttreturn result;tswitch (toupper((int) prefix)) {tcase 'K':ttfactor = 1024LL;ttbreak;tcase 'M':ttfactor = 1024LL * 1024;ttbreak;tcase 'G':ttfactor = 1024LL * 1024 * 1024;ttbreak;tcase 'T':ttfactor = 1024LL * 1024 * 1024 * 1024;ttbreak;tcase 'P':ttfactor = 1024LL * 1024 * 1024 * 1024 * 1024;ttbreak;tdefault:ttfactor = 0;ttbreak;t}treturn result * factor;}",2,"cwe120,cweother"
"main(int argc, char **argv){tgfarm_error_t e;tint i, c, status = 0;textern int optind;tif (argc > 0)ttprogram_name = basename(argv[0]);te = gfarm_initialize(&argc, &argv);tif (e != GFARM_ERR_NO_ERROR) {ttfprintf(stderr, ""%s: %s"", program_name,tt    gfarm_error_string(e));ttexit(1);t}twhile ((c = getopt(argc, argv, ""h?"")) != -1) {ttswitch (c) {ttcase 'h':ttcase '?':ttdefault:tttusage();tt}t}targc -= optind;targv += optind;tif (argc <= 0)ttusage();tfor (i = 0; i < argc; i++) {tte = gfs_rmdir(argv[i]);ttif (e != GFARM_ERR_NO_ERROR) {tttfprintf(stderr, ""%s: %s: %s"",ttt    program_name, argv[i], gfarm_error_string(e));tttstatus = 1;tt}t}te = gfarm_terminate();tif (e != GFARM_ERR_NO_ERROR) {ttfprintf(stderr, ""%s: %s"", program_name,tt    gfarm_error_string(e));ttstatus = 1;t}treturn (status);}",2,"cwe120,cweother"
"res_do_304(struct sess *sp){tchar lm[64];tchar *p;thttp_ClrHeader(sp->wrk->resp);tsp->wrk->resp->logtag = HTTP_Tx;thttp_SetResp(sp->wrk->resp, ""HTTP/1.1"", 304, ""Not Modified"");tTIM_format(sp->t_req, lm);thttp_PrintfHeader(sp->wrk, sp->fd, sp->wrk->resp, ""Date: %s"", lm);thttp_SetHeader(sp->wrk, sp->fd, sp->wrk->resp, ""Via: 1.1 varnish"");thttp_PrintfHeader(sp->wrk, sp->fd, sp->wrk->resp,t    ""X-Varnish: %u"", sp->xid);tif (sp->obj->last_modified) {ttTIM_format(sp->obj->last_modified, lm);tthttp_PrintfHeader(sp->wrk, sp->fd, sp->wrk->resp,tt    ""Last-Modified: %s"", lm);t}t tif (http_GetHdr(sp->obj->http, H_Cache_Control, &p))tthttp_PrintfHeader(sp->wrk, sp->fd, sp->wrk->resp,tt    ""Cache-Control: %s"", p);tif (http_GetHdr(sp->obj->http, H_Content_Location, &p))tthttp_PrintfHeader(sp->wrk, sp->fd, sp->wrk->resp,tt    ""Content-Location: %s"", p);tif (http_GetHdr(sp->obj->http, H_ETag, &p))tthttp_PrintfHeader(sp->wrk, sp->fd, sp->wrk->resp,tt    ""ETag: %s"", p);tif (http_GetHdr(sp->obj->http, H_Expires, &p))tthttp_PrintfHeader(sp->wrk, sp->fd, sp->wrk->resp,tt    ""Expires: %s"", p);tif (http_GetHdr(sp->obj->http, H_Vary, &p))tthttp_PrintfHeader(sp->wrk, sp->fd, sp->wrk->resp,tt    ""Vary: %s"", p);thttp_PrintfHeader(sp->wrk, sp->fd, sp->wrk->resp, ""Connection: %s"",t    sp->doclose ? ""close"" : ""keep-alive"");tsp->wantbody = 0;}",2,"cwe119,cwe120"
"read_directory_recursive(struct dir_struct *dir, const char *path, const char *base, int baselen, int check_only, const struct path_simplify *simplify){tDIR *fdir = opendir(path);tint contents = 0;tif (fdir) {ttstruct dirent *de;ttchar fullname[PATH_MAX + 1];ttmemcpy(fullname, base, baselen);ttwhile ((de = readdir(fdir)) != NULL) {tttint len, dtype;tttint exclude;tttif ((de->d_name[0] == '.') &&ttt    (de->d_name[1] == 0 ||ttt     !strcmp(de->d_name + 1, ""."") ||ttt     !strcmp(de->d_name + 1, ""git"")))ttttcontinue;tttlen = strlen(de->d_name);ttt tttif (len + baselen + 8 > sizeof(fullname))ttttcontinue;tttmemcpy(fullname + baselen, de->d_name, len+1);tttif (simplify_away(fullname, baselen + len, simplify))ttttcontinue;tttdtype = DTYPE(de);tttexclude = excluded(dir, fullname, &dtype);tttif (exclude && dir->collect_ignoredttt    && in_pathspec(fullname, baselen + len, simplify))ttttdir_add_ignored(dir, fullname, baselen + len);ttt tttif (exclude && !dir->show_ignored)ttttcontinue;tttif (dtype == DT_UNKNOWN)ttttdtype = get_dtype(de, fullname);ttt tttif (!exclude && dir->show_ignored) {ttttif (dtype != DT_DIR)tttttcontinue;ttt}tttswitch (dtype) {tttdefault:ttttcontinue;tttcase DT_DIR:ttttmemcpy(fullname + baselen + len, ""/"", 2);ttttlen++;ttttswitch (treat_directory(dir, fullname, baselen + len, simplify)) {ttttcase show_directory:tttttif (exclude != dir->show_ignored)ttttttcontinue;tttttbreak;ttttcase recurse_into_directory:tttttcontents += read_directory_recursive(dir,ttttttfullname, fullname, baselen + len, 0, simplify);tttttcontinue;ttttcase ignore_directory:tttttcontinue;tttt}ttttbreak;tttcase DT_REG:tttcase DT_LNK:ttttbreak;ttt}tttcontents++;tttif (check_only)ttttgoto exit_early;tttelsettttdir_add_name(dir, fullname, baselen + len);tt}exit_early:ttclosedir(fdir);t}treturn contents;}",3,"cwe119,cwe120,cwe469"
"key_sched_LBlocks(r   const unsigned char *keystate,r   unsigned char *subkeyr )r {trtint i, j, r;rtunsigned char temp[10], ttemp[10], temp1;rrt tfor(i = 0; i < 10; i++)rt{rttttemp[i] = keystate[i];rt}rrt tfor(j = 0; j < 4; j++)rt{rttsubkey[j] = ttemp[j];rt}rrtfor (r = 1; r < 32; r++)rt{trtt ttfor (i = 0; i < 10; i++)rtt{rttttemp[i] = ttemp[(i + 3) % 10];rtt}rtttemp1 = (S[temp[0] >> 4] << 4) ^ (S[temp[0] & 0xf]);t tttemp[3] ^= (temp1 & 0xf0) ^ (temp[8] & 0xf);rtttemp[6] ^= temp1 << 4;rtttemp[1] ^= temp[1] >> 4;rtttemp[3] ^= r << 2;tttt rttfor (i = 0; i < 10; i++)rtt{rtttttemp[i] = temp[i];rtt}rttfor (j = 0; j < 4; j++)rtt{rtttsubkey[r * 4 + j] = ttemp[j];t tt}trt}rrtreturn;r }",2,"cwe119,cwe120"
"mag_read(void){  if (gpx_vec) {    char** f = os_gpx_files(explorist_info->track_path);    while (f && *f) {      gpx_vec->rd_init(*f);      gpx_vec->read();      f++;    }    f = os_gpx_files(explorist_info->waypoint_path);    while (f && *f) {      gpx_vec->rd_init(*f);      gpx_vec->read();      f++;    }#if 0    f = os_gpx_files(explorist_info->geo_path);    while (f && *f) {      gpx_vec->rd_init(*f);      gpx_vec->read();      f++;    }#endif    return;  }  found_done = 0;  if (global_opts.masked_objective & TRKDATAMASK) {    magrxstate = mrs_handoff;    if (!is_file) {      mag_writemsg(""PMGNCMD,TRACK,2"");    }    while (!found_done) {      mag_readmsg(trkdata);    }  }  found_done = 0;  if (global_opts.masked_objective & WPTDATAMASK) {    magrxstate = mrs_handoff;    if (!is_file) {      mag_writemsg(""PMGNCMD,WAYPOINT"");    }    while (!found_done) {      mag_readmsg(wptdata);    }  }  found_done = 0;  if (global_opts.masked_objective & RTEDATAMASK) {    magrxstate = mrs_handoff;    if (!is_file) {             mag_writemsg(""PMGNCMD,WAYPOINT"");      while (!found_done) {        mag_readmsg(rtedata);      }      mag_writemsg(""PMGNCMD,ROUTE"");      found_done = 0;      while (!found_done) {        mag_readmsg(rtedata);      }    } else {             while (!found_done) {        mag_readmsg(rtedata);      }    }  }}",2,"cwe120,cweother"
"""ssl_CBCExtractMAC(sslBuffer *plaintext,tt  unsigned int originalLength,tt  SSL3Opaque* out,tt  unsigned int macSize){    unsigned char rotatedMac[MAX_MAC_LENGTH];    /* macEnd is the index of |plaintext->buf| just after the end of the     * MAC. */    unsigned macEnd = plaintext->len;    unsigned macStart = macEnd - macSize;    /* scanStart contains the number of bytes that we can ignore because     * the MAC's position can only vary by 255 bytes. */    unsigned scanStart = 0;    unsigned i, j, divSpoiler;    unsigned char rotateOffset;    if (originalLength > macSize + 255 + 1)tscanStart = originalLength - (macSize + 255 + 1);    /* divSpoiler contains a multiple of macSize that is used to cause the     * modulo operation to be constant time. Without this, the time varies     * based on the amount of padding when running on Intel chips at least.     *     * The aim of right-shifting macSize is so that the compiler doesn't     * figure out that it can remove divSpoiler as that would require it     * to prove that macSize is always even, which I hope is beyond it. */    divSpoiler = macSize >> 1;    divSpoiler <<= (sizeof(divSpoiler)-1)*8;    rotateOffset = (divSpoiler + macStart - scanStart) % macSize;    memset(rotatedMac, 0, macSize);    for (i = scanStart; i < originalLength;) {tfor (j = 0; j < macSize && i < originalLength; i++, j++) {t    unsigned char macStarted = ssl_ConstantTimeGE(i, macStart);t    unsigned char macEnded = ssl_ConstantTimeGE(i, macEnd);t    unsigned char b = 0;t    b = plaintext->buf[i];t    rotatedMac[j] |= b & macStarted & ~macEnded;t}    }    /* Now rotate the MAC. If we knew that the MAC fit into a CPU cache line     * we could line-align |rotatedMac| and rotate in place. */    memset(out, 0, macSize);    for (i = 0; i < macSize; i++) {tunsigned char offset =t    (divSpoiler + macSize - rotateOffset + i) % macSize;tfor (j = 0; j < macSize; j++) {t    out[j] |= rotatedMac[i] & ssl_ConstantTimeEQ8(j, offset);t}    }}""",2,"cwe119,cwe120"
"do_luks_add_key (const char *device, const char *key, const char *newkey,                 int keyslot){  char *keyfile = write_key_to_temp (key);  if (!keyfile)    return -1;  char *newkeyfile = write_key_to_temp (newkey);  if (!newkeyfile) {    remove_temp (keyfile);    return -1;  }  const char *argv[MAX_ARGS];  char keyslot_s[16];  size_t i = 0;  ADD_ARG (argv, i, str_cryptsetup);  ADD_ARG (argv, i, ""-q"");  ADD_ARG (argv, i, ""-d"");  ADD_ARG (argv, i, keyfile);  ADD_ARG (argv, i, ""--key-slot"");  snprintf (keyslot_s, sizeof keyslot_s, ""%d"", keyslot);  ADD_ARG (argv, i, keyslot_s);  ADD_ARG (argv, i, ""luksAddKey"");  ADD_ARG (argv, i, device);  ADD_ARG (argv, i, newkeyfile);  ADD_ARG (argv, i, NULL);  CLEANUP_FREE char *err = NULL;  int r = commandv (NULL, &err, (const char * const *) argv);  remove_temp (keyfile);  remove_temp (newkeyfile);  if (r == -1) {    reply_with_error (""%s"", err);    return -1;  }  return 0;}",2,"cwe119,cwe120"
"MD5File(char *dest, const char *file_name){tif (!dest || !file_name) {ttLM_ERR(""invalid parameter value"");ttreturn -1;t}tMD5_CTX context;tFILE *input;tunsigned char buffer[32768];tunsigned char hash[16];tunsigned int counter, size;ttstruct stat stats;    if (stat(file_name, &stats) != 0) {ttLM_ERR(""could not stat file %s"", file_name);ttreturn -1;t}tsize = stats.st_size;tMD5Init(&context);tif((input = fopen(file_name, ""rb"")) == NULL) {ttLM_ERR(""could not open file %s"", file_name);ttreturn -1;t}twhile(size) {ttcounter = (size > sizeof(buffer)) ? sizeof(buffer) : size;ttif ((counter = fread(buffer, 1, counter, input)) <= 0) {tttfclose(input);tttreturn -1;tt}ttMD5Update(&context, buffer, counter);ttsize -= counter;t}tfclose(input);tMD5Final(hash, &context);tstring2hex(hash, 16, dest);tLM_DBG(""MD5 calculated: %.*s for file %s"", MD5_LEN, dest, file_name);treturn 0;}",3,"cwe119,cwe120,cweother"
"show_pci_devices(int argc __unused, char **argv __unused,ttt     struct s_hardware *hardware){    int i = 1;    struct pci_device *pci_device;    char kernel_modules[LINUX_KERNEL_MODULE_SIZE *tttMAX_KERNEL_MODULES_PER_PCI_DEVICE];    bool nopciids = false;    bool nomodulespcimap = false;    bool nomodulesalias = false;    bool nomodulesfile = false;    char first_line[81];    char second_line[81];    reset_more_printf();    more_printf(""%d PCI devices detected"", hardware->nb_pci_devices);    if (hardware->pci_ids_return_code == -ENOPCIIDS) {tnopciids = true;    }    if (hardware->modules_pcimap_return_code == -ENOMODULESPCIMAP) {tnomodulespcimap = true;    }    if (hardware->modules_pcimap_return_code == -ENOMODULESALIAS) {tnomodulesalias = true;    }    nomodulesfile = nomodulespcimap && nomodulesalias;         for_each_pci_func(pci_device, hardware->pci_domain) {tmemset(kernel_modules, 0, sizeof kernel_modules);tfor (int kmod = 0;t     kmod < pci_device->dev_info->linux_kernel_module_count; kmod++) {t    if (kmod > 0) {ttstrncat(kernel_modules, "" | "", 3);t    }t    strncat(kernel_modules,tt    pci_device->dev_info->linux_kernel_module[kmod],tt    LINUX_KERNEL_MODULE_SIZE - 1);t}tif (pci_device->dev_info->linux_kernel_module_count == 0)t    strlcpy(kernel_modules, ""unknown"", 7);tif (nopciids == false) {t    snprintf(first_line, sizeof(first_line),tt     ""%02d: %s %s "", i,tt     pci_device->dev_info->vendor_name,tt     pci_device->dev_info->product_name);t    if (nomodulesfile == false)ttsnprintf(second_line, sizeof(second_line),ttt ""    # %-25s # Kmod: %s"",ttt pci_device->dev_info->class_name, kernel_modules);t    elsettsnprintf(second_line, sizeof(second_line),ttt ""    # %-25s # ID:%04x:%04x[%04x:%04x]"",ttt pci_device->dev_info->class_name,ttt pci_device->vendor,ttt pci_device->product,ttt pci_device->sub_vendor, pci_device->sub_product);t    more_printf(""%s"", first_line);t    more_printf(""%s"", second_line);t    more_printf("""");t} else if (nopciids == true) {t    if (nomodulesfile == true) {ttmore_printf(""%02d: %04x:%04x [%04x:%04x] "",ttt    i, pci_device->vendor,ttt    pci_device->product,ttt    pci_device->sub_vendor, pci_device->sub_product);t    } else {ttmore_printftt    (""%02d: %04x:%04x [%04x:%04x] Kmod:%s"", i,tt     pci_device->vendor, pci_device->product,tt     pci_device->sub_vendor,tt     pci_device->sub_product, kernel_modules);t    }t}ti++;    }}",2,"cwe119,cwe120"
"insert_into_cache(char *str, unsigned int len){tint i;tstruct cache_entry *least;tint start = random() % (NUM_CACHE_ENTRIES - 1);tleast = cache[start];tfor (i = start + 1; i != start; i = (i + 1) % NUM_CACHE_ENTRIES) {ttif (!cache[i]->taken) {tttcache[i]->taken = 1;tttleast = cache[i];tttbreak;tt}ttif (cache[i]->used < least->used && (cache[i]->checked + (NUM_CACHE_ENTRIES * 2)) < check_count)tttleast = cache[i];t}tstrcpy(least->entryname, str);tleast->used = 0;tleast->len = len;tleast->checked = check_count;treturn;}",2,"cwe120,cweother"
"locked_EVP_MD_CTX_copy(EVP_MD_CTX *new_ctx_p, EVPobject *self){    ENTER_HASHLIB(self);    EVP_MD_CTX_copy(new_ctx_p, &self->ctx);    LEAVE_HASHLIB(self);}",2,"cwe119,cwe120"
"""abiview_graphTextDisplay(AjPGraph graphs, ajint nstart,ttttt     ajint nstop,ttttt     const AjPShort basePositions,ttttt     const AjPStr nseq,ttttt     float tmax, float scale, ajint nt){    ajint i;    ajint colres;    AjPGraphdata gdata;    char res[2];    res[1]='0';    /* create graph data object */    gdata = ajGraphdataNewI(ajShortGet(basePositions,nstop-1)-nt);    for(i=nstart;i<nstop;i++)    {t*res = ajStrGetCharPos(nseq,i);tcolres = abiview_getResColour(*res);tajGraphdataAddposTextScaleC(gdata,(float)i+(float)1.,tttt   tmax+(float)75.,colres, scale,tttt   res);    }    ajGraphdataSetMinmax(gdata,(float)nstart+1,ttt   (float)nstop,tmax+(float)70.,tmax+(float)80.);    /* add graph to list in a multiple graph */    ajGraphDataAdd(graphs,gdata);    return gdata;}""",2,"cwe119,cwe120"
"save_sectors(char *dev, int fdin) {    struct sector *s;    char ss[516];    int fdout = -1;    fdout = open(save_sector_file, O_WRONLY | O_CREAT, 0444);    if (fdout < 0) {tperror(save_sector_file);terror(_(""cannot open partition sector save file (%s)""),t      save_sector_file);tgoto err;    }    for (s = sectorhead; s; s = s->next)tif (s->to_be_written) {t    ulong_to_chars(s->sectornumber, ss);t    if (!sseek(dev, fdin, s->sectornumber))ttgoto err;t    if (read(fdin, ss + 4, 512) != 512) {ttperror(""read"");tterror(_(""read error on %s - cannot read sector %lu""),tt      dev, s->sectornumber);ttgoto err;t    }t    if (write(fdout, ss, sizeof(ss)) != sizeof(ss)) {ttperror(""write"");tterror(_(""write error on %s""), save_sector_file);ttgoto err;t    }t}    close(fdout);    return 1; err:    if (fdout >= 0)tclose(fdout);    return 0;}",3,"cwe119,cwe120,cweother"
"ucspi_protocol(void){  if (proto == 0 && (proto = getenv(""PROTO"")) != 0) {    protolen = strlen(proto);    vartmp = malloc(protolen + MAXNAME+1);    memcpy(vartmp, proto, protolen);    memset(vartmp + protolen, 0, MAXNAME+1);  }  return proto;}",2,"cwe120,cweother"
"_tenEpiRegThreshold(Nrrd **nthresh, Nrrd **nblur, unsigned int ninLen,                    double DWthr, int verb, int progress, double expo) {  static const char me[]=""_tenEpiRegThreshold"";  airArray *mop;  size_t I, sx, sy, sz, ni;  float val;  unsigned char *thr;  if (!( AIR_EXISTS(DWthr) )) {    if (_tenEpiRegThresholdFind(&DWthr, nblur, ninLen, progress, expo)) {      biffAddf(TEN, ""%s: trouble with automatic threshold determination"", me);      return 1;    }    fprintf(stderr, ""%s: using %g for DWI threshold"", me, DWthr);  }  mop = airMopNew();  if (verb) {    fprintf(stderr, ""%s:            "", me); fflush(stderr);  }  sx = nblur[0]->axis[0].size;  sy = nblur[0]->axis[1].size;  sz = nblur[0]->axis[2].size;  for (ni=0; ni<ninLen; ni++) {    if (verb) {      fprintf(stderr, ""%2u "", (unsigned int)ni); fflush(stderr);    }    if (nrrdMaybeAlloc_va(nthresh[ni], nrrdTypeUChar, 3,                          sx, sy, sz)) {      biffMovef(TEN, NRRD, ""%s: trouble allocating threshold %u"",                me, (unsigned int)ni);      airMopError(mop); return 1;    }    thr = (unsigned char *)(nthresh[ni]->data);    for (I=0; I<sx*sy*sz; I++) {      val = nrrdFLookup[nblur[ni]->type](nblur[ni]->data, I);      val -= AIR_CAST(float, DWthr);      thr[I] = (val >= 0 ? 1 : 0);    }  }  if (verb) {    fprintf(stderr, ""done"");  }  airMopOkay(mop);  return 0;}",2,"cwe119,cwe120"
"v_unpack_o_method_group_create(const char *buf, size_t buffer_length){tunsigned int buffer_pos = 0;tvoid (* func_o_method_group_create)(void *user_data, VNodeID node_id, uint16 group_id, const char *name);tVNodeID node_id;tuint16 group_id;tchar name[16];ttfunc_o_method_group_create = v_fs_get_user_func(41);tif(buffer_length < 6)ttreturn -1;tbuffer_pos += vnp_raw_unpack_uint32(&buf[buffer_pos], &node_id);tbuffer_pos += vnp_raw_unpack_uint16(&buf[buffer_pos], &group_id);tbuffer_pos += vnp_raw_unpack_string(&buf[buffer_pos], name, 16, buffer_length - buffer_pos);#if defined V_PRINT_RECEIVE_COMMANDStif(name[0] == 0)ttprintf(""receive: verse_send_o_method_group_destroy(node_id = %u group_id = %u ); callback = %p"", node_id, group_id, v_fs_get_alias_user_func(41));telsettprintf(""receive: verse_send_o_method_group_create(node_id = %u group_id = %u name = %s ); callback = %p"", node_id, group_id, name, v_fs_get_user_func(41));#endiftif(name[0] == 0)t{ttvoid (* alias_o_method_group_destroy)(void *user_data, VNodeID node_id, uint16 group_id);ttalias_o_method_group_destroy = v_fs_get_alias_user_func(41);ttif(alias_o_method_group_destroy != NULL)tttalias_o_method_group_destroy(v_fs_get_alias_user_data(41), node_id, group_id);ttreturn buffer_pos;t}tif(func_o_method_group_create != NULL)ttfunc_o_method_group_create(v_fs_get_user_data(41), node_id, group_id, name);treturn buffer_pos;}",2,"cwe119,cwe120"
"main(int argc, char *argv[]){     int sockfd, newsockfd, portno;     socklen_t clilen;     char buffer[256];     struct sockaddr_in serv_addr, cli_addr;     int n;     if (argc < 2) {         fprintf(stderr,""ERROR, no port provided"");         exit(1);     }     sockfd = socket(AF_INET, SOCK_STREAM, 0);     if (sockfd < 0)         error(""ERROR opening socket"");     bzero((char *) &serv_addr, sizeof(serv_addr));     portno = atoi(argv[1]);     serv_addr.sin_family = AF_INET;     serv_addr.sin_addr.s_addr = INADDR_ANY;     serv_addr.sin_port = htons(portno);     if (bind(sockfd, (struct sockaddr *) &serv_addr,              sizeof(serv_addr)) < 0)               error(""ERROR on binding"");     listen(sockfd,5);     clilen = sizeof(cli_addr);           int processed=0;     while(1){t     newsockfd = accept(sockfd, ttt (struct sockaddr *) &cli_addr, ttt &clilen);t     if (newsockfd < 0) tt  error(""ERROR on accept"");t     bzero(buffer,256);t     n = read(newsockfd,buffer,255);t     if (n < 0) error(""ERROR reading from socket"");t      t     int done=0;t     char correct[] = ""DLE ETX"";t     int i;t     for(i=0;i<strlen(buffer);i++){tttif (strcmp(buffer,correct)==0){ttttdone=1;ttttstrcpy(buffer,""Done""); ttt}tt}t t     n = write(newsockfd,buffer,strlen(buffer)); t     processed++;t     if (n < 0) error(""ERROR writing to socket"");t     close(newsockfd);t      t     if(done){    ttprintf(""EnhancedServer echoed %d strings"",processed-1);ttbreak;tt}     }     close(sockfd);     return 0; }",3,"cwe119,cwe120,cweother"
"group_match_count_function_read(struct ast_channel *chan,ttttt   const char *cmd, char *data, char *buf,ttttt   size_t len){tchar group[80] = """";tchar category[80] = """";tast_app_group_split_group(data, group, sizeof(group), category,tttt  sizeof(category));tif (!ast_strlen_zero(group)) {ttint count;ttcount = ast_app_group_match_get_count(group, category);ttsnprintf(buf, len, ""%d"", count);ttreturn 0;t}treturn -1;}",2,"cwe119,cwe120"
"sendto_one(struct Client *to, const char *pattern, ...){  va_list args;  char buffer[IRCD_BUFSIZE];  int len;  if (to->from != NULL)    to = to->from;  if (IsDead(to))    return;    va_start(args, pattern);  len = send_format(buffer, IRCD_BUFSIZE, pattern, args);  va_end(args);  send_message(to, buffer, len);}",2,"cwe119,cwe120"
"var_list_set_int(lList **varl, const char *name, int value){   char buffer[2048];   DENTER(TOP_LAYER, ""var_list_set_int"");   sprintf(buffer, ""%d"", value);   var_list_set_string(varl, name, buffer);   DEXIT;}",2,"cwe119,cwe120"
"e2_recv_info_block(Epson_Scanner * s, unsigned char *scanner_status,tt       size_t info_size, size_t * payload_size){tSANE_Status status;tunsigned char info[6];tif (s->hw->connection == SANE_EPSON_PIO)tte2_recv(s, info, 1, &status);telsette2_recv(s, info, info_size, &status);tif (status != SANE_STATUS_GOOD)ttreturn status;t tif (info[0] == NAK) {ttDBG(1, ""%s: command not supported"", __func__);ttreturn SANE_STATUS_UNSUPPORTED;t}t tif (info[0] != STX) {ttDBG(1, ""%s: expecting STX, got %02X"", __func__, info[0]);ttreturn SANE_STATUS_INVAL;t}t tif (s->hw->connection == SANE_EPSON_PIO) {tte2_recv(s, &info[1], info_size - 1, &status);ttif (status != SANE_STATUS_GOOD)tttreturn status;t}tif (scanner_status)tt*scanner_status = info[1];tif (payload_size) {tt*payload_size = le16atoh(&info[2]);ttif (info_size == 6)ttt*payload_size *= le16atoh(&info[4]);ttDBG(14, ""%s: payload length: %lu"", __func__,ttt(u_long) *payload_size);t}treturn SANE_STATUS_GOOD;}",2,"cwe119,cwe120"
"_output_dell_system_info_idrac_info (ipmi_oem_state_data_t *state_data){  uint8_t dhcp_or_static;  char ip_address_buf[IPMI_OEM_STR_BUFLEN + 1];   char idrac_firmware_version_buf[IPMI_OEM_STR_BUFLEN + 1];  uint8_t idrac_type;  char *dhcp_or_static_str;  char *idrac_type_str;  int rv = -1;  int ret;  assert (state_data);  assert (state_data->prog_data->args->oem_options_count == 1);  memset (ip_address_buf, '0', IPMI_OEM_STR_BUFLEN + 1);  memset (idrac_firmware_version_buf, '0', IPMI_OEM_STR_BUFLEN + 1);  if ((ret = _get_dell_system_info_idrac_info (state_data,ttttt       &dhcp_or_static,ttttt       ip_address_buf,ttttt       IPMI_OEM_STR_BUFLEN,ttttt       idrac_firmware_version_buf,ttttt       IPMI_OEM_STR_BUFLEN,ttttt       &idrac_type)) < 0)    goto cleanup;  if (!ret)    {      pstdout_fprintf (state_data->pstate,tt       stderr,tt       ""%s:%s '%s' option not supported on this system"",tt       state_data->prog_data->args->oem_id,tt       state_data->prog_data->args->oem_command,tt       state_data->prog_data->args->oem_options[0]);      goto cleanup;    }  pstdout_printf (state_data->pstate,tt  ""IP Address             : %s"",tt  ip_address_buf);  if (dhcp_or_static == IPMI_OEM_DELL_SYSTEM_INFO_IDRAC_INFO_IP_ADDRESS_CONFIG_DHCP)    dhcp_or_static_str = ""DHCP"";  else if (dhcp_or_static == IPMI_OEM_DELL_SYSTEM_INFO_IDRAC_INFO_IP_ADDRESS_CONFIG_STATIC)    dhcp_or_static_str = ""Static"";  else    dhcp_or_static_str = ""Unknown"";  pstdout_printf (state_data->pstate,tt  ""IP Configuration       : %s"",tt  dhcp_or_static_str);  pstdout_printf (state_data->pstate,tt  ""iDRAC Firmware Version : %s"",tt  idrac_firmware_version_buf);  if (idrac_type == IPMI_OEM_DELL_SYSTEM_INFO_IDRAC_INFO_IDRAC_TYPE_10G)    idrac_type_str = ""Dell Poweredge 10G"";  else if (idrac_type == IPMI_OEM_DELL_SYSTEM_INFO_IDRAC_INFO_IDRAC_TYPE_CMC)    idrac_type_str = ""Dell Chassis Management Controller "";  else if (idrac_type == IPMI_OEM_DELL_SYSTEM_INFO_IDRAC_INFO_IDRAC_TYPE_11G_MONOLITHIC)    idrac_type_str = ""Dell Poweredge 11G (Monolithic)"";  else if (idrac_type == IPMI_OEM_DELL_SYSTEM_INFO_IDRAC_INFO_IDRAC_TYPE_11G_MODULAR)    idrac_type_str = ""Dell Poweredge 11G (Modular)"";  else if (idrac_type == IPMI_OEM_DELL_SYSTEM_INFO_IDRAC_INFO_IDRAC_TYPE_MASER_LITE_BMC)    idrac_type_str = ""Maser Lite BMC"";  else if (idrac_type == IPMI_OEM_DELL_SYSTEM_INFO_IDRAC_INFO_IDRAC_TYPE_12G_MONOLITHIC)    idrac_type_str = ""Dell Poweredge 12G (Monolithic)"";  else if (idrac_type == IPMI_OEM_DELL_SYSTEM_INFO_IDRAC_INFO_IDRAC_TYPE_12G_MODULAR)    idrac_type_str = ""Dell Poweredge 12G (Modular)"";  else    idrac_type_str = ""Unknown"";  pstdout_printf (state_data->pstate,tt  ""iDRAC Type             : %s"",tt  idrac_type_str);  rv = 0; cleanup:  return (rv);}",2,"cwe119,cwe120"
"diplomat_bribe(struct player *pplayer, struct unit *pdiplomat,tt    struct unit *pvictim){  char victim_link[MAX_LEN_LINK];  struct player *uplayer;  struct tile *victim_tile;  int bribe_cost;  int diplomat_id = pdiplomat->id;     if (!pvictim) {    return;  }  uplayer = unit_owner(pvictim);     if (!uplayer || pplayers_allied(pplayer, uplayer)) {    return;  }  log_debug(""bribe-unit: unit: %d"", pdiplomat->id);     if (get_player_bonus(uplayer, EFT_UNBRIBABLE_UNITS)) {    notify_player(pplayer, unit_tile(pdiplomat),                  E_MY_DIPLOMAT_FAILED, ftc_server,                  _(""You can't bribe a unit from this nation.""));    return;  }     bribe_cost = unit_bribe_cost(pvictim);     if (pplayer->economic.gold < bribe_cost) {    notify_player(pplayer, unit_tile(pdiplomat),                  E_MY_DIPLOMAT_FAILED, ftc_server,                  _(""You don't have enough gold to bribe the %s %s.""),                  nation_adjective_for_player(uplayer),                  unit_link(pvictim));    log_debug(""bribe-unit: not enough gold"");    return;  }  if (unit_has_type_flag(pvictim, F_UNBRIBABLE)) {    notify_player(pplayer, unit_tile(pdiplomat),                  E_MY_DIPLOMAT_FAILED, ftc_server,                  _(""You cannot bribe the %s!""),                  unit_link(pvictim));    return;  }  log_debug(""bribe-unit: succeeded"");  victim_tile = unit_tile(pvictim);  pvictim = unit_change_owner(pvictim, pplayer, pdiplomat->homecity,                              ULR_BRIBED);     sz_strlcpy(victim_link, unit_link(pvictim));     notify_player(pplayer, victim_tile, E_MY_DIPLOMAT_BRIBE, ftc_server,                                 _(""Your %s succeeded in bribing the %s.""),                unit_link(pdiplomat), victim_link);  if (maybe_make_veteran(pdiplomat)) {    notify_unit_experience(pdiplomat);  }  notify_player(uplayer, victim_tile, E_ENEMY_DIPLOMAT_BRIBE, ftc_server,                                 _(""Your %s was bribed by the %s.""),                victim_link, nation_plural_for_player(pplayer));     pplayer->economic.gold -= bribe_cost;     maybe_cause_incident(DIPLOMAT_BRIBE, pplayer, uplayer,                       victim_tile, victim_link);  if (!unit_alive(diplomat_id)) {    return;  }     if (!unit_move_handling(pdiplomat, victim_tile, FALSE, FALSE)) {    pdiplomat->moves_left = 0;  }  if (NULL != player_unit_by_number(pplayer, diplomat_id)) {    send_unit_info(pplayer, pdiplomat);  }     send_player_all_c(pplayer, NULL);}",2,"cwe119,cwe120"
"save_arguments(int argc, const char **argv) {  unsigned Length, i;  if (SavedArgs || !argv) return argc;        while (argc > 1 && !strncmp(argv[1], ""-llvmprof-"", 10)) {         const char *Arg = argv[1];    memmove(&argv[1], &argv[2], (argc-1)*sizeof(char*));    --argc;    if (!strcmp(Arg, ""-llvmprof-output"")) {      if (argc == 1)        puts(""-llvmprof-output requires a filename argument!"");      else {        OutputFilename = strdup(argv[1]);        memmove(&argv[1], &argv[2], (argc-1)*sizeof(char*));        --argc;      }    } else {      printf(""Unknown option to the profiler runtime: '%s' - ignored."", Arg);    }  }  for (Length = 0, i = 0; i != (unsigned)argc; ++i)    Length += strlen(argv[i])+1;  SavedArgs = (char*)malloc(Length);  for (Length = 0, i = 0; i != (unsigned)argc; ++i) {    unsigned Len = strlen(argv[i]);    memcpy(SavedArgs+Length, argv[i], Len);    Length += Len;    SavedArgs[Length++] = ' ';  }  SavedArgsLength = Length;  return argc;}",2,"cwe120,cweother"
"file_contents(struct filetest *ft){    int res;    int fd;    off_t off;    size_t size;    char buf[TESTFILESIZE / 2];    res = flush_cache();    if(res == -1)        return 0;    res = virt_open(ft->filename, O_RDONLY, 0);    if(res == -1)        return 0;    fd = res;    for(off = 0; off < TESTFILESIZE; off += size) {        size = rand() % TESTFILESIZE / 2;        res = virt_read(fd, buf, size);        if(off + size > TESTFILESIZE)            size = TESTFILESIZE - off;        if(res != size)            return 0;        if(memcmp(ft->data + off, buf, size) != 0)            return 0;    }        res = virt_read(fd, buf, 100);    if(res != 0)        return 0;    res = virt_close(fd);    if(res == -1)        return 0;    return 1;}",2,"cwe119,cwe120"
"""MGD77_Read_Header_Record_m77t (char *file, struct MGD77_CONTROL *F, struct MGD77_HEADER *H){t/* Applies to MGD77T files */tchar *MGD77_header, line[BUFSIZ], *not_used = NULL;tint i, err, n_eols, c, n;tn_eols = c = n = 0;t/* Also shuts up the boring compiler warnings */t/* argument file is generally ignored since file is already open */tmemset ((void *)H, '0', sizeof (struct MGD77_HEADER));t/* Completely wipe existing header */t/* Since we do not know the number of records, we must quickly count lines */twhile (fgets (line, BUFSIZ, F->fp)) H->n_records++;t/* Count every line */trewind (F->fp);ttttt/* Go back to beginning of file */tH->n_records -= MGD77T_N_HEADER_RECORDS;t/* Adjust for the 2 records in the header block */tnot_used = fgets (line, BUFSIZ, F->fp);tt/* Skip the column header  */tMGD77_header = (char *)GMT_memory (VNULL, (size_t)MGD77T_HEADER_LENGTH, sizeof (char), GMT_program);tnot_used = fgets (MGD77_header, BUFSIZ, F->fp);ttt/* Read the entire header record  */tfor (i = 0; i < 2; i++) H->mgd77[i] = (struct MGD77_HEADER_PARAMS *) GMT_memory (VNULL, (size_t)1, sizeof (struct MGD77_HEADER_PARAMS), GMT_program);t/* Allocate parameter header */tif ((err = MGD77_Decode_Header_m77t (H->mgd77[MGD77_ORIG], MGD77_header))) return (err);t/* Decode individual items in the text headers */tGMT_free ((void *)MGD77_header);t/* Fill in info in F */tMGD77_set_plain_mgd77 (H, TRUE);ttt/* Set the info for the standard 27 data fields in MGD-77 files */tif ((err = MGD77_Order_Columns (F, H))) return (err);t/* Make sure requested columns are OK; if not given set defaults */treturn (MGD77_NO_ERROR);t/* Success, it seems */}""",2,"cwe119,cwe120"
"display_bh_4(void){tint i, len;tchar buf[BUFSIZE];tchar *array; tulong *p;tstruct load_module *lm;tif (!(len = get_array_length(""softirq_vec"", NULL, 0)))tterror(FATAL, ""cannot determine softirq_vec array length"");tfprintf(fp, ""SOFTIRQ_VEC %s"",ttmkstring(buf, VADDR_PRLEN, CENTER|RJUST, ""ACTION""));tarray = GETBUF(SIZE(softirq_action) * (len+1));ttreadmem(symbol_value(""softirq_vec""), KVADDR,ttarray, SIZE(softirq_action) * len,tt""softirq_vec"", FAULT_ON_ERROR);tfor (i = 0, p = (ulong *)array; i < len; i++, p++) {ttif (*p) {tttfprintf(fp, ""    [%d]%s %s  <%s>"",tttti, i < 10 ? space(4) : space(3),ttttmkstring(buf, VADDR_PRLEN, ttttLONG_HEX|CENTER|RJUST, MKSTR(*p)),ttttvalue_symbol(*p));tttif (module_symbol(*p, NULL, &lm, NULL, 0))ttttfprintf(fp, ""  [%s]"", lm->mod_name);tttfprintf(fp, """");tt}ttif (SIZE(softirq_action) == (sizeof(void *)*2))tttp++;t}tFREEBUF(array);}",2,"cwe119,cwe120"
"autogroup_add_entry( Operation *op, SlapReply *rs){tslap_overinsttt*on = (slap_overinst *)op->o_bd->bd_info;tautogroup_info_tt*agi = (autogroup_info_t *)on->on_bi.bi_private;tautogroup_def_ttt*agd = agi->agi_def;tautogroup_entry_tt*age;tautogroup_filter_tt*agf;tinttttrc = 0;tDebug( LDAP_DEBUG_TRACE, ""==> autogroup_add_entry <%s>"", ttop->ora_e->e_name.bv_val, 0, 0);tldap_pvt_thread_mutex_lock( &agi->agi_mutex );ttt tfor ( ; agd ; agd = agd->agd_next ) {ttif ( is_entry_objectclass_or_sub( op->ora_e, agd->agd_oc ) ) {tttModificationttmod;tttconst chartt*text = NULL;tttcharttttextbuf[1024];tttmod.sm_op = LDAP_MOD_DELETE;tttmod.sm_desc = agd->agd_member_ad;tttmod.sm_type = agd->agd_member_ad->ad_cname;tttmod.sm_values = NULL;tttmod.sm_nvalues = NULL;ttt tttmodify_delete_values( op->ora_e, &mod,   1, &text, textbuf, sizeof( textbuf ) );tttautogroup_add_group( op, agi, agd, op->ora_e, NULL, 1 , 0);tttldap_pvt_thread_mutex_unlock( &agi->agi_mutex );tttttreturn SLAP_CB_CONTINUE;tt}t}ttfor ( age = agi->agi_entry; age ; age = age->age_next ) {ttldap_pvt_thread_mutex_lock( &age->age_mutex );tttt ttfor ( agf = age->age_filter; agf ; agf = agf->agf_next ) {tttif ( dnIsSuffix( &op->o_req_ndn, &agf->agf_ndn ) ) {ttttrc = test_filter( op, op->ora_e, agf->agf_filter );ttttif ( rc == LDAP_COMPARE_TRUE ) {tttttif ( agf->agf_anlist ) {ttttttautogroup_add_member_values_to_group( op, op->ora_e, age, agf->agf_anlist[0].an_desc );ttttt} else {ttttttautogroup_add_member_to_group( op, &op->ora_e->e_name, &op->ora_e->e_nname, age );ttttt}tttttbreak;tttt}ttt}tt}ttldap_pvt_thread_mutex_unlock( &age->age_mutex );ttt}tldap_pvt_thread_mutex_unlock( &agi->agi_mutex );tttreturn SLAP_CB_CONTINUE;}",2,"cwe119,cwe120"
"filter_shoutcast_metadata (source_t *source, char *metadata, unsigned int meta_len){    if (metadata)    {        char *end, *p;        int len;        do        {            metadata++;            if (strncmp (metadata, ""StreamTitle='"", 13))                break;            if ((end = strstr (metadata+13, ""';"")) == NULL)                break;            len = (end - metadata) - 13;            p = calloc (1, len+1);            if (p)            {                memcpy (p, metadata+13, len);                logging_playlist (source->mount, p, source->listeners);                stats_event_conv (source->mount, ""title"", p, source->format->charset);                yp_touch (source->mount);                free (p);            }        } while (0);    }}",2,"cwe120,cweother"
"__glusterd_brick_op_cbk (struct rpc_req *req, struct iovec *iov,                          int count, void *myframe){        gd1_mgmt_brick_op_rsp         rsp   = {0};        int                           ret   = -1;        int32_t                       op_ret = -1;        glusterd_op_sm_event_type_t   event_type = GD_OP_EVENT_NONE;        call_frame_t                  *frame = NULL;        glusterd_op_brick_rsp_ctx_t   *ev_ctx = NULL;        dict_t                        *dict = NULL;        int                           index = 0;        glusterd_req_ctx_t            *req_ctx = NULL;        glusterd_pending_node_t       *node = NULL;        xlator_t                      *this = NULL;        this = THIS;        GF_ASSERT (this);        GF_ASSERT (req);        frame = myframe;        req_ctx = frame->local;        if (-1 == req->rpc_status) {                rsp.op_ret   = -1;                rsp.op_errno = EINVAL;                                 rsp.op_errstr = strdup (""error"");ttevent_type = GD_OP_EVENT_RCVD_RJT;                goto out;        }        ret =  xdr_to_generic (*iov, &rsp, (xdrproc_t)xdr_gd1_mgmt_brick_op_rsp);        if (ret < 0) {                gf_log (this->name, GF_LOG_ERROR, ""Failed to decode brick op ""                        ""response received"");                rsp.op_ret   = -1;                rsp.op_errno = EINVAL;                rsp.op_errstr = strdup (""Unable to decode brick op response"");ttevent_type = GD_OP_EVENT_RCVD_RJT;                goto out;        }        if (rsp.output.output_len) {                                 dict  = dict_new ();                ret = dict_unserialize (rsp.output.output_val,                                        rsp.output.output_len,                                        &dict);                if (ret < 0) {                        gf_log (this->name, GF_LOG_ERROR, ""Failed to ""                                ""unserialize rsp-buffer to dictionary"");tttevent_type = GD_OP_EVENT_RCVD_RJT;                        goto out;                } else {                        dict->extra_stdfree = rsp.output.output_val;                }        }        op_ret = rsp.op_ret;                 if (GD_OP_STATUS_VOLUME == req_ctx->op) {                node = frame->cookie;                index = node->index;                ret = dict_set_int32 (dict, ""index"", index);                if (ret) {                        gf_log (this->name, GF_LOG_ERROR,                                ""Error setting index on brick status rsp dict"");                        rsp.op_ret = -1;                        event_type = GD_OP_EVENT_RCVD_RJT;                        goto out;                }        }out:        ev_ctx = GF_CALLOC (1, sizeof (*ev_ctx), gf_gld_mt_brick_rsp_ctx_t);        GF_ASSERT (ev_ctx);        if (op_ret) {                event_type = GD_OP_EVENT_RCVD_RJT;                ev_ctx->op_ret = op_ret;                ev_ctx->op_errstr = gf_strdup(rsp.op_errstr);        } else {                event_type = GD_OP_EVENT_RCVD_ACC;        }        ev_ctx->pending_node = frame->cookie;        ev_ctx->rsp_dict  = dict;        ev_ctx->commit_ctx = frame->local;        ret = glusterd_op_sm_inject_event (event_type, ev_ctx);        if (!ret) {                glusterd_friend_sm ();                glusterd_op_sm ();        }        if (ret && dict)                dict_unref (dict);        free (rsp.op_errstr);          GLUSTERD_STACK_DESTROY (frame);        return ret;}",2,"cwe469,cwe476"
"dossl(int fd, int argn, int argc, char **argv){tssl_context ctx;tssl_handle ssl;tinttstdin_fd, stdout_fd;tstruct tls_info info= *tls_get_default_info();tinfo.peer_verify_domain=peer_verify_domain;tinfo.tls_err_msg=ssl_errmsg;tinfo.connect_callback= &verify_connection;tinfo.app_data=NULL;tctx=tls_create(server ? 1:0, &info);tif (ctx == 0)treturn (1);tssl=tls_connect(ctx, fd);tif (!ssl)t{ttclose(fd);ttreturn (1);t}tif (!connect_completed(ssl, fd))t{tttls_disconnect(ssl, fd);ttclose(fd);tttls_destroy(ctx);ttreturn 1;t}tstdin_fd=0;tstdout_fd=1;tstartclient(argn, argc, argv, fd, &stdin_fd, &stdout_fd);tdocopy(ssl, fd, stdin_fd, stdout_fd);ttls_disconnect(ssl, fd);tclose(fd);ttls_destroy(ctx);treturn (0);}",3,"cwe119,cwe120,cwe469"
"compresspath(char *base, char *path, size_t pathlen){    register int i;    int  depth = 0;    char *p;    char *stack[32];    char  pathbuf[NLINE];#define PUSHD(X)  (stack[depth++] = X)#define POPD()    ((depth > 0) ? stack[--depth] : """")#ifndef _WINDOWS    if(*path == '~'){tfixpath(path, pathlen);tstrncpy(pathbuf, path, sizeof(pathbuf));tpathbuf[sizeof(pathbuf)-1] = '0';    }    else if(*path != C_FILESEP)      snprintf(pathbuf, sizeof(pathbuf), ""%s%c%s"", base, C_FILESEP, path);    else{      strncpy(pathbuf, path, sizeof(pathbuf));      pathbuf[sizeof(pathbuf)-1] = '0';    }#else      strncpy(pathbuf, path, sizeof(pathbuf));    pathbuf[sizeof(pathbuf)-1] = '0';    fixpath(pathbuf, sizeof(pathbuf));#endif      p = &pathbuf[0];    for(i=0; pathbuf[i] != '0'; i++){tt tif(pathbuf[i] == C_FILESEP){t    if(p != pathbuf)t      PUSHD(p);tttt t    p = &pathbuf[i+1];ttt t    pathbuf[i] = '0';ttt t    continue;t}tif(pathbuf[i] == '.'){ttt t    if(pathbuf[i+1] == '.' tt t       && (pathbuf[i+2] == C_FILESEP || pathbuf[i+2] == '0')){ttif(!strcmp(POPD(), """"))tt tt  return(0);tti += 2;ttp = (pathbuf[i] == '0') ? """" : &pathbuf[i+1];t    }t    else if(pathbuf[i+1] == C_FILESEP || pathbuf[i+1] == '0'){tti++;ttp = (pathbuf[i] == '0') ? """" : &pathbuf[i+1];t    }t}    }    if(*p != '0')      PUSHD(p);ttttt     path[0] = '0';    for(i = 0; i < depth; i++){tstrncat(path, S_FILESEP, pathlen-strlen(path)-1);tpath[pathlen-1] = '0';tstrncat(path, stack[i], pathlen-strlen(path)-1);tpath[pathlen-1] = '0';    }    return(1);ttttt }",3,"cwe119,cwe120,cwe469"
"read_table(cache_handle_t *handle, request_rec *r,                               apr_table_t *table, apr_file_t *file){    char w[MAX_STRING_LEN];    char *l;    int p;    apr_status_t rv;    while (1) {                 rv = apr_file_gets(w, MAX_STRING_LEN - 1, file);        if (rv != APR_SUCCESS) {            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00717)                          ""Premature end of cache headers."");            return rv;        }                 p = strlen(w);                 if (p > 0 && w[p - 1] == '') {            if (p > 1 && w[p - 2] == CR) {                w[p - 2] = '0';            }            else {                w[p - 1] = '0';            }        }                 if (w[0] == '0') {            break;        }#if APR_CHARSET_EBCDIC                 if (!(l = strchr(w, ':'))) {            int maybeASCII = 0, maybeEBCDIC = 0;            unsigned char *cp, native;            apr_size_t inbytes_left, outbytes_left;            for (cp = w; *cp != '0'; ++cp) {                native = apr_xlate_conv_byte(ap_hdrs_from_ascii, *cp);                if (apr_isprint(*cp) && !apr_isprint(native))                    ++maybeEBCDIC;                if (!apr_isprint(*cp) && apr_isprint(native))                    ++maybeASCII;            }            if (maybeASCII > maybeEBCDIC) {                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00718)                        ""CGI Interface Error: Script headers apparently ASCII: (CGI = %s)"",                        r->filename);                inbytes_left = outbytes_left = cp - w;                apr_xlate_conv_buffer(ap_hdrs_from_ascii,                                      w, &inbytes_left, w, &outbytes_left);            }        }#endif                   if (!(l = strchr(w, ':'))) {            return APR_EGENERAL;        }        *l++ = '0';        while (apr_isspace(*l)) {            ++l;        }        apr_table_add(table, w, l);    }    return APR_SUCCESS;}",2,"cwe119,cwe120"
"glkunix_startup_code(glkunix_startup_t *data){    glk_stylehint_set(wintype_AllTypes, style_Emphasized, stylehint_Weight, 0);    glk_stylehint_set(wintype_AllTypes, style_Emphasized, stylehint_Oblique, 1);    glk_stylehint_set(wintype_AllTypes, style_BlockQuote, stylehint_Indentation, 10);         openGlkWindows();#ifdef HAVE_GARGLKtgarglk_set_program_name(alan.shortHeader);tgarglk_set_program_info(""Alan Interpreter 3.0 beta 2 by Thomas Nilsson"");#endif         args(data->argc, data->argv);    if (adventureFileName == NULL || strcmp(adventureFileName, """") == 0) {        printf(""You should supply a game file to play."");        usage(""arun"");          terminate(0);    }         openResourceFile();    return TRUE;}",3,"cwe119,cwe120,cwe469"
"writeClustersD(t_Params *ptParams, int nN, int nK, int* anT, int *anZ, t_Data *ptData, int* anCentroids, double* adW){  char *szClustFile = (char *) malloc(MAX_LINE_LENGTH*sizeof(char));  FILE *ofp = NULL;  int index =0, i = 0, j = 0, s = 0, nM = ptData->nMaxLen;  sprintf(szClustFile, ""%s_cd%s"", ptParams->szOutFileStub, FASTA_SUFFIX);  ofp = fopen(szClustFile, ""w"");  for(i = 0; i < nK; i++){    if(anT[i] > 0.0){      int nI = anCentroids[i];      fprintf(ofp, "">%s_%d_%d"",ptParams->szOutFileStub,index, anT[i]);            for(j = 0; j < ptData->anLen[nI]; j++){tchar cBase = ptData->acSequences[nI*nM + j];tif(cBase != NOTSET_CHAR){t  fprintf(ofp, ""%c"", cBase);t}      }      index++;      fprintf(ofp,"""");    }  }    fclose(ofp);  free(szClustFile);}",2,"cwe120,cweother"
"LE_Put_Char(int c){#if defined(__unix__) || defined(__CYGWIN__)  char c0 = c;  if (use_ansi)    {      char buf[20];      switch(c)t{tcase 'b':t  if (pos == 0)t    {t      pos = nb_cols - 1;t      sprintf(buf, ""033[A033[%dC"", pos);t      write(fd_out, buf, strlen(buf));t      return;t    }t  pos--;t  break;tcase 'a':t  break;tcase '':t  pos = 0;t  break;tdefault:t  if (++pos > nb_cols)t    pos = 1;t}    }  c0 = c;  write(fd_out, &c0, 1);#elif defined(_WIN32)  CONSOLE_SCREEN_BUFFER_INFO csbi;  if (c != 'b')    {#ifdef WIN32_CONVERT_OEM_ASCII      unsigned char buff[2];      buff[0] = c;      buff[1] = '0';      CharToOem(buff, buff);      c = buff[0];#endif      putch(c);      return;    }  GetConsoleScreenBufferInfo(h_stdout, &csbi);  if (csbi.dwCursorPosition.X == 0)    {      csbi.dwCursorPosition.X = csbi.dwSize.X - 1;      csbi.dwCursorPosition.Y--;    }  else    csbi.dwCursorPosition.X--;  SetConsoleCursorPosition(h_stdout, csbi.dwCursorPosition);#endif}",2,"cwe119,cwe120"
"vrtpprintf(TURN_LOG_LEVEL level, const char *format, va_list args){t #define MAX_RTPPRINTF_BUFFER_SIZE (1024)tchar s[MAX_RTPPRINTF_BUFFER_SIZE+1];#undef MAX_RTPPRINTF_BUFFER_SIZEtsize_t sz;tsnprintf(s, sizeof(s), ""%lu: "",(unsigned long)log_time());tsz=strlen(s);tvsnprintf(s+sz, sizeof(s)-1-sz, format, args);ts[sizeof(s)-1]=0;tif(to_syslog) {ttsyslog(get_syslog_level(level),""%s"",s);t} else {ttlog_lock();ttset_rtpfile();ttif(fprintf(_rtpfile,""%s"",s)<0) {tttreset_rtpprintf();tt} else if(fflush(_rtpfile)<0) {tttreset_rtpprintf();tt}ttlog_unlock();t}treturn 0;}",3,"cwe119,cwe120,cweother"
"""sfgets(void){    struct pollfd pfd;    int pollret;    ssize_t readnb;    signed char seen_r = 0;        if (scanned > (size_t) 0U) {       /* support pipelining */        readnbd -= scanned;                memmove(cmd, cmd + scanned, readnbd);   /* safe */        scanned = (size_t) 0U;    }    pfd.fd = clientfd;#ifdef __APPLE_CC__    pfd.events = POLLIN | POLLERR | POLLHUP;#else    pfd.events = POLLIN | POLLPRI | POLLERR | POLLHUP;#endif    while (scanned < cmdsize) {        if (scanned >= readnbd) {      /* nothing left in the buffer */            pfd.revents = 0;            while ((pollret = poll(&pfd, 1U, idletime * 1000UL)) < 0 &&                   errno == EINTR);            if (pollret == 0) {                return -1;            }            if (pollret <= 0 ||                (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) != 0) {                return -2;            }            if ((pfd.revents & (POLLIN | POLLPRI)) == 0) {                continue;            }            if (readnbd >= cmdsize) {                break;            }#ifdef WITH_TLS            if (tls_cnx != NULL) {                while ((readnb = SSL_read                        (tls_cnx, cmd + readnbd, cmdsize - readnbd))                       < (ssize_t) 0 && errno == EINTR);            } else#endif            {                while ((readnb = read(clientfd, cmd + readnbd,                                      cmdsize - readnbd)) < (ssize_t) 0 &&                       errno == EINTR);            }            if (readnb <= (ssize_t) 0) {                return -2;            }            readnbd += readnb;            if (readnbd > cmdsize) {                return -2;            }        }#ifdef RFC_CONFORMANT_LINES        if (seen_r != 0) {#endif            if (cmd[scanned] == '') {#ifndef RFC_CONFORMANT_LINES                if (seen_r != 0) {#endif                    cmd[scanned - 1U] = 0;#ifndef RFC_CONFORMANT_LINES                } else {                    cmd[scanned] = 0;                }#endif                if (++scanned >= readnbd) {   /* non-pipelined command */                    scanned = readnbd = (size_t) 0U;                }                return 0;            }            seen_r = 0;#ifdef RFC_CONFORMANT_LINES        }#endif        if (ISCTRLCODE(cmd[scanned])) {            if (cmd[scanned] == 'r') {                seen_r = 1;            }#ifdef RFC_CONFORMANT_PARSER                   /* disabled by default, intentionnaly */            else if (cmd[scanned] == 0) {                cmd[scanned] = '';            }#else            /* replace control chars with _ */            cmd[scanned] = '_';                #endif        }        scanned++;    }    die(421, LOG_WARNING, MSG_LINE_TOO_LONG);   /* don't remove this */        return 0;                         /* to please GCC */}""",2,"cwe120,cweother"
"utton_hfoption(GtkWidget *w){tGtkWidget* Table;tGtkWidget* button;tguint i;tguint j;        guint ColonneT=2;         guint LigneT=4; tchar *LabelButton[2][4]={                {_(""Defining the wavefunction""),                 _(""Specifying closed-shell orbitals""),                 _(""Starting with previous orbitals""),                 _(""Starting with a previous density matrix"")},                {_(""Defining the number of occupied orbitals in each symmetry""),                 _(""Saving the final orbital""),                 _(""Initial orbital guess""),                 ""00"" }tt};  Table = gtk_table_new(LigneT,ColonneT,TRUE);  gtk_container_add(GTK_CONTAINER(w),Table);    for ( i = 0;i<LigneT;i++)t  for ( j = 0;j<ColonneT;j++)  {    if(strcmp(LabelButton[j][i],""00""))          {t  button = gtk_button_new_with_label(LabelButton[j][i]);          g_signal_connect(G_OBJECT(button), ""clicked"",                            (GCallback)Traite_hf_Option,(gpointer )LabelButton[j][i]);t  gtk_table_attach(GTK_TABLE(Table),button,j,j+1,i,i+1,tt  (GtkAttachOptions)(GTK_FILL | GTK_EXPAND) ,tt  (GtkAttachOptions)(GTK_FILL | GTK_EXPAND),tt  1,1);          gtk_widget_show (button);         }  }  gtk_widget_show (Table); t}",2,"cwe119,cwe120"
"scram_start (Gsasl_session * sctx, void **mech_data, int plus){  struct scram_client_state *state;  char buf[CNONCE_ENTROPY_BYTES];  const char *p;  int rc;  state = (struct scram_client_state *) calloc (sizeof (*state), 1);  if (state == NULL)    return GSASL_MALLOC_ERROR;  state->plus = plus;  rc = gsasl_nonce (buf, CNONCE_ENTROPY_BYTES);  if (rc != GSASL_OK)    {      free (state);      return rc;    }  rc = gsasl_base64_to (buf, CNONCE_ENTROPY_BYTES,ttt&state->cf.client_nonce, NULL);  if (rc != GSASL_OK)    {      free (state);      return rc;    }  p = gsasl_property_get (sctx, GSASL_CB_TLS_UNIQUE);  if (state->plus && !p)    {      free (state->cf.client_nonce);      free (state);      return GSASL_NO_CB_TLS_UNIQUE;    }  if (p)    {      rc = gsasl_base64_from (p, strlen (p), &state->cbtlsunique,ttt      &state->cbtlsuniquelen);      if (rc != GSASL_OK)t{t  free (state->cf.client_nonce);t  free (state);t  return rc;t}    }  *mech_data = state;  return GSASL_OK;}",2,"cwe119,cwe120"
"command_fsetstat(char * token, Channel * c) {    char id[256];    FileAttrs attrs;    OpenFileInfo * h = NULL;    json_read_string(&c->inp, id, sizeof(id));    if (read_stream(&c->inp) != 0) exception(ERR_JSON_SYNTAX);    memset(&attrs, 0, sizeof(FileAttrs));    json_read_struct(&c->inp, read_file_attrs, &attrs);    if (read_stream(&c->inp) != 0) exception(ERR_JSON_SYNTAX);    if (read_stream(&c->inp) != MARKER_EOM) exception(ERR_JSON_SYNTAX);    h = find_open_file_info(id);    if (h == NULL) {        reply_setstat(token, &c->out, EBADF);    }    else {        IORequest * req = create_io_request(token, h, REQ_FSETSTAT);        req->attrs = attrs;        post_io_requst(h);    }}",2,"cwe119,cwe120"
"snd_intel8x0m_pcm1(struct intel8x0m *chip, int device,ttt      struct ich_pcm_table *rec){tstruct snd_pcm *pcm;tint err;tchar name[32];tif (rec->suffix)ttsprintf(name, ""Intel ICH - %s"", rec->suffix);telsettstrcpy(name, ""Intel ICH"");terr = snd_pcm_new(chip->card, name, device,ttt  rec->playback_ops ? 1 : 0,ttt  rec->capture_ops ? 1 : 0, &pcm);tif (err < 0)ttreturn err;tif (rec->playback_ops)ttsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, rec->playback_ops);tif (rec->capture_ops)ttsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, rec->capture_ops);tpcm->private_data = chip;tpcm->info_flags = 0;tpcm->dev_class = SNDRV_PCM_CLASS_MODEM;tif (rec->suffix)ttsprintf(pcm->name, ""%s - %s"", chip->card->shortname, rec->suffix);telsettstrcpy(pcm->name, chip->card->shortname);tchip->pcm[device] = pcm;tsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,ttttt      snd_dma_pci_data(chip->pci),ttttt      rec->prealloc_size,ttttt      rec->prealloc_max_size);treturn 0;}",2,"cwe119,cwe120"
"rename_file(char *sdir, int smsg, char *mailboxuser, char *mailboxcontext, char *ddir, int dmsg){tSQLHSTMT stmt;tchar sql[PATH_MAX];tchar msgnums[20];tchar msgnumd[20];tstruct odbc_obj *obj;tchar *argv[] = { ddir, msgnumd, mailboxuser, mailboxcontext, sdir, msgnums };tstruct generic_prepare_struct gps = { .sql = sql, .argc = 6, .argv = argv };tdelete_file(ddir, dmsg);tobj = ast_odbc_request_obj(odbc_database, 0);tif (obj) {ttsnprintf(msgnums, sizeof(msgnums), ""%d"", smsg);ttsnprintf(msgnumd, sizeof(msgnumd), ""%d"", dmsg);ttsnprintf(sql, sizeof(sql), ""UPDATE %s SET dir=?, msgnum=?, mailboxuser=?, mailboxcontext=? WHERE dir=? AND msgnum=?"", odbc_table);ttstmt = ast_odbc_prepare_and_execute(obj, generic_prepare, &gps);ttif (!stmt)tttast_log(AST_LOG_WARNING, ""SQL Execute error![%s]"", sql);ttelsetttSQLFreeHandle(SQL_HANDLE_STMT, stmt);ttast_odbc_release_obj(obj);t} elsettast_log(AST_LOG_WARNING, ""Failed to obtain database object for '%s'!"", odbc_database);treturn;t}",2,"cwe119,cwe120"
"convert_edge_labels_to_nodes(Agraph_t* g){  Agnode_t *n, *newnode;  Agraph_t *dg;  int nnodes;  int nedges;  Agedge_t *ep, *e;  int i = 0;  Agnode_t **ndmap = NULL;  char *s;  char *elabel;  int id = 0;  Agsym_t* sym = agattr(g, AGEDGE, ""label"", NULL);  dg = agopen(""test"", g->desc, 0);  if (!g) return NULL;  nnodes = agnnodes (g);  nedges = agnedges (g);  ndmap = malloc(sizeof(Agnode_t *)*nnodes);  agattr(dg, AGNODE, ""label"", ""N"");   agattr(dg, AGNODE, ""shape"", ""ellipse"");   agattr(dg, AGNODE, ""width"",""0.00001"");  agattr(dg, AGNODE, ""height"", ""0.00001"");  agattr(dg, AGNODE, ""margin"",""0."");  agattr(dg, AGEDGE, ""arrowsize"", ""0.5"");   for (n = agfstnode (g); n; n = agnxtnode (g, n)) {    newnode = mkNode(dg, agnameof(n));    agset(newnode,""shape"",""box"");    ndmap[i] = newnode;    ND_id(n) = i++;  }     for (n = agfstnode (g); n; n = agnxtnode (g, n)) {    for (ep = agfstedge(g, n); ep; ep = agnxtedge(g, ep, n)) {      if (agtail(ep) == n && (aghead(ep) != n)) continue;      if (sym && (elabel = agxget(ep,sym)) && strcmp(elabel,"""") != 0) {ts = cat_string3(""|edgelabel"",agnameof(agtail(ep)), agnameof(aghead(ep)), id++);tnewnode = mkNode(dg,s);tagset(newnode,""label"",elabel);tagset(newnode,""shape"",""plaintext"");te = agedge(dg, ndmap[ND_id(agtail(ep))], newnode, NULL, 1);tagset(e, ""arrowsize"",""0"");tagedge(dg, newnode, ndmap[ND_id(aghead(ep))], NULL, 1);tfree(s);      } else {tagedge(dg, ndmap[ND_id(agtail(ep))], ndmap[ND_id(aghead(ep))], NULL, 1);      }    }  }  free(ndmap);  return dg; }",2,"cwe120,cwe469"
"command_realpath(char * token, Channel * c) {    char path[FILE_PATH_SIZE];    char * real = NULL;    int err = 0;    read_path(&c->inp, path, sizeof(path));    if (read_stream(&c->inp) != 0) exception(ERR_JSON_SYNTAX);    if (read_stream(&c->inp) != MARKER_EOM) exception(ERR_JSON_SYNTAX);    real = canonicalize_file_name(path);    if (real == NULL) err = errno;    write_stringz(&c->out, ""R"");    write_stringz(&c->out, token);    write_fs_errno(&c->out, err);    json_write_string(&c->out, real);    write_stream(&c->out, 0);    write_stream(&c->out, MARKER_EOM);    free(real);}",2,"cwe119,cwe120"
"set_logical_name(int id, Tcl_Interp * interp, int argc, char *argv[]){    Nv_clientData *data = NULL;    char err_string[80];         if (argc != 3) {tTcl_SetResult(interp, ""Usage: <map> set_logical_name <string>"",tt      TCL_VOLATILE);treturn (TCL_ERROR);    }         switch (get_type(argv[0])) {    case SURF:tdata = (Nv_clientData *) GS_Get_ClientData(id);tbreak;    case SITE:tdata = (Nv_clientData *) GP_Get_ClientData(id);tbreak;    case VECT:tdata = (Nv_clientData *) GV_Get_ClientData(id);tbreak;    case VOL:tdata = (Nv_clientData *) GVL_Get_ClientData(id);tbreak;    }    if (data == NULL) {tsprintf(err_string,tt""Internal Error: Can't find client data for map %d"", id);tTcl_SetResult(interp, err_string, TCL_VOLATILE);treturn (TCL_ERROR);    }         if (data->logical_name != NULL)tG_free(data->logical_name);         data->logical_name =t(char *)G_malloc(sizeof(char) * (strlen(argv[2]) + 1));    if (data->logical_name == NULL) {tTcl_SetResult(interp,tt      ""Error: out of memory in set_logical_name - allocating new space"",tt      TCL_VOLATILE);treturn (TCL_ERROR);    }    strcpy(data->logical_name, argv[2]);         return (TCL_OK);}",3,"cwe119,cwe120,cwe469"
"smk_bu_file(struct file *file, int mode, int rc){tstruct task_smack *tsp = current_security();tstruct smack_known *sskp = tsp->smk_task;tstruct inode *inode = file_inode(file);tstruct inode_smack *isp = inode->i_security;tchar acc[SMK_NUM_ACCESS_TYPE + 1];tif (isp->smk_flags & SMK_INODE_IMPURE)ttpr_info(""Smack Unconfined Corruption: inode=(%s %ld) %s"",tttinode->i_sb->s_id, inode->i_ino, current->comm);tif (rc <= 0)ttreturn rc;tif (rc > SMACK_UNCONFINED_OBJECT)ttrc = 0;tsmk_bu_mode(mode, acc);tpr_info(""Smack %s: (%s %s %s) file=(%s %ld %pD) %s"", smk_bu_mess[rc],ttsskp->smk_known, smk_of_inode(inode)->smk_known, acc,ttinode->i_sb->s_id, inode->i_ino, file,ttcurrent->comm);treturn 0;}",2,"cwe119,cwe120"
"getAccessKey(int index){    if (index == 10) {        abuf[0] = '*';        abuf[1] = '0';    } else if (index == 11) {        abuf[0] = '0';        abuf[1] = '0';    } else if (index == 12) {        abuf[0] = '#';        abuf[1] = '0';    } else {        sprintf(abuf,""%d"",index);    }    return abuf;}",2,"cwe120,cwe469"
"GENESIS_identify( FILE * fp ){    char buf[ 4 ];    size_t c;    c = fread( buf, 1, 4, fp );    rewind( fp );    return c == 4 && strncmp( buf, ""IMGF"", 4 ) == 0;}",2,"cwe119,cwe120"
"__ecereMethod___ecereNameSpace__ecere__gui__dialogs__ColorARamp_OnRedraw(struct __ecereNameSpace__ecere__com__Instance * this, struct __ecereNameSpace__ecere__com__Instance * surface){struct __ecereNameSpace__ecere__sys__Size __simpleStruct0;struct __ecereNameSpace__ecere__com__Instance * picker = ((struct __ecereNameSpace__ecere__com__Instance *)__ecereProp___ecereNameSpace__ecere__gui__Window_Get_master(this));int a;for(a = 0; a < (int)(__ecereProp___ecereNameSpace__ecere__gui__Window_Get_clientSize(this, &__simpleStruct0), __simpleStruct0).w; a++){struct __ecereNameSpace__ecere__sys__Size __simpleStruct1;struct __ecereNameSpace__ecere__sys__Size __simpleStruct0;unsigned int color = __ecereNameSpace__ecere__gui__dialogs__ColorFunctions[((struct __ecereNameSpace__ecere__gui__dialogs__ColorPicker *)(((char *)picker + __ecereClass___ecereNameSpace__ecere__gui__dialogs__ColorPicker->offset)))->colorMode](((struct __ecereNameSpace__ecere__gui__dialogs__ColorPicker *)(((char *)picker + __ecereClass___ecereNameSpace__ecere__gui__dialogs__ColorPicker->offset)))->x, ((struct __ecereNameSpace__ecere__gui__dialogs__ColorPicker *)(((char *)picker + __ecereClass___ecereNameSpace__ecere__gui__dialogs__ColorPicker->offset)))->y, ((struct __ecereNameSpace__ecere__gui__dialogs__ColorPicker *)(((char *)picker + __ecereClass___ecereNameSpace__ecere__gui__dialogs__ColorPicker->offset)))->z, (float)(int)((float)(float)a / ((__ecereProp___ecereNameSpace__ecere__gui__Window_Get_clientSize(this, &__simpleStruct0), __simpleStruct0.w - 1))));__ecereMethod___ecereNameSpace__ecere__gfx__Surface_SetForeground(surface, color);__ecereMethod___ecereNameSpace__ecere__gfx__Surface_VLine(surface, 0, (int)((__ecereProp___ecereNameSpace__ecere__gui__Window_Get_clientSize(this, &__simpleStruct1), __simpleStruct1.h - 1)), a);}}",2,"cwe119,cwe120"
"check_gretldir (char *config_path){    char testname[FILENAME_MAX];    FILE *fp;    int gotit = 0;    sprintf(testname, ""%sCOPYING"", paths.gretldir);    fp = gretl_fopen(testname, ""r"");    if (fp != NULL) {t tfclose(fp);tgotit = 1;    } else if (*config_path != '0') {tslash_terminate(config_path);tif (strcmp(config_path, paths.gretldir)) {t     t    sprintf(testname, ""%sCOPYING"", config_path);t    fp = gretl_fopen(testname, ""r"");t    if (fp != NULL) {ttstrcpy(paths.gretldir, config_path);ttfclose(fp);ttgotit = 1;t    }t}    }    if (!gotit) {t tpid_t pid = getpid();tgchar *proc_exe;tconst char *s;tssize_t nr;tproc_exe = g_strdup_printf(""/proc/%d/exe"", pid);tnr = readlink(proc_exe, testname, FILENAME_MAX - 1);tif (nr > 0) {t    testname[nr] = '0';t    fprintf(stderr, ""gretl is process %d, '%s'"", (int) pid, testname);t     t    s = strstr(testname, ""bin/gretl"");t    if (s != NULL) {tt*paths.gretldir = '0';ttstrncat(paths.gretldir, testname, s - testname);ttstrcat(paths.gretldir, ""share/gretl/"");ttfprintf(stderr, ""gretldir is maybe '%s'?"", tttpaths.gretldir);t    }t}tg_free(proc_exe);    }}",3,"cwe119,cwe120,cweother"
"assure_option(const char *name){    option_t *opt, *last;    if ((opt = find_option(name)))        return opt;    opt = calloc(1, sizeof(option_t));         if (!strcmp(name, ""PageRegion""))        strlcpy(opt->name, ""PageSize"", 128);    else        strlcpy(opt->name, name, 128);         strcpy(opt->varname, opt->name);    strrepl(opt->varname, ""-/."", '_');         opt->style = 'G';    opt->type = TYPE_NONE;         if (optionlist) {        for (last = optionlist; last->next; last = last->next);        last->next = opt;    }    else        optionlist = opt;         if (optionlist_sorted_by_order) {        opt->next_by_order = optionlist_sorted_by_order;        optionlist_sorted_by_order = opt;    }    else {        optionlist_sorted_by_order = opt;    }    _log(""Added option %s"", opt->name);    return opt;}",2,"cwe120,cwe469"
"canvas_dosetbounds(t_canvas *x, int x1, int y1, int x2, int y2){    int heightwas = y2 - y1;    int heightchange = y2 - y1 - (x->gl_screeny2 - x->gl_screeny1);    if (x->gl_screenx1 == x1 && x->gl_screeny1 == y1 &&        x->gl_screenx2 == x2 && x->gl_screeny2 == y2)            return;    x->gl_screenx1 = x1;    x->gl_screeny1 = y1;    x->gl_screenx2 = x2;    x->gl_screeny2 = y2;    if (!glist_isgraph(x) && (x->gl_y2 < x->gl_y1))     {                     t_float diff = x->gl_y1 - x->gl_y2;        t_gobj *y;        x->gl_y1 = heightwas * diff;        x->gl_y2 = x->gl_y1 - diff;                     for (y = x->gl_list; y; y = y->g_next)            if (pd_checkobject(&y->g_pd))                gobj_displace(y, x, 0, heightchange);        canvas_redraw(x);    }}",3,"cwe119,cwe120,cwe469"
"pack_objects(int fd, struct ref *refs){t tconst char *argv[] = {tt""pack-objects"",tt""--all-progress"",tt""--revs"",tt""--stdout"",ttNULL,ttNULL,t};tstruct child_process po;tif (args.use_thin_pack)ttargv[4] = ""--thin"";tmemset(&po, 0, sizeof(po));tpo.argv = argv;tpo.in = -1;tpo.out = fd;tpo.git_cmd = 1;tif (start_command(&po))ttdie(""git pack-objects failed (%s)"", strerror(errno));t twhile (refs) {ttchar buf[42];ttif (!is_null_sha1(refs->old_sha1) &&tt    has_sha1_file(refs->old_sha1)) {tttmemcpy(buf + 1, sha1_to_hex(refs->old_sha1), 40);tttbuf[0] = '^';tttbuf[41] = '';tttif (!write_or_whine(po.in, buf, 42,tttttt""send-pack: send refs""))ttttbreak;tt}ttif (!is_null_sha1(refs->new_sha1)) {tttmemcpy(buf, sha1_to_hex(refs->new_sha1), 40);tttbuf[40] = '';tttif (!write_or_whine(po.in, buf, 41,tttttt""send-pack: send refs""))ttttbreak;tt}ttrefs = refs->next;t}tclose(po.in);tif (finish_command(&po))ttreturn error(""pack-objects died with strange error"");treturn 0;}",2,"cwe119,cwe120"
"_cgsem_mswait(cgsem_t *cgsem, int ms, const char *file, const char *func, const int line){tstruct timespec abs_timeout, ts_now;tstruct timeval tv_now;tint ret;tcgtime(&tv_now);ttimeval_to_spec(&ts_now, &tv_now);tms_to_timespec(&abs_timeout, ms);retry:ttimeraddspec(&abs_timeout, &ts_now);tret = sem_timedwait(cgsem, &abs_timeout);tif (ret) {ttif (likely(sock_timeout()))tttreturn ETIMEDOUT;ttif (interrupted())tttgoto retry;ttquitfrom(1, file, func, line, ""Failed to sem_timedwait errno=%d cgsem=0x%p"", errno, cgsem);t}treturn 0;}",2,"cwe120,cweother"
"mark_pids_add(int sid, int aid, char *pids){tint i, la;tadapter *ad;tchar *arg[MAX_PIDS + 2];tint pid;tad = get_adapter(aid);tif (!ad)ttreturn -1;tif (!pids)ttreturn -1;tLOG(""adding pids to adapter %d, sid %d, pids=%s"", aid, sid,tttpids ? pids : ""NULL"");tla = split(arg, pids, MAX_PIDS, ',');tfor (i = 0; i < la; i++)t{ttpid = map_intd(arg[i], NULL, -1);ttif (pid == -1)tttcontinue;ttif (mark_pid_add(sid, aid, pid) < 0)tttreturn -1;t}tdump_pids(aid);treturn 0;}",2,"cwe119,cwe120"
"""decode_qp(struct rfc2045 *p, const char *s, size_t l){size_ttstart,i;inttrc;tif (!s)ttreturn (do_decode_qp(p));tfor (start=0; start<l; )t{ttfor (i=start; i<l; i++)tt{tttif (s[i] != '') continue;tttrfc2045_add_workbuf(p, s+start, i-start);tttrfc2045_add_workbufch(p, '');tttif ((rc=do_decode_qp(p)) != 0)treturn (rc);tttstart= ++i;tttbreak;tt}ttrfc2045_add_workbuf(p, s+start, i-start);ttif (p->workbuflen > 1024)tt{ttchartbuf[10];ttintti;tttfor (i=p->workbuflen - 5; i<p->workbuflen; i++)ttttif (p->workbuf[i] == '=')tbreak;tttif (i < p->workbuflen)ttt{tttint j=p->workbuflen-i;ttttmemcpy(buf, p->workbuf+i, j);ttttbuf[j]=0;ttttp->workbuflen=i;ttt}tttelsetbuf[0]=0;tttif ((rc=do_decode_qp(p)) != 0)treturn (rc);tttrfc2045_add_workbuf(p, buf, strlen(buf));tt}ttstart=i;t}treturn (0);}""",2,"cwe119,cwe120"
"restore_cdfname(char *vname, char *oldval){tstruct  varname  *vp = lookuphash(vname);tif  (vp->vn_value)  {ttunlink(vp->vn_value);ttfree(vp->vn_value);t}tvp->vn_value = oldval;}",2,"cwe119,cwe120"
"freadjambaseheader(FILE *fp,s_JamBaseHeader *s_JamBaseHeader){   uchar buf[SIZE_JAMBASEHEADER];   if(fread(buf,SIZE_JAMBASEHEADER,1,fp) != 1)      return 0;   memcpy(s_JamBaseHeader->Signature,&buf[JAMBASEHEADER_SIGNATURE],4);   s_JamBaseHeader->DateCreated = jamgetulong(buf,JAMBASEHEADER_DATECREATED);   s_JamBaseHeader->ModCounter  = jamgetulong(buf,JAMBASEHEADER_MODCOUNTER);   s_JamBaseHeader->ActiveMsgs  = jamgetulong(buf,JAMBASEHEADER_ACTIVEMSGS);   s_JamBaseHeader->PasswordCRC = jamgetulong(buf,JAMBASEHEADER_PASSWORDCRC);   s_JamBaseHeader->BaseMsgNum  = jamgetulong(buf,JAMBASEHEADER_BASEMSGNUM);   memcpy(s_JamBaseHeader->RSRVD,&buf[JAMBASEHEADER_RSRVD],1000);   return 1;}",2,"cwe120,cweother"
"sha512_update( sha512_context *ctx, const unsigned char *input, size_t ilen ){    size_t fill;    unsigned int left;    if( ilen <= 0 )        return;    left = (unsigned int) (ctx->total[0] & 0x7F);    fill = 128 - left;    ctx->total[0] += (uint64_t) ilen;    if( ctx->total[0] < (uint64_t) ilen )        ctx->total[1]++;    if( left && ilen >= fill )    {        memcpy( (void *) (ctx->buffer + left), input, fill );        sha512_process( ctx, ctx->buffer );        input += fill;        ilen  -= fill;        left = 0;    }    while( ilen >= 128 )    {        sha512_process( ctx, input );        input += 128;        ilen  -= 128;    }    if( ilen > 0 )        memcpy( (void *) (ctx->buffer + left), input, ilen );}",3,"cwe119,cwe120,cweother"
"mca_coll_ml_check_if_bcol_is_used(const char *bcol_name, const mca_coll_ml_module_t *ml_module,        int topo_index){    int i, rc, hier, *ranks_in_comm,        is_used = 0,        comm_size = ompi_comm_size(ml_module->comm);    int n_hier, tp , max_tp;    const mca_coll_ml_topology_t *topo_info;    ranks_in_comm = (int *) malloc(comm_size * sizeof(int));    if (OPAL_UNLIKELY(NULL == ranks_in_comm)) {        ML_ERROR((""Memory allocation failed.""));        ompi_mpi_abort(&ompi_mpi_comm_world.comm, MPI_ERR_NO_MEM, true);    }    for (i = 0; i < comm_size; ++i) {        ranks_in_comm[i] = i;    }    if (COLL_ML_TOPO_MAX == topo_index) {        tp = 0;        max_tp = COLL_ML_TOPO_MAX;    } else {        tp = topo_index;        max_tp = topo_index + 1;    }    for (; tp < max_tp; tp++) {        topo_info = &ml_module->topo_list[tp];        n_hier = topo_info->n_levels;        for (hier = 0; hier < n_hier; ++hier) {            hierarchy_pairs *pair = &topo_info->component_pairs[hier];            mca_bcol_base_component_t *b_cm = pair->bcol_component;            if(0 == strcmp(bcol_name,                        b_cm->bcol_version.mca_component_name)) {                is_used = 1;                break;            }        }    }    rc = comm_allreduce_pml(&is_used, &is_used, 1, MPI_INT,                  ompi_comm_rank(ml_module->comm), MPI_MAX,                  comm_size, ranks_in_comm, ml_module->comm);    if (OPAL_UNLIKELY(OMPI_SUCCESS != rc)) {        ML_ERROR((""comm_allreduce_pml failed.""));        ompi_mpi_abort(&ompi_mpi_comm_world.comm, MPI_ERR_OP, true);    }    free(ranks_in_comm);    return is_used;}",2,"cwe120,cwe476"
"xgdImageInfosFromGifCtx (xgdIOCtxPtr fd, int *errcode){    int BitPixel;    unsigned char buf[16];    int imw, imh, screen_width, screen_height;    int bitPixel;    gGraphImageInfosPtr infos = NULL;    if (!ReadOK (fd, buf, 6))      {t  *errcode = GGRAPH_GIF_CODEC_ERROR;t  return NULL;      }    if (strncmp ((char *) buf, ""GIF"", 3) != 0)      {t  *errcode = GGRAPH_GIF_CODEC_ERROR;t  return NULL;      }    if (memcmp ((char *) buf + 3, ""87a"", 3) == 0t|| memcmp ((char *) buf + 3, ""89a"", 3) == 0)t;    else      {t  *errcode = GGRAPH_GIF_CODEC_ERROR;t  return NULL;      }    if (!ReadOK (fd, buf, 7))      {t  *errcode = GGRAPH_GIF_CODEC_ERROR;t  return NULL;      }    BitPixel = 2 << (buf[4] & 0x07);    screen_width = imw = LM_to_uint (buf[0], buf[1]);    screen_height = imh = LM_to_uint (buf[2], buf[3]);    bitPixel = colorstobpp (BitPixel);    if (!t(infos =t gg_image_infos_create (GG_PIXEL_PALETTE, screen_width, screen_height,ttttbitPixel, 1, GGRAPH_SAMPLE_UINT, NULL, NULL)))      {t  *errcode = GGRAPH_INSUFFICIENT_MEMORY;t  return NULL;      }    infos->compression = GGRAPH_TIFF_COMPRESSION_LZW;    if (!infos)      {t  *errcode = GGRAPH_GIF_CODEC_ERROR;t  return NULL;      }    return infos;}",2,"cwe119,cwe120"
"rpc_do_reply(struct client *clnt, struct rpc *rpc, size_t off){tint ret;tif ((ret = read(clnt->sock,ttt((char *)rpc->reply) + off,tttrpc->reply_len - off)) == -1) {ttperror(""read"");ttgoto bail;t} else if (ret < sizeof(struct rpc_reply) - off) {ttfprintf(stderr, ""short read: %d < %zu"", ret,tttsizeof(struct rpc_reply) - off);ttgoto bail;t}trpc->reply_len = ret + off;tif ((!off && !(ntohl(rpc->reply->hdr.frag_hdr) & LAST_FRAG)) ||t    rpc->reply->hdr.udp.xid != rpc->call->hdr.udp.xid ||t    rpc->reply->hdr.udp.msg_type != htonl(RPC_REPLY)) {ttfprintf(stderr, ""bad reply"");ttgoto bail;t}tif (ntohl(rpc->reply->state) != REPLY_OK) {ttfprintf(stderr, ""rpc failed: %d"", ntohl(rpc->reply->state));ttgoto bail;t}tret = 0;tgoto done;bail:tret = -1;done:treturn ret;}",2,"cwe120,cweother"
"getVMLibrarySearchPath(_TCHAR * vmLibrary) {t_TCHAR ** paths = NULL;t_TCHAR * buffer = NULL;t_TCHAR * path, * entry, *c;t_TCHAR separator;tint numPaths = 3;tint i;tstruct _stat stats;ttbuffer = (eeLibPath != NULL) ? _tcsdup(eeLibPath) : _tcsdup(vmLibrary);t#ifdef WIN32t ti = -1;twhile (buffer[++i] != 0) {ttif (buffer[i] == _T_ECLIPSE('')) tttbuffer[i] = _T_ECLIPSE('/');t}#endifttseparator = (eeLibPath != NULL) ? pathSeparator : _T_ECLIPSE('/');ttif (eeLibPath != NULL) {tt ttnumPaths = 1;ttc = eeLibPath;ttwhile( (c = _tcschr(c, pathSeparator)) != NULL) {tttnumPaths++;tttc++;tt}t} tttpaths = malloc((numPaths + 1) * sizeof(_TCHAR*));tpaths[numPaths] = NULL;ttt tfor (i = 0; i < numPaths; i++) {ttc = _tcsrchr(buffer, separator);ttif (c != 0) {ttt*c++ = 0;tttif (eeLibPath != NULL) { ttttpath = c;tt ttt} else { ttttpath = buffer; t ttt}tt} else {tttif (eeLibPath != NULL) {ttttpath = buffer;ttt} else {ttttpaths[i] = NULL;ttttbreak;ttt}tt}ttif (path != NULL) {tttentry = resolveSymlinks(path);  tttif (eeLibPath == NULL && i == 2) {tttt ttttconst _TCHAR * arch = getVMArch();ttttpaths[i] = malloc((_tcslen(entry) + 7 + _tcslen(arch)) * sizeof(_TCHAR));tttt_stprintf(paths[i], _T_ECLIPSE(""%s/lib/%s""), entry, arch);tttt ttttif (_tstat(paths[i], &stats) == 0) {ttttt_TCHAR separatorString[] = { pathSeparator, 0 };ttttt_tcscat(paths[i], separatorString);tttt} else {tttttfree(paths[i]);tttttpaths[i] = NULL;tttt}ttt} else {ttttpaths[i] = malloc((_tcslen(entry) + 2) * sizeof(_TCHAR));tttt_stprintf( paths[i], _T_ECLIPSE(""%s%c""), entry, pathSeparator );ttt}tttif (entry != path)ttttfree(entry);tttpath = NULL;tt}t}ttfree(buffer);treturn paths;}",2,"cwe120,cweother"
"ns__echoString(struct soap *soap, char *str, char **res){ char port[16];     if (check_header(soap))  { printf(""Malformed header"");    return SOAP_FAULT;    }     if (check_received(soap->header->wsa__MessageID))  { printf(""Request message %s already received"", soap->header->wsa__MessageID);    return SOAP_STOP;  }     getnameinfo((struct sockaddr*)&soap->peer, soap->peerlen, soap->host, sizeof(soap->host), port, 16, NI_DGRAM | NI_NAMEREQD | NI_NUMERICSERV);  printf(""Request message %s from %s:%s accepted"", soap->header->wsa__MessageID, soap->host, port);     if (!soap->header->wsa__ReplyTo || !soap->header->wsa__ReplyTo->Address)    return soap_sender_fault(soap, ""No WS-Addressing ReplyTo address"", NULL);     soap->header->wsa__To = soap->header->wsa__ReplyTo->Address;     soap->header->wsa__MessageID = soap_strdup(soap, soap_int2s(soap, id_count++));  soap->header->wsa__Action = ""http://genivia.com/udp/echoStringResponse"";     printf(""Response message %s returned"", soap->header->wsa__MessageID);  *res = str;  return SOAP_OK;}",2,"cwe119,cwe120"
"report_top_five_cities(struct conn_list *dest){  const int NUM_BEST_CITIES = 5;     const int WONDER_FACTOR = 5;  struct city_score_entry size[NUM_BEST_CITIES];  int i;  char buffer[4096];  for (i = 0; i < NUM_BEST_CITIES; i++) {    size[i].value = 0;    size[i].city = NULL;  }  shuffled_players_iterate(pplayer) {    city_list_iterate(pplayer->cities, pcity) {      int value_of_pcity = city_size_get(pcity)                           + nr_wonders(pcity) * WONDER_FACTOR;      if (value_of_pcity > size[NUM_BEST_CITIES - 1].value) {        size[NUM_BEST_CITIES - 1].value = value_of_pcity;        size[NUM_BEST_CITIES - 1].city = pcity;        qsort(size, NUM_BEST_CITIES, sizeof(size[0]), secompare);      }    } city_list_iterate_end;  } shuffled_players_iterate_end;  buffer[0] = '0';  for (i = 0; i < NUM_BEST_CITIES; i++) {    int wonders;    if (!size[i].city) {t       break;    }    if (player_count() > team_count()) {             char team_name[2 * MAX_LEN_NAME];      team_pretty_name(city_owner(size[i].city)->team, team_name,                       sizeof(team_name));      cat_snprintf(buffer, sizeof(buffer),                                       _(""%2d: The %s City of %s (%s) of size %d, ""), i + 1,                   nation_adjective_for_player(city_owner(size[i].city)),                   city_name(size[i].city), team_name,                   city_size_get(size[i].city));    } else {      cat_snprintf(buffer, sizeof(buffer),                   _(""%2d: The %s City of %s of size %d, ""), i + 1,                   nation_adjective_for_player(city_owner(size[i].city)),                   city_name(size[i].city), city_size_get(size[i].city));    }    wonders = nr_wonders(size[i].city);    if (wonders == 0) {      cat_snprintf(buffer, sizeof(buffer), _(""with no wonders""));    } else {      cat_snprintf(buffer, sizeof(buffer),tt   PL_(""with %d wonder"", ""with %d wonders"", wonders),tt   wonders);}  }  page_conn(dest, _(""Traveler's Report:""),t    _(""The Five Greatest Cities in the World!""), buffer);}",2,"cwe119,cwe120"
"tds_convert_flt8(int srctype, const TDS_CHAR * src, int desttype, CONV_RESULT * cr){tTDS_FLOAT the_value;tchar tmp_str[25];tmemcpy(&the_value, src, 8);tswitch (desttype) {tcase TDS_CONVERT_CHAR:tcase CASE_ALL_CHAR:ttsprintf(tmp_str, ""%.16g"", the_value);ttreturn string_to_result(tmp_str, cr);ttbreak;tcase CASE_ALL_BINARY:ttreturn binary_to_result(src, sizeof(TDS_FLOAT), cr);ttbreak;tcase SYBINT1:ttif (!IS_TINYINT(the_value))tttreturn TDS_CONVERT_OVERFLOW;ttcr->ti = (TDS_TINYINT) the_value;ttreturn sizeof(TDS_TINYINT);ttbreak;tcase SYBINT2:ttif (!IS_SMALLINT(the_value))tttreturn TDS_CONVERT_OVERFLOW;ttcr->si = (TDS_SMALLINT) the_value;ttreturn sizeof(TDS_SMALLINT);ttbreak;tcase SYBINT4:ttif (!IS_INT(the_value))tttreturn TDS_CONVERT_OVERFLOW;ttcr->i = (TDS_INT) the_value;ttreturn sizeof(TDS_INT);ttbreak;tcase SYBINT8:ttif (the_value > (TDS_FLOAT) TDS_INT8_MAX || the_value < (TDS_FLOAT) TDS_INT8_MIN)tttreturn TDS_CONVERT_OVERFLOW;ttcr->bi = (TDS_INT8) the_value;ttreturn sizeof(TDS_INT8);ttbreak;tcase SYBBIT:tcase SYBBITN:ttcr->ti = the_value ? 1 : 0;ttreturn sizeof(TDS_TINYINT);ttbreak;tcase SYBMONEY:ttif (the_value > (TDS_FLOAT) (TDS_INT8_MAX / 10000) || the_value < (TDS_FLOAT) (TDS_INT8_MIN / 10000))tttreturn TDS_CONVERT_OVERFLOW;ttcr->m.mny = (TDS_INT8) (the_value * 10000);ttreturn sizeof(TDS_MONEY);ttbreak;tcase SYBMONEY4:ttif (the_value > (TDS_FLOAT) (TDS_INT_MAX / 10000) || the_value < (TDS_FLOAT) (TDS_INT_MIN / 10000))tttreturn TDS_CONVERT_OVERFLOW;ttcr->m4.mny4 = (TDS_INT) (the_value * 10000);ttreturn sizeof(TDS_MONEY4);ttbreak;tcase SYBREAL:tt ttcr->r = (TDS_REAL)the_value;ttreturn sizeof(TDS_REAL);ttbreak;tcase SYBFLT8:ttcr->f = the_value;ttreturn sizeof(TDS_FLOAT);ttbreak;tcase SYBNUMERIC:tcase SYBDECIMAL:ttsprintf(tmp_str, ""%.16g"", the_value);ttreturn stringz_to_numeric(tmp_str, cr);ttbreak;tt tcase SYBUNIQUE:tcase SYBDATETIME4:tcase SYBDATETIME:tcase SYBDATETIMN:tdefault:ttbreak;t}treturn TDS_CONVERT_NOAVAIL;}",2,"cwe119,cwe120"
"do_setval(Oid relid, int64 next, bool iscalled){tSeqTabletelm;tRelationtseqrel;tBufferttbuf;tForm_pg_sequence seq;t tinit_sequence(relid, &elm, &seqrel);tif (pg_class_aclcheck(elm->relid, GetUserId(), ACL_UPDATE) != ACLCHECK_OK)ttereport(ERROR,tttt(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),tttt errmsg(""permission denied for sequence %s"",ttttttRelationGetRelationName(seqrel))));t tseq = read_info(elm, seqrel, &buf);tif ((next < seq->min_value) || (next > seq->max_value))t{ttcharttbufv[100],tttttbufm[100],tttttbufx[100];ttsnprintf(bufv, sizeof(bufv), INT64_FORMAT, next);ttsnprintf(bufm, sizeof(bufm), INT64_FORMAT, seq->min_value);ttsnprintf(bufx, sizeof(bufx), INT64_FORMAT, seq->max_value);ttereport(ERROR,tttt(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),tttt errmsg(""setval: value %s is out of bounds for sequence ""%s"" (%s..%s)"",ttttttbufv, RelationGetRelationName(seqrel),ttttttbufm, bufx)));t}t tif (iscalled)t{ttelm->last = next;tt ttelm->last_valid = true;t}t telm->cached = elm->last;tSTART_CRIT_SECTION();tMarkBufferDirty(buf);t tif (!seqrel->rd_istemp)t{ttxl_seq_rectxlrec;ttXLogRecPtrtrecptr;ttXLogRecData rdata[2];ttPagettpage = BufferGetPage(buf);ttxlrec.node = seqrel->rd_node;ttrdata[0].data = (char *) &xlrec;ttrdata[0].len = sizeof(xl_seq_rec);ttrdata[0].buffer = InvalidBuffer;ttrdata[0].next = &(rdata[1]);tt ttseq->last_value = next;ttseq->is_called = true;ttseq->log_cnt = 0;ttrdata[1].data = (char *) page + ((PageHeader) page)->pd_upper;ttrdata[1].len = ((PageHeader) page)->pd_special -ttt((PageHeader) page)->pd_upper;ttrdata[1].buffer = InvalidBuffer;ttrdata[1].next = NULL;ttrecptr = XLogInsert(RM_SEQ_ID, XLOG_SEQ_LOG, rdata);ttPageSetLSN(page, recptr);ttPageSetTLI(page, ThisTimeLineID);t}t tseq->last_value = next;tt tseq->is_called = iscalled;tseq->log_cnt = (iscalled) ? 0 : 1;tEND_CRIT_SECTION();tUnlockReleaseBuffer(buf);trelation_close(seqrel, NoLock);}",3,"cwe119,cwe120,cweother"
"get_seq(int **seq, FILE *fp) {  int len = 0;     int mem = sizeof(int);     int *buf = xmalloc(mem);     register int c;  while((c = getc(fp)) != EOF) {    if (c == '>')      break;    else if (isspace(c))         continue;    if (len * sizeof(int) == mem)      buf = moremem(buf, &mem);    buf[len] = c;    ++len;  }  if (ferror(fp))    die(""%s: error reading fasta file: %s"", prog_name, strerror(errno));  if (c == '>')    xungetc(c, fp);  buf = XREALLOC(buf, len);     *seq = buf;     return len;   }",2,"cwe120,cweother"
"PrintControlValues(bool guessed){tcharttsysident_str[32];tif (guessed)ttprintf(_(""Guessed pg_control values:""));telsettprintf(_(""Current pg_control values:""));t tsnprintf(sysident_str, sizeof(sysident_str), UINT64_FORMAT,ttt ControlFile.system_identifier);tprintf(_(""pg_control version number:            %u""),tt   ControlFile.pg_control_version);tprintf(_(""Catalog version number:               %u""),tt   ControlFile.catalog_version_no);tprintf(_(""Database system identifier:           %s""),tt   sysident_str);tprintf(_(""Latest checkpoint's TimeLineID:       %u""),tt   ControlFile.checkPointCopy.ThisTimeLineID);tprintf(_(""Latest checkpoint's full_page_writes: %s""),tt   ControlFile.checkPointCopy.fullPageWrites ? _(""on"") : _(""off""));tprintf(_(""Latest checkpoint's NextXID:          %u/%u""),tt   ControlFile.checkPointCopy.nextXidEpoch,tt   ControlFile.checkPointCopy.nextXid);tprintf(_(""Latest checkpoint's NextOID:          %u""),tt   ControlFile.checkPointCopy.nextOid);tprintf(_(""Latest checkpoint's NextMultiXactId:  %u""),tt   ControlFile.checkPointCopy.nextMulti);tprintf(_(""Latest checkpoint's NextMultiOffset:  %u""),tt   ControlFile.checkPointCopy.nextMultiOffset);tprintf(_(""Latest checkpoint's oldestXID:        %u""),tt   ControlFile.checkPointCopy.oldestXid);tprintf(_(""Latest checkpoint's oldestXID's DB:   %u""),tt   ControlFile.checkPointCopy.oldestXidDB);tprintf(_(""Latest checkpoint's oldestActiveXID:  %u""),tt   ControlFile.checkPointCopy.oldestActiveXid);tprintf(_(""Latest checkpoint's oldestMultiXid:   %u""),tt   ControlFile.checkPointCopy.oldestMulti);tprintf(_(""Latest checkpoint's oldestMulti's DB: %u""),tt   ControlFile.checkPointCopy.oldestMultiDB);tprintf(_(""Latest checkpoint's oldestCommitTs:   %u""),tt   ControlFile.checkPointCopy.oldestCommitTs);tprintf(_(""Latest checkpoint's newestCommitTs:   %u""),tt   ControlFile.checkPointCopy.newestCommitTs);tprintf(_(""Maximum data alignment:               %u""),tt   ControlFile.maxAlign);t tprintf(_(""Database block size:                  %u""),tt   ControlFile.blcksz);tprintf(_(""Blocks per segment of large relation: %u""),tt   ControlFile.relseg_size);tprintf(_(""WAL block size:                       %u""),tt   ControlFile.xlog_blcksz);tprintf(_(""Bytes per WAL segment:                %u""),tt   ControlFile.xlog_seg_size);tprintf(_(""Maximum length of identifiers:        %u""),tt   ControlFile.nameDataLen);tprintf(_(""Maximum columns in an index:          %u""),tt   ControlFile.indexMaxKeys);tprintf(_(""Maximum size of a TOAST chunk:        %u""),tt   ControlFile.toast_max_chunk_size);tprintf(_(""Size of a large-object chunk:         %u""),tt   ControlFile.loblksize);tprintf(_(""Date/time type storage:               %s""),tt   (ControlFile.enableIntTimes ? _(""64-bit integers"") : _(""floating-point numbers"")));tprintf(_(""Float4 argument passing:              %s""),tt   (ControlFile.float4ByVal ? _(""by value"") : _(""by reference"")));tprintf(_(""Float8 argument passing:              %s""),tt   (ControlFile.float8ByVal ? _(""by value"") : _(""by reference"")));tprintf(_(""Data page checksum version:           %u""),tt   ControlFile.data_checksum_version);}",3,"cwe119,cwe120,cweother"
"""read_line(FILE *input, char *line, size_t len){tint i;tint c;tfor (i = 0; i < (int)len-1; i++) {ttc = getc(input);ttif (c == EOF) {tttreturn -1;tt} else if (c != '') {tttline[i] = c;tt} else {tttbreak;tt}t}tline[i] = '0';treturn i;}""",2,"cwe120,cweother"
"imap_login( struct mbox_struct * mb, SOCKET ** sock ) {   int ret;tchar input[MAX_INPUT_LENGTH+1];tchar output[MAX_INPUT_LENGTH+1];tSOCKET * s;   CREATE_OPEN_SOCK;#ifdef HAVE_OPENSSL_SSL_H   if ( (mb->flags & FLAG_SSL) && (Sslclient(s, mb->trustedCaDir) == -1) ) {             Sclose(s);      s = NULL;      CREATE_OPEN_SOCK;      CHECK_GREETING;      sprintf(output, ""A000 STARTTLSr"");      WRITE_OUTPUT;      WAITOK;      if ( strncmp(input, ""A000 OK"", 7) ) {         BYE(STAT_CONN);      }      if ( Sslclient(s, mb->trustedCaDir) == -1) {         BYE(STAT_CONN);      }   }   else {      CHECK_GREETING;   }#else   CHECK_GREETING;#endift tsprintf(output, ""A000 LOGIN %s %sr"", mb->user, mb->pass);   WRITE_OUTPUT;tWAITOK;tif ( strncmp(input, ""A000 OK"", 7) ) {ttBYE(STAT_LOGIN);t}treturn(STAT_IDLE);}",2,"cwe119,cwe120"
"reply_resent(struct pine *pine_state, long int msgno, char *section){#define RESENTFROM 0#define RESENTTO   1#define RESENTCC   2    ADDRESSt*rlist = NULL, **a, **b;    chart*hdrs, *values[RESENTCC+1];    inttt i;    static char *fields[] = {""Resent-From"", ""Resent-To"", ""Resent-Cc"", NULL};    static char *fakedomain = ""@"";    if((hdrs = pine_fetchheader_lines(pine_state->mail_stream,tttt     msgno, section, fields)) != NULL){tmemset(values, 0, (RESENTCC+1) * sizeof(char *));tsimple_header_parse(hdrs, fields, values);tfor(i = RESENTFROM; i <= RESENTCC; i++)t  rfc822_parse_adrlist(&rlist, values[i],ttt       (F_ON(F_COMPOSE_REJECTS_UNQUAL, pine_state))tttt ? fakedomain : pine_state->maildomain);t tfor(a = &rlist; *a; a = &(*a)->next)t t  for(b = &(*a)->next; *b; )tt t    if(address_is_same(*a, *b)){ttADDRESS *t = *b;ttif(!(*a)->personal){tt tt    (*a)->personal = (*b)->personal;tt    (*b)->personal = NULL;tt}tt*bt= t->next;ttt->next = NULL;ttmail_free_address(&t);t    }t    elset      b = &(*b)->next;    }    if(hdrs)      fs_give((void **) &hdrs);        return(rlist);}",2,"cwe119,cwe120"
"__checkhost_sa (struct sockaddr *ra, size_t ralen, char *lhost,ttconst char *rhost){tstruct addrinfo hints, *res0, *res;tchar raddr[INET6_ADDRSTRLEN];tint match;tint negate=1;     t tif (strncmp (""+@"", lhost, 2) == 0)ttreturn innetgr (&lhost[2], rhost, NULL, NULL);tif (strncmp (""-@"", lhost, 2) == 0)ttreturn -innetgr (&lhost[2], rhost, NULL, NULL);t tif (strncmp (""-"", lhost,1) == 0) {ttnegate = -1;ttlhost++;t} else if (strcmp (""+"",lhost) == 0) {ttreturn 1;                     t}t t tif (getnameinfo(ra, ralen,tttraddr, sizeof(raddr), NULL, 0,tttNI_NUMERICHOST) == 0t    && strcmp(raddr, lhost) == 0)ttreturn negate;t tmatch = 0;tmemset(&hints, '0', sizeof(hints));thints.ai_family = ra->sa_family;tif (getaddrinfo(lhost, NULL, &hints, &res0) == 0){tt ttfor (res = res0; res; res = res->ai_next)tt  {tt    if (res->ai_family == ra->sa_familyttt&& !memcmp(res->ai_addr, ra, res->ai_addrlen))tt      {tttmatch = 1;tttbreak;tt      }tt  }ttfreeaddrinfo (res0);t}treturn negate * match;}",2,"cwe119,cwe120"
"hxtool_hex(struct hex_options *opt, int argc, char **argv){    if (opt->decode_flag) {tchar buf[1024], buf2[1024], *p;tssize_t len;twhile(fgets(buf, sizeof(buf), stdin) != NULL) {t    buf[strcspn(buf, ""r"")] = '0';t    p = buf;t    while(isspace(*(unsigned char *)p))ttp++;t    len = hex_decode(p, buf2, strlen(p));t    if (len < 0)tterrx(1, ""hex_decode failed"");t    if (fwrite(buf2, 1, len, stdout) != (size_t)len)tterrx(1, ""fwrite failed"");t}    } else {        char buf[28], *p;tssize_t len;twhile((len = fread(buf, 1, sizeof(buf), stdin)) != 0) {t    len = hex_encode(buf, len, &p);t    if (len < 0)t        continue;t    fprintf(stdout, ""%s"", p);t    free(p);t}    }    return 0;}",4,"cwe119,cwe120,cwe476,cweother"
"_plugin_config_cb(void *data, void *data2 __UNUSED__){   Plugin_Page *page = data;   Evry_Plugin *p = page->cur->plugin;   if (!p) return;   printf("" %s"", p->name);   e_configure_registry_call(p->config_path,                             e_container_current_get(e_manager_current_get()),                             p->name);}",2,"cwe119,cwe120"
"eject_scsi(const char *dev){tstatic const char sg_commands[3][6] = {tt{ ALLOW_MEDIUM_REMOVAL, 0, 0, 0, 0, 0 },tt{ START_STOP, 0, 0, 0, 1, 0 },tt{ START_STOP, 0, 0, 0, 2, 0 }t};tunsigned i;tunsigned char sense_buffer[32];tunsigned char inqBuff[2];tsg_io_hdr_t io_hdr;tif ((ioctl(dev_fd, SG_GET_VERSION_NUM, &i) < 0) || (i < 30000))ttbb_error_msg_and_die(""not a sg device or old sg driver"");tmemset(&io_hdr, 0, sizeof(sg_io_hdr_t));tio_hdr.interface_id = 'S';tio_hdr.cmd_len = 6;tio_hdr.mx_sb_len = sizeof(sense_buffer);tio_hdr.dxfer_direction = SG_DXFER_NONE;t tio_hdr.dxferp = inqBuff;tio_hdr.sbp = sense_buffer;tio_hdr.timeout = 2000;tfor (i = 0; i < 3; i++) {ttio_hdr.cmdp = (void *)sg_commands[i];ttioctl_or_perror_and_die(dev_fd, SG_IO, (void *)&io_hdr, ""%s"", dev);t}t tioctl(dev_fd, BLKRRPART);}",2,"cwe119,cwe120"
"""ReadLock(int fd){  int i;  pid_t pid;  char buff[BUFSIZ];  lseek(fd, 0, SEEK_SET);  /* Read the pid that is written there. */  if (BinaryLock) {    if (read(fd, (char *)&pid, sizeof(pid)) != sizeof(pid)) {      return 0;    }  } else {    if ((i = read(fd, buff, sizeof(buff) - 1)) <= 0) {      return 0;    }    buff[i] = '0';    pid = (pid_t) atol(buff);  }  return pid;}""",3,"cwe119,cwe120,cweother"
"vs_t_create_node(unsigned int owner){tVSNodeText *node;tchar name[48];tunsigned int i;tnode = malloc(sizeof *node);tvs_add_new_node(&node->head, V_NT_TEXT);tsprintf(name, ""Text_Node_%u"", node->head.id);tcreate_node_head(&node->head, name, owner);tnode->language[0] = 0;tnode->buffer_count = 16;tnode->buffer = malloc((sizeof *node->buffer) * node->buffer_count);tfor(i = 0; i < node->buffer_count; i++)ttnode->buffer[i].name[0] = 0;treturn node;}",2,"cwe119,cwe120"
"load_firmware(const char *firmware, const char *sysfs_path){tint cnt;tint firmware_fd, loading_fd;t txchdir(""/lib/firmware"");tfirmware_fd = open(firmware, O_RDONLY);  t txchdir(sysfs_path);tfor (cnt = 0; cnt < 30; ++cnt) {ttloading_fd = open(""loading"", O_WRONLY);ttif (loading_fd >= 0)tttgoto loading;ttsleep(1);t}tgoto out; loading:tcnt = 0;tif (firmware_fd >= 0) {ttint data_fd;tt ttif (full_write(loading_fd, ""1"", 1) != 1)tttgoto out;tt ttdata_fd = open(""data"", O_WRONLY);ttif (data_fd < 0)tttgoto out;ttcnt = bb_copyfd_eof(firmware_fd, data_fd);ttif (ENABLE_FEATURE_CLEAN_UP)tttclose(data_fd);t}t tif (cnt > 0)ttfull_write(loading_fd, ""0"", 1);telsettfull_write(loading_fd, ""-1"", 2); out:txchdir(""/dev"");tif (ENABLE_FEATURE_CLEAN_UP) {ttclose(firmware_fd);ttclose(loading_fd);t}}",2,"cwe120,cweother"
"t_readline(FILE *fp){tinttttlen;tchart   *recoded;tcharttbuf[4096];tt tif (fgets(buf, sizeof(buf), fp) == NULL)ttreturn NULL;tlen = strlen(buf);t t(void) pg_verify_mbstr(PG_UTF8, buf, len, false);t trecoded = (char *) pg_do_encoding_conversion((unsigned char *) buf,tttttttttttt len,tttttttttttt PG_UTF8,tttttttttttt GetDatabaseEncoding());tif (recoded == NULL)tt ttelog(ERROR, ""encoding conversion failed"");tif (recoded == buf)t{tt ttrecoded = pnstrdup(recoded, len);t}treturn recoded;}",2,"cwe119,cwe120"
"check_outbox(const char *message, const char *mailbox){tchar *argv[10];tconst char *from;tif (!is_outbox(mailbox))ttreturn (0);tfrom=defaultSendFrom();targv[1]=""-oi"";targv[2]=""-t"";targv[3]=NULL;tif (from)t{ttargv[3]=""-f"";ttargv[4]=(char *)from;ttargv[5]=NULL;t}treturn (imapd_sendmsg(message, argv, errlogger));}",2,"cwe119,cwe120"
"mm_append (MAILSTREAM *stream,void *data,char **flags,char **date,ttSTRING **message){  char *t,*t1,tmp[MAILTMPLEN];  unsigned long u;  MESSAGECACHE *elt;  APPENDPACKAGE *ap = (APPENDPACKAGE *) data;  *flags = *date = NIL;tt   if (ap->flags) fs_give ((void **) &ap->flags);  if (ap->date) fs_give ((void **) &ap->date);  mail_gc (ap->stream,GC_TEXTS);  if (++ap->msgno <= ap->msgmax) {tttt     memset (t = tmp,0,MAILTMPLEN);tttt     if ((elt = mail_elt (ap->stream,ap->msgno))->seen) strcat (t,"" Seen"");    if (elt->deleted) strcat (t,"" Deleted"");    if (elt->flagged) strcat (t,"" Flagged"");    if (elt->answered) strcat (t,"" Answered"");    if (elt->draft) strcat (t,"" Draft"");tttt     if (!ignorep && (u = elt->user_flags)) do      if ((t1 = ap->stream->user_flags[find_rightmost_bit (&u)]) &&t  (MAILTMPLEN - ((t += strlen (t)) - tmp)) > (long) (2 + strlen (t1))){t*t++ = ' ';tt tstrcpy (t,t1);tt       }    while (u);ttt     *flags = ap->flags = cpystr (tmp + 1);    *date = ap->date = cpystr (mail_date (tmp,elt));    *message = ap->message;t     INIT (ap->message,mstring,(void *) ap,elt->rfc822_size);  }  else *message = NIL;tt   return LONGT;}",2,"cwe119,cwe120"
"dump_ole(MdbTableDef *table, char *colname, char *sargname){char ole_data[200000];int len;MdbSarg sarg;char *sargcol, *sargop, *sargval;tmdb_bind_column_by_name(table, colname, ole_data, &len);tif (sargname) {ttsargcol = strtok(sargname,"" "");ttsargop = strtok(NULL,"" "");ttsargval = strtok(NULL,"" "");ttprintf(""col %s op %s val %s"",sargcol,sargop,sargval);        tsarg.op = MDB_EQUAL;  ttstrcpy(sarg.value.s, sargval);ttmdb_add_sarg_by_name(table, sargcol, &sarg);t}        mdb_rewind_table(table);twhile (mdb_fetch_row(table)) {ttbuffer_dump(ole_data, 0, len);ttprintf(""---"");t}}",2,"cwe119,cwe120"
"ath10k_dbg_dump(struct ath10k *ar,tt     enum ath10k_debug_mask mask,tt     const char *msg, const char *prefix,tt     const void *buf, size_t len){tchar linebuf[256];tunsigned int linebuflen;tconst void *ptr;tif (ath10k_debug_mask & mask) {ttif (msg)tttath10k_dbg(ar, mask, ""%s"", msg);ttfor (ptr = buf; (ptr - buf) < len; ptr += 16) {tttlinebuflen = 0;tttlinebuflen += scnprintf(linebuf + linebuflen,ttttttsizeof(linebuf) - linebuflen,tttttt""%s%08x: "",tttttt(prefix ? prefix : """"),tttttt(unsigned int)(ptr - buf));ttthex_dump_to_buffer(ptr, len - (ptr - buf), 16, 1,ttttt   linebuf + linebuflen,ttttt   sizeof(linebuf) - linebuflen, true);tttdev_printk(KERN_DEBUG, ar->dev, ""%s"", linebuf);tt}t}t ttrace_ath10k_log_dbg_dump(ar, msg ? msg : """", prefix ? prefix : """",tttt  buf, len);}",2,"cwe119,cwe120"
"addinvk(name, n)char *name;int n;   {   struct invkl *p;   if (n == 1) {ttt       if (strcmp(name, ""all"") != 0) {         tfatal(""invalid operand to invocable"", name);         return;         }      else         name = ""0"";ttt       }   else if (!isalpha(name[0]) && (name[0] != '_'))      return;tttt    p = alloc(sizeof(struct invkl));   if (!p)      tsyserr(""not enough memory for invocable list"");   p->iv_name = salloc(name);   p->iv_link = invkls;   invkls = p;   }",2,"cwe469,cwe476"
"expand_options (int *argcp, char ***argvp){  int argc = *argcp;  char **argv = *argvp;     if (argc > 1 && argv[1][1] != '-')    {      char buf[3];      char **new_argv;      size_t new_argc;      size_t args_to_expand;      char *p;      char **in, **out;      buf[0] = '-';      buf[2] = '0';      args_to_expand = strlen (argv[1]);      if (argv[1][0] == '-')        --args_to_expand;              new_argc = argc - 1 + args_to_expand;      new_argv = (char **) malloc (new_argc * sizeof (char *));      in = argv;      out = new_argv;      *out++ = *in++;      p = *in++;      if (*p == '-')        p++;      while (*p != '0')t{t  char *opt;t  buf[1] = *p;t  *out++ = strdup (buf);t   t  opt = strchr (OPTION_STRING, *p);t  if (opt && opt[1] == ':')t    {t      if (in < argv + argc)tt*out++ = *in++;t      elsett{tt  fprintf(stderr, ""%s: option `%s' requires an argument."",ttt  argv[0], buf);tt  usage(argv[0]);tt}t    }t  ++p;t}             while (in < argv + argc)t*out++ = *in++;      *argcp = (int) new_argc;      *argvp = new_argv;    }}",2,"cwe119,cwe120"
"groestl_big_close(sph_groestl_big_context *sc,tunsigned ub, unsigned n, void *dst, size_t out_len){tunsigned char pad[136];tsize_t ptr, pad_len, u;#if SPH_64tsph_u64 count;#elsetsph_u32 count_high, count_low;#endiftunsigned z;tDECL_STATE_BIGtptr = sc->ptr;tz = 0x80 >> n;tpad[0] = ((ub & -z) | z) & 0xFF;tif (ptr < 120) {ttpad_len = 128 - ptr;#if SPH_64ttcount = SPH_T64(sc->count + 1);#elsettcount_low = SPH_T32(sc->count_low + 1);ttcount_high = SPH_T32(sc->count_high);ttif (count_low == 0)tttcount_high = SPH_T32(count_high + 1);#endift} else {ttpad_len = 256 - ptr;#if SPH_64ttcount = SPH_T64(sc->count + 2);#elsettcount_low = SPH_T32(sc->count_low + 2);ttcount_high = SPH_T32(sc->count_high);ttif (count_low <= 1)tttcount_high = SPH_T32(count_high + 1);#endift}tmemset(pad + 1, 0, pad_len - 9);#if SPH_64tsph_enc64be(pad + pad_len - 8, count);#elsetsph_enc64be(pad + pad_len - 8, count_high);tsph_enc64be(pad + pad_len - 4, count_low);#endiftgroestl_big_core(sc, pad, pad_len);tREAD_STATE_BIG(sc);tFINAL_BIG;#if SPH_GROESTL_64tfor (u = 0; u < 8; u ++)ttenc64e(pad + (u << 3), H[u + 8]);#elsetfor (u = 0; u < 16; u ++)ttenc32e(pad + (u << 2), H[u + 16]);#endiftmemcpy(dst, pad + 64 - out_len, out_len);tgroestl_big_init(sc, (unsigned)out_len << 3);}",2,"cwe119,cwe120"
"iwlist ( struct net80211_device *dev ) {tstruct net80211_probe_ctx *ctx;tstruct list_head *networks;tstruct net80211_wlan *wlan;tchar ssid_buf[22];tint rc;tunsigned i;tint was_opened = dev->netdev->state & NETDEV_OPEN;tint was_channel = dev->channels[dev->channel].channel_nr;tif ( ! was_opened ) {ttdev->state |= NET80211_NO_ASSOC;ttrc = netdev_open ( dev->netdev );ttif ( rc < 0 )tttgoto err;t}tif ( dev->state & NET80211_WORKING ) {ttrc = -EINVAL;ttgoto err_close_netdev;t}tif ( ! was_opened ) {ttrc = net80211_prepare_probe ( dev, dev->hw->bands, 0 );ttif ( rc < 0 )tttgoto err_close_netdev;t}tctx = net80211_probe_start ( dev, """", 0 );tif ( ! ctx ) {ttrc = -ENOMEM;ttgoto err_close_netdev;t}twhile ( ! ( rc = net80211_probe_step ( ctx ) ) ) {ttstep();t}tnetworks = net80211_probe_finish_all ( ctx );tif ( list_empty ( networks ) ) {ttgoto err_free_networks;t}trc = 0;tprintf ( ""Networks on %s:"", dev->netdev->name );t t tprintf ( ""[Sig] SSID                  BSSID              Ch  Crypt/Auth""tt ""-------------------------------------------------------------"" );tlist_for_each_entry ( wlan, networks, list ) {tt ttsnprintf ( ssid_buf, sizeof ( ssid_buf ), ""%s"", wlan->essid );ttfor ( i = strlen ( ssid_buf ); i < sizeof ( ssid_buf ) - 1;tt      i++ )tttssid_buf[i] = ' ';ttif ( ssid_buf[sizeof ( ssid_buf ) - 2] != ' ' )tttssid_buf[sizeof ( ssid_buf ) - 2] = '>';ttssid_buf[sizeof ( ssid_buf ) - 1] = 0;tt ttif ( wlan->crypto >= NR_CRYPTO_TYPES ||tt     wlan->handshaking >= NR_AUTH_TYPES )tttcontinue;ttprintf ( ""[%3d] %s %s  %2d  %s  %s"",ttt wlan->signal < 0 ? 100 + wlan->signal : wlan->signal,ttt ssid_buf, eth_ntoa ( wlan->bssid ), wlan->channel,ttt crypto_types[wlan->crypto],ttt auth_types[wlan->handshaking] );t}tprintf ( """" ); err_free_networks:tnet80211_free_wlanlist ( networks ); err_close_netdev:tif ( ! was_opened ) {ttdev->state &= ~NET80211_NO_ASSOC;ttnetdev_close ( dev->netdev );t} else {ttnet80211_change_channel ( dev, was_channel );t}tif ( ! rc )ttreturn 0; err:tprintf ( ""Scanning for networks on %s: %s"",tt dev->netdev->name, strerror ( rc ) );treturn rc;}",2,"cwe119,cwe120"
"""entryGetNextItem(Relation index, GinScanEntry entry){tPagettpage;tBlockNumber blkno;tfor (;;)t{ttif (entry->offset < entry->nlist)tt{tttentry->curItem = entry->list[entry->offset++];tttreturn;tt}ttLockBuffer(entry->buffer, GIN_SHARE);ttpage = BufferGetPage(entry->buffer);ttfor (;;)tt{ttt/*ttt * It's needed to go by right link. During that we should refindttt * first ItemPointer greater that storedttt */tttblkno = GinPageGetOpaque(page)->rightlink;tttLockBuffer(entry->buffer, GIN_UNLOCK);tttif (blkno == InvalidBlockNumber)ttt{ttttReleaseBuffer(entry->buffer);ttttItemPointerSetInvalid(&entry->curItem);ttttentry->buffer = InvalidBuffer;ttttentry->isFinished = TRUE;ttttreturn;ttt}tttentry->buffer = ReleaseAndReadBuffer(entry->buffer, index, blkno);tttLockBuffer(entry->buffer, GIN_SHARE);tttpage = BufferGetPage(entry->buffer);tttentry->offset = InvalidOffsetNumber;tttif (!ItemPointerIsValid(&entry->curItem) ||ttttfindItemInPage(page, &entry->curItem, &entry->offset))ttt{tttt/*tttt * Found position equal to or greater than storedtttt */ttttentry->nlist = GinPageGetOpaque(page)->maxoff;ttttmemcpy(entry->list, GinDataPageGetItem(page, FirstOffsetNumber),tttt   GinPageGetOpaque(page)->maxoff * sizeof(ItemPointerData));ttttLockBuffer(entry->buffer, GIN_UNLOCK);ttttif (!ItemPointerIsValid(&entry->curItem) ||tttttcompareItemPointers(&entry->curItem,ttttttttttentry->list + entry->offset - 1) == 0)tttt{ttttt/*ttttt * First pages are deleted or empty, or we found exactttttt * position, so break inner loop and continue outer one.ttttt */tttttbreak;tttt}tttt/*tttt * Find greater than entry->curItem position, store it.tttt */ttttentry->curItem = entry->list[entry->offset - 1];ttttreturn;ttt}tt}t}}""",2,"cwe120,cweother"
"kernel_load(EFI_HANDLE image, CHAR16 *kname, kdesc_t *kd, memdesc_t *imem, memdesc_t *mmem){tCHAR16 kernel[FILENAME_MAXLEN];t tif (elilo_opt.vmcode[0])ttStrCpy(kernel, elilo_opt.vmcode);telsettStrCpy(kernel, kname);t tswitch(do_kernel_load(kernel, kd)) {ttcase ELILO_LOAD_SUCCESS:tttbreak;ttcase ELILO_LOAD_ERROR:ttt tttreturn ELILO_LOAD_ERROR;ttttcase ELILO_LOAD_ABORTED:ttt tttelilo_opt.initrd[0] = CHAR_NULL;tttelilo_opt.vmcode[0] = CHAR_NULL;ttt tttelilo_opt.prompt  = 1; tttelilo_opt.timeout = ELILO_DEFAULT_TIMEOUT;tttelilo_opt.delay   = 0;tttreturn ELILO_LOAD_RETRY;tt}tVERB_PRT(3, Print(L""kernel loaded in ["" PTR_FMT ""-"" PTR_FMT ""] entry="" PTR_FMT """", ttt  kd->kstart, kd->kend, kd->kentry));tif (elilo_opt.initrd[0]) {tt ttif (sysdeps_initrd_get_addr(kd, imem) == -1) goto exit_error;ttswitch(load_file(elilo_opt.initrd, imem)) {tttcase ELILO_LOAD_SUCCESS:ttttbreak;tttcase ELILO_LOAD_ERROR:ttttgoto exit_error;tttcase ELILO_LOAD_ABORTED:ttttfree_kmem();tttt ttttelilo_opt.initrd[0] = CHAR_NULL;ttttelilo_opt.vmcode[0] = CHAR_NULL;ttttelilo_opt.prompt    = 1; ttttelilo_opt.timeout   = ELILO_DEFAULT_TIMEOUT;ttttelilo_opt.delay     = 0;ttttreturn ELILO_LOAD_RETRY;tt}t}tif (elilo_opt.vmcode[0]) {ttmmem->start_addr = 0;  ttswitch(load_file(kname, mmem)) {tttcase ELILO_LOAD_SUCCESS:ttttbreak;tttcase ELILO_LOAD_ERROR:ttttgoto exit_error;tttcase ELILO_LOAD_ABORTED:ttttif (imem->start_addr)tttttfree(imem->start_addr);ttttfree_kmem();tttt ttttelilo_opt.initrd[0] = CHAR_NULL;ttttelilo_opt.vmcode[0] = CHAR_NULL;ttttelilo_opt.prompt    = 1; ttttelilo_opt.timeout   = ELILO_DEFAULT_TIMEOUT;ttttelilo_opt.delay     = 0;ttttreturn ELILO_LOAD_RETRY;tt}tt ttif (gzip_probe(mmem->start_addr, mmem->size) == 0 &&tt    gunzip_image(mmem) != ELILO_LOAD_SUCCESS) {tttif (imem->start_addr)ttttfree(imem->start_addr);tttfree(mmem->start_addr);tttfree_kmem();ttt tttelilo_opt.initrd[0] = CHAR_NULL;tttelilo_opt.vmcode[0] = CHAR_NULL;tttelilo_opt.prompt    = 1; tttelilo_opt.timeout   = ELILO_DEFAULT_TIMEOUT;tttelilo_opt.delay     = 0;tttreturn ELILO_LOAD_RETRY;tt}t}treturn ELILO_LOAD_SUCCESS;exit_error:tfree_kmem();tif (imem->start_addr) free(imem->start_addr);tif (mmem->start_addr) free(mmem->start_addr);treturn ELILO_LOAD_ERROR;}",2,"cwe120,cweother"
"s48_if_indextoname(s48_call_t call, s48_ref_t sch_ifindex){  char ifname[IF_NAMESIZE];  if (if_indextoname(s48_extract_unsigned_long_2(call, sch_ifindex), ifname) != NULL)    return s48_enter_string_latin_1_2(call, ifname);  else    s48_os_error_2(call, ""s48_if_indextoname"", errno, 1, sch_ifindex);}",2,"cwe119,cwe120"
"windows_conn_read_entry_attribute(Repl_Connection *conn, const char *dn,tchar *type, struct berval ***returned_bvals){tConnResult return_value;tint ldap_rc;tLDAPControl *server_controls[2];tLDAPMessage *res = NULL;tchar *attrs[2];tLDAPDebug( LDAP_DEBUG_TRACE, ""=> windows_conn_read_entry_attribute"", 0, 0, 0 );tPR_ASSERT(NULL != type);tif (windows_conn_connected(conn))t{ttserver_controls[0] = &manageDSAITControl;ttserver_controls[1] = NULL;ttattrs[0] = type;ttattrs[1] = NULL;ttldap_rc = ldap_search_ext_s(conn->ld, dn, LDAP_SCOPE_BASE,ttt""(objectclass=*)"", attrs, 0  ,tttserver_controls, NULL  ,ttt&conn->timeout, 0  , &res);ttif (LDAP_SUCCESS == ldap_rc)tt{tttLDAPMessage *entry = ldap_first_entry(conn->ld, res);tttif (NULL != entry)ttt{tttt*returned_bvals = ldap_get_values_len(conn->ld, entry, type);ttt}tttreturn_value = CONN_OPERATION_SUCCESS;tt}ttelse if (IS_DISCONNECT_ERROR(ldap_rc))tt{tttwindows_conn_disconnect(conn);tttreturn_value = CONN_NOT_CONNECTED;tt}ttelsett{tttreturn_value = CONN_OPERATION_FAILED;tt}ttconn->last_ldap_error = ldap_rc;ttif (NULL != res)tt{tttldap_msgfree(res);tttres = NULL;tt}t}telset{ttreturn_value = CONN_NOT_CONNECTED;t}tLDAPDebug( LDAP_DEBUG_TRACE, ""<= windows_conn_read_entry_attribute"", 0, 0, 0 );treturn return_value;}",2,"cwe119,cwe120"
"load_font(char font[100]){    if (!Togl_cur) {tfprintf(stderr, ""set Togl_CreateFunc"");treturn (0);    }    FontBase = Togl_LoadBitmapFont(Togl_cur, font);    if (!FontBase) {tfprintf(stderr, ""Cannot Load Font"");tfprintf(stderr, ""Trying default Font"");tFontBase = Togl_LoadBitmapFont(Togl_cur, TOGL_BITMAP_HELVETICA_12);tif (!FontBase) {t    fprintf(stderr, ""Cannot Load Default Font"");t    return (0);t}    }    return (FontBase);}",2,"cwe119,cwe120"
"__ecereMethod___ecereNameSpace__ecere__sys__File_GetHexValue(struct __ecereNameSpace__ecere__com__Instance * this){struct __ecereNameSpace__ecere__sys__File * __ecerePointer___ecereNameSpace__ecere__sys__File = (struct __ecereNameSpace__ecere__sys__File *)(this ? (((char *)this) + __ecereClass___ecereNameSpace__ecere__sys__File->offset) : 0);char string[32];__ecereMethod___ecereNameSpace__ecere__sys__File_GetString(this, string, sizeof string);return (unsigned int)strtoul(string, (((void *)0)), 16);}",2,"cwe119,cwe120"
"I_get_init_info(char *group, struct Ortho_Camera_Exp_Init *init_info){    FILE *fd;    char msg[100];    int stat;    fd = I_fopen_group_init_old(group);    if (fd == NULL) {tsprintf(msg, ""unable to open camera initial file %s in %s"",ttgroup, G_mapset());tG_warning(msg);treturn 0;    }    stat = I_read_init_info(fd, init_info);    fclose(fd);    if (stat < 0) {tsprintf(msg, ""bad format in camera initial file %s in %s"",ttgroup, G_mapset());tG_warning(msg);treturn 0;    }    return 1;}",2,"cwe119,cwe120"
"""adjust_indirect_blocks(struct gfs2_sbd *sbp, struct gfs2_inode *ip){tuint64_t dinode_size;tuint32_t gfs2_hgt, di_height;tosi_list_t *tmp=NULL, *x;tstruct blocklist blocks, *blk;tint error = 0;tint isdir = S_ISDIR(ip->i_di.di_mode); /* is always jdata */tint isjdata = ((GFS2_DIF_JDATA & ip->i_di.di_flags) && !isdir);tint isreg = (!isjdata && !isdir);t/* regular files and dirs are same upto height=2t   jdata files (not dirs) are same only when height=0 */tif (((isreg||isdir) && ip->i_di.di_height <= 1) ||t    (isjdata && ip->i_di.di_height == 0))ttreturn 0; /* nothing to do */tosi_list_init(&blocks.list);terror = get_inode_metablocks(sbp, ip, &blocks);tif (error)ttgoto out;t/* The gfs2 height may be different.  We need to rebuild thet   metadata tree to the gfs2 height. */tgfs2_hgt = calc_gfs2_tree_height(ip, ip->i_di.di_size);t/* Save off the size because we're going to empty the contentst   and add the data blocks back in later. */tdinode_size = ip->i_di.di_size;tip->i_di.di_size = 0ULL;tdi_height = ip->i_di.di_height;tip->i_di.di_height = 0;t/* Now run through the block list a second time.  If the blockt   is a data block, rewrite the data to the gfs2 offset. */tosi_list_foreach_safe(tmp, &blocks.list, x) {ttblk = osi_list_entry(tmp, struct blocklist, list);tt/* If it's not metadata that holds data block pointerstt   (i.e. metadata pointing to other metadata) */ttif (blk->height != di_height - 1) {tttosi_list_del(tmp);tttfree(blk->ptrbuf);tttfree(blk);tttcontinue;tt}ttif (isreg || isdir) /* more or less same way to deal with either */ttterror = fix_ind_reg_or_dir(sbp, ip, di_height, tttttt   gfs2_hgt, blk, &blocks);ttelse if (isjdata)ttterror = fix_ind_jdata(sbp, ip, di_height, gfs2_hgt, ttttt      dinode_size, blk, &blocks);ttif (error)tttgoto out;ttosi_list_del(tmp);ttfree(blk->ptrbuf);ttfree(blk);t}tip->i_di.di_size = dinode_size;t/* Set the new dinode height, which may or may not have changed.  */t/* The caller will take it from the ip and write it to the buffer */tip->i_di.di_height = gfs2_hgt;treturn error;out:twhile (!osi_list_empty(&blocks.list)) {ttblk = osi_list_entry(tmp, struct blocklist, list);ttosi_list_del(&blocks.list);ttfree(blk->ptrbuf);ttfree(blk);t}treturn error;}""",3,"cwe119,cwe120,cwe476"
"main(int argc, char **argv){  ESL_GETOPTS    *go   = p7_CreateDefaultApp(options, 0, argc, argv, banner, usage);  ESL_RANDOMNESS *r    = esl_randomness_CreateFast(esl_opt_GetInteger(go, ""-s""));  ESL_ALPHABET   *abc  = NULL;  P7_HMM         *hmm  = NULL;  P7_PROFILE     *gm   = NULL;  P7_BG          *bg   = NULL;  int             M    = 100;  int             L    = 200;  int             nseq = 20;  char            errbuf[eslERRBUFSIZE];  p7_FLogsumInit();  if ((abc = esl_alphabet_Create(eslAMINO))         == NULL)  esl_fatal(""failed to create alphabet"");  if (p7_hmm_Sample(r, M, abc, &hmm)                != eslOK) esl_fatal(""failed to sample an HMM"");  if ((bg = p7_bg_Create(abc))                      == NULL)  esl_fatal(""failed to create null model"");  if ((gm = p7_profile_Create(hmm->M, abc))         == NULL)  esl_fatal(""failed to create profile"");  if (p7_ProfileConfig(hmm, bg, gm, L, p7_LOCAL)    != eslOK) esl_fatal(""failed to config profile"");  if (p7_hmm_Validate    (hmm, errbuf, 0.0001)      != eslOK) esl_fatal(""whoops, HMM is bad!: %s"", errbuf);  if (p7_profile_Validate(gm,  errbuf, 0.0001)      != eslOK) esl_fatal(""whoops, profile is bad!: %s"", errbuf);  utest_forward    (go, r, abc, bg, gm, nseq, L);  utest_generation (go, r, abc, gm, hmm, bg, nseq);  utest_enumeration(go, r, abc, 4);t   p7_profile_Destroy(gm);  p7_bg_Destroy(bg);  p7_hmm_Destroy(hmm);  esl_alphabet_Destroy(abc);  esl_randomness_Destroy(r);  esl_getopts_Destroy(go);  return 0;}",2,"cwe119,cwe120"
"""make_a_section_from_file (bfd *abfd,ttt  struct internal_scnhdr *hdr,ttt  unsigned int target_index){  asection *return_section;  char *name;  bfd_boolean result = TRUE;  flagword flags;  name = NULL;  /* Handle long section names as in PE.  On reading, we want to    accept long names if the format permits them at all, regardless    of the current state of the flag that dictates if we would generate    them in outputs; this construct checks if that is the case by    attempting to set the flag, without changing its state; the call    will fail for formats that do not support long names at all.  */  if (bfd_coff_set_long_section_names (abfd, bfd_coff_long_section_names (abfd))      && hdr->s_name[0] == '/')    {      char buf[SCNNMLEN];      long strindex;      char *p;      const char *strings;      /* Flag that this BFD uses long names, even though the format might         expect them to be off by default.  This won't directly affect the         format of any output BFD created from this one, but the information         can be used to decide what to do.  */      bfd_coff_set_long_section_names (abfd, TRUE);      memcpy (buf, hdr->s_name + 1, SCNNMLEN - 1);      buf[SCNNMLEN - 1] = '0';      strindex = strtol (buf, &p, 10);      if (*p == '0' && strindex >= 0)t{t  strings = _bfd_coff_read_string_table (abfd);t  if (strings == NULL)t    return FALSE;t  /* FIXME: For extra safety, we should make sure that             strindex does not run us past the end, but right now we             don't know the length of the string table.  */t  strings += strindex;t  name = (char *) bfd_alloc (abfd,                                     (bfd_size_type) strlen (strings) + 1);t  if (name == NULL)t    return FALSE;t  strcpy (name, strings);t}    }  if (name == NULL)    {      /* Assorted wastage to null-terminate the name, thanks AT&T! */      name = (char *) bfd_alloc (abfd,                                 (bfd_size_type) sizeof (hdr->s_name) + 1);      if (name == NULL)treturn FALSE;      strncpy (name, (char *) &hdr->s_name[0], sizeof (hdr->s_name));      name[sizeof (hdr->s_name)] = 0;    }  return_section = bfd_make_section_anyway (abfd, name);  if (return_section == NULL)    return FALSE;  return_section->vma = hdr->s_vaddr;  return_section->lma = hdr->s_paddr;  return_section->size = hdr->s_size;  return_section->filepos = hdr->s_scnptr;  return_section->rel_filepos = hdr->s_relptr;  return_section->reloc_count = hdr->s_nreloc;  bfd_coff_set_alignment_hook (abfd, return_section, hdr);  return_section->line_filepos = hdr->s_lnnoptr;  return_section->lineno_count = hdr->s_nlnno;  return_section->userdata = NULL;  return_section->next = NULL;  return_section->target_index = target_index;  if (! bfd_coff_styp_to_sec_flags_hook (abfd, hdr, name, return_section,ttttt & flags))    result = FALSE;  return_section->flags = flags;  /* At least on i386-coff, the line number count for a shared library     section must be ignored.  */  if ((return_section->flags & SEC_COFF_SHARED_LIBRARY) != 0)    return_section->lineno_count = 0;  if (hdr->s_nreloc != 0)    return_section->flags |= SEC_RELOC;  /* FIXME: should this check 'hdr->s_size > 0'.  */  if (hdr->s_scnptr != 0)    return_section->flags |= SEC_HAS_CONTENTS;  return result;}""",2,"cwe119,cwe120"
"ahci_sgpio_write(struct block_device *device, enum ibpi_pattern ibpi){tchar temp[WRITE_BUFFER_SIZE];tchar path[PATH_MAX];tchar *sysfs_path = device->cntrl_path;t tif (ibpi == device->ibpi_prev)ttreturn 1;tif (sysfs_path == NULL)tt__set_errno_and_return(EINVAL);tif ((ibpi < IBPI_PATTERN_NORMAL) || (ibpi > IBPI_PATTERN_LOCATE_OFF))tt__set_errno_and_return(ERANGE);tsprintf(temp, ""%u"", ibpi2sgpio[ibpi]);tstr_cpy(path, sysfs_path, PATH_MAX);tstr_cat(path, ""/em_message"", PATH_MAX);tusleep(EM_MSG_WAIT);treturn buf_write(path, temp) > 0;}",3,"cwe119,cwe120,cweother"
"p_parse_and_add_GapFmacRefEntry(GapFmacContext *fmacContext, char *line_ptr){  char *l_key;  char *l_value;  char *scan_ptr;  long id;  long ainfo_type;  long frame_nr;  long stackposition;  long track;  long mtime;  char *filename;  id = -1;  ainfo_type = -1;  frame_nr = -1;  stackposition = -1;  track = -1;  mtime = -1;  filename = NULL;    scan_ptr = line_ptr;  while (scan_ptr != NULL)  {    l_key = p_parse_string(&scan_ptr);    if (l_key == NULL)    {      break;    }    l_value = p_parse_string(&scan_ptr);    if (l_value == NULL)    {      g_free(l_key);      break;    }        if (strcmp(l_key, GAP_FMREF_ID) == 0)    {      id = atol(l_value);    }     else if (strcmp(l_key, GAP_FMREF_FRAME_NR) == 0)    {      frame_nr = atol(l_value);    }    else if (strcmp(l_key, GAP_FMREF_STACK) == 0)    {      stackposition = atol(l_value);    }    else if (strcmp(l_key, GAP_FMREF_TRACK) == 0)    {      track = atol(l_value);    }    else if (strcmp(l_key, GAP_FMREF_MTIME) == 0)    {      mtime = atol(l_value);    }    else if (strcmp(l_key, GAP_FMREF_TYPE) == 0)    {      ainfo_type = atol(l_value);    }    else if (strcmp(l_key, GAP_FMREF_FILE) == 0)    {      int len;      char *l_raw_filename;            l_raw_filename = l_value;      if(gap_debug)      {        printf(""RAW filename:%s:"", l_raw_filename);      }      if (*l_raw_filename == '""')      {        l_raw_filename++;      }      len = strlen(l_raw_filename);      if (len > 0)      {        if (l_raw_filename[len -1] == '""')        {          l_raw_filename[len -1] = '0';        }      }      filename = g_strdup(l_raw_filename);    }    else    {      printf(""WARNING: unkonwn token: %s"", l_key);    }    g_free(l_key);    g_free(l_value);  }     if (id < 0)  {    printf(""ERROR: incomplete record, expected: %s is missing"", GAP_FMREF_ID);    return;  }  if (frame_nr < 0)  {    printf(""ERROR: incomplete record, expected: %s is missing"", GAP_FMREF_FRAME_NR);    return;  }  if (filename == NULL)  {    printf(""ERROR: incomplete record, expected: %s is missing"", GAP_FMREF_FILE);    return;  }  if (ainfo_type < 0)  {    printf(""ERROR: incomplete record, expected: %s is missing"", GAP_FMREF_TYPE);    return;  }  if (mtime < 0)  {    printf(""ERROR: incomplete record, expected: %s is missing"", GAP_FMREF_MTIME);    return;  }     gap_fmct_add_GapFmacRefEntry(ainfo_type      , frame_nr      , stackposition      , track      , id      , filename      , TRUE                   , fmacContext      );  if (filename != NULL)  {    g_free(filename);  }}",2,"cwe469,cweother"
"write_lastlog_entry(uid_t user_uid, char *rmthost, struct lastlog *oldlog){  struct lastlog lastlog;          int lastlog_file;                   if ((lastlog_file = open (FILENAME_LASTLOG, O_RDWR)) == -1)    {      log_message (10001, ""couldn't open FILENAME_LASTLOG for O_RDWR!"");      return -1;    }     sscanf (ttyname(0), ""/dev/%s"", lastlog.ll_line);     strcpy (lastlog.ll_host, rmthost);     time (&lastlog.ll_time);     lseek (lastlog_file, (unsigned long)user_uid, SEEK_SET);     read (lastlog_file, oldlog, sizeof *oldlog);     lseek (lastlog_file, (unsigned long)user_uid, SEEK_SET);     write (lastlog_file, (char *)&lastlog, sizeof lastlog);     close (lastlog_file);     return 0;}",2,"cwe120,cweother"
"handle_classic_atom(int fh, off_t pos, off_t size, int depth){    struct classic_atom a;    uint64_t asize;    size_t off;    int i;    if (-1 == lseek(fh,pos,SEEK_SET)) {tperror(""lseek"");texit(1);    }    if (sizeof(a) != read(fh,&a,sizeof(a))) {tperror(""read"");texit(1);    }    swap_classic_atom(&a);    switch (a.size) {    case 0:tasize = size;toff   = 8;tbreak;    case 1:tasize = a.extsize;toff   = 16;tbreak;    default:tasize = a.size;toff   = 8;    }    printf(""0x%08"" PRIx64 "" 0x%08"" PRIx64 "" %*s%s"",t   (int64_t)pos,(int64_t)asize,depth,"""",strfcc(a.type));    switch (a.type) {    case a_dinf:    case a_edts:    case a_mdia:    case a_minf:    case a_moov:    case a_stbl:    case a_trak:    case a_udta:twhile (off < asize)t    off += handle_classic_atom(fh,pos+off,asize-off,depth+3);tif (off != asize) {t    fprintf(stderr,""Huh?  atom size mismatch!"");t    exit(1);t}tbreak;    default:tif (169 == ((a.type >> 24) & 0xff)) {t    dump_string(fh,pos+off,asize-off);t} else {t    for (i = 0; alist[i].type != 0; i++)ttif (alist[i].type == a.type)tt    break;t    if (alist[i].type != 0)ttdump_fields(fh,pos+off,alist[i].fields);t}    }    return asize;}",2,"cwe120,cweother"
"is_ephemeral(int port){tif (!ip_local_port_min) {ttFILE *f = ephemeral_ports_open();ttif (f) {tttfscanf(f, ""%d %d"",ttt       &ip_local_port_min, &ip_local_port_max);tttfclose(f);tt} else {tttip_local_port_min = 1024;tttip_local_port_max = 4999;tt}t}treturn (port >= ip_local_port_min && port<= ip_local_port_max);}",2,"cwe119,cwe120"
"print_crldist (gnutls_buffer_st * str, gnutls_x509_crt_t cert){  char *buffer = NULL;  size_t size;  char str_ip[64];  char *p;  int err;  int indx;  for (indx = 0;; indx++)    {      size = 0;      err = gnutls_x509_crt_get_crl_dist_points (cert, indx, buffer, &size,                                                 NULL, NULL);      if (err == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE)        return;      if (err != GNUTLS_E_SHORT_MEMORY_BUFFER)        {          addf (str, ""error: get_crl_dist_points: %s"",                gnutls_strerror (err));          return;        }      buffer = gnutls_malloc (size);      if (!buffer)        {          addf (str, ""error: malloc: %s"",                gnutls_strerror (GNUTLS_E_MEMORY_ERROR));          return;        }      err = gnutls_x509_crt_get_crl_dist_points (cert, indx, buffer, &size,                                                 NULL, NULL);      if (err < 0)        {          gnutls_free (buffer);          addf (str, ""error: get_crl_dist_points2: %s"",                gnutls_strerror (err));          return;        }      if ((err == GNUTLS_SAN_DNSNAME           || err == GNUTLS_SAN_RFC822NAME           || err == GNUTLS_SAN_URI) && strlen (buffer) != size)        {          adds (str, _(""warning: distributionPoint contains an embedded NUL, ""                       ""replacing with '!'""));          while (strlen (buffer) < size)            buffer[strlen (buffer)] = '!';        }      switch (err)        {        case GNUTLS_SAN_DNSNAME:          addf (str, ""tttDNSname: %.*s"", (int) size, buffer);          break;        case GNUTLS_SAN_RFC822NAME:          addf (str, ""tttRFC822name: %.*s"", (int) size, buffer);          break;        case GNUTLS_SAN_URI:          addf (str, ""tttURI: %.*s"", (int) size, buffer);          break;        case GNUTLS_SAN_IPADDRESS:          p = ip_to_string (buffer, size, str_ip, sizeof (str_ip));          if (p == NULL)            p = ERROR_STR;          addf (str, ""tttIPAddress: %s"", p);          break;        case GNUTLS_SAN_DN:          addf (str, ""tttdirectoryName: %.*s"", (int) size, buffer);          break;        default:          addf (str, ""error: unknown SAN"");          break;        }      gnutls_free (buffer);    }}",2,"cwe119,cwe120"
"listBuffers(){tint i;tint j;tfor (i = 0; i < NUM_BUFFERS; i++){ttprintf(""Buffer number %d"", i);ttfor (j = 0; j < BUFFER_SIZE; j++){tttif(buffers[i][j].init == 0){ttttbreak;ttt}tttelse{ttttprintf(""%d:tDevice: %dtAddr: %dtAccess Type: "",j, buffers[i][j].device_num, buffers[i][j].addr);ttttif(buffers[i][j].access_type == READ){tttttprintf(""Read"");tttt}ttttelse{tttttprintf(""Write"");tttt}ttttprintf("""");ttt}tt}ttprintf(""End buffer %d"", i);t}}",2,"cwe120,cweother"
"report_char_chartab_status(int reset, int received, int used,tint rejected, int do_characters){tstatic char const *object_type[] = {tt""character class entries"",tt""character descriptions"",t};tint len;tchar buf[80];tif (reset) {ttpr_info(""%s reset to defaults"", object_type[do_characters]);t} else if (received) {ttlen = snprintf(buf, sizeof(buf),tttt"" updated %d of %d %s"",ttttused, received, object_type[do_characters]);ttif (rejected)tttsnprintf(buf + (len - 1), sizeof(buf) - (len - 1),tttt "" with %d reject%s"",tttt rejected, rejected > 1 ? ""s"" : """");ttprintk(buf);t}}",2,"cwe119,cwe120"
"readsamples(const char **samplenames,const char *basename)r r r{rtint i;rtstruct GameSamples *samples;rtint skipfirst = 0;rrt rtif (!options.use_samples) return 0;rrtif (samplenames == 0 || samplenames[0] == 0) return 0;rrtif (samplenames[0][0] == '*')rttskipfirst = 1;rrti = 0;rtwhile (samplenames[i+skipfirst] != 0) i++;rrtif (!i) return 0;rrtif ((samples = auto_malloc(sizeof(struct GameSamples) + (i-1)*sizeof(struct GameSample))) == 0)rttreturn 0;rrtsamples->total = i;rtfor (i = 0;i < samples->total;i++)rttsamples->sample[i] = 0;rrtfor (i = 0;i < samples->total;i++)rt{rttmame_file *f;rrttif (samplenames[i+skipfirst][0])rtt{rtttif ((f = mame_fopen(basename,samplenames[i+skipfirst],FILETYPE_SAMPLE,0)) == 0)rttttif (skipfirst)rtttttf = mame_fopen(samplenames[0]+1,samplenames[i+skipfirst],FILETYPE_SAMPLE,0);rtttif (f != 0)rttt{rttttsamples->sample[i] = read_wav_sample(f);rttttmame_fclose(f);rttt}rtt}rt}rrtreturn samples;r}",2,"cwe476,cweother"
"minerstats(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group){tstruct cgpu_info *cgpu;tbool io_open = false;tstruct api_data *extra;tchar id[20];tint i, j;tmessage(io_data, MSG_MINESTATS, 0, NULL, isjson);tif (isjson)ttio_open = io_add(io_data, COMSTR JSON_MINESTATS);ti = 0;tfor (j = 0; j < total_devices; j++) {ttcgpu = get_devices(j);ttif (cgpu && cgpu->drv) {tttif (cgpu->drv->get_api_stats)ttttextra = cgpu->drv->get_api_stats(cgpu);tttelsettttextra = NULL;tttsprintf(id, ""%s%d"", cgpu->drv->name, cgpu->device_id);ttti = itemstats(io_data, i, id, &(cgpu->cgminer_stats), NULL, extra, isjson);tt}t}tfor (j = 0; j < total_pools; j++) {ttstruct pool *pool = pools[j];ttsprintf(id, ""POOL%d"", j);tti = itemstats(io_data, i, id, &(pool->cgminer_stats), &(pool->cgminer_pool_stats), NULL, isjson);t}tif (isjson && io_open)ttio_close(io_data);}",2,"cwe119,cwe120"
"punc_store(struct kobject *kobj, struct kobj_attribute *attr,ttt const char *buf, size_t count){tint x;tstruct st_var_header *p_header;tstruct punc_var_t *var;tchar punc_buf[100];tunsigned long flags;tx = strlen(buf);tif (x < 1 || x > 99)ttreturn -EINVAL;tp_header = spk_var_header_by_name(attr->attr.name);tif (!p_header) {ttpr_warn(""p_header is null, attr->attr.name is %s"",tttattr->attr.name);ttreturn -EINVAL;t}tvar = spk_get_punc_var(p_header->var_id);tif (!var) {ttpr_warn(""var is null, p_header->var_id is %i"",ttttp_header->var_id);ttreturn -EINVAL;t}tstrncpy(punc_buf, buf, x);twhile (x && punc_buf[x - 1] == '')ttx--;tpunc_buf[x] = '0';tspin_lock_irqsave(&speakup_info.spinlock, flags);tif (*punc_buf == 'd' || *punc_buf == 'r')ttx = spk_set_mask_bits(NULL, var->value, 3);telsettx = spk_set_mask_bits(punc_buf, var->value, 3);tspin_unlock_irqrestore(&speakup_info.spinlock, flags);treturn count;}",2,"cwe119,cwe120"
"check_random (int nb_tests){  int i;  mpfr_t x;  mpfr_rnd_t rnd;  char flag[] =    {      '-',      '+',      ' ',      '#',      '0',        '''    };  char specifier[] =    {      'a',      'b',      'e',      'f',      'g'    };  mpfr_exp_t old_emin, old_emax;  old_emin = mpfr_get_emin ();  old_emax = mpfr_get_emax ();  mpfr_init (x);  for (i = 0; i < nb_tests; ++i)    {      int ret;      int j, jmax;      int spec, prec;#define FMT_SIZE 13      char fmt[FMT_SIZE];        char *ptr = fmt;      tests_default_random (x, 256, MPFR_EMIN_MIN, MPFR_EMAX_MAX);      rnd = (mpfr_rnd_t) RND_RAND ();      spec = (int) (randlimb () % 5);      jmax = (spec == 3 || spec == 4) ? 6 : 5;               prec = (randlimb () % 2) ? 10 : prec_max_printf;      prec = (int) (randlimb () % prec);      if (spec == 3          && (mpfr_get_exp (x) > prec_max_printf              || mpfr_get_exp (x) < -prec_max_printf))                 --spec;      *ptr++ = '%';      for (j = 0; j < jmax; j++)        {          if (randlimb () % 3 == 0)            *ptr++ = flag[j];        }      *ptr++ = '.';      *ptr++ = '*';      *ptr++ = 'R';      *ptr++ = '*';      *ptr++ = specifier[spec];      *ptr = '0';      MPFR_ASSERTD (ptr - fmt < FMT_SIZE);      mpfr_printf (""mpfr_printf(""%s"", %d, %s, %Re)"", fmt, prec,                   mpfr_print_rnd_mode (rnd), x);      ret = mpfr_printf (fmt, prec, rnd, x);      if (ret == -1)        {          if (spec == 3              && (MPFR_GET_EXP (x) > INT_MAX || MPFR_GET_EXP (x) < -INT_MAX))                         {              mpfr_printf (""too large !"");            }          else            {              printf (""Error in mpfr_printf(""%s"", %d, %s, ...)"",                      fmt, prec, mpfr_print_rnd_mode (rnd));              if (stdout_redirect)                {                  if ((fflush (stdout) == EOF) || (fclose (stdout) == -1))                    {                      perror (""check_random"");                      exit (1);                    }                }              exit (1);            }        }      putchar ('');    }  mpfr_set_emin (old_emin);  mpfr_set_emax (old_emax);  mpfr_clear (x);}",2,"cwe119,cwe120"
"""exit_policy_is_general_exit_helper(smartlist_t *policy, int port){  uint32_t mask, ip, i;  /* Is this /8 rejected (1), or undecided (0)? */  char subnet_status[256];  memset(subnet_status, 0, sizeof(subnet_status));  SMARTLIST_FOREACH(policy, addr_policy_t *, p, {    if (tor_addr_family(&p->addr) != AF_INET)      continue; /* IPv4 only for now */    if (p->prt_min > port || p->prt_max < port)      continue; /* Doesn't cover our port. */    mask = 0;    tor_assert(p->maskbits <= 32);    if (p->maskbits)      mask = UINT32_MAX<<(32-p->maskbits);    ip = tor_addr_to_ipv4h(&p->addr);    /* Calculate the first and last subnet that this exit policy touches     * and set it as loop boundaries. */    for (i = ((mask & ip)>>24); i <= (~((mask & ip) ^ mask)>>24); ++i) {      tor_addr_t addr;      if (subnet_status[i] != 0)        continue; /* We already reject some part of this /8 */      tor_addr_from_ipv4h(&addr, i<<24);      if (tor_addr_is_internal(&addr, 0))        continue; /* Local or non-routable addresses */      if (p->policy_type == ADDR_POLICY_ACCEPT) {        if (p->maskbits > 8)          continue; /* Narrower than a /8. */        /* We found an allowed subnet of at least size /8. Done         * for this port! */        return 1;      } else if (p->policy_type == ADDR_POLICY_REJECT) {        subnet_status[i] = 1;      }    }  });  return 0;}""",2,"cwe119,cwe120"
"gg_image_strip_prepare_from_ascii_grid (FILE * in,tttttgGraphStripImagePtr * image_handle){     gGraphStripImagePtr img = NULL;    struct grid_codec_data *grid_codec = NULL;    int width;    int height;    double ulx;    double uly;    double pixel_x_size;    double pixel_y_size;    double no_data;    long *row_offsets = NULL;    int ret = GGRAPH_ASCII_CODEC_ERROR;    *image_handle = NULL;    if (!parse_asc_hdrt(NULL, in, &width, &height, &ulx, &uly, &pixel_x_size, &pixel_y_size,t &no_data))treturn GGRAPH_ASCII_CODEC_ERROR;     row_offsets = malloc (sizeof (long) * height);    if (!row_offsets)treturn GGRAPH_ASCII_CODEC_ERROR;    if (!parse_asc_offsets (in, height, &row_offsets))      {t  free (row_offsets);t  return GGRAPH_ASCII_CODEC_ERROR;      }    img =tgg_strip_image_create (in, GGRAPH_IMAGE_ASCII_GRID, GG_PIXEL_GRID,ttt       width, height, 32, 1, GGRAPH_SAMPLE_FLOAT, NULL,ttt       NULL);    if (!img)      {t  ret = GGRAPH_INSUFFICIENT_MEMORY;t  goto error;      }     img->is_georeferenced = 1;    img->upper_left_x = ulx;    img->upper_left_y = uly;    img->pixel_x_size = pixel_x_size;    img->pixel_y_size = pixel_y_size;    img->no_data_value = no_data;     grid_codec = malloc (sizeof (struct grid_codec_data));    if (!grid_codec)tgoto error;    grid_codec->grid_type = GRID_ASCII;    grid_codec->is_writer = 0;    grid_codec->grid_buffer = NULL;    grid_codec->row_offsets = row_offsets;    img->codec_data = grid_codec;    *image_handle = img;    return GGRAPH_OK;  error:    if (img)tgGraphDestroyImage (img);    return ret;}",2,"cwe120,cweother"
"xbsd_new_part (void){  unsigned int begin, end;  char mesg[256];  int i;  if (!xbsd_check_new_partition (&i))    return;#if !defined (__alpha__) && !defined (__powerpc__) && !defined (__hppa__)  begin = get_start_sect(xbsd_part);  end = begin + get_nr_sects(xbsd_part) - 1;#else  begin = 0;  end = xbsd_dlabel.d_secperunit - 1;#endif  snprintf (mesg, sizeof(mesg), _(""First %s""), str_units(SINGULAR));  begin = read_int (bsd_cround (begin), bsd_cround (begin), bsd_cround (end),tt    0, mesg);  if (display_in_cyl_units)    begin = (begin - 1) * xbsd_dlabel.d_secpercyl;  snprintf (mesg, sizeof(mesg), _(""Last %s or +size or +sizeM or +sizeK""),t   str_units(SINGULAR));  end = read_int (bsd_cround (begin), bsd_cround (end), bsd_cround (end),tt  bsd_cround (begin), mesg);  if (display_in_cyl_units)    end = end * xbsd_dlabel.d_secpercyl - 1;  xbsd_dlabel.d_partitions[i].p_size   = end - begin + 1;  xbsd_dlabel.d_partitions[i].p_offset = begin;  xbsd_dlabel.d_partitions[i].p_fstype = BSD_FS_UNUSED;}",2,"cwe119,cwe120"
"readps2(int fd){tchar ch;twhile(read(fd,&ch,1) && (ch==(char)0xfa || ch==(char)0xaa))t{ttfprintf(stderr,""<%02X>"",ch&0xff);t}tfprintf(stderr,""[%02X]"",ch&0xff);treturn(ch);}",2,"cwe120,cweother"
"TexinfoPromiseTypesFor(FILE *fout,struct SubTypeSyntax *st){ int j;  char filename[CF_BUFSIZE]; for (j = 0; st[j].btype != NULL; j++)   {   CfOut(cf_verbose,"""","" - Dealing with promise type %s"",st[j].subtype);   if (strcmp(""*"",st[j].btype) == 0)      {      fprintf(fout,""@node %s in common promises@section @code{%s} promises"",st[j].subtype,st[j].subtype);      snprintf(filename,CF_BUFSIZE-1,""promise_common_intro.texinfo"");      IncludeManualFile(fout,filename);      TexinfoBodyParts(fout,st[j].bs,st[j].subtype);      }   else      {      fprintf(fout,""@node %s in %s promises@section @code{%s} promises in @samp{%s}"",st[j].subtype,st[j].btype,st[j].subtype,st[j].btype);      snprintf(filename,CF_BUFSIZE-1,""promise_%s_intro.texinfo"",st[j].subtype);      IncludeManualFile(fout,filename);      snprintf(filename,CF_BUFSIZE-1,""promise_%s_example.texinfo"",st[j].subtype);      IncludeManualFile(fout,filename);      snprintf(filename,CF_BUFSIZE-1,""promise_%s_notes.texinfo"",st[j].subtype);      IncludeManualFile(fout,filename);      TexinfoBodyParts(fout,st[j].bs,st[j].subtype);      }   }}",2,"cwe119,cwe120"
"prn_header(void){    int i, len;    char buf[1024], *titles, *label;    char *mask;    FILE *fd;    if (output == NULL)tfd = stdout;    else if ((fd = fopen(output, ""w"")) == NULL) {tG_fatal_error(_(""Cannot open file <%s> to write header""), output);treturn;    }         fprintf(fd, ""ttt%s"", title);    sprintf(buf, ""LOCATION: %stttt%s"", G_location(), G_date());    fprintf(fd, ""%s"", buf);    if ((mask = maskinfo()))tsprintf(buf, ""MASK: %s"", mask);    fprintf(fd, ""%s"", buf);    fprintf(fd, ""MAPS: "");    label = ""MAP"";    len = strlen(label);    for (i = 0; i < nlayers; i++) {ttitles = G_get_cats_title(&(layers[i].labels));tif (titles)t    G_strip(titles);tif (titles == NULL || *titles == 0)t    titles = ""(untitled)"";tsprintf(buf, ""%*s%-*s%d = %s (%s in %s)"", i * 6, """", len, label,tti + 1, titles, layers[i].name, layers[i].mapset);tfprintf(fd, ""%s"", buf);    }    if (output != NULL)tfclose(fd);}",3,"cwe119,cwe120,cweother"
"do_host(const char *arg){tinttret;tcharthn[LARGEBUF];tret = gethostname(hn, sizeof(hn));tif (ret != 0) {ttupslog_with_errno(LOG_ERR, ""gethostname failed"");ttreturn;t}tsnprintfcat(logbuffer, sizeof(logbuffer), ""%s"", hn);}",2,"cwe119,cwe120"
"rebuild_citydlg_title_str(struct widget *pWindow,tttt      struct city *pCity){  char cBuf[512];  fc_snprintf(cBuf, sizeof(cBuf),t      _(""City of %s (Population %s citizens)""),t      city_name(pCity),t      population_to_text(city_population(pCity)));  if (city_unhappy(pCity)) {    fc_strlcat(cBuf, _("" - DISORDER""), sizeof(cBuf));  } else {    if (city_celebrating(pCity)) {      fc_strlcat(cBuf, _("" - celebrating""), sizeof(cBuf));    } else {      if (city_happy(pCity)) {tfc_strlcat(cBuf, _("" - happy""), sizeof(cBuf));      }    }  }  if (cma_is_city_under_agent(pCity, NULL)) {    fc_strlcat(cBuf, _("" - under Citizen Governor control.""), sizeof(cBuf));  }    copy_chars_to_string16(pWindow->string16, cBuf);}",2,"cwe119,cwe120"
"RTSP_ParseResponseHeader(GF_RTSPSession *sess, GF_RTSPResponse *rsp, u32 BodyStart){tchar LineBuffer[1024];tchar ValBuf[400];tchar *buffer;ts32 Pos, ret;tu32 Size;tSize = sess->CurrentSize - sess->CurrentPos;tbuffer = sess->TCPBuffer + sess->CurrentPos;t tret = gf_token_get_line(buffer, 0, Size, LineBuffer, 1024);tif (ret < 0) return GF_REMOTE_SERVICE_ERROR;t tPos = gf_token_get(LineBuffer, 0, "" tr"", ValBuf, 400);tif (Pos <= 0) return GF_REMOTE_SERVICE_ERROR;tif (strcmp(ValBuf, GF_RTSP_VERSION)) return GF_SERVICE_ERROR;t tPos = gf_token_get(LineBuffer, Pos, "" tr"", ValBuf, 400);tif (Pos <= 0) return GF_REMOTE_SERVICE_ERROR;trsp->ResponseCode = atoi(ValBuf);t tPos = gf_token_get(LineBuffer, Pos, ""tr"", ValBuf, 400);tif (Pos > 0) rsp->ResponseInfo = gf_strdup(ValBuf);treturn gf_rtsp_parse_header(buffer + ret, Size - ret, BodyStart, NULL, rsp);}",4,"cwe119,cwe120,cwe476,cweother"
"program_name_from_file_name (char *file_name){  int i;  char *program_name = xstrdup (filename_non_directory (file_name));  for (i = strlen (program_name) - 1; i > 0; i--)    if (program_name[i] == '.'        && (FILENAME_CMPN (program_name + i, "".info"", 5) == 0            || FILENAME_CMPN (program_name + i, "".inf"", 4) == 0#ifdef __MSDOS__            || FILENAME_CMPN (program_name + i, "".i"", 2) == 0#endif            || isdigit (program_name[i + 1])))        {        program_name[i] = 0;        break;      }  return program_name;}",2,"cwe120,cweother"
"afm_create (const char *path, unsigned int verbose_level,t    AFMHandle *handle_return){  AFMHandle handle;  AFMError error = AFM_SUCCESS;  const char *cp, *cp2;  int len;  char buf[512];  struct stat stat_st;     handle = (AFMHandle) calloc (1, sizeof (*handle));  if (handle == NULL)    {      error = AFM_ERROR_MEMORY;      goto error_out;    }  handle->font_map = strhash_init ();  if (handle->font_map == NULL)    {      error = AFM_ERROR_MEMORY;      goto error_out;    }  handle->verbose = verbose_level;     if (path == NULL)    path = default_path;  afm_message (handle, 1, ""AFM: scanning path..."");  for (cp = path; cp; cp = strchr (cp, PATH_SEPARATOR))    {      if (cp != path)tcp++;      cp2 = strchr (cp, PATH_SEPARATOR);      if (cp2)tlen = cp2 - cp;      elsetlen = strlen (cp);      memcpy (buf, cp, len);      buf[len] = '0';      if (len > 0 && buf[len - 1] == '/')tbuf[len - 1] = '0';      strcat (buf, ""/font.map"");      if (stat (buf, &stat_st) == 0)tread_font_map (handle, buf);    }  *handle_return = handle;  return AFM_SUCCESS;    error_out:  (void) afm_destroy (handle);  return error;}",2,"cwe119,cwe120"
"ADIOI_Shfp_fname(ADIO_File fd, int rank){    double tm;    int i, len;    char *slash, *ptr, tmp[128];    fd->shared_fp_fname = (char *) ADIOI_Malloc(256);    if (!rank) {ttm = MPI_Wtime();twhile (tm > 1000000000.0) tm -= 1000000000.0;ti = (int) tm;ttm = tm - (double) i;ttm *= 1000000.0;ti = (int) tm;ttADIOI_Strncpy(fd->shared_fp_fname, fd->filename, 256);t#ifdef ROMIO_NTFStslash = strrchr(fd->filename, '');#elsetslash = strrchr(fd->filename, '/');#endiftif (!slash) {t    ADIOI_Strncpy(fd->shared_fp_fname, ""."", 2);t    ADIOI_Strncpy(fd->shared_fp_fname + 1, fd->filename, 255);t}telse {t    ptr = slash;#ifdef ROMIO_NTFSttslash = strrchr(fd->shared_fp_fname, '');#elset    slash = strrchr(fd->shared_fp_fname, '/');#endift    ADIOI_Strncpy(slash + 1, ""."", 2);t    len = 256 - (slash+2 - fd->shared_fp_fname);t    ADIOI_Strncpy(slash + 2, ptr + 1, len);t}t    tADIOI_Snprintf(tmp, 128, "".shfp.%d"", i);tADIOI_Strnapp(fd->shared_fp_fname, tmp, 256);ttlen = (int)strlen(fd->shared_fp_fname);tMPI_Bcast(&len, 1, MPI_INT, 0, fd->comm);tMPI_Bcast(fd->shared_fp_fname, len+1, MPI_CHAR, 0, fd->comm);    }    else {tMPI_Bcast(&len, 1, MPI_INT, 0, fd->comm);tMPI_Bcast(fd->shared_fp_fname, len+1, MPI_CHAR, 0, fd->comm);    }}",2,"cwe119,cwe120"
"load_all_modules(int warn){  DIR *system_module_dir = NULL;  struct dirent *ldirent = NULL;  char module_fq_name[PATH_MAX + 1];  modules_init();  if ((system_module_dir = opendir(AUTOMODPATH)) == NULL)  {    ilog(L_WARN, ""Could not load modules from %s: %s"",         AUTOMODPATH, strerror(errno));    return;  }  while ((ldirent = readdir(system_module_dir)) != NULL)  {    if (modules_valid_suffix(ldirent->d_name))    {       snprintf(module_fq_name, sizeof(module_fq_name), ""%s/%s"",                AUTOMODPATH, ldirent->d_name);       load_a_module(module_fq_name, warn, 0);    }  }  closedir(system_module_dir);}",2,"cwe119,cwe120"
"test_qof_backend_get_access_method_list (Fixture *fixture, gconstpointer pData){    GList *list = NULL;    const char *access_methods[4] = { ""file"", ""http"", ""postgres"", ""sqlite"" };    int i;    for (i = 0; i < 4; i++)    {        QofBackendProvider *prov = g_new0 (QofBackendProvider, 1);        g_assert (prov);        prov->access_method = access_methods[ i ];        qof_backend_register_provider (prov);        g_assert_cmpint (g_slist_length (get_provider_list ()), == , (i + 1));    }    g_assert_cmpint (g_slist_length (get_provider_list ()), == , 4);    g_test_message (""Test list of access methods is returned"");    list = qof_backend_get_registered_access_method_list ();    g_assert (list);    g_assert_cmpint (g_list_length (list), == , 4);    g_assert_cmpstr (g_list_nth_data (list, 0), == , ""file"");    g_assert_cmpstr (g_list_nth_data (list, 1), == , ""http"");    g_assert_cmpstr (g_list_nth_data (list, 2), == , ""postgres"");    g_assert_cmpstr (g_list_nth_data (list, 3), == , ""sqlite"");    g_list_free (list);    unregister_all_providers ();}",2,"cwe119,cwe120"
"cli_vm_execute_jit(const struct cli_all_bc *bcs, struct cli_bc_ctx *ctx,tt       const struct cli_bc_func *func){    int ret;    struct timeval tv0, tv1;    struct watchdog_item witem;              void *code = bcs->engine->compiledFunctions[func];    if (!code) {tcli_warnmsg(""[Bytecode JIT]: Unable to find compiled function"");tif (func->numArgs)t    cli_warnmsg(""[Bytecode JIT] Function has %d arguments, it must have 0 to be called as entrypoint"",tttfunc->numArgs);treturn CL_EBYTECODE;    }    if (cli_debug_flag)tgettimeofday(&tv0, NULL);    if (ctx->bytecode_timeout) {t tif (watchdog_arm(&witem, ctx->bytecode_timeout, &ctx->timeout))t    return CL_EBYTECODE;    }    ret = bytecode_execute((intptr_t)code, ctx);    if (ctx->bytecode_timeout)twatchdog_disarm(&witem);    if (cli_debug_flag) {tlong diff;tgettimeofday(&tv1, NULL);ttv1.tv_sec -= tv0.tv_sec;ttv1.tv_usec -= tv0.tv_usec;tdiff = tv1.tv_sec*1000000 + tv1.tv_usec;tcli_dbgmsg_internal(""bytecode finished in %ld us"", diff);    }    return ctx->timeout ? CL_ETIMEOUT : ret;}",3,"cwe119,cwe120,cweother"
"log_apr_error(MWK_REQ_CTXT *rc,             apr_status_t astatus,             const char *mwk_func,             const char *ap_func,             const char *path){    char errbuff[512];    ap_log_error(APLOG_MARK, APLOG_ERR, 0, rc->r->server,                 ""mod_webkdc: %s: %s (%s): %s (%d)"",                 mwk_func,                 ap_func,                 path,                 apr_strerror(astatus, errbuff, sizeof(errbuff)-1),                 astatus);}",2,"cwe119,cwe120"
"put_addr(unsigned char **here,struct sockaddr_atmsvc *addr,  unsigned char *num_tl,unsigned char *sub_tl){    if (!addr) return;    if (addr->sas_family != AF_ATMSVC) return;    if (!*addr->sas_addr.pub) *sub_tl = 0;    else {t*num_tl = strlen(addr->sas_addr.pub) | TL_E164;tmemcpy(*here,addr->sas_addr.pub,*num_tl & TL_LEN);t(*here) += *num_tl & TL_LEN;tnum_tl = sub_tl;    }    if (!*addr->sas_addr.prv) *num_tl = 0;    else {t*num_tl = ATM_ESA_LEN;tmemcpy(*here,addr->sas_addr.prv,ATM_ESA_LEN);t(*here) += ATM_ESA_LEN;    }}",2,"cwe120,cweother"
"rc_config_init(rc_handle *rh){tint i;tSERVER *authservers;tSERVER *acctservers;        rh->config_options = malloc(sizeof(config_options_default));        if (rh->config_options == NULL) t{                rc_log(LOG_CRIT, ""rc_config_init: out of memory"");ttrc_destroy(rh);                return NULL;        }        memcpy(rh->config_options, &config_options_default, sizeof(config_options_default));        authservers = rc_conf_srv(rh, ""authserver""); tacctservers = rc_conf_srv(rh, ""acctserver"");tauthservers = malloc(sizeof(SERVER));tacctservers = malloc(sizeof(SERVER));tif(authservers == NULL || acctservers == NULL)t{                rc_log(LOG_CRIT, ""rc_config_init: error initializing server structs"");ttrc_destroy(rh);                return NULL;t}tauthservers->max = 0;tacctservers->max = 0;tfor(i=0; i < SERVER_MAX; i++) t{tttauthservers->name[i] = NULL;ttauthservers->secret[i] = NULL;ttacctservers->name[i] = NULL;ttacctservers->secret[i] = NULL;t} treturn rh;}",2,"cwe120,cweother"
"""accsegmentpos_table_gc (Table_T *accsegmentpos_table) {  int n, i = 0;  char *accession;  Segmentpos_T segmentpos;  void **keys, **values;  /* For some reason, this was failing on some computers, perhaps     because we weren't checking for n > 0 */  if ((n = Table_length(*accsegmentpos_table)) > 0) {    keys = Table_keys(*accsegmentpos_table,NULL);    values = Table_values(*accsegmentpos_table,NULL);    for (i = 0; i < n; i++) {      accession = (char *) keys[i];      FREE(accession);    }    for (i = 0; i < n; i++) {      segmentpos = (Segmentpos_T) values[i];      Segmentpos_free(&segmentpos);    }    FREE(values);    FREE(keys);  }  Table_free(&(*accsegmentpos_table));  return;}""",3,"cwe119,cwe120,cweother"
"us_getopt_dump( us_getopt_t *self, us_print_t *printer, const char *ignore_key ){    bool r = true;    us_getopt_option_list_t *list = self->m_option_lists;    while ( list && r )    {        const us_getopt_option_t *opt = list->m_options;        if ( list->m_prefix )        {            r &= printer->printf( printer, ""## Option group '%s': %s#"", list->m_prefix, list->m_description );        }        while ( opt && r && opt->m_name != 0 )        {            char key_name[1024] = """";            char value_string[1024] = """";            us_getopt_string_for_value( value_string, sizeof( value_string ) - 1, opt->m_value_type, opt->m_current_value );            if ( list->m_prefix )            {                sprintf( key_name, ""%s.%s"", list->m_prefix, opt->m_name );            }            else            {                strcpy( key_name, opt->m_name );            }            if ( !( ignore_key && strcmp( key_name, ignore_key ) == 0 ) )            {                if ( opt->m_value_type == US_GETOPT_FLAG )                {                    if ( *(bool *)opt->m_current_value == true )                    {                        r &= printer->printf( printer,                                              ""# %s (%s) : %s"",                                              key_name,                                              us_getopt_value_types[opt->m_value_type],                                              opt->m_description );                        r &= printer->printf( printer, ""%s = "", key_name );                    }                    else                    {                        r &= printer->printf( printer, """" );                    }                }                else                {                    r &= printer->printf(                        printer, ""# %s (%s) : %s"", key_name, us_getopt_value_types[opt->m_value_type], opt->m_description );                    r &= printer->printf( printer, ""%s = ""%s"""", key_name, value_string );                }            }            opt++;        }        list = list->m_next;    }    return r;}",3,"cwe119,cwe120,cweother"
"StartChildProcess(AuxProcType type){tpid_tttpid;tchart   *av[10];tinttttac = 0;tchartttypebuf[32];t tav[ac++] = ""postgres"";#ifdef EXEC_BACKENDtav[ac++] = ""--forkboot"";tav[ac++] = NULL;ttt #endiftsnprintf(typebuf, sizeof(typebuf), ""-x%d"", type);tav[ac++] = typebuf;tav[ac] = NULL;tAssert(ac < lengthof(av));#ifdef EXEC_BACKENDtpid = postmaster_forkexec(ac, av);#elsettttttt tpid = fork_process();tif (pid == 0)tttt t{ttInitPostmasterChild();tt ttClosePostmasterPorts(false);tt ttMemoryContextSwitchTo(TopMemoryContext);ttMemoryContextDelete(PostmasterContext);ttPostmasterContext = NULL;ttAuxiliaryProcessMain(ac, av);ttExitPostmaster(0);t}#endif    tif (pid < 0)t{tt ttinttttsave_errno = errno;tterrno = save_errno;ttswitch (type)tt{tttcase StartupProcess:ttttereport(LOG,tttttt(errmsg(""could not fork startup process: %m"")));ttttbreak;tttcase BgWriterProcess:ttttereport(LOG,tttt   (errmsg(""could not fork background writer process: %m"")));ttttbreak;tttcase CheckpointerProcess:ttttereport(LOG,tttttt(errmsg(""could not fork checkpointer process: %m"")));ttttbreak;tttcase WalWriterProcess:ttttereport(LOG,tttttt(errmsg(""could not fork WAL writer process: %m"")));ttttbreak;tttcase WalReceiverProcess:ttttereport(LOG,tttttt(errmsg(""could not fork WAL receiver process: %m"")));ttttbreak;tttdefault:ttttereport(LOG,tttttt(errmsg(""could not fork process: %m"")));ttttbreak;tt}tt ttif (type == StartupProcess)tttExitPostmaster(1);ttreturn 0;t}t treturn pid;}",2,"cwe119,cwe120"
"hnmatch(const char *hn, const char *pat){tif ((hn == NULL) && (strcmp(pat, ""localhost"") == 0))ttreturn 1;tif ((hn == NULL) || *hn == '0')ttreturn 0;tif (*pat >= '0' && *pat <= '9')ttreturn hostfamily == AF_INET ? hnmatch_ip4(pat) : 0;telse if (*pat == '[')ttreturn hostfamily == AF_INET6 ? hnmatch_ip6(pat) : 0;telse {tt ttint tn = strlen(pat),tttm = strlen(hn);ttif (n > m)tttreturn 0;ttreturn (strcasecmp(pat, hn + m - n) == 0);t}}",2,"cwe119,cwe120"
"mapif_send_mailbox(int fd,const char *char_name,int store,struct mail_data md[MAIL_STORE_MAX]){tint i,size = sizeof(struct mail_data);tif(md == NULL)ttreturn 0;tWFIFOW(fd,0)=0x3849;tWFIFOL(fd,4)=store;tmemcpy(WFIFOP(fd,8),char_name,24);tfor(i=0;i<store;i++)ttmemcpy(WFIFOP(fd,32+i*size),&md[i],size);tWFIFOW(fd,2)=32+i*size;tWFIFOSET(fd,WFIFOW(fd,2));treturn 0;}",2,"cwe119,cwe120"
"ap_setup_listeners(server_rec *s){    server_rec *ls;    server_addr_rec *addr;    ap_listen_rec *lr;    int num_listeners = 0;    const char* proto;    int found;    for (ls = s; ls; ls = ls->next) {        proto = ap_get_server_protocol(ls);        if (!proto) {            found = 0;                         for (addr = ls->addrs; addr && !found; addr = addr->next) {                for (lr = ap_listeners; lr; lr = lr->next) {                    if (apr_sockaddr_equal(lr->bind_addr, addr->host_addr) &&                        lr->bind_addr->port == addr->host_port) {                        ap_set_server_protocol(ls, lr->protocol);                        found = 1;                        break;                    }                }            }            if (!found) {                                 ap_set_server_protocol(ls, ""http"");            }        }    }    if (open_listeners(s->process->pool)) {       return 0;    }    for (lr = ap_listeners; lr; lr = lr->next) {        num_listeners++;        found = 0;        for (ls = s; ls && !found; ls = ls->next) {            for (addr = ls->addrs; addr && !found; addr = addr->next) {                if (apr_sockaddr_equal(lr->bind_addr, addr->host_addr) &&                    lr->bind_addr->port == addr->host_port) {                    found = 1;                    ap_apply_accept_filter(s->process->pool, lr, ls);                }            }        }        if (!found) {            ap_apply_accept_filter(s->process->pool, lr, s);        }    }    return num_listeners;}",2,"cwe469,cwe476"
"iso9660_pathtable_l_add_entry (void *pt,                                const char name[],                                uint32_t extent,                                uint16_t parent){  iso_path_table_t *ipt =     (iso_path_table_t *)((char *)pt + iso9660_pathtable_get_size (pt));  size_t name_len = strlen (name) ? strlen (name) : 1;  unsigned int entrynum = 0;  cdio_assert (iso9660_pathtable_get_size (pt) < ISO_BLOCKSIZE);    memset (ipt, 0, sizeof (iso_path_table_t) + name_len);    ipt->name_len = to_711 (name_len);  ipt->extent = to_731 (extent);  ipt->parent = to_721 (parent);  memcpy (ipt->name, name, name_len);  pathtable_get_size_and_entries (pt, NULL, &entrynum);  if (entrynum > 1)    {      const iso_path_table_t *ipt2         = pathtable_get_entry (pt, entrynum - 2);      cdio_assert (ipt2 != NULL);      cdio_assert (from_721 (ipt2->parent) <= parent);    }    return entrynum;}",2,"cwe120,cwe476"
"nouveau_drm_open(struct drm_device *dev, struct drm_file *fpriv){tstruct nouveau_drm *drm = nouveau_drm(dev);tstruct nouveau_cli *cli;tchar name[32], tmpname[TASK_COMM_LEN];tint ret;t tret = pm_runtime_get_sync(dev->dev);tif (ret < 0 && ret != -EACCES)ttreturn ret;tget_task_comm(tmpname, current);tsnprintf(name, sizeof(name), ""%s[%d]"", tmpname, pid_nr(fpriv->pid));tret = nouveau_cli_create(dev, name, sizeof(*cli), (void **)&cli);tif (ret)ttgoto out_suspend;tcli->base.super = false;tif (drm->device.info.family >= NV_DEVICE_INFO_V0_TESLA) {ttret = nvkm_vm_new(nvxx_device(&drm->device), 0, (1ULL << 40),tttt  0x1000, NULL, &cli->vm);ttif (ret) {tttnouveau_cli_destroy(cli);tttgoto out_suspend;tt}ttnvxx_client(&cli->base)->vm = cli->vm;t}tfpriv->driver_priv = cli;tmutex_lock(&drm->client.mutex);tlist_add(&cli->head, &drm->clients);tmutex_unlock(&drm->client.mutex);out_suspend:tpm_runtime_mark_last_busy(dev->dev);tpm_runtime_put_autosuspend(dev->dev);treturn ret;}",2,"cwe119,cwe120"
"VSref_index(int32 file_id,             int32 vd_ref){   int32  find_ref = -1;   int    index    = 0;     int32  ret_value = FAIL;      while ((find_ref = VSgetid(file_id, find_ref)) != FAIL)   {      if (find_ref == vd_ref)      {         ret_value = index;         goto done;        }      index++;   }done:    if (ret_value == FAIL)      {        }             return ret_value;}",2,"cwe119,cwe120"
"as_escaped(char *arg){      unsigned idx, cur, cnt, len = strlen(arg);      char *res = (char *) malloc(sizeof(char *) * len);      cur = 0;      cnt = len;      for (idx = 0; idx < cnt; idx++) {t    if (isprint((int)arg[idx])) {tt  res[cur] = arg[idx];tt  cur += 1;t    } else {tt  len += 3;tt  res = (char *) realloc(res, sizeof(char *) * len);tt  sprintf(&(res[cur]), ""%03o"", arg[idx]);tt  cur += 4;t    }      }      res[cur] = 0;      return res;}",2,"cwe120,cweother"
"_ldapfull_get_password(authreg_t ar, char *username, char *realm, char password[LDAPFULL_PASSBUF_MAX]) {    moddata_t data = (moddata_t) ar->private;    LDAPMessage *result, *entry;    char *dn, *no_attrs[] = { data->pwattr, NULL }, **vals;    log_debug(ZONE, ""getting password for %s"", username);    if( _ldapfull_connect_bind(data) ) {        return 1;    }    dn = _ldapfull_search(data, realm, username);    if(dn == NULL)        return 1;    if(ldap_search_s(data->ld, dn, LDAP_SCOPE_BASE, ""(objectClass=*)"", no_attrs, 0, &result))    {        log_write(data->ar->c2s->log, LOG_ERR, ""ldap: search %s failed: %s"", dn, ldap_err2string(_ldapfull_get_lderrno(data->ld)));        ldap_memfree(dn);        _ldapfull_unbind(data);        return 1;    }    ldap_memfree(dn);    entry = ldap_first_entry(data->ld, result);    if(entry == NULL)    {        ldap_msgfree(result);        return 1;    }        vals=(char **)ldap_get_values(data->ld,entry,data->pwattr);    if( ldap_count_values(vals) <= 0 ) {        ldap_value_free(vals);        ldap_msgfree(result);        return 1;    }    strncpy(password,vals[0],LDAPFULL_PASSBUF_MAX-1);    password[LDAPFULL_PASSBUF_MAX-1] = '0';    ldap_value_free(vals);    ldap_msgfree(result);    log_debug(ZONE, ""found password for %s"", username);    return 0;}",2,"cwe119,cwe120"
"uffer_OpenFileAs(const char *filename, enum esl_buffer_mode_e mode_is, ESL_BUFFER **ret_bf){  char        msg[] = ""buffer_OpenFileAs() failed"";  ESL_BUFFER *bf    = NULL;#ifdef _POSIX_VERSION  struct stat fileinfo;#endif  esl_pos_t   filesize = -1;  if (buffer_create(&bf)                         != eslOK) esl_fatal(msg);  if ((bf->fp = fopen(filename, ""rb""))           == NULL)  esl_fatal(msg);  if (esl_strdup(filename, -1, &(bf->filename))  != eslOK) esl_fatal(msg);#ifdef _POSIX_VERSION  if (fstat(fileno(bf->fp), &fileinfo)           == -1)    esl_fatal(msg);  filesize     = fileinfo.st_size;  bf->pagesize = fileinfo.st_blksize;  if (bf->pagesize < 512)     bf->pagesize = 512;       if (bf->pagesize > 4194304) bf->pagesize = 4194304;#endif    switch (mode_is) {  case eslBUFFER_ALLFILE: if (buffer_init_file_slurped(bf, filesize) != eslOK) esl_fatal(msg); break;  case eslBUFFER_MMAP:    if (buffer_init_file_mmap   (bf, filesize) != eslOK) esl_fatal(msg); break;  case eslBUFFER_FILE:    if (buffer_init_file_basic  (bf)           != eslOK) esl_fatal(msg); break;  default:                                                                     esl_fatal(msg);                  }  *ret_bf = bf;  return eslOK;}",2,"cwe476,cweother"
"get_token(tic_hdr_t **tok_entry){    bool retval = FALSE;    tic_hdr_t *found;    u8 *save_pc;         char cmnd_cpy[FUNC_CPY_BUF_SIZE+1];    strncpy( cmnd_cpy, statbuf, FUNC_CPY_BUF_SIZE);    cmnd_cpy[FUNC_CPY_BUF_SIZE] = 0;        save_pc = pc;    if ( get_word_in_line( statbuf) )    {tfwtoken defr = UNSPECIFIED;t tfound = lookup_with_definer( statbuf, &defr);tif ( found != NULL )t{t     t    if ( defr == BI_FWRD_DEFN )t    {t        found = lookup_token( statbuf);ttretval = BOOLVAL( found != NULL );t    }else{ttretval = entry_is_token( found);t    }t}thandle_invocation( found);tif ( retval)t{t    *tok_entry = found;t}else{t    cannot_apply( cmnd_cpy, strupr(statbuf), defr );t    pc = save_pc;t}    }    return ( retval );}",2,"cwe119,cwe120"
"Printf (Object port, const char *fmt, ...) {    va_list args;    char buf[1024];    va_start (args, fmt);    if (PORT(port)->flags & P_STRING) {        vsprintf (buf, fmt, args);        Print_String (port, buf, strlen (buf));    } else {        vfprintf (PORT(port)->file, fmt, args);        if (ferror (PORT(port)->file)) {            Saved_Errno = errno;                Primitive_Error (""write error on ~s: ~E"", port);        }    }    va_end (args);}",3,"cwe119,cwe120,cweother"
"crunch_list (char **oldlist, char *list){  int count, i;  char *p, *q;  p = list;     while (p[strlen (p) - 1] == LIST_DELIMITER)    {      p[strlen (p) - 1] = '0';    }     while (p[0] == LIST_DELIMITER)    {      p++;    }     if (*p == '0')    return oldlist;     for (count = 1, i = 0; p[i]; i++)    if (p[i] == LIST_DELIMITER)      count++;     for (i = 0; oldlist && oldlist[i]; i++)    ;     oldlist = (char **) realloc (oldlist, (i + count + 1) * sizeof (*oldlist));  if (oldlist == NULL)    error (EXIT_FAILURE, errno, ""can't allocate memory"");        for (count = i; (q = strchr (p, LIST_DELIMITER)) != NULL;       count++, p = q, p++)    {      oldlist[count] = (char *) malloc ((q - p + 1) * sizeof (char));      if (oldlist[count] == NULL)        error (EXIT_FAILURE, errno, ""can't allocate memory"");      strncpy (oldlist[count], p, q - p);      oldlist[count][q - p] = '0';    }     oldlist[count] = (char *) xmalloc ((strlen (p) + 1) * sizeof (char));  if (oldlist[count] == NULL)    error (EXIT_FAILURE, errno, ""can't allocate memory"");  strcpy (oldlist[count], p);  oldlist[++count] = NULL;t   if (Debug)    {      for (count = 0; oldlist[count]; count++)tprintf (""#%d: %s"", count, oldlist[count]);    }  return oldlist;}",2,"cwe120,cweother"
"GC_printf(const char *format, ...){    va_list args;    char buf[BUFSZ+1];    va_start(args, format);    if (GC_quiet) return;    buf[BUFSZ] = 0x15;    (void) vsnprintf(buf, BUFSZ, format, args);    va_end(args);    if (buf[BUFSZ] != 0x15) ABORT(""GC_printf clobbered stack"");    if (WRITE(GC_stdout, buf, strlen(buf)) < 0)      ABORT(""write to stdout failed"");}",3,"cwe119,cwe120,cweother"
"jk_is_input_event(jk_sock_t sd, int timeout, jk_logger_t *l){    struct pollfd fds;    int rc;    int save_errno;    char buf[64];    JK_TRACE_ENTER(l);    errno = 0;    fds.fd = sd;    fds.events = POLLIN;    fds.revents = 0;    do {        rc = poll(&fds, 1, timeout);    } while (rc < 0 && errno == EINTR);    if (rc == 0) {        if (JK_IS_DEBUG_LEVEL(l)) {            jk_log(l, JK_LOG_DEBUG,                   ""timeout during poll on socket %d [%s] (timeout=%d)"",                   sd, jk_dump_sinfo(sd, buf), timeout);        }                 errno = ETIMEDOUT;        JK_TRACE_EXIT(l);        return JK_FALSE;    }    else if (rc < 0) {        save_errno = errno;        if (JK_IS_DEBUG_LEVEL(l)) {            jk_log(l, JK_LOG_DEBUG,                   ""error during poll on socket %d [%s] (errno=%d)"",                   sd, jk_dump_sinfo(sd, buf), errno);        }        errno = save_errno;        JK_TRACE_EXIT(l);        return JK_FALSE;    }    if ((fds.revents & (POLLERR | POLLHUP))) {        save_errno = fds.revents & (POLLERR | POLLHUP);        if (JK_IS_DEBUG_LEVEL(l)) {            jk_log(l, JK_LOG_DEBUG,                   ""error event during poll on socket %d [%s] (event=%d)"",                   sd, jk_dump_sinfo(sd, buf), save_errno);        }        errno = save_errno;        JK_TRACE_EXIT(l);        return JK_FALSE;    }    errno = 0;    JK_TRACE_EXIT(l);    return JK_TRUE;}",2,"cwe119,cwe120"
"CreateFileListInfo(FileListInfoPtr pFileListInfo, char* path, int flag){tDIR* pDir = NULL;tstruct dirent* pDirent = NULL;ttif((path == NULL) || (strlen(path) == 0)) {tt ttsprintf(path, ""%s%s"", GetFtpRoot(), ""/"");t}tif((pDir = opendir(path)) == NULL) {ttrfbLog(""File [%s]: Method [%s]: not able to open the dir"",tttt__FILE__, __FUNCTION__);ttreturn FAILURE; ttt}twhile((pDirent = readdir(pDir))) {ttif(strcmp(pDirent->d_name, ""."") && strcmp(pDirent->d_name, "".."")) {tttstruct stat stat_buf;ttt tttchar fullpath[PATH_MAX];tttmemset(fullpath, 0, PATH_MAX);tttstrcpy(fullpath, path);tttif(path[strlen(path)-1] != '/')ttttstrcat(fullpath, ""/"");tttstrcat(fullpath, pDirent->d_name);tttif(stat(fullpath, &stat_buf) < 0) {ttttrfbLog(""File [%s]: Method [%s]: Reading stat for file %s failed"", tttttt__FILE__, __FUNCTION__, fullpath);ttttcontinue;ttt}tttif(S_ISDIR(stat_buf.st_mode)) {ttttif(AddFileListItemInfo(pFileListInfo, pDirent->d_name, -1, 0) == 0) {tttttrfbLog(""File [%s]: Method [%s]: Add directory %s in the""ttttttt"" list failed"", __FILE__, __FUNCTION__, fullpath);tttttcontinue;tttt}ttt}tttelse {ttttif(flag) {tttttif(AddFileListItemInfo(pFileListInfo, pDirent->d_name, ttttttttttttstat_buf.st_size, ttttttttttttstat_buf.st_mtime) == 0) {ttttttrfbLog(""File [%s]: Method [%s]: Add file %s in the ""tttttttt""list failed"", __FILE__, __FUNCTION__, fullpath);ttttttcontinue;ttttt}ttttttt}ttt}tt}t}tif(closedir(pDir) < 0) {t    rfbLog(""File [%s]: Method [%s]: ERROR Couldn't close dir"",t    t__FILE__, __FUNCTION__);t}ttreturn SUCCESS;}",3,"cwe119,cwe120,cwe469"
"main(int argc, char **argv) {    char *filename;    int fix = 0;    if (argc < 2) {        printf(""Usage: %s [--fix] <file.aof>"", argv[0]);        exit(1);    } else if (argc == 2) {        filename = argv[1];    } else if (argc == 3) {        if (strcmp(argv[1],""--fix"") != 0) {            printf(""Invalid argument: %s"", argv[1]);            exit(1);        }        filename = argv[2];        fix = 1;    } else {        printf(""Invalid arguments"");        exit(1);    }    FILE *fp = fopen(filename,""r+"");    if (fp == NULL) {        printf(""Cannot open file: %s"", filename);        exit(1);    }    struct redis_stat sb;    if (redis_fstat(fileno(fp),&sb) == -1) {        printf(""Cannot stat file: %s"", filename);        exit(1);    }    long size = sb.st_size;    if (size == 0) {        printf(""Empty file: %s"", filename);        exit(1);    }    long pos = process(fp);    long diff = size-pos;    if (diff > 0) {        if (fix) {            char buf[2];            printf(""This will shrink the AOF from %ld bytes, with %ld bytes, to %ld bytes"",size,diff,pos);            printf(""Continue? [y/N]: "");            if (fgets(buf,sizeof(buf),stdin) == NULL ||                strncasecmp(buf,""y"",1) != 0) {                    printf(""Aborting..."");                    exit(1);            }            if (ftruncate(fileno(fp), pos) == -1) {                printf(""Failed to truncate AOF"");                exit(1);            } else {                printf(""Successfully truncated AOF"");            }        } else {            printf(""AOF is not valid"");            exit(1);        }    } else {        printf(""AOF is valid"");    }    fclose(fp);    return 0;}",4,"cwe119,cwe120,cwe476,cweother"
"cmd_addserver(){tinttport;tchart*p;tcontext;tif(!cmdinfo.isparam)t{ttsay(""Usage: addserver <servername> [port]"");ttsayf(2,0,""Add a server to the serverlist."");ttreturn;t}tcontext;tif(!cmdinfo.istok2)t{ttport = DEFAULT_PORT;ttp = strchr(cmdinfo.tok1,':');ttif(p != NULL)tt{ttt ttt*p = 0;tttport = atoi(p+1);tt}t}telsettport = atoi(cmdinfo.tok2);tcontext;tServer_addserver(cmdinfo.tok1,port);tsayf(0,0,""Server ""%s:%d"" added to serverlist."",cmdinfo.tok1,port);}",3,"cwe119,cwe120,cweother"
"SHA_Final(SHA_State * s, unsigned char *output){    int i;    int pad;    unsigned char c[64];    uint32 lenhi, lenlo;    if (s->blkused >= 56)tpad = 56 + 64 - s->blkused;    elsetpad = 56 - s->blkused;    lenhi = (s->lenhi << 3) | (s->lenlo >> (32 - 3));    lenlo = (s->lenlo << 3);    memset(c, 0, pad);    c[0] = 0x80;    SHA_Bytes(s, &c, pad);    c[0] = (lenhi >> 24) & 0xFF;    c[1] = (lenhi >> 16) & 0xFF;    c[2] = (lenhi >> 8) & 0xFF;    c[3] = (lenhi >> 0) & 0xFF;    c[4] = (lenlo >> 24) & 0xFF;    c[5] = (lenlo >> 16) & 0xFF;    c[6] = (lenlo >> 8) & 0xFF;    c[7] = (lenlo >> 0) & 0xFF;    SHA_Bytes(s, &c, 8);    for (i = 0; i < 5; i++) {toutput[i * 4] = (s->h[i] >> 24) & 0xFF;toutput[i * 4 + 1] = (s->h[i] >> 16) & 0xFF;toutput[i * 4 + 2] = (s->h[i] >> 8) & 0xFF;toutput[i * 4 + 3] = (s->h[i]) & 0xFF;    }}",2,"cwe119,cwe120"
"my_vsnprintf_mb2(char *dst, size_t n, const char* fmt, va_list ap){  char *start=dst, *end= dst + n - 1;  for (; *fmt ; fmt++)  {    if (fmt[0] != '%')    {      if (dst == end)                              break;            *dst++='0';      *dst++= *fmt;                 continue;    }        fmt++;             while ( (*fmt >= '0' && *fmt <= '9') || *fmt == '.' || *fmt == '-')      fmt++;        if (*fmt == 'l')      fmt++;        if (*fmt == 's')                           {      char *par= va_arg(ap, char *);      size_t plen;      size_t left_len= (size_t)(end-dst);      if (!par)        par= (char*) ""(null)"";      plen= strlen(par);      if (left_len <= plen * 2)        plen = left_len / 2 - 1;      for ( ; plen ; plen--, dst+=2, par++)      {        dst[0]= '0';        dst[1]= par[0];      }      continue;    }    else if (*fmt == 'd' || *fmt == 'u')       {      int iarg;      char nbuf[16];      char *pbuf= nbuf;            if ((size_t) (end - dst) < 32)        break;      iarg= va_arg(ap, int);      if (*fmt == 'd')        int10_to_str((long) iarg, nbuf, -10);      else        int10_to_str((long) (uint) iarg, nbuf,10);      for (; pbuf[0]; pbuf++)      {        *dst++= '0';        *dst++= *pbuf;      }      continue;    }             if (dst == end)      break;    *dst++= '0';    *dst++= '%';                               }    DBUG_ASSERT(dst <= end);  *dst='0';                                   return (size_t) (dst - start);}",2,"cwe119,cwe120"
"local_read_chunk(unsigned char *chunk, const unsigned char *digest,ttvoid *db_info){tchar *chunk_dir = db_info;tint err, fd, len, n;tchar *path;terr = asprintf(&path, ""%s/%s"", chunk_dir, digest_string(digest));tif (err < 0)ttreturn -errno;tTRACE(""path=%s"", path);tfd = open(path, O_RDONLY);tif (fd < 0) {ttWARNING(""%s: %s"", path, strerror(errno));ttfree(path);ttreturn -EIO;t}tfree(path);tlen = 0;twhile (len < CHUNK_SIZE) {ttn = read(fd, chunk + len, CHUNK_SIZE - len);ttif (n < 0) {tttif (errno == EINTR)ttttcontinue;ttterr = -errno;tttWARNING(""read %s: %s"", path, strerror(errno));tttclose(fd);tttreturn err;tt}ttlen += n;t}tclose(fd);treturn CHUNK_SIZE;}",2,"cwe120,cweother"
"arp_show(char *name){tconst char *host;tconst char *hostname;tFILE *fp;tstruct sockaddr sa;tint type, flags;tint num;tunsigned entries = 0, shown = 0;tchar ip[128];tchar hwa[128];tchar mask[128];tchar line[128];tchar dev[128];thost = NULL;tif (name != NULL) {tt ttif (ap->input(name, &sa) < 0) {tttbb_herror_msg_and_die(""%s"", name);tt}tthost = xstrdup(ap->sprint(&sa, 1));t}tfp = xfopen_for_read(""/proc/net/arp"");t tfgets(line, sizeof(line), fp);t twhile (fgets(line, sizeof(line), fp)) {ttmask[0] = '-'; mask[1] = '0';ttdev[0] = '-'; dev[1] = '0';tt ttnum = sscanf(line, ""%s 0x%x 0x%x %s %s %s"",ttttt ip, &type, &flags, hwa, mask, dev);ttif (num < 4)tttbreak;ttentries++;tt ttif (hw_set && (type != hw->type))tttcontinue;tt ttif (host && strcmp(ip, host) != 0)tttcontinue;tt ttif (device[0] && strcmp(dev, device) != 0)tttcontinue;ttshown++;tt tthostname = ""?"";ttif (!(option_mask32 & ARP_OPT_n)) {tttif (ap->input(ip, &sa) < 0)tttthostname = ip;tttelsetttthostname = ap->sprint(&sa, (option_mask32 & ARP_OPT_n) | 0x8000);tttif (strcmp(hostname, ip) == 0)tttthostname = ""?"";tt}ttarp_disp(hostname, ip, type, flags, hwa, mask, dev);t}tif (option_mask32 & ARP_OPT_v)ttprintf(""Entries: %dtSkipped: %dtFound: %d"",ttt   entries, entries - shown, shown);tif (!shown) {ttif (hw_set || host || device[0])tttprintf(""No match found in %d entries"", entries);t}tif (ENABLE_FEATURE_CLEAN_UP) {ttfree((char*)host);ttfclose(fp);t}treturn 0;}",3,"cwe119,cwe120,cweother"
"rewriteAppendOnlyFileBackground(void) {    pid_t childpid;    if (server.bgrewritechildpid != -1) return REDIS_ERR;    if (server.vm_enabled) waitEmptyIOJobsQueue();    if ((childpid = fork()) == 0) {                 char tmpfile[256];        if (server.vm_enabled) vmReopenSwapFile();        if (server.ipfd > 0) close(server.ipfd);        if (server.sofd > 0) close(server.sofd);        snprintf(tmpfile,256,""temp-rewriteaof-bg-%d.aof"", (int) getpid());        if (rewriteAppendOnlyFile(tmpfile) == REDIS_OK) {            _exit(0);        } else {            _exit(1);        }    } else {                 if (childpid == -1) {            redisLog(REDIS_WARNING,                ""Can't rewrite append only file in background: fork: %s"",                strerror(errno));            return REDIS_ERR;        }        redisLog(REDIS_NOTICE,            ""Background append only file rewriting started by pid %d"",childpid);        server.bgrewritechildpid = childpid;        updateDictResizePolicy();                 server.appendseldb = -1;        return REDIS_OK;    }    return REDIS_OK;  }",3,"cwe119,cwe120,cweother"
"glusterd_do_gsync_log_rotate (char *master, char *slave, uuid_t *uuid, char **op_errstr){        int              ret     = 0;        glusterd_conf_t *priv    = NULL;        pid_t            pid     = 0;        char log_file1[PATH_MAX] = {0,};        char log_file2[PATH_MAX] = {0,};        GF_ASSERT (THIS);        GF_ASSERT (THIS->private);        priv = THIS->private;        ret = glusterd_get_pid_from_file (master, slave, &pid);        if (ret)                goto out;                 ret = glusterd_gsyncd_getlogfile (master, slave, log_file1);        if (ret)                goto out;                 ret = glusterd_gsync_get_slave_log_file (master, slave, log_file2);        if (ret)                goto out;        ret = glusterd_send_log_rotate_signal (pid, log_file1, log_file2); out:        if (ret && op_errstr)                *op_errstr = gf_strdup(""Error rotating log file"");        return ret;}",2,"cwe119,cwe120"
"process_fd (iconv_t cd, int fd, FILE **output, const char *output_file){     static char *inbuf = NULL;  static size_t maxlen = 0;  char *inptr = NULL;  size_t actlen = 0;  while (actlen < maxlen)    {      ssize_t n = read (fd, inptr, maxlen - actlen);      if (n == 0)t tbreak;      if (n == -1)t{t   t  error (0, errno, _(""error while reading the input""));t  return -1;t}      inptr += n;      actlen += n;    }  if (actlen == maxlen)    while (1)      {tssize_t n;tchar *new_inbuf;t tnew_inbuf = (char *) realloc (inbuf, maxlen + 32768);tif (new_inbuf == NULL)t  {t    error (0, errno, _(""unable to allocate buffer for input""));t    return -1;t  }tinbuf = new_inbuf;tmaxlen += 32768;tinptr = inbuf + actlen;tdot  {t    n = read (fd, inptr, maxlen - actlen);t    if (n == 0)t       t      break;t    if (n == -1)t      {tt tterror (0, errno, _(""error while reading the input""));ttreturn -1;t      }t    inptr += n;t    actlen += n;t  }twhile (actlen < maxlen);tif (n == 0)t   t  break;      }     return process_block (cd, inbuf, actlen, output, output_file);}",2,"cwe120,cweother"
"is_executable(const char *name){tstruct stat st;tif (stat(name, &st) ||  t    !S_ISREG(st.st_mode))ttreturn 0;#ifdef WIN32{t tchar buf[3] = { 0 };tint n;tint fd = open(name, O_RDONLY);tst.st_mode &= ~S_IXUSR;tif (fd >= 0) {ttn = read(fd, buf, 2);ttif (n == 2)ttt tttif (!strcmp(buf, ""#!"") || !strcmp(buf, ""MZ""))ttttst.st_mode |= S_IXUSR;ttclose(fd);t}}#endiftreturn st.st_mode & S_IXUSR;}",3,"cwe119,cwe120,cweother"
"copy_to_user_fromio(void __user *dst, const volatile void __iomem *src, size_t count){#if defined(__i386__) || defined(CONFIG_SPARC32)treturn copy_to_user(dst, (const void __force*)src, count) ? -EFAULT : 0;#elsetchar buf[256];twhile (count) {ttsize_t c = count;ttif (c > sizeof(buf))tttc = sizeof(buf);ttmemcpy_fromio(buf, (void __iomem *)src, c);ttif (copy_to_user(dst, buf, c))tttreturn -EFAULT;ttcount -= c;ttdst += c;ttsrc += c;t}treturn 0;#endif}",2,"cwe119,cwe120"
phpwrap(){tif ( --php_include_stack_ptr < 0 ) {ttreturn 1;t} else {ttphp_delete_buffer(YY_CURRENT_BUFFER );ttphp_switch_to_buffer(php_include_stack[php_include_stack_ptr] );t}treturn 0;},2,"cwe120,cweother"
"""stabstr_D (HOST_WIDE_INT num){  char buf[64];  char *p = buf + sizeof buf;  unsigned int unum;  if (num == 0)    {      stabstr_C ('0');      return;    }  if (num < 0)    {      stabstr_C ('-');      unum = -num;    }  else    unum = num;  NUMBER_FMT_LOOP (p, unum, 10);  obstack_grow (&stabstr_ob, p, (buf + sizeof buf) - p);}""",2,"cwe119,cwe120"
"json_print_pwr_cpufreq_stats(struct activity *a, int curr, int tab,ttttt     unsigned long long itv){tint i;tstruct stats_pwr_cpufreq *spc;tint sep = FALSE;tchar cpuno[8];tif (!IS_SELECTED(a->options) || (a->nr <= 0))ttgoto close_json_markup;tjson_markup_power_management(tab, OPEN_JSON_MARKUP);ttab++;txprintf(tab++, """"cpu-frequency"": ["");ttfor (i = 0; (i < a->nr) && (i < a->bitmap->b_size + 1); i++) {ttttspc = (struct stats_pwr_cpufreq *) ((char *) a->buf[curr]  + i * a->msize);ttt ttif (a->bitmap->b_array[i >> 3] & (1 << (i & 0x07))) {ttt tttif (!i) {tttt ttttstrcpy(cpuno, ""all"");ttt}tttelse {ttttsprintf(cpuno, ""%d"", i - 1);ttt}tttif (sep) {ttttprintf("","");ttt}tttsep = TRUE;ttttttxprintf0(tab, ""{""number"": ""%s"", ""tttt """"frequency"": %.2f}"",tttt cpuno,tttt ((double) spc->cpufreq) / 100);tt}t}ttprintf("""");txprintf0(--tab, ""]"");ttab--;close_json_markup:tif (CLOSE_MARKUP(a->options)) {ttjson_markup_power_management(tab, CLOSE_JSON_MARKUP);t}}",2,"cwe119,cwe120"
"dump_area2(uint8_t *area, int len, char *info){#define BPL    16                    int i, linelength;    char outputline[100];    char *outbuf;    linelength = BPL * 3;    if ( ! info[0] )        info = ""No additional info available"";        DBG(1, ""[%s]"", info);    outbuf = outputline;    for ( i = 0; i < len; i++)      {        sprintf(outbuf, ""%02x,"", *(area + i));        outbuf += 3;        if ( ((i+1)%BPL == 0) || (i == len-1) )           {             outbuf = outputline;             DBG(1, ""%s"", outbuf);           }      }    return SANE_STATUS_GOOD;}",2,"cwe119,cwe120"
"avahi_set_proc_title(const char *name, const char *fmt,...) {#ifdef HAVE_SETPROCTITLE    char t[256];    va_list ap;    va_start(ap, fmt);    vsnprintf(t, sizeof(t), fmt, ap);    va_end(ap);    setproctitle(""-%s"", t);#elif defined(__linux__)    size_t l;    va_list ap;    if (!argv_buffer)        return;    va_start(ap, fmt);    vsnprintf(argv_buffer[0], argv_size, fmt, ap);    va_end(ap);    l = strlen(argv_buffer[0]);    memset(argv_buffer[0] + l, 0, argv_size - l);    argv_buffer[1] = NULL;#endif#if defined(HAVE_SYS_PRCTL_H) && defined(PR_SET_NAME)    if (name)        prctl(PR_SET_NAME, (unsigned long) name, 0, 0, 0);#endif}",3,"cwe119,cwe120,cweother"
"main() {  int physical_wk;  int virtual_wk1;  int work_in[11] = { 1,1,1,1,1,1,1,1,1,1,2 };  int work_out[57];     printf(""--- Physical workstation ----------"");  printf(""Opening physical workstation..."");  v_opnwk(work_in, &physical_wk, work_out);  if(!physical_wk) {    printf(""Failed"");    return 0;  }  printf("" OK, got handle %d"",physical_wk);     printf(""Now going to close that physical workstation : Press a RETURN to continue"");  getc(stdin);    printf(""Closing physical workstation..."");  v_clswk(physical_wk);     printf(""OK"");     printf(""--- Virtual workstation ----------"");  printf(""We are going to open the physical workstation again and create a virtual workstation"");  printf(""Press RETURN to continue"");  getc(stdin);  v_opnwk(work_in, &physical_wk, work_out);  printf(""Opening virtual workstation..."");  virtual_wk1 = physical_wk;    v_opnvwk(work_in, &virtual_wk1, work_out);  if(!virtual_wk1) {    printf(""Failed"");    printf(""Closing the physical workstatoin and exiting."");    v_clswk(physical_wk);    return 0;  }  printf(""OK, got handle %d"",virtual_wk1);     printf(""Now going to close that physical workstation : Press RETURN to continue"");  getc(stdin);    printf(""Closing virtual workstation..."");  v_clsvwk(virtual_wk1);     printf(""OK"");  printf(""Now closing the physical workstation and exiting"");  v_clswk(physical_wk);    return 0;}",2,"cwe120,cweother"
"c_list_suffices(state_t *s){tsuffix_t **suffices;tint suffices_nr;tint i;tchar word_buf[256], alt_buf[256];tsuffices = vocab_get_suffices(s->resmgr, &suffices_nr);tif (!suffices) {ttsciprintf(""No suffix vocabulary."");ttreturn 1;t}tfor (i = 0; i < suffices_nr; i++) {ttsuffix_t *suf = suffices[i];ttstrncpy(word_buf, suf->word_suffix,tttsuf->word_suffix_length);ttword_buf[suf->word_suffix_length] = 0;ttstrncpy(alt_buf, suf->alt_suffix,tttsuf->alt_suffix_length);ttalt_buf[suf->alt_suffix_length] = 0;ttsciprintf(""%4d: (%03x) -%12s  =>  -%12s (%03x)"",ttt  i, suf->class_mask, word_buf,ttt  alt_buf, suf->result_class);t}tvocab_free_suffices(s->resmgr, suffices, suffices_nr);treturn 0;}",2,"cwe119,cwe120"
"glibtop_get_proc_uid_s (glibtop *server, glibtop_proc_uid *buf, pid_t pid){tchar buffer [BUFSIZ], *p;tmemset (buf, 0, sizeof (glibtop_proc_uid));tif (proc_status_to_buffer(buffer, sizeof buffer, pid))ttreturn;t tp = strstr (buffer, ""Pid:"");tif (!p) return;tp = skip_token (p);  tbuf->pid = strtol (p, &p, 0);tp = skip_token (p);  tbuf->ppid = strtol (p, &p, 0);t tp = strstr (p, ""Uid:"");tif (!p) return;tp = skip_token (p);  tbuf->uid  = strtol (p, &p, 0);tbuf->euid = strtol (p, &p, 0);t tp = strstr (p, ""Gid:"");tif (!p) return;tp = skip_token (p);  tbuf->gid  = strtol (p, &p, 0);tbuf->egid = strtol (p, &p, 0);tbuf->flags = _glibtop_sysdeps_proc_uid;tif (proc_stat_to_buffer(buffer, sizeof buffer, pid))ttreturn;tp = proc_stat_after_cmd (buffer);tif (!p) return;tp = skip_multiple_token (p, 2);tbuf->pgrp    = strtol (p, &p, 0);tbuf->session = strtol (p, &p, 0);tbuf->tty     = strtol (p, &p, 0);tbuf->tpgid   = strtol (p, &p, 0);tp = skip_multiple_token (p, 9);tbuf->priority = strtol (p, &p, 0);tbuf->nice     = strtol (p, &p, 0);tif (buf->tty == 0)tt ttbuf->tty = -1;tif (server->os_version_code < LINUX_VERSION_CODE(1,3,39)) {tt ttbuf->priority = 2*15 - buf->priority;ttbuf->nice = 15 - buf->nice;t}telse if (server->os_version_code < LINUX_VERSION_CODE(1,1,30) && buf->tty != -1)tt ttbuf->tty = 4*0x100 + buf->tty;tbuf->flags |= _glibtop_sysdeps_proc_uid_stat;}",2,"cwe119,cwe120"
"noise_get_heavy(void (*func) (void *, int)){    char buf[512];    FILE *fp;    int ret;    int got_dev_urandom = 0;    if (read_dev_urandom(buf, 32)) {tgot_dev_urandom = 1;tfunc(buf, 32);    }    fp = popen(""ps -axu 2>/dev/null"", ""r"");    if (fp) {twhile ( (ret = fread(buf, 1, sizeof(buf), fp)) > 0)t    func(buf, ret);tpclose(fp);    } else if (!got_dev_urandom) {tfprintf(stderr, ""popen: %s""tt""Unable to access fallback entropy source"", strerror(errno));texit(1);    }    fp = popen(""ls -al /tmp 2>/dev/null"", ""r"");    if (fp) {twhile ( (ret = fread(buf, 1, sizeof(buf), fp)) > 0)t    func(buf, ret);tpclose(fp);    } else if (!got_dev_urandom) {tfprintf(stderr, ""popen: %s""tt""Unable to access fallback entropy source"", strerror(errno));texit(1);    }    read_random_seed(func);    random_save_seed();}",3,"cwe119,cwe120,cweother"
"""base64_decode(const unsigned char *instr, unsigned char *outstr){  unsigned char in[4], out[3], v;  int i, len;  while (*instr)  {    for (len = 0, i = 0; i < 4 && *instr; i++)    {      v = 0;      while (*instr && v == 0)      {        v = *instr++;        v = (unsigned char)((v < 43 || v > 122) ? 0 : cd64[v - 43]);        if (v)          v = (unsigned char)((v == '$') ? 0 : v - 61);      }      if (*instr)      {        len++;        if (v)          in[i] = (unsigned char)(v - 1);      }      else      {        in[i] = 0;      }    }    if (len)    {      decodeblock(in, out);      for (i = 0; i < len - 1; i++)        *outstr++ = out[i];    }  }}""",2,"cwe119,cwe120"
"""read_line(char *buf, int size){tint ch;tint count = 0;twhile ((ch = fgetc(stream)) != EOF && (int) ch != ''t       && (int) ch != 'r') {ttif (count < size)tttbuf[count] = (int) ch;ttelsetttbreak;ttcount++;t}treturn (ch == EOF) ? 0 : 1;}""",2,"cwe120,cweother"
"lpfc_idiag_cmd_get(const char __user *buf, size_t nbytes,ttt      struct lpfc_idiag_cmd *idiag_cmd){tchar mybuf[64];tchar *pbuf, *step_str;tint i;tsize_t bsize;t tif (!access_ok(VERIFY_READ, buf, nbytes))ttreturn -EFAULT;tmemset(mybuf, 0, sizeof(mybuf));tmemset(idiag_cmd, 0, sizeof(*idiag_cmd));tbsize = min(nbytes, (sizeof(mybuf)-1));tif (copy_from_user(mybuf, buf, bsize))ttreturn -EFAULT;tpbuf = &mybuf[0];tstep_str = strsep(&pbuf, ""t "");t tif (!step_str)ttreturn -EINVAL;tidiag_cmd->opcode = simple_strtol(step_str, NULL, 0);tif (idiag_cmd->opcode == 0)ttreturn -EINVAL;tfor (i = 0; i < LPFC_IDIAG_CMD_DATA_SIZE; i++) {ttstep_str = strsep(&pbuf, ""t "");ttif (!step_str)tttreturn i;ttidiag_cmd->data[i] = simple_strtol(step_str, NULL, 0);t}treturn i;}",2,"cwe119,cwe120"
"config_edit_num_prepare(void){tstatic char prompt[CFGVAR_LEN + 48];tCNUM *pnum;t tpnum = config[panel_cfg.pd->curs].table;ttextline = &line_tmp;tsprintf(prompt,""%s (range: %d - %d%s%s): "",t  config[panel_cfg.pd->curs].var,pnum->min,pnum->max,t  pnum->extra_val != 0 ? "" or "" : """",t  pnum->extra_val != 0 ? pnum->extra_val : """");tedit_setprompt(textline,prompt);tedit_nu_putstr(config_print_value(panel_cfg.pd->curs));}",2,"cwe119,cwe120"
"env_init(void){tchar **epp, *cp;tstruct env_lst *ep;tfor (epp = environ; *epp; epp++) {ttif ((cp = strchr(*epp, '='))) {ttt*cp = '0';tttep = env_define((unsigned char *)*epp,ttttt(unsigned char *)cp+1);tttep->export = 0;ttt*cp = '=';tt}t}t tif ((ep = env_find((unsigned char*)""DISPLAY""))t    && (*ep->value == ':'t    || strncmp((char *)ep->value, ""unix:"", 5) == 0)) {ttchar hbuf[256+1];ttchar *cp2 = strchr((char *)ep->value, ':');ttint error;tt ttgethostname(hbuf, 256);tthbuf[256] = '0';tt ttif (strchr(hbuf, '.') == 0) {tttstruct addrinfo hints, *ai, *a;tttmemset (&hints, 0, sizeof(hints));ttthints.ai_flags = AI_CANONNAME;ttterror = getaddrinfo (hbuf, NULL, &hints, &ai);tttif (error == 0) {ttttfor (a = ai; a != NULL; a = a->ai_next)tttttif (a->ai_canonname != NULL) {ttttttstrlcpy (hbuf,ttttttt ai->ai_canonname,ttttttt 256);ttttttbreak;ttttt}ttttfreeaddrinfo (ai);ttt}tt}tterror = asprintf (&cp, ""%s%s"", hbuf, cp2);ttif (error != -1) {tt    free (ep->value);tt    ep->value = (unsigned char *)cp;tt}t}t tif ((env_find((unsigned char*)""USER"") == NULL) &&t    (ep = env_find((unsigned char*)""LOGNAME""))) {ttenv_define((unsigned char *)""USER"", ep->value);ttenv_unexport((unsigned char *)""USER"");t}tenv_export((unsigned char *)""DISPLAY"");tenv_export((unsigned char *)""PRINTER"");tenv_export((unsigned char *)""XAUTHORITY"");}",2,"cwe119,cwe120"
"cpl_msg_set_log_level(cpl_msg_severity verbosity){    _cpl_msg_init(cpl_func);    if (logfile) {                 return cpl_error_set_(CPL_ERROR_FILE_ALREADY_OPEN);    }    if (verbosity != CPL_MSG_OFF) {        char timeLabel[TIME_ISO8601_LENGTH];        if ((logfile = fopen(logfile_name, ""w"")) == NULL)            return cpl_error_set_message_(CPL_ERROR_FILE_NOT_CREATED, ""%s"",                                          logfile_name);        (void)setvbuf(logfile, (char *) NULL, _IOLBF, 0);        log_min_level = verbosity;                 getTimeISO8601(timeLabel);        fprintf(logfile, """");        fprintf(logfile, ""Start time     : %s"", timeLabel);        fprintf(logfile, ""Program name   : %s"", domain);        fprintf(logfile, ""Severity level : "");        switch(verbosity) {            case CPL_MSG_DEBUG   : fprintf(logfile, DEBUG_STRING); break;            case CPL_MSG_INFO    : fprintf(logfile, INFO_STRING); break;            case CPL_MSG_WARNING : fprintf(logfile, WARNING_STRING); break;            case CPL_MSG_ERROR   : fprintf(logfile, ERROR_STRING); break;            default              : break;        }        fprintf(logfile, """");    }    return CPL_ERROR_NONE;}",3,"cwe119,cwe120,cweother"
efreet_menu_file_set(const char *file){    IF_RELEASE(efreet_menu_file);    efreet_menu_file = NULL;    if (file) efreet_menu_file = eina_stringshare_add(file);},2,"cwe119,cwe120"
"store_data(ext2_filsys fs, int fd, ext2_ino_t newfile, off_t *file_size){  ext2_file_ttoutfile;  long retval;  int bytes_read;  unsigned int bytes_written;  char buf[8192];  char *ptr;  off_t total = 0;  if ((retval = ext2fs_file_open(fs, newfile, EXT2_FILE_WRITE, &outfile)))    {      fprintf(stderr, ""%s"", error_message(retval));      ext2fs_file_close(outfile);      *file_size = 0;      return retval;    }  while (0 < (bytes_read = read(fd, buf, sizeof(buf))))    {      ptr = buf;      while (bytes_read > 0)        {          if ((retval = ext2fs_file_write(outfile, ptr, bytes_read,                                          &bytes_written)))            {              fprintf(stderr, ""%s"", error_message(retval));              ext2fs_file_close(outfile);              *file_size = total;              return retval;            }          bytes_read -= bytes_written;          total += bytes_written;          ptr += bytes_written;        }      update_progress((unsigned long) total);    }  if (bytes_read < 0)    {      perror(""store_data"");      retval = errno;    }  else    retval = 0;      finish_progress();    ext2fs_file_close(outfile);  *file_size = total;  return retval;}",3,"cwe119,cwe120,cweother"
"attack_hth(object *pl, int dir, const char *string, object *skill) {    object *weapon;    if (QUERY_FLAG(pl, FLAG_READY_WEAPON)) {        weapon = object_find_by_type_applied(pl, WEAPON);        if (weapon != NULL) {            if (apply_special(pl, weapon, AP_UNAPPLY|AP_NOPRINT)) {                char weaponname[MAX_BUF];                query_name(weapon, weaponname, MAX_BUF);                draw_ext_info_format(NDI_UNIQUE, 0, pl,                                     MSG_TYPE_SKILL, MSG_TYPE_SKILL_ERROR,                                     ""You are unable to unwield %s in order to attack with %s."",                                     weaponname, skill->name);                return;            } else {                draw_ext_info(NDI_UNIQUE, 0, pl, MSG_TYPE_SKILL, MSG_TYPE_SKILL_ERROR,                              ""You unwield your weapon in order to attack."");            }        }    }    skill_attack(NULL, pl, dir, string, skill);}",2,"cwe119,cwe120"
"CreateFireWatcher(struct __ecereNameSpace__ecere__com__Property * prop, struct Expression * object, struct Statement * stmt){char propName[1024], propNameM[1024];char getName[1024], setName[1024];struct __ecereNameSpace__ecere__sys__OldList * args;DeclareProperty(prop, setName, getName);strcpy(propName, ""__ecereProp_"");FullClassNameCat(propName, prop->_class->fullName, 0x0);strcat(propName, ""_"");FullClassNameCat(propName, prop->name, 0x1);MangleClassName(propName);strcpy(propNameM, ""__ecerePropM_"");FullClassNameCat(propNameM, prop->_class->fullName, 0x0);strcat(propNameM, ""_"");FullClassNameCat(propNameM, prop->name, 0x1);MangleClassName(propNameM);if(prop->isWatchable){args = MkList();ListAdd(args, object ? CopyExpression(object) : MkExpIdentifier(MkIdentifier(""this"")));ListAdd(args, MkExpIdentifier(MkIdentifier(propName)));ListAdd(stmt->expressions, MkExpCall(MkExpIdentifier(MkIdentifier(""ecere::com::eInstance_FireWatchers"")), args));args = MkList();ListAdd(args, object ? CopyExpression(object) : MkExpIdentifier(MkIdentifier(""this"")));ListAdd(args, MkExpIdentifier(MkIdentifier(propNameM)));ListAdd(stmt->expressions, MkExpCall(MkExpIdentifier(MkIdentifier(""ecere::com::eInstance_FireWatchers"")), args));}{args = MkList();ListAdd(args, object ? CopyExpression(object) : MkExpIdentifier(MkIdentifier(""this"")));ListAdd(args, MkExpIdentifier(MkIdentifier(propName)));ListAdd(stmt->expressions, MkExpCall(MkExpIdentifier(MkIdentifier(""ecere::com::eInstance_FireSelfWatchers"")), args));args = MkList();ListAdd(args, object ? CopyExpression(object) : MkExpIdentifier(MkIdentifier(""this"")));ListAdd(args, MkExpIdentifier(MkIdentifier(propNameM)));ListAdd(stmt->expressions, MkExpCall(MkExpIdentifier(MkIdentifier(""ecere::com::eInstance_FireSelfWatchers"")), args));}if(curFunction->propSet && !strcmp(curFunction->propSet->string, prop->name) && (!object || (object->type == 0 && !strcmp(object->identifier->string, ""this""))))curFunction->propSet->fireWatchersDone = 0x1;}",2,"cwe119,cwe120"
"cmd_merge_base(int argc, const char **argv, const char *prefix){tstruct commit *rev1, *rev2;tunsigned char rev1key[20], rev2key[20];tint show_all = 0;tgit_config(git_default_config);twhile (1 < argc && argv[1][0] == '-') {ttconst char *arg = argv[1];ttif (!strcmp(arg, ""-a"") || !strcmp(arg, ""--all""))tttshow_all = 1;ttelsetttusage(merge_base_usage);ttargc--; argv++;t}tif (argc != 3)ttusage(merge_base_usage);tif (get_sha1(argv[1], rev1key))ttdie(""Not a valid object name %s"", argv[1]);tif (get_sha1(argv[2], rev2key))ttdie(""Not a valid object name %s"", argv[2]);trev1 = lookup_commit_reference(rev1key);trev2 = lookup_commit_reference(rev2key);tif (!rev1 || !rev2)ttreturn 1;treturn show_merge_base(rev1, rev2, show_all);}",3,"cwe119,cwe120,cwe469"
"nes_nic_tune_timer(struct nes_device *nesdev){tunsigned long flags;tstruct nes_adapter *nesadapter = nesdev->nesadapter;tstruct nes_hw_tune_timer *shared_timer = &nesadapter->tune_timer;tu16 cq_count = nesdev->currcq_count;tspin_lock_irqsave(&nesadapter->periodic_timer_lock, flags);tif (shared_timer->cq_count_old <= cq_count)ttshared_timer->cq_direction_downward = 0;telsettshared_timer->cq_direction_downward++;tshared_timer->cq_count_old = cq_count;tif (shared_timer->cq_direction_downward > NES_NIC_CQ_DOWNWARD_TREND) {ttif (cq_count <= shared_timer->threshold_low &&tt    shared_timer->threshold_low > 4) {tttshared_timer->threshold_low = shared_timer->threshold_low/2;tttshared_timer->cq_direction_downward=0;tttnesdev->currcq_count = 0;tttspin_unlock_irqrestore(&nesadapter->periodic_timer_lock, flags);tttreturn;tt}t}tif (cq_count > 1) {ttnesdev->deepcq_count += cq_count;ttif (cq_count <= shared_timer->threshold_low) {        tttshared_timer->timer_direction_upward++;tttshared_timer->timer_direction_downward = 0;tt} else if (cq_count <= shared_timer->threshold_target) {  tttshared_timer->timer_direction_upward = 0;tttshared_timer->timer_direction_downward = 0;tt} else if (cq_count <= shared_timer->threshold_high) {   tttshared_timer->timer_direction_downward++;tttshared_timer->timer_direction_upward = 0;tt} else if (cq_count <= (shared_timer->threshold_high) * 2) {tttshared_timer->timer_in_use -= 2;tttshared_timer->timer_direction_upward = 0;tttshared_timer->timer_direction_downward++;tt} else {tttshared_timer->timer_in_use -= 4;tttshared_timer->timer_direction_upward = 0;tttshared_timer->timer_direction_downward++;tt}ttif (shared_timer->timer_direction_upward > 3 ) {   tttshared_timer->timer_in_use += 3;tttshared_timer->timer_direction_upward = 0;tttshared_timer->timer_direction_downward = 0;tt}ttif (shared_timer->timer_direction_downward > 5) {  tttshared_timer->timer_in_use -= 4 ;tttshared_timer->timer_direction_downward = 0;tttshared_timer->timer_direction_upward = 0;tt}t}t tif (shared_timer->timer_in_use > shared_timer->threshold_high)ttshared_timer->timer_in_use = shared_timer->threshold_high;telse if (shared_timer->timer_in_use < shared_timer->threshold_low)ttshared_timer->timer_in_use = shared_timer->threshold_low;tnesdev->currcq_count = 0;tspin_unlock_irqrestore(&nesadapter->periodic_timer_lock, flags);}",2,"cwe119,cwe120"
edge_degfree(e_id)edge_id e_id;{ int degfree;  int eattr = get_eattr(e_id);  struct boundary *ebdry;  conmap_t *emap;  int i;     degfree = SDIM;  if ( eattr & FIXED ) degfree = 0;  else if ( eattr & BOUNDARY )  { ebdry = get_edge_boundary(e_id);    if ( (ebdry->attr & NONWALL) )      degfree = ebdry->pcount;  }  else if ( eattr & CONSTRAINT )  { emap = get_e_constraint_map(e_id);    for ( i = 1; i <= (int)emap[0] ; i++ )     if (!((get_constraint(emap[i])->attr)&(NONPOSITIVE|NONNEGATIVE|NONWALL)))      degfree--;  }   return degfree;},2,"cwe476,cweother"
"crypto_aead_decrypt(r  unsigned char       *m,r  unsigned long long  *mlen,r  unsigned char       *nsec,r  const unsigned char *c,r  unsigned long long  clen,r  const unsigned char *ad,r  unsigned long long  adlen,r  const unsigned char *npub,r  const unsigned char *kr  )r{r  unsigned long long cr;r  int d, ret=0;r  unsigned char tag[TAGBYTES];rr  cr = clen + adlen;r  if( (cr<clen) && (cr<adlen) ) return -1;rr  clen -= TAGBYTES;rtif( clen % BLOCK_SIZE ) return -1;rtif( clen < BLOCK_SIZE ) return -1;rr   r  AEAD_TGEN( k, npub, ad, adlen, c, clen, tag );r  for( d=0; d<TAGBYTES; d++ ){r    if( tag[d] != c[d+clen] ) ret |= 1;r  }r  if( ret != 0 )  return -1;r  if(AEAD_MGEN( k, npub, c, clen, m, mlen ) < 0){r    return -1;r  }rr  return 0;r}",2,"cwe119,cwe120"
"ast_func_read(struct ast_channel *chan, const char *function, char *workspace, size_t len){tchar *copy = ast_strdupa(function);tchar *args = func_args(copy);tstruct ast_custom_function *acfptr = ast_custom_function_find(copy);tint res;tstruct ast_module_user *u = NULL;tif (acfptr == NULL) {ttast_log(LOG_ERROR, ""Function %s not registered"", copy);t} else if (!acfptr->read && !acfptr->read2) {ttast_log(LOG_ERROR, ""Function %s cannot be read"", copy);t} else if (!is_read_allowed(acfptr)) {ttast_log(LOG_ERROR, ""Dangerous function %s read blocked"", copy);t} else if (acfptr->read) {ttif (acfptr->mod) {tttu = __ast_module_user_add(acfptr->mod, chan);tt}ttres = acfptr->read(chan, copy, args, workspace, len);ttif (acfptr->mod && u) {ttt__ast_module_user_remove(acfptr->mod, u);tt}ttreturn res;t} else {ttstruct ast_str *str = ast_str_create(16);ttif (acfptr->mod) {tttu = __ast_module_user_add(acfptr->mod, chan);tt}ttres = acfptr->read2(chan, copy, args, &str, 0);ttif (acfptr->mod && u) {ttt__ast_module_user_remove(acfptr->mod, u);tt}ttast_copy_string(workspace, ast_str_buffer(str), len > ast_str_size(str) ? ast_str_size(str) : len);ttast_free(str);ttreturn res;t}treturn -1;}",2,"cwe120,cweother"
"_wait_for_io(stepd_step_rec_t *job){tdebug(""Waiting for IO"");tio_close_all(job);t tif (job->ioid) {tt_delay_kill_thread(job->ioid, 300);ttpthread_join(job->ioid, NULL);t} elsettinfo(""_wait_for_io: ioid==0"");t tio_close_local_fds(job);treturn;}",3,"cwe119,cwe120,cweother"
"""get_sha1_with_mode(const char *name, unsigned char *sha1, unsigned *mode){tint ret, bracket_depth;tint namelen = strlen(name);tconst char *cp;t*mode = S_IFINVALID;tret = get_sha1_1(name, namelen, sha1);tif (!ret)ttreturn ret;t/* sha1:path --> object name of path in ent sha1t * :path -> object name of path in indext * :[0-3]:path -> object name of path in index at staget */tif (name[0] == ':') {ttint stage = 0;ttstruct cache_entry *ce;ttint pos;ttif (namelen > 2 && name[1] == '/')tttreturn get_sha1_oneline(name + 2, sha1);ttif (namelen < 3 ||tt    name[2] != ':' ||tt    name[1] < '0' || '3' < name[1])tttcp = name + 1;ttelse {tttstage = name[1] - '0';tttcp = name + 3;tt}ttnamelen = namelen - (cp - name);ttif (!active_cache)tttread_cache();ttpos = cache_name_pos(cp, namelen);ttif (pos < 0)tttpos = -pos - 1;ttwhile (pos < active_nr) {tttce = active_cache[pos];tttif (ce_namelen(ce) != namelen ||ttt    memcmp(ce->name, cp, namelen))ttttbreak;tttif (ce_stage(ce) == stage) {tttthashcpy(sha1, ce->sha1);tttt*mode = ce->ce_mode;ttttreturn 0;ttt}tttpos++;tt}ttreturn -1;t}tfor (cp = name, bracket_depth = 0; *cp; cp++) {ttif (*cp == '{')tttbracket_depth++;ttelse if (bracket_depth && *cp == '}')tttbracket_depth--;ttelse if (!bracket_depth && *cp == ':')tttbreak;t}tif (*cp == ':') {ttunsigned char tree_sha1[20];ttif (!get_sha1_1(name, cp-name, tree_sha1))tttreturn get_tree_entry(tree_sha1, cp+1, sha1,ttttt      mode);t}treturn ret;}""",2,"cwe119,cwe120"
"set_dsgwcharset(){  auto char* fname = dsgw_file2path (gc->gc_configdir, ""dsgwcharset.conf"");  auto FILE* f = fopen (fname, ""r"");  if (f != NULL) {    auto char buf[BUFSIZ];    if (fgets (buf, sizeof(buf), f)) {      auto const size_t buflen = strlen (buf);      if (buf[buflen-1] == '') {        buf[buflen-1] = '0';      }      gc->gc_charset = dsgw_ch_strdup (buf);    }    fclose (f);  }  free (fname);}",3,"cwe119,cwe120,cweother"
"objdump_symbol_at_address (bfd_vma vma, struct disassemble_info * inf){  asymbol * sym;  sym = find_symbol_for_address (vma, inf, NULL);  return (sym != NULL && (bfd_asymbol_value (sym) == vma));}",2,"cwe120,cweother"
"update_memory_map( void ){  int source, page_num, writable, contended;  libspectrum_word offset;  size_t i, j, block, row;  for( i = 0; i < MEMORY_PAGES_IN_64K; i++ ) {    if( map_label[i][0] ) {      for( j = 0; j < 4; j++ ) {        gtk_container_remove( GTK_CONTAINER( memory_map_table ), map_label[i][j] );        map_label[i][j] = NULL;      }    }  }  source = page_num = writable = contended = -1;  offset = 0;  row = 0;  for( block = 0; block < MEMORY_PAGES_IN_64K; block++ ) {    memory_page *page = &memory_map_read[block];    if( page->source != source ||      page->page_num != page_num ||      page->offset != offset ||      page->writable != writable ||      page->contended != contended ) {      char buffer[40];      GtkWidget **row_labels = map_label[row];      snprintf( buffer, 40, format_16_bit(),                (unsigned)block * MEMORY_PAGE_SIZE );      row_labels[0] = gtk_label_new( buffer );      snprintf( buffer, 40, ""%s %d"",        memory_source_description( page->source ), page->page_num );      row_labels[1] = gtk_label_new( buffer );      row_labels[2] = gtk_label_new( page->writable ? ""Y"" : ""N"" );      row_labels[3] = gtk_label_new( page->contended ? ""Y"" : ""N"" );      for( i = 0; i < 4; i++ ) {#if GTK_CHECK_VERSION( 3, 0, 0 )        gtk_grid_attach( GTK_GRID( memory_map_table ), row_labels[i],                         i, row + 1, 1, 1 );#else        gtk_table_attach( GTK_TABLE( memory_map_table ), row_labels[i],                          i, i + 1, row + 1, row + 2, 0, 0, 2, 2 );#endif      }      row++;      source = page->source;      page_num = page->page_num;      writable = page->writable;      contended = page->contended;      offset = page->offset;    }         offset += MEMORY_PAGE_SIZE;  }  gtk_widget_show_all( GTK_WIDGET( memory_map_table ) );}",3,"cwe119,cwe120,cweother"
"meta_parse_id3v2_apic(metadata_t * meta, unsigned char * buf, int len) {tchar enc = buf[10];tchar * mime_type;tchar * descr;tchar pic_type;tint len1;tint len2;tlen1 = meta_id3v2_strlen(buf+11, len-1, 0x0 );tif (len1 > len-1) {ttlen1 = len-1;ttfprintf(stderr, ""warning: APIC mime-type field too large, truncating"");t}tmime_type = meta_id3v2_to_utf8(0x0 , buf+11, len1);tpic_type = buf[12+len1];tlen2 = meta_id3v2_strlen(buf+13+len1, len-3-len1, enc);tdescr = meta_id3v2_to_utf8(enc, buf+13+len1, len2);tif ((mime_type != NULL) && (descr != NULL)) {ttmeta_frame_t * frame = meta_frame_new();ttframe->tag = META_TAG_ID3v2;ttframe->type = META_FIELD_APIC;ttframe->field_name = strdup(mime_type);ttframe->field_val = strdup(descr);ttframe->int_val = pic_type;ttframe->length = len - (4+len1+len2);ttif (frame->length > 0) {tttframe->data = malloc(frame->length);tttif (frame->data == NULL) {ttttfprintf(stderr, ""meta_parse_id3v2_apic: malloc error"");ttttreturn;ttt}tttmemcpy(frame->data, buf+14+len1+len2, frame->length);tt}ttmetadata_add_frame(meta, frame);t}tif (mime_type != NULL) {ttg_free(mime_type);t}tif (descr != NULL) {ttg_free(descr);t}}",3,"cwe120,cwe476,cweother"
"nameserver_send_probe(struct nameserver *const ns) {tstruct evdns_request *handle;tstruct request *req;tchar addrbuf[128];t t tASSERT_LOCKED(ns->base);tlog(EVDNS_LOG_DEBUG, ""Sending probe to %s"",t    evutil_format_sockaddr_port(tt    (struct sockaddr *)&ns->address,tt    addrbuf, sizeof(addrbuf)));thandle = mm_calloc(1, sizeof(*handle));tif (!handle) return;treq = request_new(ns->base, handle, TYPE_A, ""google.com"", DNS_QUERY_NO_SEARCH, nameserver_probe_callback, ns);tif (!req) return;tns->probe_request = handle;t trequest_trans_id_set(req, transaction_id_pick(ns->base));treq->ns = ns;trequest_submit(req);}",2,"cwe119,cwe120"
"get_trace_fd(int *need_close){tchar *trace = getenv(""GIT_TRACE"");tif (!trace || !strcmp(trace, """") ||t    !strcmp(trace, ""0"") || !strcasecmp(trace, ""false""))ttreturn 0;tif (!strcmp(trace, ""1"") || !strcasecmp(trace, ""true""))ttreturn STDERR_FILENO;tif (strlen(trace) == 1 && isdigit(*trace))ttreturn atoi(trace);tif (is_absolute_path(trace)) {ttint fd = open(trace, O_WRONLY | O_APPEND | O_CREAT, 0666);ttif (fd == -1) {tttfprintf(stderr,tttt""Could not open '%s' for tracing: %s""tttt""Defaulting to tracing on stderr..."",tttttrace, strerror(errno));tttreturn STDERR_FILENO;tt}tt*need_close = 1;ttreturn fd;t}tfprintf(stderr, ""What does '%s' for GIT_TRACE mean?"", trace);tfprintf(stderr, ""If you want to trace into a file, ""tt""then please set GIT_TRACE to an absolute pathname ""tt""(starting with /)."");tfprintf(stderr, ""Defaulting to tracing on stderr..."");treturn STDERR_FILENO;}",2,"cwe469,cweother"
"candidate_read(FILE * fp, char *name1, char *name2, char *extra_data){tchar line[CAND_FILE_LINE_MAX];tclearerr(fp);tlong start_of_line = ftell(fp);tif(!fgets(line, CAND_FILE_LINE_MAX, fp))ttreturn CANDIDATE_WAIT;tif(line[strlen(line) - 1] != '') {ttfseek(fp, start_of_line, SEEK_SET);ttreturn CANDIDATE_WAIT;t}tif(!strcmp(line, ""EOF"")) {ttmore_candidates = 0;ttreturn CANDIDATE_EOF;t}tint n = sscanf(line, ""%s %s %[^]"", name1, name2, extra_data);tif(n != 3)ttfatal(""candidate file is corrupted: %s"", line);tcandidates_loaded++;treturn CANDIDATE_SUCCESS;}",3,"cwe119,cwe120,cweother"
"_thin_pool_callback(struct dm_tree_node *node,ttt       dm_node_callback_t type, void *cb_data){tint ret, status;tconst struct thin_cb_data *data = cb_data;tconst char *dmdir = dm_dir();tconst struct dm_config_node *cn;tconst struct dm_config_value *cv;tconst char *thin_check =ttfind_config_tree_str_allow_empty(data->pool_lv->vg->cmd,tttttt ""global/thin_check_executable"",tttttt THIN_CHECK_CMD);tconst struct logical_volume *mlv = first_seg(data->pool_lv)->metadata_lv;tsize_t len = strlen(dmdir) + 2 * (strlen(mlv->vg->name) + strlen(mlv->name)) + 3;tchar meta_path[len];tint args = 0;tconst char *argv[19];  tchar *split, *dm_name;tif (!thin_check[0])ttreturn 1;  tif (!(dm_name = dm_build_dm_name(data->dm->mem, mlv->vg->name,ttttt mlv->name, NULL)) ||t    (dm_snprintf(meta_path, len, ""%s/%s"", dmdir, dm_name) < 0)) {ttlog_error(""Failed to build thin metadata path."");ttreturn 0;t}tif ((cn = find_config_tree_node(mlv->vg->cmd, ""global/thin_check_options""))) {ttfor (cv = cn->v; cv && args < 16; cv = cv->next) {tttif (cv->type != DM_CFG_STRING) {ttttlog_error(""Invalid string in config file: ""ttttt  ""global/thin_check_options"");ttttreturn 0;ttt}tttargv[++args] = cv->v.str;tt}t} else {tt ttif (!(split = dm_pool_strdup(data->dm->mem, DEFAULT_THIN_CHECK_OPTIONS))) {tttlog_error(""Failed to duplicate thin check string."");tttreturn 0;tt}ttargs = dm_split_words(split, 16, 0, (char**) argv + 1);t}tif (args == 16) {ttlog_error(""Too many options for thin check command."");ttreturn 0;t}targv[0] = thin_check;targv[++args] = meta_path;targv[++args] = NULL;tif (!(ret = exec_cmd(data->pool_lv->vg->cmd, (const char * const *)argv,ttt     &status, 0))) {ttswitch (type) {ttcase DM_NODE_CALLBACK_PRELOADED:tttlog_err_once(""Check of thin pool %s/%s failed (status:%d). ""tttt     ""Manual repair required (thin_dump --repair %s)!"",tttt     data->pool_lv->vg->name, data->pool_lv->name,tttt     status, meta_path);tttbreak;ttdefault:tttlog_warn(""WARNING: Integrity check of metadata for thin pool ""tttt ""%s/%s failed."",tttt data->pool_lv->vg->name, data->pool_lv->name);tt}tt t}tdm_pool_free(data->dm->mem, dm_name);treturn ret;}",2,"cwe119,cwe120"
"lcdm001_output (Driver *drvthis, int state){tPrivateData *p = drvthis->private_data;tchar out[5];tint one = (state & 0xFF);tint two = (state > 255) ? ((state >> 8) & 0xFF) : 0;        snprintf(out, sizeof(out), ""~L%c%c"", one, two);        write(p->fd, out, 4);        debug(RPT_DEBUG, ""LCDM001: current LED state %d"", state);}",2,"cwe119,cwe120"
"treewrite(boolean *done){     long maxinput;  boolean rooted;  if (nexus && onfirsttree) {    fprintf(outtree, ""#NEXUS"");    fprintf(outtree, ""BEGIN TREES"");    fprintf(outtree, ""TRANSLATE;"");    }  if (xmltree && onfirsttree) {    fprintf(outtree, ""<phylogenies>"");  }  onfirsttree = false;  maxinput = 1;  do {    fprintf(stderr, ""Enter R if the tree is to be rooted, "");    fprintf(stderr, ""OR enter U if the tree is to be unrooted: "");#ifdef WIN32    phyFillScreenColor();#endif    fflush(stdout);    scanf(""%c%*[^]"", &ch);    getchar();    if (ch == '')      ch = ' ';    ch = (isupper((int)ch)) ? ch : toupper((int)ch);    maxinput++;    if (maxinput == 100) {      fprintf(stderr, ""ERROR: too many tries at choosing option"");      embExitBad();    }  } while (ch != 'R' && ch != 'U');  col = 0;  rooted = (ch == 'R');  roottreeout(&rooted);  treenumber++;  fprintf(stderr, ""Tree written to file ""%s"""", outtreename);  waswritten = true;  written = true;  if (!(*done))    printree();  FClose(outtree);}",2,"cwe120,cweother"
"unlinkread(void){  int fd, fd1;  printf(1, ""unlinkread test"");  fd = open(""unlinkread"", O_CREATE | O_RDWR);  if(fd < 0){    printf(1, ""create unlinkread failed"");    exit();  }  write(fd, ""hello"", 5);  close(fd);  fd = open(""unlinkread"", O_RDWR);  if(fd < 0){    printf(1, ""open unlinkread failed"");    exit();  }  if(unlink(""unlinkread"") != 0){    printf(1, ""unlink unlinkread failed"");    exit();  }  fd1 = open(""unlinkread"", O_CREATE | O_RDWR);  write(fd1, ""yyy"", 3);  close(fd1);  if(read(fd, buf, sizeof(buf)) != 5){    printf(1, ""unlinkread read failed"");    exit();  }  if(buf[0] != 'h'){    printf(1, ""unlinkread wrong data"");    exit();  }  if(write(fd, buf, 10) != 10){    printf(1, ""unlinkread write failed"");    exit();  }  close(fd);  unlink(""unlinkread"");  printf(1, ""unlinkread ok"");}",2,"cwe120,cweother"
"allocate_alias(int origin){tint i;tint size;        struct alias_data *ad;        struct alias_data *newad;tchar *p1, *enclosed_string;tint found;tif ((enclosed_string = strstr(args[2], "" "")))tt*enclosed_string = NULLCHAR;tfound = FALSE;tif (get_command_table_entry(args[1])) {                error(INFO, ""cannot alias existing command name: %s"", tttargs[1]);                return FALSE;t}tif (get_command_table_entry(args[2])) ttfound = TRUE;tif (!found) {ttif (!strlen(args[2])) {tttif (alias_exists(args[1])) {ttttdeallocate_alias(args[1]);ttttfprintf(fp, ""alias deleted: %s"", args[1]);ttt}tt} else {ttterror(INFO, tt          ""invalid alias attempt on non-existent command: %s"",ttttargs[2]);tt}ttreturn FALSE;t} tif (alias_exists(args[1]))ttdeallocate_alias(args[1]);tif (enclosed_string)tt*enclosed_string = ' ';tsize = sizeof(struct alias_data) + argcnt;tfor (i = 0; i < argcnt; i++) ttsize += strlen(args[i]);        if ((newad = (struct alias_data *)malloc(size+1)) == NULL) {                error(INFO, ""alias_data malloc: %s"", strerror(errno));                return FALSE;        }tBZERO(newad, size);tnewad->next = NULL;tnewad->size = size;tnewad->origin = origin;tp1 = newad->argbuf;tfor (i = 1; i < argcnt; i++) {                sprintf(p1, ""%s "", args[i]);ttwhile (*p1)tttp1++;t}tp1 = strstr(newad->argbuf, "" "");t*p1 = NULLCHAR;tnewad->alias = newad->argbuf;tnewad->argcnt = parse_line(p1+1, newad->args); tfor (ad = &alias_head; ad->next; ad = ad->next) tt;tad->next = newad;treturn TRUE;}",2,"cwe120,cweother"
"show_line(FILE *stream, struct name_list **acl_names,  acl_t acl,              acl_entry_t *acl_ent, const char *acl_mask,              struct name_list **dacl_names, acl_t dacl,t      acl_entry_t *dacl_ent, const char *dacl_mask){tacl_tag_t tag_type;tconst char *tag, *name;tchar acl_perm[ACL_PERMS+1], dacl_perm[ACL_PERMS+1];tif (acl) {ttacl_get_tag_type(*acl_ent, &tag_type);ttname = (*acl_names)->name;t} else {ttacl_get_tag_type(*dacl_ent, &tag_type);ttname = (*dacl_names)->name;t}tswitch(tag_type) {ttcase ACL_USER_OBJ:ttttag = ""USER"";tttbreak;ttcase ACL_USER:ttttag = ""user"";tttbreak;ttcase ACL_GROUP_OBJ:ttttag = ""GROUP"";tttbreak;ttcase ACL_GROUP:ttttag = ""group"";tttbreak;ttcase ACL_MASK:ttttag = ""mask"";tttbreak;ttcase ACL_OTHER:ttttag = ""other"";tttbreak;ttdefault:tttreturn -1;t}tmemset(acl_perm, ' ', ACL_PERMS);tacl_perm[ACL_PERMS] = '0';tif (acl_ent) {ttacl_perm_str(*acl_ent, acl_perm);ttif (tag_type != ACL_USER_OBJ && tag_type != ACL_OTHER &&tt    tag_type != ACL_MASK)tttapply_mask(acl_perm, acl_mask);t}tmemset(dacl_perm, ' ', ACL_PERMS);tdacl_perm[ACL_PERMS] = '0';tif (dacl_ent) {ttacl_perm_str(*dacl_ent, dacl_perm);ttif (tag_type != ACL_USER_OBJ && tag_type != ACL_OTHER &&tt    tag_type != ACL_MASK)tttapply_mask(dacl_perm, dacl_mask);t}tfprintf(stream, ""%-5s  %*s  %*s  %*s"",t        tag, -names_width, name,t        -(int)ACL_PERMS, acl_perm,tt-(int)ACL_PERMS, dacl_perm);tif (acl_names) {ttacl_get_entry(acl, ACL_NEXT_ENTRY, acl_ent);tt(*acl_names) = (*acl_names)->next;t}tif (dacl_names) {ttacl_get_entry(dacl, ACL_NEXT_ENTRY, dacl_ent);tt(*dacl_names) = (*dacl_names)->next;t}treturn 0;}",2,"cwe119,cwe120"
"gom_file_load(enum gom_info_types verb, char * fname,                   int is_settings_file, char * allowed_actions){tFILE * f;tchar fn_user[FILENAME_MAX];tchar fn_sys[FILENAME_MAX];tchar * fn = NULL;tenum gom_info_types open_err_verb = is_settings_file ? GOM_INFO_ERROR : verb;t tgom_file_fn_make (verb, fn_user, fname, is_settings_file, 0);tif ((f = fopen(fn_user, ""r"")) == NULL)t{tt ttgom_file_fn_make (verb, fn_sys, fname, is_settings_file, 1);ttif ((f = fopen(fn_sys, ""r"")) == NULL)tt{tttgom_info(open_err_verb,ttttttt ""No such file from stem ""%s"" (tried ""%s"" and ""%s"")."",ttttttt fname, fn_user, fn_sys);tttreturn;tt}ttelsett{tttfn = fn_sys;tt}t}telset{ttfn = fn_user;t}t tgom_info(verb, ""Loading option file from ""%s""..."", fn);tgom_file_options_read(verb+1, f, allowed_actions);tgom_info(verb, ""Option file load from ""%s"" completed."", fn);t tfclose(f);}",3,"cwe119,cwe120,cweother"
"sysfs_find_fd (int fd, char **path_p, int verbose){tstatic int have_prev = 0;tstatic dev_t prev;tstatic char path[PATH_MAX];tdev_t dev;tint err;tmemset(&dev, 0, sizeof(dev));terr = get_dev_from_fd(fd, &dev, verbose);tif (!err) {ttif (have_prev && 0 == memcmp(&dev, &prev, sizeof(dev))) {ttt tt} else {tttprev = dev;ttthave_prev = 1;ttterr = sysfs_find_dev(dev, path, verbose);tt}t}tif (err)tthave_prev = 0;telsett*path_p = path;treturn err;}",2,"cwe119,cwe120"
"rs_sta_dbgfs_scale_table_write(struct file *file,tttconst char __user *user_buf, size_t count, loff_t *ppos){tstruct iwl_lq_sta *lq_sta = file->private_data;tstruct iwl_priv *priv;tchar buf[64];tsize_t buf_size;tu32 parsed_rate;tpriv = lq_sta->drv;tmemset(buf, 0, sizeof(buf));tbuf_size = min(count, sizeof(buf) -  1);tif (copy_from_user(buf, user_buf, buf_size))ttreturn -EFAULT;tif (sscanf(buf, ""%x"", &parsed_rate) == 1)ttlq_sta->dbg_fixed_rate = parsed_rate;telsettlq_sta->dbg_fixed_rate = 0;trs_program_fix_rate(priv, lq_sta);treturn count;}",2,"cwe119,cwe120"
"show_smap_vma_flags(struct seq_file *m, struct vm_area_struct *vma){t tstatic const char mnemonics[BITS_PER_LONG][2] = {tt tt[0 ... (BITS_PER_LONG-1)] = ""??"",tt[ilog2(VM_READ)]t= ""rd"",tt[ilog2(VM_WRITE)]t= ""wr"",tt[ilog2(VM_EXEC)]t= ""ex"",tt[ilog2(VM_SHARED)]t= ""sh"",tt[ilog2(VM_MAYREAD)]t= ""mr"",tt[ilog2(VM_MAYWRITE)]t= ""mw"",tt[ilog2(VM_MAYEXEC)]t= ""me"",tt[ilog2(VM_MAYSHARE)]t= ""ms"",tt[ilog2(VM_GROWSDOWN)]t= ""gd"",tt[ilog2(VM_PFNMAP)]t= ""pf"",tt[ilog2(VM_DENYWRITE)]t= ""dw"",#ifdef CONFIG_X86_INTEL_MPXtt[ilog2(VM_MPX)]tt= ""mp"",#endiftt[ilog2(VM_LOCKED)]t= ""lo"",tt[ilog2(VM_IO)]tt= ""io"",tt[ilog2(VM_SEQ_READ)]t= ""sr"",tt[ilog2(VM_RAND_READ)]t= ""rr"",tt[ilog2(VM_DONTCOPY)]t= ""dc"",tt[ilog2(VM_DONTEXPAND)]t= ""de"",tt[ilog2(VM_ACCOUNT)]t= ""ac"",tt[ilog2(VM_NORESERVE)]t= ""nr"",tt[ilog2(VM_HUGETLB)]t= ""ht"",tt[ilog2(VM_ARCH_1)]t= ""ar"",tt[ilog2(VM_DONTDUMP)]t= ""dd"",#ifdef CONFIG_MEM_SOFT_DIRTYtt[ilog2(VM_SOFTDIRTY)]t= ""sd"",#endiftt[ilog2(VM_MIXEDMAP)]t= ""mm"",tt[ilog2(VM_HUGEPAGE)]t= ""hg"",tt[ilog2(VM_NOHUGEPAGE)]t= ""nh"",tt[ilog2(VM_MERGEABLE)]t= ""mg"",tt[ilog2(VM_UFFD_MISSING)]= ""um"",tt[ilog2(VM_UFFD_WP)]t= ""uw"",t};tsize_t i;tseq_puts(m, ""VmFlags: "");tfor (i = 0; i < BITS_PER_LONG; i++) {ttif (vma->vm_flags & (1UL << i)) {tttseq_printf(m, ""%c%c "",tttt   mnemonics[i][0], mnemonics[i][1]);tt}t}tseq_putc(m, '');}",2,"cwe119,cwe120"
"device_discovery(){   char buf[HPMUD_LINE_SIZE*64];   int cnt=0, bytes_read, r=1;     enum HPMUD_RESULT stat;   stat = hpmud_probe_devices(HPMUD_BUS_ALL, buf, sizeof(buf), &cnt, &bytes_read);   if (stat != HPMUD_R_OK)      goto bugout;   if (cnt == 0)#ifdef HAVE_CUPS11      fprintf(stdout, ""direct hp:/no_device_found ""Unknown"" ""hp no_device_found"""");#else      fprintf(stdout, ""direct hp ""Unknown"" ""HP Printer (HPLIP)"""");#endif   else      fprintf(stdout, ""%s"", buf);   r = 0;bugout:   return r;}",2,"cwe119,cwe120"
"EnvSlotTypes(  void *theEnv,  void *clsptr,  char *sname,  DATA_OBJECT *result)  {   register unsigned i,j;   register SLOT_DESC *sp;   char typemap[2];   unsigned msize;   if ((sp = SlotInfoSlot(theEnv,result,(DEFCLASS *) clsptr,sname,""slot-types"")) == NULL)     return;   if ((sp->constraint != NULL) ? sp->constraint->anyAllowed : TRUE)     {      typemap[0] = typemap[1] = (char) 0xFF;      ClearBitMap(typemap,MULTIFIELD);      msize = 8;     }   else     {      typemap[0] = typemap[1] = (char) 0x00;      msize = 0;      if (sp->constraint->symbolsAllowed)        {         msize++;         SetBitMap(typemap,SYMBOL);        }      if (sp->constraint->stringsAllowed)        {         msize++;         SetBitMap(typemap,STRING);        }      if (sp->constraint->floatsAllowed)        {         msize++;         SetBitMap(typemap,FLOAT);        }      if (sp->constraint->integersAllowed)        {         msize++;         SetBitMap(typemap,INTEGER);        }      if (sp->constraint->instanceNamesAllowed)        {         msize++;         SetBitMap(typemap,INSTANCE_NAME);        }      if (sp->constraint->instanceAddressesAllowed)        {         msize++;         SetBitMap(typemap,INSTANCE_ADDRESS);        }      if (sp->constraint->externalAddressesAllowed)        {         msize++;         SetBitMap(typemap,EXTERNAL_ADDRESS);        }      if (sp->constraint->factAddressesAllowed)        {         msize++;         SetBitMap(typemap,FACT_ADDRESS);        }     }   SetpDOEnd(result,msize);   result->value = EnvCreateMultifield(theEnv,msize);   i = 1;   j = 0;   while (i <= msize)     {      if (TestBitMap(typemap,j))       {        SetMFType(result->value,i,SYMBOL);        SetMFValue(result->value,i,                   (void *) GetDefclassNamePointer((void *)DefclassData(theEnv)->PrimitiveClassMap[j]));        i++;       }      j++;     }  }",2,"cwe119,cwe120"
"CheckSubType(char *bundletype,char *subtype){ int i,j;  struct SubTypeSyntax *ss;  char output[CF_BUFSIZE];  if (subtype == NULL)   {   snprintf(output,CF_BUFSIZE,""Missing promise type category for %s bundle"",bundletype);   ReportError(output);   return CF_NOSTYPE;   }for  (i = 0; i < CF3_MODULES; i++)   {   if ((ss = CF_ALL_SUBTYPES[i]) == NULL)      {      continue;      }      for (j = 0; ss[j].btype != NULL; j++)      {      if (subtype && strcmp(subtype,ss[j].subtype) == 0)         {         if ((strcmp(bundletype,ss[j].btype) == 0) || (strcmp(""*"",ss[j].btype) == 0))            {                         Debug(""Subtype %s syntax ok for %s"",subtype,bundletype);            return ss[j];            }         }      }   }snprintf(output,CF_BUFSIZE,""%s is not a valid type category for %s bundle"",subtype,bundletype);ReportError(output);snprintf(output,CF_BUFSIZE,""Possibly the bundle type ""%s"" itself is undefined"",bundletype);ReportError(output);return CF_NOSTYPE;}",2,"cwe119,cwe120"
"_snd_pcm_copy_chmap(const snd_pcm_chmap_t *src){tsnd_pcm_chmap_t *map;tmap = malloc((src->channels + 1) * sizeof(int));tif (!map)ttreturn NULL;tmemcpy(map, src, (src->channels + 1) * sizeof(int));treturn map;}",2,"cwe120,cweother"
"crypt_init_arcfour128(LIBSSH2_SESSION * session,                      const LIBSSH2_CRYPT_METHOD * method,                      unsigned char *iv, int *free_iv,                      unsigned char *secret, int *free_secret,                      int encrypt, void **abstract){    int rc;    rc = crypt_init (session, method, iv, free_iv, secret, free_secret,                     encrypt, abstract);    if (rc == 0) {        struct crypt_ctx *cctx = *(struct crypt_ctx **) abstract;        unsigned char block[8];        size_t discard = 1536;        for (; discard; discard -= 8)            _libssh2_cipher_crypt(&cctx->h, cctx->algo, cctx->encrypt, block,                                  method->blocksize);    }    return rc;}",2,"cwe119,cwe120"
"st_modify_nonidx(SearchThread *st){    LDAPMod *attrs[2];    LDAPMod attr_description;    int e;    int rval;    char *dn = NULL;    char description[256];    char *description_values[2];         if (NULL == sdattable || sdt_getlen(sdattable) == 0) {        fprintf(stderr, ""-m option requires a DN file.  Use -B file."");        return 0;    }         do {        e = sdt_getrand(sdattable);    } while (e < 0);    dn = sdt_dn_get(sdattable, e);    sprintf(description, ""%s modified at %lu"", dn, time(NULL));    description_values[0] = description;    description_values[1] = NULL;    attrs[0] = &attr_description;    attrs[1] = NULL;    attr_description.mod_op = LDAP_MOD_REPLACE;    attr_description.mod_type = ""description"";    attr_description.mod_values = description_values;    rval = ldap_modify_ext_s(st->ld, dn, attrs, NULL, NULL);    if (rval != LDAP_SUCCESS) {        fprintf(stderr, ""T%d: Failed to modify error=0x%x"", st->id, rval);        fprintf(stderr, ""dn: %s"", dn);    }    return rval;}",2,"cwe119,cwe120"
"intel_lpss_register_clock(struct intel_lpss *lpss){tconst struct mfd_cell *cell = lpss->cell;tstruct clk *clk;tchar devname[24];tint ret;tif (!lpss->info->clk_rate)ttreturn 0;t tclk = clk_register_fixed_rate(NULL, dev_name(lpss->dev), NULL,tttt      CLK_IS_ROOT, lpss->info->clk_rate);tif (IS_ERR(clk))ttreturn PTR_ERR(clk);tsnprintf(devname, sizeof(devname), ""%s.%d"", cell->name, lpss->devid);t tif (lpss->type != LPSS_DEV_I2C) {ttret = intel_lpss_register_clock_divider(lpss, devname, &clk);ttif (ret)tttgoto err_clk_register;t}tret = -ENOMEM;t tlpss->clock = clkdev_create(clk, lpss->info->clk_con_id, ""%s"", devname);tif (!lpss->clock)ttgoto err_clk_register;tlpss->clk = clk;treturn 0;err_clk_register:tintel_lpss_unregister_clock_tree(clk);treturn ret;}",2,"cwe119,cwe120"
"_nrrdHestKernelSpecParse(void *ptr, char *str, char err[AIR_STRLEN_HUGE]) {  NrrdKernelSpec **ksP;  char me[]=""_nrrdHestKernelSpecParse"", *nerr;  if (!(ptr && str)) {    sprintf(err, ""%s: got NULL pointer"", me);    return 1;  }  ksP = (NrrdKernelSpec **)ptr;  *ksP = nrrdKernelSpecNew();  if (nrrdKernelParse(&((*ksP)->kernel), (*ksP)->parm, str)) {    nerr = biffGetDone(NRRD);    airStrcpy(err, AIR_STRLEN_HUGE, nerr);    free(nerr);    return 1;  }  return 0;}",2,"cwe119,cwe120"
"mk_password_hash(passwd_ctx *ctx){    char *pw;    char salt[16];    apr_status_t rv;    int ret = 0;#if CRYPT_ALGO_SUPPORTED    char *cbuf;#endif    pw = ctx->passwd;    switch (ctx->alg) {    case ALG_APSHA:                 apr_sha1_base64(pw, strlen(pw), ctx->out);        break;    case ALG_APMD5:        ret = generate_salt(salt, 8, &ctx->errstr, ctx->pool);        if (ret != 0) {            ret = ERR_GENERAL;            break;        }        rv = apr_md5_encode(pw, salt, ctx->out, ctx->out_len);        if (rv != APR_SUCCESS) {            ctx->errstr = apr_psprintf(ctx->pool,                                       ""could not encode password: %pm"", &rv);            ret = ERR_GENERAL;        }        break;#if CRYPT_ALGO_SUPPORTED    case ALG_CRYPT:        ret = generate_salt(salt, 8, &ctx->errstr, ctx->pool);        if (ret != 0)            break;        cbuf = crypt(pw, salt);        if (cbuf == NULL) {            rv = APR_FROM_OS_ERROR(errno);            ctx->errstr = apr_psprintf(ctx->pool, ""crypt() failed: %pm"", &rv);            ret = ERR_PWMISMATCH;            break;        }        apr_cpystrn(ctx->out, cbuf, ctx->out_len - 1);        if (strlen(pw) > 8) {            char *truncpw = apr_pstrdup(ctx->pool, pw);            truncpw[8] = '0';            if (!strcmp(ctx->out, crypt(truncpw, salt))) {                ctx->errstr = apr_psprintf(ctx->pool,                                           ""Warning: Password truncated to 8 ""                                           ""characters by CRYPT algorithm."");            }            memset(truncpw, '0', strlen(pw));        }        break;#endif  #if BCRYPT_ALGO_SUPPORTED    case ALG_BCRYPT:        rv = apr_generate_random_bytes((unsigned char*)salt, 16);        if (rv != APR_SUCCESS) {            ctx->errstr = apr_psprintf(ctx->pool, ""Unable to generate random ""                                       ""bytes: %pm"", &rv);            ret = ERR_RANDOM;            break;        }        if (ctx->cost == 0)            ctx->cost = BCRYPT_DEFAULT_COST;        rv = apr_bcrypt_encode(pw, ctx->cost, (unsigned char*)salt, 16,                               ctx->out, ctx->out_len);        if (rv != APR_SUCCESS) {            ctx->errstr = apr_psprintf(ctx->pool, ""Unable to encode with ""                                       ""bcrypt: %pm"", &rv);            ret = ERR_PWMISMATCH;            break;        }        break;#endif      default:        ctx->errstr = apr_psprintf(ctx->pool,                                  ""mk_password_hash(): unsupported algorithm %d"",                                  ctx->alg);        ret = ERR_GENERAL;    }    memset(pw, '0', strlen(pw));    return ret;}",3,"cwe119,cwe120,cweother"
"imagetopgx(opj_image_t * image, const char *outfile) {tint w, h;tint i, j, compno;tFILE *fdest = NULL;tfor (compno = 0; compno < image->numcomps; compno++) {ttopj_image_comp_t *comp = &image->comps[compno];ttchar bname[256];      char *name = bname;      int nbytes = 0;    size_t res;    const size_t olen = strlen(outfile);    const size_t dotpos = olen - 4;    const size_t total = dotpos + 1 + 1 + 4;      if( outfile[dotpos] != '.' ) {             fprintf(stderr, ""ERROR -> Impossible happen."" );      return 1;      }    if( total > 256 ) {      name = (char*)malloc(total+1);      }    strncpy(name, outfile, dotpos);tt tttsprintf(name+dotpos, ""_%d.pgx"", compno);tt ttfdest = fopen(name, ""wb"");ttif (!fdest) {tttfprintf(stderr, ""ERROR -> failed to open %s for writing"", name);tttreturn 1;tt}         if( total > 256 ) {      free(name);      }ttw = image->comps[compno].w;tth = image->comps[compno].h;t    ttfprintf(fdest, ""PG ML %c %d %d %d"", comp->sgnd ? '-' : '+', comp->prec, w, h);ttif (comp->prec <= 8) {tttnbytes = 1;tt} else if (comp->prec <= 16) {tttnbytes = 2;tt} else {tttnbytes = 4;tt}ttfor (i = 0; i < w * h; i++) {tttint v = image->comps[compno].data[i];tttfor (j = nbytes - 1; j >= 0; j--) {ttttchar byte = (char) (v >> (j * 8));ttttres = fwrite(&byte, 1, 1, fdest);        if( res < 1 ) {          fprintf(stderr, ""failed to write 1 byte for %s"", name);          return 1;        }ttt}tt}ttfclose(fdest);t}treturn 0;}",3,"cwe119,cwe120,cweother"
"file_checksum(char *file, long *retsum){tint i;tint fd;tssize_t cnt;tchar buf[MIN_PAGE_SIZE];tlong csum;tif ((fd = open(file, O_RDONLY)) < 0)ttreturn FALSE;tcsum = 0;tBZERO(buf, MIN_PAGE_SIZE);twhile ((cnt = read(fd, buf, MIN_PAGE_SIZE)) > 0) {ttfor (i = 0; i < cnt; i++)tttcsum += buf[i];ttBZERO(buf, MIN_PAGE_SIZE);t}tclose(fd);t*retsum = csum;treturn TRUE;}",3,"cwe119,cwe120,cweother"
"stdout_service (output_plugin* unused, asset *main, serv_asset *service, connection *c){    static char ip_addr_s[INET6_ADDRSTRLEN];    uint8_t tmp_ttl;    u_ntop(main->ip_addr, main->af, ip_addr_s);    printf(""%s"", ip_addr_s);    if (main->vlan != 0) printf("",[vlan:%u]"", ntohs(main->vlan));    if (service->role == SC_SERVER) {        printf("",[service:%s:%u:%u]"",        (char *)bdata(service->application),        ntohs(service->port),service->proto);    } else {        printf("",[client:%s:%u:%u]"",        (char*)bdata(service->application),        ntohs(service->port),service->proto);    }    if (service->ttl) {        tmp_ttl = normalize_ttl(service->ttl);        printf("",[distance:%d]"",tmp_ttl - service->ttl);    }    printf("""");    fflush(0);}",2,"cwe119,cwe120"
"kmo_wave_guess_table_update_1 (const char *filename,        int global_ifu_nr,   const char *filter_id,        cpl_vector *positions, cpl_vector *lambdas) {    cpl_table* table = NULL;    char *coeff_cols[NR_COEFFS_COLS] = {COEFF_COLS};    int selected_row;     cpl_size pows[1];    KMO_TRY    {   cpl_polynomial *poly = cpl_polynomial_new(1);double *px = cpl_vector_get_data((cpl_vector*)positions);cpl_matrix *x_matrix = cpl_matrix_wrap(1, cpl_vector_get_size(positions), px);const cpl_boolean   sampsym     = CPL_FALSE;cpl_size mindeg1d    = 0,              maxdeg1d    = 3;cpl_polynomial_fit(poly,                   x_matrix,                   &sampsym,                   lambdas,                   NULL,                   CPL_FALSE,                   &mindeg1d,                   &maxdeg1d);         table = kmo_wave_guess_table_open(filename, 1);        selected_row = kmo_wave_guess_table_get_column(table, filter_id, global_ifu_nr);        int ix = 0;        for (ix = 0; ix < NR_COEFFS_COLS; ix++) {            pows[0] = ix;            KMO_TRY_EXIT_IF_ERROR(                    cpl_table_set_double(table, coeff_cols[ix], selected_row,                            cpl_polynomial_get_coeff(poly, pows)));        }        KMO_TRY_EXIT_IF_ERROR(                cpl_table_fill_invalid_int(table, ""IFU"", -1));        KMO_TRY_EXIT_IF_ERROR(                cpl_table_save(table, NULL, NULL, filename, CPL_IO_CREATE));    } KMO_CATCH {        KMO_CATCH_MSG();    }    cpl_table_delete(table);}",2,"cwe119,cwe120"
"ipr_update_res_entry(struct ipr_resource_entry *res,tttt struct ipr_config_table_entry_wrapper *cfgtew){tchar buffer[IPR_MAX_RES_PATH_LENGTH];tunsigned int proto;tint new_path = 0;tif (res->ioa_cfg->sis64) {ttres->flags = be16_to_cpu(cfgtew->u.cfgte64->flags);ttres->res_flags = be16_to_cpu(cfgtew->u.cfgte64->res_flags);ttres->type = cfgtew->u.cfgte64->res_type;ttmemcpy(&res->std_inq_data, &cfgtew->u.cfgte64->std_inq_data,tttsizeof(struct ipr_std_inq_data));ttres->qmodel = IPR_QUEUEING_MODEL64(res);ttproto = cfgtew->u.cfgte64->proto;ttres->res_handle = cfgtew->u.cfgte64->res_handle;ttres->dev_id = cfgtew->u.cfgte64->dev_id;ttmemcpy(&res->dev_lun.scsi_lun, &cfgtew->u.cfgte64->lun,tttsizeof(res->dev_lun.scsi_lun));ttif (memcmp(res->res_path, &cfgtew->u.cfgte64->res_path,tttttsizeof(res->res_path))) {tttmemcpy(res->res_path, &cfgtew->u.cfgte64->res_path,ttttsizeof(res->res_path));tttnew_path = 1;tt}ttif (res->sdev && new_path)tttsdev_printk(KERN_INFO, res->sdev, ""Resource path: %s"",tttt    ipr_format_res_path(res->ioa_cfg,tttttres->res_path, buffer, sizeof(buffer)));t} else {ttres->flags = cfgtew->u.cfgte->flags;ttif (res->flags & IPR_IS_IOA_RESOURCE)tttres->type = IPR_RES_TYPE_IOAFP;ttelsetttres->type = cfgtew->u.cfgte->rsvd_subtype & 0x0f;ttmemcpy(&res->std_inq_data, &cfgtew->u.cfgte->std_inq_data,tttsizeof(struct ipr_std_inq_data));ttres->qmodel = IPR_QUEUEING_MODEL(res);ttproto = cfgtew->u.cfgte->proto;ttres->res_handle = cfgtew->u.cfgte->res_handle;t}tipr_update_ata_class(res, proto);}",2,"cwe119,cwe120"
"get_qm_name(char *master_host,const char *master_file,char *err_str ) {   FILE *fp;   char buf[CL_MAXHOSTLEN*3+1], *cp, *first;   int len;   DENTER(TOP_LAYER, ""get_qm_name"");      if (!master_host || !master_file) {      if (err_str) {         if (master_host) {            sprintf(err_str, MSG_GDI_NULLPOINTERPASSED );         }      }         DRETURN(-1);   }   if (!(fp=fopen(master_file,""r""))) {      ERROR((SGE_EVENT, MSG_GDI_FOPEN_FAILED, master_file, strerror(errno)));      if (err_str) {         sprintf(err_str, MSG_GDI_OPENMASTERFILEFAILED_S , master_file);      }         DRETURN(-1);   }           if (!(len = fread(buf, 1, CL_MAXHOSTLEN*3, fp))) {      if (err_str) {         sprintf(err_str, MSG_GDI_READMASTERHOSTNAMEFAILED_S , master_file);      }      }   buf[len] = '0';          cp = buf;   while (*cp && (*cp == ' ' || *cp == 't' || *cp == ''))      cp++;      first = cp;       while (*cp && !(*cp == ' ' || *cp == 't' || *cp == '')) {      cp++;   }            *cp = '0';   len = cp - first;   if (len == 0) {      if (err_str) {         sprintf(err_str, MSG_GDI_MASTERHOSTNAMEHASZEROLENGTH_S , master_file);      }         FCLOSE(fp);      DRETURN(-1);   }             if (len > CL_MAXHOSTLEN - 1) {      if (err_str) {         sprintf(err_str, MSG_GDI_MASTERHOSTNAMEEXCEEDSCHARS_SI ,                  master_file, (int) CL_MAXHOSTLEN);         sprintf(err_str, """");      }         FCLOSE(fp);      DRETURN(-1);   }   FCLOSE(fp);   strcpy(master_host, first);   DRETURN(0);FCLOSE_ERROR:   DRETURN(-1);}",3,"cwe119,cwe120,cweother"
"clear_wakeup(AvahiSimplePoll *s) {    char c[10];      if (!s->wakeup_issued)        return;    s->wakeup_issued = 0;    for(;;)        if (read(s->wakeup_pipe[0], &c, sizeof(c)) != sizeof(c))            break;}",3,"cwe119,cwe120,cweother"
"rebase_next_merge(tgit_rebase_operation **out,tgit_rebase *rebase){tgit_buf path = GIT_BUF_INIT;tgit_commit *current_commit = NULL, *parent_commit = NULL;tgit_tree *current_tree = NULL, *head_tree = NULL, *parent_tree = NULL;tgit_index *index = NULL;tgit_indexwriter indexwriter = GIT_INDEXWRITER_INIT;tgit_rebase_operation *operation;tgit_checkout_options checkout_opts;tchar current_idstr[GIT_OID_HEXSZ];tunsigned int parent_count;tint error;t*out = NULL;tif ((error = rebase_movenext(rebase)) < 0)ttgoto done;toperation = git_array_get(rebase->operations, rebase->current);tif ((error = git_commit_lookup(&current_commit, rebase->repo, &operation->id)) < 0 ||tt(error = git_commit_tree(&current_tree, current_commit)) < 0 ||tt(error = git_repository_head_tree(&head_tree, rebase->repo)) < 0)ttgoto done;tif ((parent_count = git_commit_parentcount(current_commit)) > 1) {ttgiterr_set(GITERR_REBASE, ""Cannot rebase a merge commit"");tterror = -1;ttgoto done;t} else if (parent_count) {ttif ((error = git_commit_parent(&parent_commit, current_commit, 0)) < 0 ||ttt(error = git_commit_tree(&parent_tree, parent_commit)) < 0)tttgoto done;t}tgit_oid_fmt(current_idstr, &operation->id);tnormalize_checkout_options_for_apply(&checkout_opts, rebase, current_commit);tif ((error = git_indexwriter_init_for_operation(&indexwriter, rebase->repo, &checkout_opts.checkout_strategy)) < 0 ||tt(error = rebase_setupfile(rebase, MSGNUM_FILE, -1, ""%d"", rebase->current+1)) < 0 ||tt(error = rebase_setupfile(rebase, CURRENT_FILE, -1, ""%.*s"", GIT_OID_HEXSZ, current_idstr)) < 0 ||tt(error = git_merge_trees(&index, rebase->repo, parent_tree, head_tree, current_tree, NULL)) < 0 ||tt(error = git_merge__check_result(rebase->repo, index)) < 0 ||tt(error = git_checkout_index(rebase->repo, index, &checkout_opts)) < 0 ||tt(error = git_indexwriter_commit(&indexwriter)) < 0)ttgoto done;t*out = operation;done:tgit_indexwriter_cleanup(&indexwriter);tgit_index_free(index);tgit_tree_free(current_tree);tgit_tree_free(head_tree);tgit_tree_free(parent_tree);tgit_commit_free(parent_commit);tgit_commit_free(current_commit);tgit_buf_free(&path);treturn error;}",2,"cwe119,cwe120"
"show_color_name(int y, int x, int color, bool wide){    if (move(y, x) != ERR) {tchar temp[80];tint width = 8;tif (wide) {t    sprintf(temp, ""%02d"", color);t    width = 4;t} else if (color >= 8) {t    sprintf(temp, ""[%02d]"", color);t} else {t    strcpy(temp, the_color_names[color]);t}tprintw(""%-*.*s"", width, width, temp);    }}",2,"cwe119,cwe120"
"cachemgrRegister(const char *action, const char *desc, OBJH * handler, int pw_req_flag, int atomic){    action_table *a;    action_table **A;    if (cachemgrFindAction(action) != NULL) {tdebug(16, 3) (""cachemgrRegister: Duplicate '%s'"", action);treturn;    }    a = xcalloc(1, sizeof(action_table));    a->action = xstrdup(action);    a->desc = xstrdup(desc);    a->handler = handler;    a->flags.pw_req = pw_req_flag;    a->flags.atomic = atomic;    for (A = &ActionTable; *A; A = &(*A)->next);    *A = a;    debug(16, 3) (""cachemgrRegister: registered %s"", action);}",2,"cwe120,cweother"
"indi_dev_enable_blob(struct indi_device_t *idev, int state){tchar msg[1024];tif (idev) {ttsprintf(msg, ""<enableBLOB device=""%s"">%s</enableBLOB>"", idev->name, state ? ""Also"" : ""Never"");ttdbg_printf(""sending (%lu):%s"", (unsigned long)strlen(msg), msg);ttio_indi_sock_write(idev->indi->fh, msg, strlen(msg));t}}",2,"cwe119,cwe120"
"print_version_number(VOID){  if((full_output || !quiet) && !print_version)    (void)fprintf(list_fd,"""");  (void)fprintf(list_fd,""%s"",VERSION_NUMBER);  if(help_screen || print_version)    (void)fprintf(list_fd,"" %s"",PATCHLEVEL);  if(full_output || !quiet || print_version)    (void)fprintf(list_fd,"""");}",2,"cwe120,cweother"
"copy_templates(const char *template_dir){tchar path[PATH_MAX];tchar template_path[PATH_MAX];tint template_len;tDIR *dir;tconst char *git_dir = get_git_dir();tint len = strlen(git_dir);tif (!template_dir)tttemplate_dir = getenv(TEMPLATE_DIR_ENVIRONMENT);tif (!template_dir)tttemplate_dir = init_db_template_dir;tif (!template_dir)tttemplate_dir = system_path(DEFAULT_GIT_TEMPLATE_DIR);tif (!template_dir[0])ttreturn;ttemplate_len = strlen(template_dir);tif (PATH_MAX <= (template_len+strlen(""/config"")))ttdie(_(""insanely long template path %s""), template_dir);tstrcpy(template_path, template_dir);tif (template_path[template_len-1] != '/') {tttemplate_path[template_len++] = '/';tttemplate_path[template_len] = 0;t}tdir = opendir(template_path);tif (!dir) {ttwarning(_(""templates not found %s""), template_dir);ttreturn;t}t tstrcpy(template_path + template_len, ""config"");trepository_format_version = 0;tgit_config_from_file(check_repository_format_version,ttt     template_path, NULL);ttemplate_path[template_len] = 0;tif (repository_format_version &&t    repository_format_version != GIT_REPO_VERSION) {ttwarning(_(""not copying templates of ""ttt""a wrong format version %d from '%s'""),tttrepository_format_version,ttttemplate_dir);ttclosedir(dir);ttreturn;t}tmemcpy(path, git_dir, len);tif (len && path[len - 1] != '/')ttpath[len++] = '/';tpath[len] = 0;tcopy_templates_1(path, len,ttt template_path, template_len,ttt dir);tclosedir(dir);}",4,"cwe119,cwe120,cwe476,cweother"
"__ipset_cmd(const char *name, in_addr_t addr, int cmd, int flags){tstruct rtnl_handle rth;tstruct req {ttstruct nlmsghdr n;ttstruct nfgenmsg nf;ttchar buf[4096];t} req;tstruct rtattr *tail1, *tail2;tuint8_t protocol = IPSET_PROTOCOL;tif (rtnl_open_byproto(&rth, 0, NETLINK_NETFILTER)) {ttlog_error(""ipset: cannot open rtnetlink"");ttreturn -1;t}ttmemset(&req, 0, sizeof(req) - 4096);treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct nfgenmsg));treq.n.nlmsg_flags = flags;treq.n.nlmsg_type = cmd | (NFNL_SUBSYS_IPSET << 8);treq.nf.nfgen_family = AF_INET;treq.nf.version = NFNETLINK_V0;treq.nf.res_id = 0;taddattr_l(&req.n, 4096, IPSET_ATTR_PROTOCOL, &protocol, 1);taddattr_l(&req.n, 4096, IPSET_ATTR_SETNAME, name, strlen(name) + 1);tttail1 = addattr_nest(&req.n, MAX_MSG, IPSET_ATTR_DATA | NLA_F_NESTED);ttail2 = addattr_nest(&req.n, MAX_MSG, IPSET_ATTR_IP | NLA_F_NESTED);taddattr32(&req.n, 4096, IPSET_ATTR_IPADDR_IPV4 | NLA_F_NET_BYTEORDER, addr);taddattr_nest_end(&req.n, tail2);ttaddattr_nest_end(&req.n, tail1);ttif (rtnl_talk(&rth, &req.n, 0, 0, NULL, NULL, NULL, 0) < 0)ttgoto out_err;ttrtnl_close(&rth);treturn 0;out_err:trtnl_close(&rth);treturn -1;}",2,"cwe119,cwe120"
"open_packed_git_1(struct packed_git *p){tstruct stat st;tstruct pack_header hdr;tunsigned char sha1[20];tunsigned char *idx_sha1;tlong fd_flag;tif (!p->index_data && open_pack_index(p))ttreturn error(""packfile %s index unavailable"", p->pack_name);tp->pack_fd = open(p->pack_name, O_RDONLY);tif (p->pack_fd < 0 || fstat(p->pack_fd, &st))ttreturn -1;t tif (!p->pack_size) {ttif (!S_ISREG(st.st_mode))tttreturn error(""packfile %s not a regular file"", p->pack_name);ttp->pack_size = st.st_size;t} else if (p->pack_size != st.st_size)ttreturn error(""packfile %s size changed"", p->pack_name);t tfd_flag = fcntl(p->pack_fd, F_GETFD, 0);tif (fd_flag < 0)ttreturn error(""cannot determine file descriptor flags"");tfd_flag |= FD_CLOEXEC;tif (fcntl(p->pack_fd, F_SETFD, fd_flag) == -1)ttreturn error(""cannot set FD_CLOEXEC"");t tif (read_in_full(p->pack_fd, &hdr, sizeof(hdr)) != sizeof(hdr))ttreturn error(""file %s is far too short to be a packfile"", p->pack_name);tif (hdr.hdr_signature != htonl(PACK_SIGNATURE))ttreturn error(""file %s is not a GIT packfile"", p->pack_name);tif (!pack_version_ok(hdr.hdr_version))ttreturn error(""packfile %s is version %u and not supported""ttt"" (try upgrading GIT to a newer version)"",tttp->pack_name, ntohl(hdr.hdr_version));t tif (p->num_objects != ntohl(hdr.hdr_entries))ttreturn error(""packfile %s claims to have %u objects""ttt     "" while index indicates %u objects"",ttt     p->pack_name, ntohl(hdr.hdr_entries),ttt     p->num_objects);tif (lseek(p->pack_fd, p->pack_size - sizeof(sha1), SEEK_SET) == -1)ttreturn error(""end of packfile %s is unavailable"", p->pack_name);tif (read_in_full(p->pack_fd, sha1, sizeof(sha1)) != sizeof(sha1))ttreturn error(""packfile %s signature is unavailable"", p->pack_name);tidx_sha1 = ((unsigned char *)p->index_data) + p->index_size - 40;tif (hashcmp(sha1, idx_sha1))ttreturn error(""packfile %s does not match index"", p->pack_name);treturn 0;}",3,"cwe119,cwe120,cweother"
"refine_solid_read (GtsObject ** o, GtsFile * fp){  GfsRefineSolid * refine = GFS_REFINE_SOLID (*o);  GfsDerivedVariableInfo v = { ""SolidCurvature"", ""curvature of the solid boundary"",ttt       solid_curvature };  refine->v = gfs_domain_add_derived_variable (GFS_DOMAIN (gfs_object_simulation (*o)), v);  if (!refine->v) {    gts_file_error (fp, ""derived variable `SolidCurvature' already defined"");    return;  }  (* GTS_OBJECT_CLASS (gfs_refine_solid_class ())->parent_class->read) (o, fp);}",2,"cwe120,cweother"
"tex_print_VECM_omega (GRETL_VAR *vecm, const DATASET *dset, PRN *prn){    char vname[48];    const int *list = vecm->ylist;    double x;    int i, j;    pprintf(prn, ""%s"", A_(""Cross-equation covariance matrix""));    pputs(prn, ""vspace{1em}"");    pputs(prn, ""begin{tabular}{"");    pputs(prn, ""l"");    for (i=0; i<vecm->neqns; i++) {tpputs(prn, ""r"");    }    pputs(prn, ""} & "");    for (i=0; i<vecm->neqns; i++) {ttex_escape(vname, dset->varname[list[i+1]]);tpprintf(prn, ""$Delta$%s "", vname);tif (i == vecm->neqns - 1) {t    pputs(prn, """");t} else {t    pputs(prn, ""& "");t}    }    pputc(prn, '');    for (i=0; i<vecm->neqns; i++) {ttex_escape(vname, dset->varname[list[i+1]]);tpprintf(prn, ""$Delta$%s & "", vname);tfor (j=0; j<vecm->neqns; j++) {t    x = gretl_matrix_get(vecm->S, i, j);t    tex_print_double(x, prn);t    if (j == vecm->neqns - 1) {ttpputs(prn, """");t    } else {ttpputs(prn, "" & "");t    }t}    }    pputs(prn, ""end{tabular}"");    pputs(prn, ""vspace{1em}"");    pputs(prn, ""oindent"");    pprintf(prn, ""%s = "", A_(""determinant""));    tex_print_double(exp(vecm->ldet), prn);    pputs(prn, """");}",2,"cwe119,cwe120"
"reg_vpi_force(register struct net_t *np, word32 *ap, word32 *bp){ register struct qcval_t *assgn_qcp, *frc_qcp; char s3[RECLEN], s4[RECLEN]; strcpy(__wrks1, """");   if (!np->frc_assgn_allocated)  {           np->frc_assgn_allocated = TRUE;   if (np->nu2.qcval == NULL) __alloc_qcval(np);  } frc_qcp = &(np->nu2.qcval[2*__inum]); assgn_qcp = &(np->nu2.qcval[2*__inum + 1]);   if (frc_qcp->qc_active)  {    frc_qcp->qcstp = NULL;   frc_qcp->qcrhsbi = -1;   frc_qcp->qclhsbi = -1;   frc_qcp->lhsitp = NULL;   strcat(__wrks1, "" replace force"");  }     else if (assgn_qcp->qc_active)  {   assgn_qcp->qc_active = FALSE;   strcat(__wrks1, "" override assign"");  } else  {       frc_qcp->qcstp = NULL;   frc_qcp->qcrhsbi = -1;   frc_qcp->qclhsbi = -1;   frc_qcp->lhsitp = NULL;  }   frc_qcp->qc_active = TRUE; if (__debug_flg && __ev_tracing)  {   __tr_msg("":: vpi_put_value%s force of reg %s to %s in %s now %s"",    __wrks1, np->nsym->synam, __regab_tostr(s3, ap, bp, np->nwid, BHEX, FALSE),    __msg2_blditree(s4, __inst_ptr), __to_timstr(__wrks2, &__simtime));  } __chg_st_val(np, ap, bp);   if (__num_vpi_force_cbs > 0) __find_call_force_cbs(np, -1); if (__vpi_force_cb_always) __cb_all_rfs(np, -1, TRUE);}",2,"cwe119,cwe120"
"jswrap_object_on(JsVar *parent, JsVar *event, JsVar *listener) {  if (!jsvIsObject(parent)) {      jsWarn(""Parent must be a proper object - not a String, Integer, etc."");      return;    }  if (!jsvIsString(event)) {      jsWarn(""First argument to EventEmitter.on(..) must be a string"");      return;    }  if (!jsvIsFunction(listener) && !jsvIsString(listener)) {    jsWarn(""Second argument to EventEmitter.on(..) must be a function or a String (containing code)"");    return;  }  char eventName[16] = ""#on"";  jsvGetString(event, &eventName[3], sizeof(eventName)-4);  JsVar *eventList = jsvFindChildFromString(parent, eventName, true);  JsVar *eventListeners = jsvSkipName(eventList);  if (jsvIsUndefined(eventListeners)) {         jsvSetValueOfName(eventList, listener);  } else {    if (jsvIsArray(eventListeners)) {             jsvArrayPush(eventListeners, listener);    } else {             JsVar *arr = jsvNewWithFlags(JSV_ARRAY);      jsvArrayPush(arr, eventListeners);      jsvArrayPush(arr, listener);      jsvSetValueOfName(eventList, arr);      jsvUnLock(arr);    }  }  jsvUnLock(eventListeners);  jsvUnLock(eventList);     if (jsvIsStringEqual(event, ""data"")) {    JsVar *buf = jsvObjectGetChild(parent, STREAM_BUFFER_NAME, 0);    if (jsvIsString(buf)) {      jsiQueueObjectCallbacks(parent, ""#ondata"", &buf, 1);      jsvRemoveNamedChild(parent, STREAM_BUFFER_NAME);    }    jsvUnLock(buf);  }}",2,"cwe119,cwe120"
enlarge_goal(signed char goal[BOARDMAX]){  int pos;  for (pos = BOARDMIN; pos < BOARDMAX; pos++) {    if (board[pos] == EMPTY && !goal[pos]) {      int k;      int goal_neighbors = 0;      for (k = 0; k < 4; k++)tif (board[pos + delta[k]] == EMPTY && goal[pos + delta[k]] == 1)t  goal_neighbors++;      if (goal_neighbors >= 2)tgoal[pos] = 2;    }  }},2,"cwe119,cwe120"
"oxc_sent_pop(Boxc *conn, Msg *m, Msg **orig){    Octstr *os;    char id[UUID_STR_LEN + 1];    Msg *msg;    if (conn->is_wap || !conn->sent || !m || (msg_type(m) != ack && msg_type(m) != sms))        return;    if (orig != NULL)        *orig = NULL;        uuid_unparse((msg_type(m) == sms ? m->sms.id : m->ack.id), id);    os = octstr_create(id);    msg = dict_remove(conn->sent, os);    octstr_destroy(os);    if (!msg) {        error(0, ""BOXC: Got ack for nonexistend message!"");        msg_dump(m, 0);        return;    }    semaphore_up(conn->pending);    if (orig == NULL)        msg_destroy(msg);    else        *orig = msg;}",2,"cwe119,cwe120"
"jack_controller_serialize_parameter(void * context, const struct jack_parameter * param_ptr){    char value[JACK_PARAM_STRING_MAX + 1];    if (!param_ptr->vtable.is_set(param_ptr->obj))    {        return true;    }    jack_controller_serialize_parameter_value(param_ptr, value);    return        jack_controller_settings_write_string(fd, ctx_ptr->indent, ctx_ptr->call) &&        jack_controller_settings_write_string(fd, ""<option name="""", ctx_ptr->call) &&        jack_controller_settings_write_string(fd, param_ptr->name, ctx_ptr->call) &&        jack_controller_settings_write_string(fd, """">"", ctx_ptr->call) &&        jack_controller_settings_write_string(fd, value, ctx_ptr->call) &&        jack_controller_settings_write_string(fd, ""</option>"", ctx_ptr->call);}",2,"cwe119,cwe120"
"ssl_password_cb(char *buf, int size, int rwflag, void *userdata){tsighandler_typetsaveint;tchart*pass = NULL;tinttlen;t(void)&saveint;t(void)&pass;tsaveint = safe_signal(SIGINT, SIG_IGN);tif (sigsetjmp(ssljmp, 1) == 0) {ttif (saveint != SIG_IGN)tttsafe_signal(SIGINT, sslcatch);ttpass = getpassword(&otio, &reset_tio, ""PEM pass phrase:"");t}tsafe_signal(SIGINT, saveint);tif (pass == NULL)ttreturn 0;tlen = strlen(pass);tif (len > size)ttlen = size;tmemcpy(buf, pass, len);treturn len;}",2,"cwe120,cweother"
"gateway_auth_cb(DBusError *derr, void *user_data){tstruct audio_device *device = user_data;tif (derr && dbus_error_is_set(derr)) {tterror(""Access denied: %s"", derr->message);ttgateway_set_state(device, GATEWAY_STATE_DISCONNECTED);t} else {ttchar ag_address[18];ttba2str(&device->dst, ag_address);ttDBG(""Accepted AG connection from %s for %s"",tttag_address, device->path);ttgateway_start_service(device);t}}",2,"cwe119,cwe120"
"log_error(const char *msg, int fatal){    char cwd[GPATH_MAX];    time_t clock;    char *gisbase;         clock = time(NULL);         getcwd(cwd, sizeof(cwd));         if ((gisbase = G_gisbase()))twrite_error(msg, fatal, clock, cwd);    return 0;}",2,"cwe119,cwe120"
"evalMode(int argc, char **argv) {    sds script = sdsempty();    FILE *fp;    char buf[1024];    size_t nread;    char **argv2;    int j, got_comma = 0, keys = 0;         fp = fopen(config.eval,""r"");    if (!fp) {        fprintf(stderr,            ""Can't open file '%s': %s"", config.eval, strerror(errno));        exit(1);    }    while((nread = fread(buf,1,sizeof(buf),fp)) != 0) {        script = sdscatlen(script,buf,nread);    }    fclose(fp);         argv2 = zmalloc(sizeof(sds)*(argc+3));    argv2[0] = sdsnew(""EVAL"");    argv2[1] = script;    for (j = 0; j < argc; j++) {        if (!got_comma && argv[j][0] == ',' && argv[j][1] == 0) {            got_comma = 1;            continue;        }        argv2[j+3-got_comma] = sdsnew(argv[j]);        if (!got_comma) keys++;    }    argv2[2] = sdscatprintf(sdsempty(),""%d"",keys);         return cliSendCommand(argc+3-got_comma, argv2, config.repeat);}",3,"cwe119,cwe120,cweother"
"ustat(BW *bw){tstatic unsigned char buf[80];tint c = brch(bw->cursor);tif (c == NO_MORE_DATA)ttjoe_snprintf_4((char *)buf, sizeof(buf), ""** Line %ld  Col %ld  Offset %ld(0x%lX) **"", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte);telsettjoe_snprintf_9((char *)buf, sizeof(buf), ""** Line %ld  Col %ld  Offset %ld(0x%lX)  %s %d(0%o/0x%X) Width %d **"", bw->cursor->line + 1, piscol(bw->cursor) + 1, bw->cursor->byte, bw->cursor->byte, bw->b->o.charmap->name, c, c, c, joe_wcwidth(bw->o.charmap->type,c));tmsgnw(bw->parent, buf);treturn 0;}",2,"cwe119,cwe120"
"menu_choose_mac(char *label, unsigned char *mac_ret, char *dfl){tchar buf[BUFSIZE];ttwhile (1) {ttif (menu_prompt(label, buf, sizeof(buf), dfl) < 0)tttreturn -1;ttif (strncasecmp(buf, ""my"", 2) == 0 || tt    strncasecmp(buf, ""my eth"", 6) == 0 ||tt    strncasecmp(buf, ""my eth mac"", 10) == 0 ||tt    strncasecmp(buf, ""my mac"", 6) == 0) {tttmemcpy(mac_ret, my_eth_mac, ETH_ALEN);tttreturn 0;tt}ttif (parse_mac(buf, mac_ret) == 0)tttreturn 0;t}}",2,"cwe119,cwe120"
"property_page_set_store_value(struct property_page *pp,                                          struct objprop *op,                                          struct objbind *ob,                                          GtkTreeIter *iter){  int col_id;  struct propval *pv;  enum value_types valtype;  char buf[128], *p;  GdkPixbuf *pixbuf = NULL;  GtkListStore *store;  if (!pp || !pp->object_store || !op || !ob) {    return FALSE;  }  if (!objprop_show_in_listview(op)) {    return FALSE;  }  col_id = objprop_get_column_id(op);  if (col_id < 0) {    return FALSE;  }  pv = objbind_get_value_from_object(ob, op);  if (!pv) {    return FALSE;  }  valtype = objprop_get_valtype(op);  store = pp->object_store;  switch (valtype) {  case VALTYPE_NONE:    break;  case VALTYPE_INT:    gtk_list_store_set(store, iter, col_id, pv->data.v_int, -1);    break;  case VALTYPE_BOOL:    gtk_list_store_set(store, iter, col_id, pv->data.v_bool, -1);    break;  case VALTYPE_STRING:    if (fc_strlcpy(buf, pv->data.v_string, 28) >= 28) {      sz_strlcat(buf, ""..."");    }    for (p = buf; *p; p++) {      if (*p == '' || *p == 't' || *p == 'r') {        *p = ' ';      }    }    gtk_list_store_set(store, iter, col_id, buf, -1);    break;  case VALTYPE_PIXBUF:    gtk_list_store_set(store, iter, col_id, pv->data.v_pixbuf, -1);    break;  case VALTYPE_BUILT_ARRAY:  case VALTYPE_INVENTIONS_ARRAY:  case VALTYPE_BV_SPECIAL:  case VALTYPE_BV_BASES:  case VALTYPE_NATION_HASH:    propval_as_string(pv, buf, sizeof(buf));    gtk_list_store_set(store, iter, col_id, buf, -1);    break;  case VALTYPE_NATION:    pixbuf = get_flag(pv->data.v_nation);    gtk_list_store_set(store, iter, col_id, pixbuf, -1);    if (pixbuf) {      g_object_unref(pixbuf);    }    break;  case VALTYPE_TILE_VISION_DATA:    break;  }  propval_free(pv);  return TRUE;}",2,"cwe119,cwe120"
"rf_val_set(struct mb86a16_state *state,tt      int f,tt      int smrt,tt      unsigned char R){tunsigned char C, F, B;tint M;tunsigned char rf_val[5];tint ack = -1;tif (smrt > 37750)ttC = 1;telse if (smrt > 18875)ttC = 2;telse if (smrt > 5500)ttC = 3;telsettC = 4;tif (smrt > 30500)ttF = 3;telse if (smrt > 9375)ttF = 1;telse if (smrt > 4625)ttF = 0;telsettF = 2;tif (f < 1060)ttB = 0;telse if (f < 1175)ttB = 1;telse if (f < 1305)ttB = 2;telse if (f < 1435)ttB = 3;telse if (f < 1570)ttB = 4;telse if (f < 1715)ttB = 5;telse if (f < 1845)ttB = 6;telse if (f < 1980)ttB = 7;telse if (f < 2080)ttB = 8;telsettB = 9;tM = f * (1 << R) / 2;trf_val[0] = 0x01 | (C << 3) | (F << 1);trf_val[1] = (R << 5) | ((M & 0x1f000) >> 12);trf_val[2] = (M & 0x00ff0) >> 4;trf_val[3] = ((M & 0x0000f) << 4) | B;t tif (mb86a16_write(state, 0x21, rf_val[0]) < 0)ttack = 0;tif (mb86a16_write(state, 0x22, rf_val[1]) < 0)ttack = 0;tif (mb86a16_write(state, 0x23, rf_val[2]) < 0)ttack = 0;tif (mb86a16_write(state, 0x24, rf_val[3]) < 0)ttack = 0;tif (mb86a16_write(state, 0x25, 0x01) < 0)ttack = 0;tif (ack == 0) {ttdprintk(verbose, MB86A16_ERROR, 1, ""RF Setup - I2C transfer error"");ttreturn -EREMOTEIO;t}treturn 0;}",2,"cwe119,cwe120"
"soap_wsse_verify_X509(struct soap *soap, X509 *cert){ struct soap_wsse_data *data = (struct soap_wsse_data*)soap_lookup_plugin(soap, soap_wsse_id);  X509_STORE_CTX *verify;  DBGFUN(""soap_wsse_verify_X509"");  if (!data)    return soap_set_receiver_error(soap, ""soap_wsse_sign"", ""Plugin not registered"", SOAP_PLUGIN_ERROR);  if (!cert)    return soap_wsse_sender_fault(soap, ""soap_wsse_verify_X509"", ""No certificate"");  if (!data->store)  { if (!(data->store = X509_STORE_new()))      return soap_wsse_receiver_fault(soap, ""soap_wsse_verify_X509"", ""Could not create X509_STORE object"");    DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Setting up a new X509 store""));    X509_STORE_set_verify_cb_func(data->store, soap->fsslverify);    if (soap->cafile || soap->capath)    { if (X509_STORE_load_locations(data->store, soap->cafile, soap->capath) != 1)        return soap_wsse_receiver_fault(soap, ""soap_wsse_verify_X509"", ""Could not load CA file or path"");    }#if (OPENSSL_VERSION_NUMBER > 0x00907000L)    if (soap->crlfile)    { X509_LOOKUP *lookup;      if (!(lookup = X509_STORE_add_lookup(data->store, X509_LOOKUP_file())))        return soap_wsse_receiver_fault(soap, ""soap_wsse_verify_X509"", ""Could not create X509_LOOKUP object"");      if (X509_load_crl_file(lookup, soap->crlfile, X509_FILETYPE_PEM) != 1)        return soap_wsse_receiver_fault(soap, ""soap_wsse_verify_X509"", ""Could not read the CRL file"");      X509_STORE_set_flags(data->store, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);    }#endif  }  if (!(verify = X509_STORE_CTX_new()))    return soap_wsse_receiver_fault(soap, ""soap_wsse_verify_X509"", ""Could not create X509_STORE_CTX object"");#if (OPENSSL_VERSION_NUMBER > 0x00907000L)  if (X509_STORE_CTX_init(verify, data->store, cert, NULL) != 1)  { X509_STORE_CTX_free(verify);    return soap_wsse_receiver_fault(soap, ""soap_wsse_verify_X509"", ""Could not initialize X509_STORE_CTX object"");  }#else  X509_STORE_CTX_init(verify, data->store, cert, NULL);#endif  if (X509_verify_cert(verify) != 1)  { X509_STORE_CTX_free(verify);    return soap_wsse_sender_fault(soap, ""soap_wsse_verify_X509"", ""Invalid certificate"");  }  DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Certificate is valid""));#ifdef SOAP_DEBUG  { char buf[1024];    X509_NAME_oneline(X509_get_issuer_name(cert), buf, sizeof(buf));    DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""certificate issuer %s"", buf));    X509_NAME_oneline(X509_get_subject_name(cert), buf, sizeof(buf));    DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""certificate subject %s"", buf));  }#endif  X509_STORE_CTX_free(verify);  return SOAP_OK;}",2,"cwe119,cwe120"
"cm2048_fops_read(struct file *file, char __user *buf,tsize_t count, loff_t *ppos){tstruct bcm2048_device *bdev = video_drvdata(file);tint i;tint retval = 0;t tcount = (count / 3) * 3;  tif (count < 3)ttreturn -ENOBUFS;twhile (!bdev->rds_data_available) {ttif (file->f_flags & O_NONBLOCK) {tttretval = -EWOULDBLOCK;tttgoto done;tt}tt ttif (wait_event_interruptible(bdev->read_queue,tttbdev->rds_data_available) < 0) {tttretval = -EINTR;tttgoto done;tt}t}tmutex_lock(&bdev->mutex);t ti = bdev->fifo_size - bdev->rd_index;tif (count > i)ttcount = (i / 3) * 3;ti = 0;twhile (i < count) {ttunsigned char tmpbuf[3];tttmpbuf[i] = bdev->rds_info.radio_text[bdev->rd_index+i+2];tttmpbuf[i+1] = bdev->rds_info.radio_text[bdev->rd_index+i+1];tttmpbuf[i+2] = (bdev->rds_info.radio_text[bdev->rd_index + i] & 0xf0) >> 4;ttif ((bdev->rds_info.radio_text[bdev->rd_index+i] &tttBCM2048_RDS_CRC_MASK) == BCM2048_RDS_CRC_UNRECOVARABLE)ttttmpbuf[i+2] |= 0x80;ttif (copy_to_user(buf+i, tmpbuf, 3)) {tttretval = -EFAULT;tttbreak;tt}tti += 3;t}tbdev->rd_index += i;tif (bdev->rd_index >= bdev->fifo_size)ttbdev->rds_data_available = 0;tmutex_unlock(&bdev->mutex);tif (retval == 0)ttretval = i;done:treturn retval;}",2,"cwe119,cwe120"
"__ecereProp_ProjectNode_Get_folder(struct ProjectNode * this){static char insidePath[797];strcpy(insidePath, (this->parent->type == 0) ? """" : this->parent->path);__ecereFunction___ecereNameSpace__ecere__sys__PathCatSlash(insidePath, this->name);if(!((__ecereFunction___ecereNameSpace__ecere__com__GetRuntimePlatform() == 1) ? (strcasecmp) : strcmp)(this->path, insidePath))return this->name;else{strcpy(insidePath, this->path);if(!insidePath[0])strcpy(insidePath, ""."");__ecereFunction___ecereNameSpace__ecere__sys__PathCatSlash(insidePath, this->name);return insidePath;}}",2,"cwe119,cwe120"
"create_interface(int fd, char *name){tchar *argv[3];ttif (interface_exist(fd,name))ttreturn -1;targv[0] = cmds[ADDIF].cmd;targv[1] = name;targv[2] = NULL;texec_args(fd,2,argv);treturn 0;}",2,"cwe119,cwe120"
"JUSTL_check_info(void){  char buf[BUFSIZ+1];  if(host == NULL)  {    if(options & OPT_DAEMON)    {      return(-1);    }    printf(""host: "");    *buf = '0';    fgets(buf, BUFSIZ, stdin);    chomp(buf);    host = strdup(buf);  }  if(interface == NULL && address == NULL)  {    if(options & OPT_DAEMON)    {      fprintf(stderr, ""you must provide either an interface or an address"");      return(-1);    }    if(interface) { free(interface); }    printf(""interface: "");    *buf = '0';    fgets(buf, BUFSIZ, stdin);    chomp(buf);    option_handler(CMD_interface, buf);  }  warn_fields(service->fields_used);  return 0;}",2,"cwe119,cwe120"
"make_georep_mountspec (gf_mount_spec_t *mspec, const char *volnames,                       char *user){        char *georep_mnt_desc = NULL;        char *meetspec        = NULL;        char *vols            = NULL;        char *vol             = NULL;        char *p               = NULL;        char *savetok         = NULL;        char *fa[3]           = {0,};        size_t siz            = 0;        int vc                = 0;        int i                 = 0;        int ret               = 0;        vols = gf_strdup ((char *)volnames);        if (!vols)                goto out;        for (vc = 1, p = vols; *p; p++) {                if (*p == ',')                        vc++;        }        siz = strlen (volnames) + vc * strlen(""volfile-id="");        meetspec = GF_CALLOC (1, siz + 1, gf_gld_mt_georep_meet_spec);        if (!meetspec)                goto out;        for (p = vols;;) {                vol = strtok_r (p, "","", &savetok);                if (!vol) {                        GF_ASSERT (vc == 0);                        break;                }                p = NULL;                strcat (meetspec, ""volfile-id="");                strcat (meetspec, vol);                if (--vc > 0)                        strcat (meetspec, "" "");        }        ret = gf_asprintf (&georep_mnt_desc, georep_mnt_desc_template,                           GF_CLIENT_PID_GSYNCD, user, meetspec);        if (ret == -1) {                georep_mnt_desc = NULL;                goto out;        }        ret = parse_mount_pattern_desc (mspec, georep_mnt_desc); out:        fa[0] = meetspec;        fa[1] = vols;        fa[2] = georep_mnt_desc;        for (i = 0; i < 3; i++) {                if (fa[i] == NULL)                        ret = -1;                else                        GF_FREE (fa[i]);        }        return ret;}",3,"cwe119,cwe120,cwe469"
"""FindDelimitedString(const char *s, char begin, char end, ttchar *buf, const char *nest_chars){   char *ret=NULL;    ASSERT(s);   while (*s && (*s != begin))ts++;   if (*s == begin) {#if 00tif (buf) {t    char *b = buf;t    p = (char*)s;t    do {t    t*b = *p;ttb++; p++;t    } while (*p && (*p != end));t    if (*p == end) {tt*b = end;tt*(++b) = '0';t        ret = buf;t    } elsettret = NULL;t} else #endift{t    char nesting_char = '0';t    const char *src = s; t    char *dest;t    t    if (buf) {ttret = dest = buf; t    } else {ttret = dest = new char [STRLEN(s) + 1];t    }t    *dest = *src;t    dest++; src++;t// Skip first delimiter (in case begin == end)t    while (*src && ((*src != end) || nesting_char))  {tt//tt// Look for a nested string that can include the last delimitertt//ttif (nest_chars) {tt    if (nesting_char)  {t// Check for end nesting chartttif (nesting_char == *src)ttt    nesting_char = '0';tt    } else {ttt// Check for begin nesting chartttif (strchr(nest_chars, *src))ttt    nesting_char = *src;tt    }tt}t        *dest = *src;t        src++; ttdest++;t    }t    if (*src == end) {tt*dest = end;tt*(++dest) = '0';t    } else {ttret = NULL;t    }t}   }   return ret; }""",2,"cwe476,cweother"
"lcrt_settings_init_local_config(struct lcrt_settings *lsettings){    char db_name[256];    int i;    static char *config[LCRT_LT_NUMBER] = {LCRT_LT_CONFIG};    snprintf(db_name, sizeof(db_name), ""%s/%s/"", lcrt_config_get_local_dir(), LCRT_SETTINGS_CONFIG_DIR);    lcrt_fmkdir(db_name);    strcat(db_name, LCRT_SETTINGS_DB);    lcrt_config_init(&lsettings->config.ldb, db_name, LCRT_ISETTINGS_TABLE);    for (i = 0; i < LCRT_LT_NUMBER; i++) {        strncpy(lsettings->config.local[i], config[i], sizeof(lsettings->config.local[i]));    }    lsettings->get_ldb = lcrt_settings_get_ldb_name;    lsettings->get_ltb = lcrt_settings_get_ltb_name;    return 0;}",2,"cwe119,cwe120"
"client_fd_lk_ctx_dump (xlator_t *this, fd_lk_ctx_t *lk_ctx, int nth_fd){        gf_boolean_t            use_try_lock             = _gf_true;        int                     ret                      = -1;        int                     lock_no                  = 0;        fd_lk_ctx_t             *lk_ctx_ref              = NULL;        fd_lk_ctx_node_t        *plock                   = NULL;        char                    key[GF_DUMP_MAX_BUF_LEN] = {0,};        lk_ctx_ref = fd_lk_ctx_try_ref (lk_ctx);        if (!lk_ctx_ref)                return;        ret = client_fd_lk_list_empty (lk_ctx_ref, (use_try_lock = _gf_true));        if (ret != 0)                return;        ret = TRY_LOCK (&lk_ctx_ref->lock);        if (ret)                return;        gf_proc_dump_write (""------"",""------"");        lock_no = 0;        list_for_each_entry (plock, &lk_ctx_ref->lk_list, next) {                snprintf (key, sizeof (key), ""granted-posix-lock[%d]"",                          lock_no++);                gf_proc_dump_write (key, ""owner = %s, cmd = %s ""                                    ""fl_type = %s, fl_start = %""                                    PRId64"", fl_end = %""PRId64                                    "", user_flock: l_type = %s, ""                                    ""l_start = %""PRId64"", l_len = %""PRId64,                                    lkowner_utoa (&plock->user_flock.l_owner),                                    get_lk_cmd (plock->cmd),                                    get_lk_type (plock->fl_type),                                    plock->fl_start, plock->fl_end,                                    get_lk_type (plock->user_flock.l_type),                                    plock->user_flock.l_start,                                    plock->user_flock.l_len);        }        gf_proc_dump_write (""------"",""------"");        UNLOCK (&lk_ctx_ref->lock);        fd_lk_ctx_unref (lk_ctx_ref);}",2,"cwe119,cwe120"
"ssh_log(Plug plug, int type, SockAddr addr, int port,tt    const char *error_msg, int error_code){    Ssh ssh = (Ssh) plug;    char addrbuf[256], *msg;    sk_getaddr(addr, addrbuf, lenof(addrbuf));    if (type == 0)tmsg = dupprintf(""Connecting to %s port %d"", addrbuf, port);    elsetmsg = dupprintf(""Failed to connect to %s: %s"", addrbuf, error_msg);    logevent(msg);    sfree(msg);}",2,"cwe119,cwe120"
"main (int argc, char *argv[]){     setlocale (LC_ALL, """");     textdomain (PACKAGE);     int remaining;  argp_parse (&argp, argc, argv, 0, &remaining, NULL);  int fd;  if (remaining == argc)    fd = STDIN_FILENO;  else if (remaining + 1 != argc)    {      argp_help (&argp, stdout, ARGP_HELP_SEE | ARGP_HELP_EXIT_ERR,tt program_invocation_short_name);      exit (1);    }  else    {             fd = open (argv[remaining], O_RDONLY);      if (fd == -1)terror (EXIT_FAILURE, errno, _(""cannot open input file""));    }     uint32_t word;  if (TEMP_FAILURE_RETRY (read (fd, &word, 4)) != 4)    error (EXIT_FAILURE, errno, _(""cannot read header""));     int must_swap = (word & 0xfffffff0) == bswap_32 (0xdeb00000);  if (must_swap)    word = bswap_32 (word);     if (word == 0xdeb00004)    {      union      {tuint32_t ptrs[2];tchar bytes[8];      } pair;      while (1)t{t  size_t len = sizeof (pair);t  size_t n;t  while (len > 0tt && (n = TEMP_FAILURE_RETRY (read (fd, &pair.bytes[8 - len],tttttt   len))) != 0)t    len -= n;t  if (len != 0)t     t    break;t  printf (""this = %#010"" PRIx32 "", caller = %#010"" PRIx32 """",tt  must_swap ? bswap_32 (pair.ptrs[0]) : pair.ptrs[0],tt  must_swap ? bswap_32 (pair.ptrs[1]) : pair.ptrs[1]);t}    }  else if (word == 0xdeb00008)    {      union      {tuint64_t ptrs[2];tchar bytes[16];      } pair;      while (1)t{t  size_t len = sizeof (pair);t  size_t n;t  while (len > 0tt && (n = TEMP_FAILURE_RETRY (read (fd, &pair.bytes[8 - len],tttttt   len))) != 0)t    len -= n;t  if (len != 0)t     t    break;t  printf (""this = %#018"" PRIx64 "", caller = %#018"" PRIx64 """",tt  must_swap ? bswap_64 (pair.ptrs[0]) : pair.ptrs[0],tt  must_swap ? bswap_64 (pair.ptrs[1]) : pair.ptrs[1]);t}    }  else         error (EXIT_FAILURE, 0, _(""invalid pointer size""));     close (fd);  return 0;}",3,"cwe119,cwe120,cweother"
"rs5c372_set_datetime(struct i2c_client *client, struct rtc_time *tm){tstruct rs5c372t*rs5c = i2c_get_clientdata(client);tunsigned chartbuf[7];tintttaddr;tdev_dbg(&client->dev, ""%s: tm is secs=%d, mins=%d, hours=%d ""tt""mday=%d, mon=%d, year=%d, wday=%d"",tt__func__,tttm->tm_sec, tm->tm_min, tm->tm_hour,tttm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);taddr   = RS5C_ADDR(RS5C372_REG_SECS);tbuf[0] = bin2bcd(tm->tm_sec);tbuf[1] = bin2bcd(tm->tm_min);tbuf[2] = rs5c_hr2reg(rs5c, tm->tm_hour);tbuf[3] = bin2bcd(tm->tm_wday);tbuf[4] = bin2bcd(tm->tm_mday);tbuf[5] = bin2bcd(tm->tm_mon + 1);tbuf[6] = bin2bcd(tm->tm_year - 100);tif (i2c_smbus_write_i2c_block_data(client, addr, sizeof(buf), buf) < 0) {ttdev_err(&client->dev, ""%s: write error"", __func__);ttreturn -EIO;t}treturn 0;}",2,"cwe119,cwe120"
"initpower(double *power){  for (;;) {    printf(""New power?"");    fflush(stdout);    if (scanf(""%lf%*[^]"", power) == 1) {      getchar();      break;    }  }}",2,"cwe120,cweother"
"Csec_name2id(char *name, uid_t *uid, uid_t *gid) {  char *func = ""Csec_name2id"";  struct passwd *pw;  uid_t luid;  gid_t lgid;      pw = Cgetpwnam(name);  if (pw == NULL) {    Csec_trace(func, ""Could not find uid/gid for <%s>"", name);    Csec_errmsg(func,""Could not find uid/gid for <%s>"", name);    serrno = ESEC_NO_USER;    return -1;  }       luid = pw->pw_uid;  lgid = pw->pw_gid;  Csec_trace(func, ""%s mapped to %d/%d"", name, luid, lgid);  if (uid != NULL && gid != NULL) {    *uid=luid;    *gid=lgid;  } else {    errno=EINVAL;    return -1;  }       return 0;}",2,"cwe119,cwe120"
"dg_check(depgraph_t *dg){  if (NULL == dg->atom)  {    exit_error(ERROR_MEMORY);  }  if (0 > pkg_match(dg->atom))  {    exit_error(ERROR_INVALID);  }  if (NULL == dg->out)  {    char *tmp = pkg_name(dg->atom);    size_t s = strlen(tmp) + 5;    dg->out = POOL_ALLOC(s);    if (NULL == dg->out)    {      exit_error(ERROR_MEMORY);    }    dg->out[0] = 0;    dg->out = strcat(dg->out, tmp);    dg->out = strcat(dg->out, "".dot"");    pool_remove(tmp);  }  if (NULL == dg->outfunc)  {    exit_error(ERROR_UNKNOWN);  }  if (NULL == dg->root)  {    dg->root = pool_add(strdup(""/usr/portage""));    if (NULL == dg->root)    {      exit_error(ERROR_MEMORY);    }  }  dg->pkg.operator = pkg_operator(dg->atom);  dg->pkg.category = pkg_category(dg->atom);  dg->pkg.name = pkg_name(dg->atom);  dg->pkg.version = pkg_version(dg->atom);  dg->pkg.revision = pkg_revision(dg->atom);  dg->pkg.glob = pkg_glob(dg->atom);  if (NULL == dg->pkg.operator || 0 == dg->pkg.operator[0])  {    pool_remove(dg->pkg.operator);    dg->pkg.operator = NULL;  }  if (NULL == dg->pkg.category || 0 == dg->pkg.category[0])  {    pool_remove(dg->pkg.category);    dg->pkg.category = NULL;  }  if (NULL == dg->pkg.name || 0 == dg->pkg.name[0])  {    pool_remove(dg->pkg.name);    dg->pkg.name = NULL;  }  if (NULL == dg->pkg.version || 0 == dg->pkg.version[0])  {    pool_remove(dg->pkg.version);    dg->pkg.version = NULL;  }  if (NULL == dg->pkg.revision || 0 == dg->pkg.revision[0])  {    pool_remove(dg->pkg.revision);    dg->pkg.revision = NULL;  }}",2,"cwe469,cwe476"
"hkl_geometry_list_sort(HklGeometryList *self, HklGeometry *ref){tsize_t len = HKL_LIST_LEN(self->items);tdouble *distances = alloca(len * sizeof(*distances));tsize_t *idx = alloca(len * sizeof(*idx));tsize_t i, x;tint j, p;tHklGeometryListItem **items;t tfor(i=0; i<len; ++i){ttdistances[i] = hkl_geometry_distance(ref, self->items[i]->geometry);ttidx[i] = i;t}t tfor(i=1; i<len; ++i){ttx = idx[i];tt ttfor(p = 0; distances[idx[p]] < distances[x] && fabs(distances[idx[p]] - distances[x]) > HKL_EPSILON; p++); tt ttfor(j=i-1; j>=p; j--)tttidx[j+1] = idx[j];ttidx[p] = x;  t}t titems = malloc(len * sizeof(HklGeometryListItem *));tfor(i=0; i<len; ++i)ttitems[i] = self->items[idx[i]];tfree(self->items);tself->items = items;}",2,"cwe120,cweother"
"wl1273_fm_vidioc_g_modulator(struct file *file, void *priv,tttttstruct v4l2_modulator *modulator){tstruct wl1273_device *radio = video_get_drvdata(video_devdata(file));tstruct wl1273_core *core = radio->core;tu16 val;tint r;tdev_dbg(radio->dev, ""%s"", __func__);tstrlcpy(modulator->name, WL1273_FM_DRIVER_NAME,ttsizeof(modulator->name));tmodulator->rangelow = WL1273_FREQ(WL1273_BAND_JAPAN_LOW);tmodulator->rangehigh = WL1273_FREQ(WL1273_BAND_OTHER_HIGH);tmodulator->capability =  V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_RDS |ttV4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_RDS_BLOCK_IO;tif (core->mode != WL1273_MODE_TX)ttreturn 0;tif (mutex_lock_interruptible(&core->lock))ttreturn -EINTR;tr = core->read(core, WL1273_MONO_SET, &val);tif (r)ttgoto out;tif (val == WL1273_TX_STEREO)ttmodulator->txsubchans = V4L2_TUNER_SUB_STEREO;telsettmodulator->txsubchans = V4L2_TUNER_SUB_MONO;tif (radio->rds_on)ttmodulator->txsubchans |= V4L2_TUNER_SUB_RDS;out:tmutex_unlock(&core->lock);treturn 0;}",2,"cwe120,cweother"
"add_transform(int finished, size_t *length, unsigned trans_id,              unsigned char *attr, size_t attr_len) {   static int first_transform = 1;   static unsigned char *trans_start=NULL;t    static size_t cur_offset;ttt    static size_t end_offset;ttt    static unsigned trans_no=1;   unsigned char *trans;ttt    size_t len;ttttt     if (!finished) {      trans = make_transform(&len, ISAKMP_NEXT_T, trans_no, trans_id, attr,                             attr_len);      trans_no++;      if (first_transform) {         cur_offset = 0;         end_offset = len;         trans_start = Malloc(end_offset);         memcpy(trans_start, trans, len);         first_transform = 0;      } else {         cur_offset = end_offset;         end_offset += len;         trans_start = Realloc(trans_start, end_offset);         memcpy(trans_start+cur_offset, trans, len);      }      free(trans);      return NULL;   } else {      struct isakmp_transform* hdr =         (struct isakmp_transform*) (trans_start+cur_offset);t       first_transform = 1;      hdr->isat_np = ISAKMP_NEXT_NONE;tt       *length = end_offset;      return trans_start;   }}",2,"cwe120,cwe476"
"""DoInt(int sx, int sy, int num){#define mxlen 5tchar s[(mxlen+1)];tchar * o=s;tint len;ts[mxlen]=0;tchar neg=0;tif(num<0){ttnum=-num;ttneg=1;t};    if(num==0){        neg=2;    };tttfor (len=(mxlen-1);len>=0;len--){tts[len]=(num%10)+'0';ttif(num==0){ttts[len]=' '; // configurable?ttto=s+len;tttbreak;tt};ttnum/=10;t};tif(neg==1)tt*o='-';    if(neg==2)        *o='0';    if(neg==0)        o++;treturn DoString(sx,sy,o);#undef mxlen}""",2,"cwe119,cwe120"
"glusterd_hooks_create_hooks_directory (char *basedir){        int  ret                                        = -1;        int  op                                         = GD_OP_NONE;        int  type                                       = GD_COMMIT_HOOK_NONE;        char version_dir[PATH_MAX]                      = {0, };        char path[PATH_MAX]                             = {0, };        char *cmd_subdir                                = NULL;        char type_subdir[GD_COMMIT_HOOK_MAX][256]       = {{0, },                                                           ""pre"",                                                           ""post""};        glusterd_conf_t *priv                           = NULL;        priv = THIS->private;        snprintf (path, sizeof (path), ""%s/hooks"", basedir);        ret = mkdir_if_missing (path);        if (ret) {                gf_log (THIS->name, GF_LOG_CRITICAL, ""Unable to create %s due""                         ""to %s"", path, strerror (errno));                goto out;        }        GLUSTERD_GET_HOOKS_DIR (version_dir, GLUSTERD_HOOK_VER, priv);        ret = mkdir_if_missing (version_dir);        if (ret) {                gf_log (THIS->name, GF_LOG_CRITICAL, ""Unable to create %s due ""                        ""to %s"", version_dir, strerror (errno));                goto out;        }        for (op = GD_OP_NONE+1; op < GD_OP_MAX; op++) {                cmd_subdir = glusterd_hooks_get_hooks_cmd_subdir (op);                if (strlen (cmd_subdir) == 0)                        continue;                snprintf (path, sizeof (path), ""%s/%s"", version_dir,                          cmd_subdir);                ret = mkdir_if_missing (path);                if (ret) {                        gf_log (THIS->name, GF_LOG_CRITICAL,                                ""Unable to create %s due to %s"",                                path, strerror (errno));                        goto out;                }                for (type = GD_COMMIT_HOOK_PRE; type < GD_COMMIT_HOOK_MAX;                     type++) {                        snprintf (path, sizeof (path), ""%s/%s/%s"",                                  version_dir, cmd_subdir, type_subdir[type]);                        ret = mkdir_if_missing (path);                        if (ret) {                                gf_log (THIS->name, GF_LOG_CRITICAL,                                        ""Unable to create %s due to %s"",                                        path, strerror (errno));                                goto out;                        }                }        }        ret = 0;out:        return ret;}",2,"cwe119,cwe120"
"cst_fopen(const char *path, int mode){    char cmode[4];         if ((mode & CST_OPEN_WRITE) && (mode & CST_OPEN_READ))tstrcpy(cmode, ""r+"");    else if ((mode & CST_OPEN_APPEND) && (mode & CST_OPEN_READ))tstrcpy(cmode, ""a+"");    else if (mode & CST_OPEN_WRITE)tstrcpy(cmode, ""w"");    else if (mode & CST_OPEN_APPEND)tstrcpy(cmode, ""a"");    else if (mode & CST_OPEN_READ)tstrcpy(cmode, ""r"");    if (mode & CST_OPEN_BINARY)tstrcat(cmode, ""b"");    return fopen(path, cmode);}",3,"cwe119,cwe120,cweother"
"""tool_read_cb(void *buffer, size_t sz, size_t nmemb, void *userdata){  ssize_t rc;  struct InStruct *in = userdata;  rc = read(in->fd, buffer, sz*nmemb);  if(rc < 0) {    if(errno == EAGAIN) {      errno = 0;      in->config->readbusy = TRUE;      return CURL_READFUNC_PAUSE;    }    /* since size_t is unsigned we can't return negative values fine */    rc = 0;  }  in->config->readbusy = FALSE;  return (size_t)rc;}""",2,"cwe120,cweother"
"ay_irc_got_welcome(const char *nick, const char *message,tirc_message_prefix *prefix, irc_account *ia){tConversation *ecr = NULL;tchar room_name[BUF_LEN];teb_local_account *ela = (eb_local_account *)ia->data;tsnprintf(room_name, sizeof(room_name), ""#notices-%s-%s@%s"", ia->nick,ttia->connect_address, ia->connect_address);tif (!(ecr = ay_conversation_find_by_name(ela, room_name)))ttecr = ay_irc_start_conversation(room_name, ela, FALSE, FALSE,tttFALSE);tay_conversation_display_notification(ecr, message, IRC_WELCOME);tif (!strcmp(nick, ia->nick))ttreturn;t tif (ia->nick)ttfree(ia->nick);tia->nick = strdup(nick);}",2,"cwe119,cwe120"
"copy_status_repo(char *path_statusfiles, char *temp_path){tchar current_workdir[GIT_PATH_MAX];tchar gitted[GIT_PATH_MAX];tint error;terror = p_getcwd(current_workdir, sizeof(current_workdir));tif (error < 0)ttreturn error;tstrcpy(path_statusfiles, current_workdir);tgit_path_join(path_statusfiles, path_statusfiles, TEMP_STATUS_FOLDER);terror = copydir_recurs(STATUS_FOLDER, path_statusfiles);tif (error < 0)ttreturn error;tgit_path_join(gitted, path_statusfiles, "".gitted"");tgit_path_join(temp_path, path_statusfiles, "".git"");tcopydir_recurs(gitted, temp_path);tgit_futils_rmdir_r(gitted, 1);treturn GIT_SUCCESS;}",2,"cwe119,cwe120"
"xsh_frame_build_sky_map(cpl_frame* slitmap_frame,const double value,const char* tag){  char name_o[256];  cpl_frame* result=NULL;  cpl_image* ima = NULL;  const char* name = NULL;  cpl_propertylist* plist = NULL;  check(name = cpl_frame_get_filename(slitmap_frame));  check(ima = cpl_image_load(name, XSH_PRE_DATA_TYPE, 0, 0));  check(plist = cpl_propertylist_load(name, 0));  check(cpl_image_add_scalar(ima,value));  sprintf(name_o,""%s.fits"",tag);  check(cpl_image_save(ima, name_o, XSH_PRE_DATA_BPP, plist, CPL_IO_DEFAULT));  result = cpl_frame_duplicate(slitmap_frame);  cpl_frame_set_filename(result, name_o);  cpl_frame_set_tag(result, tag);  xsh_add_temporary_file(name_o);  cleanup:  xsh_free_propertylist(&plist);  xsh_free_image(&ima);  return result;}",2,"cwe119,cwe120"
"PurgeMultipleIPReferences(CF_DB *dbp,char *rkey,char *ipaddress){ CF_DBC *dbcp;  struct CfKeyHostSeen q,newq;   double lastseen,delta2,lsea = LASTSEENEXPIREAFTER;  void *stored;  char name[CF_BUFSIZE],*key;  time_t now = time(NULL);  int qsize,ksize,update_address,keys_match;    if (!NewDBCursor(dbp,&dbcp))   {   CfOut(cf_inform,"""","" !! Unable to scan the last seen db"");   return;   }while(NextDB(dbp,dbcp,&key,&ksize,&stored,&qsize))   {   keys_match = false;      if (strcmp(key+1,rkey+1) == 0)      {      keys_match = true;      }   memcpy(&q,stored,sizeof(q));   lastseen = (double)now - q.Q.q;   if (lastseen > lsea)      {      CfOut(cf_verbose,"""","" -> Last-seen record for %s expired after %.1lf > %.1lf hours"",key,lastseen/3600,lsea/3600);      DeleteDB(dbp,key);      continue;      }          if (keys_match && strcmp(q.address,ipaddress) != 0)      {      CfOut(cf_verbose,"""","" ! Synchronizing %s's address as this host %s seems to have moved from location %s to %s"",key,rkey,q.address,ipaddress);      strcpy(q.address,ipaddress);      update_address = true;      }   else if (!keys_match && strcmp(q.address,ipaddress) == 0)      {      CfOut(cf_verbose,"""","" ! Updating %s's address (%s) as this host %s seems to have gone off line"",key,ipaddress,rkey);      strcpy(q.address,CF_UNKNOWN_IP);      update_address = true;      }   else       {      update_address = false;      }   if (update_address)      {      WriteDB(dbp,key,&q,sizeof(q));      }   }DeleteDBCursor(dbp,dbcp);}",2,"cwe119,cwe120"
"check_and_set_import_cache(struct ldbminfo *li){    size_t import_pages = 0;    size_t pagesize, pages, procpages, availpages;    size_t soft_limit = 0;    size_t hard_limit = 0;    size_t page_delta = 0;    char s[64];        dblayer_sys_pages(&pagesize, &pages, &procpages, &availpages);    if (0 == pagesize || 0 == pages) {        LDAPDebug2Args(LDAP_DEBUG_ANY, ""check_and_set_import_cache: ""                       ""Failed to get pagesize: %ld or pages: %ld"",                       pagesize, pages);        return ENOENT;    }    LDAPDebug(LDAP_DEBUG_ANY, ""check_and_set_import_cache: ""                  ""pagesize: %ld, pages: %ld, procpages: %ld"",                  pagesize, pages, procpages);         soft_limit = (DBLAYER_IMPORTCACHESIZE_SL*1024) / (pagesize/1024);         hard_limit = (DBLAYER_IMPORTCACHESIZE_HL*1024) / (pagesize/1024);         if (li->li_import_cache_autosize < 0) {        li->li_import_cache_autosize = 50;    }         if (li->li_import_cache_autosize >= 100) {        LDAPDebug0Args(LDAP_DEBUG_ANY,            ""check_and_set_import_cache: ""            ""import cache autosizing value ""            ""(nsslapd-import-cache-autosize) should not be ""            ""greater than or equal to 100(%). Reset to 50(%)."");        li->li_import_cache_autosize = 50;    }    if (li->li_import_cache_autosize == 0) {                 import_pages = li->li_import_cachesize / pagesize;    } else {                          import_pages = (li->li_import_cache_autosize * pages) / 125;    }    page_delta = pages - import_pages;    if (page_delta < hard_limit) {        LDAPDebug(LDAP_DEBUG_ANY,             ""After allocating import cache %ldKB, ""            ""the available memory is %ldKB, ""            ""which is less than the hard limit %ldKB. ""            ""Please decrease the import cache size and rerun import."",            import_pages*(pagesize/1024), page_delta*(pagesize/1024),            hard_limit*(pagesize/1024));        return ENOMEM;    }    if (page_delta < soft_limit) {        LDAPDebug(LDAP_DEBUG_ANY,             ""WARNING: After allocating import cache %ldKB, ""            ""the available memory is %ldKB, ""            ""which is less than the soft limit %ldKB. ""            ""You may want to decrease the import cache size and ""            ""rerun import."",            import_pages*(pagesize/1024), page_delta*(pagesize/1024),            soft_limit*(pagesize/1024));    }    LDAPDebug1Arg(LDAP_DEBUG_ANY, ""Import allocates %ldKB import cache."",                   import_pages*(pagesize/1024));    if (li->li_import_cache_autosize > 0) {                   sprintf(s, ""%lu"", (unsigned long)(import_pages * pagesize));        ldbm_config_internal_set(li, CONFIG_IMPORT_CACHESIZE, s);    }    return 0;}",2,"cwe119,cwe120"
"LoadInstrumentTable(void){    byte *lump;    lump = W_CacheLumpName(""GENMIDI"", PU_STATIC);         if (strncmp((char *) lump, GENMIDI_HEADER, strlen(GENMIDI_HEADER)) != 0)    {        W_ReleaseLumpName(""GENMIDI"");        return false;    }    main_instrs = (genmidi_instr_t *) (lump + strlen(GENMIDI_HEADER));    percussion_instrs = main_instrs + GENMIDI_NUM_INSTRS;    main_instr_names = (char (*)[32]) (percussion_instrs + GENMIDI_NUM_PERCUSSION);    percussion_names = main_instr_names + GENMIDI_NUM_INSTRS;    return true;}",2,"cwe119,cwe120"
"to_real_path(char *dest, const char *source){tchar tmp[DEFAULT_TEXT_BUFFER_SIZE];tif (sscanf(source, ""~/%s"", tmp) || sscanf(source, ""$HOME/%s"", tmp)) {ttchar *homedir = getenv(""HOME"");ttif (homedir) {tttsnprintf(dest, DEFAULT_TEXT_BUFFER_SIZE, ""%s/%s"", homedir, tmp);tt} else {tttNORM_ERR(""$HOME environment variable doesn't exist"");tttstrncpy(dest, source, DEFAULT_TEXT_BUFFER_SIZE);tt}t} else if (dest != source) {t ttstrncpy(dest, source, DEFAULT_TEXT_BUFFER_SIZE);t}}",3,"cwe119,cwe120,cweother"
"gfs_output_droplet_sums_read (GtsObject ** o, GtsFile * fp){  (* GTS_OBJECT_CLASS (gfs_output_droplet_sums_class ())->parent_class->read) (o, fp);  if (fp->type == GTS_ERROR)    return;  GfsOutputDropletSums * d = GFS_OUTPUT_DROPLET_SUMS (*o);  GfsDomain * domain = GFS_DOMAIN (gfs_object_simulation (*o));  gfs_function_read (d->c, domain, fp);  if (fp->type == GTS_ERROR)    return;  if (fp->type == GTS_STRING) {    if (!(d->tag = gfs_domain_get_or_add_variable (domain, fp->token->str, ""Droplet index""))) {      gts_file_error (fp, ""`%s' is a reserved variable name"", fp->token->str);      return;    }    gts_file_next_token (fp);  }}",2,"cwe120,cweother"
"max3100_startup(struct uart_port *port){tstruct max3100_port *s = container_of(port,ttttt      struct max3100_port,ttttt      port);tchar b[12];tdev_dbg(&s->spi->dev, ""%s"", __func__);ts->conf = MAX3100_RM;ts->baud = s->crystal ? 230400 : 115200;ts->rx_enabled = 1;tif (s->suspending)ttreturn 0;ts->force_end_work = 0;ts->parity = 0;ts->rts = 0;tsprintf(b, ""max3100-%d"", s->minor);ts->workqueue = create_freezable_workqueue(b);tif (!s->workqueue) {ttdev_warn(&s->spi->dev, ""cannot create workqueue"");ttreturn -EBUSY;t}tINIT_WORK(&s->work, max3100_work);tif (request_irq(s->irq, max3100_irq,tttIRQF_TRIGGER_FALLING, ""max3100"", s) < 0) {ttdev_warn(&s->spi->dev, ""cannot allocate irq %d"", s->irq);tts->irq = 0;ttdestroy_workqueue(s->workqueue);tts->workqueue = NULL;ttreturn -EBUSY;t}tif (s->loopback) {ttu16 tx, rx;tttx = 0x4001;ttmax3100_sr(s, tx, &rx);t}tif (s->max3100_hw_suspend)tts->max3100_hw_suspend(0);ts->conf_commit = 1;tmax3100_dowork(s);t tmsleep(50);tmax3100_enable_ms(&s->port);treturn 0;}",2,"cwe119,cwe120"
"oc_dec_residual_tokens_unpack(oc_dec_ctx *_dec){  static const unsigned char OC_HUFF_LIST_MAX[5]={1,6,15,28,64};  ptrdiff_t  ntoks_left[3][64];  int        huff_idxs[2];  ptrdiff_t  eobs;  long       val;  int        pli;  int        zzi;  int        hgi;  for(pli=0;pli<3;pli++)for(zzi=0;zzi<64;zzi++){    ntoks_left[pli][zzi]=_dec->state.ncoded_fragis[pli];  }  val=oc_pack_read(&_dec->opb,4);  huff_idxs[0]=(int)val;  val=oc_pack_read(&_dec->opb,4);  huff_idxs[1]=(int)val;  _dec->eob_runs[0][0]=0;  eobs=oc_dec_dc_coeff_unpack(_dec,huff_idxs,ntoks_left);#if defined(HAVE_CAIRO)  _dec->telemetry_dc_bytes=oc_pack_bytes_left(&_dec->opb);#endif  val=oc_pack_read(&_dec->opb,4);  huff_idxs[0]=(int)val;  val=oc_pack_read(&_dec->opb,4);  huff_idxs[1]=(int)val;  zzi=1;  for(hgi=1;hgi<5;hgi++){    huff_idxs[0]+=16;    huff_idxs[1]+=16;    for(;zzi<OC_HUFF_LIST_MAX[hgi];zzi++){      eobs=oc_dec_ac_coeff_unpack(_dec,zzi,huff_idxs,ntoks_left,eobs);    }  }   }",2,"cwe119,cwe120"
"php_stream_ftp_rename(php_stream_wrapper *wrapper, char *url_from, char *url_to, int options, php_stream_context *context TSRMLS_DC){tphp_stream *stream = NULL;tphp_url *resource_from = NULL, *resource_to = NULL;tint result;tchar tmp_line[512];tresource_from = php_url_parse(url_from);tresource_to = php_url_parse(url_to);t tif (!resource_from ||tt!resource_to ||tt!resource_from->scheme ||tt!resource_to->scheme ||ttstrcmp(resource_from->scheme, resource_to->scheme) ||tt!resource_from->host ||tt!resource_to->host ||ttstrcmp(resource_from->host, resource_to->host) ||tt(resource_from->port != resource_to->port && tt resource_from->port * resource_to->port != 0 && tt resource_from->port + resource_to->port != 21) ||tt!resource_from->path ||tt!resource_to->path) {ttgoto rename_errexit;t}tstream = php_ftp_fopen_connect(wrapper, url_from, ""r"", 0, NULL, NULL, NULL, NULL, NULL, NULL TSRMLS_CC);tif (!stream) {ttif (options & REPORT_ERRORS) {tttphp_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to connect to %s"", resource_from->host);tt}ttgoto rename_errexit;t}t tphp_stream_printf(stream TSRMLS_CC, ""RNFR %sr"", (resource_from->path != NULL ? resource_from->path : ""/""));tresult = GET_FTP_RESULT(stream);tif (result < 300 || result > 399) {ttif (options & REPORT_ERRORS) {tttphp_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error Renaming file: %s"", tmp_line);tt}ttgoto rename_errexit;t}t tphp_stream_printf(stream TSRMLS_CC, ""RNTO %sr"", (resource_to->path != NULL ? resource_to->path : ""/""));tresult = GET_FTP_RESULT(stream);tif (result < 200 || result > 299) {ttif (options & REPORT_ERRORS) {tttphp_error_docref(NULL TSRMLS_CC, E_WARNING, ""Error Renaming file: %s"", tmp_line);tt}ttgoto rename_errexit;t}tphp_url_free(resource_from);tphp_url_free(resource_to);tphp_stream_close(stream);treturn 1;rename_errexit:tif (resource_from) {ttphp_url_free(resource_from);t}tif (resource_to) {ttphp_url_free(resource_to);t}tif (stream) {ttphp_stream_close(stream);t}treturn 0;}",2,"cwe119,cwe120"
"simple_iv (struct loop *wrto_loop, struct loop *use_loop, tree op,t   affine_iv *iv, bool allow_nonconstant_step){  tree type, ev;  bool folded_casts;  iv->base = NULL_TREE;  iv->step = NULL_TREE;  iv->no_overflow = false;  type = TREE_TYPE (op);  if (TREE_CODE (type) != INTEGER_TYPE      && TREE_CODE (type) != POINTER_TYPE)    return false;  ev = analyze_scalar_evolution_in_loop (wrto_loop, use_loop, op,ttttt &folded_casts);  if (chrec_contains_undetermined (ev)      || chrec_contains_symbols_defined_in_loop (ev, wrto_loop->num))    return false;  if (tree_does_not_contain_chrecs (ev))    {      iv->base = ev;      iv->step = build_int_cst (TREE_TYPE (ev), 0);      iv->no_overflow = true;      return true;    }  if (TREE_CODE (ev) != POLYNOMIAL_CHREC      || CHREC_VARIABLE (ev) != (unsigned) wrto_loop->num)    return false;  iv->step = CHREC_RIGHT (ev);  if ((!allow_nonconstant_step && TREE_CODE (iv->step) != INTEGER_CST)      || tree_contains_chrecs (iv->step, NULL))    return false;  iv->base = CHREC_LEFT (ev);  if (tree_contains_chrecs (iv->base, NULL))    return false;  iv->no_overflow = !folded_casts && TYPE_OVERFLOW_UNDEFINED (type);  return true;}",2,"cwe476,cweother"
"""textwidth(char *s){  int n;  n=0;  for(;*s!=0;s++) n+=(*s=='t') ? TAB_SIZE : 1;  return n;}""",2,"cwe119,cwe120"
"pref_to_xmlnode( xmlnode *psParent, struct sPref *psPref ) {txmlnode *psNode = NULL;tstruct sPref *psChild;tchar anBuf[ 20 ];tpsNode = xmlnode_new_child( psParent, ""pref"" );txmlnode_set_attrib( psNode, ""name"", psPref -> pnName );tif ( psPref -> nType == PREF_STRING ) {ttxmlnode_set_attrib( psNode, ""type"", ""string"" );ttxmlnode_set_attrib( psNode, ""value"", psPref -> uValue.pnString ? psPref -> uValue.pnString : """" );t} else if ( psPref -> nType == PREF_INT ) {ttxmlnode_set_attrib( psNode, ""type"", ""int"" );ttsnprintf( anBuf, sizeof( anBuf ), ""%d"", psPref -> uValue.nInteger );ttxmlnode_set_attrib( psNode, ""value"", anBuf );t} else if ( psPref -> nType == PREF_BOOLEAN ) {ttxmlnode_set_attrib( psNode, ""type"", ""bool"" );ttsnprintf( anBuf, sizeof( anBuf ), ""%d"", psPref -> uValue.bBoolean );ttxmlnode_set_attrib( psNode, ""value"", anBuf );t} else if ( psPref -> nType == PREF_PATH ) {ttgchar *pnEncoded = g_filename_to_utf8( psPref -> uValue.pnString ? psPref -> uValue.pnString : """", -1, NULL, NULL, NULL );ttxmlnode_set_attrib( psNode, ""type"", ""path"" );ttxmlnode_set_attrib( psNode, ""value"", pnEncoded );ttg_free( pnEncoded );t}tfor ( psChild = psPref -> psFirstChild; psChild != NULL; psChild = psChild -> psSibling ) {ttpref_to_xmlnode( psNode, psChild );t}}",2,"cwe119,cwe120"
"sfifo_get(struct sfifo *fifo, void *val){tint ret = 0;tif (!fifo || !val) {ttreturn -EINVAL;t}tif (!in_interrupt()) {ttspin_lock_irq(&fifo->lock);ttret = __sfifo_get(fifo, val);ttspin_unlock_irq(&fifo->lock);t} else {ttspin_lock(&fifo->lock);ttret = __sfifo_get(fifo, val);ttspin_unlock(&fifo->lock);t}treturn ret;}",2,"cwe119,cwe120"
"fill_polygon(PLStream *pls){    TekDev *dev = (TekDev *) pls->dev;    int i;    char fillcol[4], firstpoint[5];    if (pls->dev_npts < 1)treturn;    tek_graph(pls);    encode_int(fillcol, -dev->curcolor);    encode_vector(firstpoint, pls->dev_x[0], pls->dev_y[0]);     pls->bytecnt += fprintf(pls->OutFile, ""033MP%s"", fillcol);      if (pls->debug)tpls->bytecnt += fprintf(pls->OutFile, ""033LP%s1"", firstpoint);    elsetpls->bytecnt += fprintf(pls->OutFile, ""033LP%s0"", firstpoint);     pls->bytecnt += fprintf(pls->OutFile, VECTOR_MODE);    for (i = 1; i < pls->dev_npts; i++) ttek_vector(pls, pls->dev_x[i], pls->dev_y[i]);     pls->bytecnt += fprintf(pls->OutFile, ""033LE"");}",3,"cwe119,cwe120,cweother"
"lmhash(tstruct berval *passwd,tstruct berval *hash){tchar UcasePassword[15];tDES_cblock key;tDES_cblock StdText = ""KGS!@#$%"";tDES_cblock hbuf[2];#ifdef HAVE_OPENSSLtDES_key_schedule schedule;#elif defined(HAVE_GNUTLS)tgcry_cipher_hd_t h = NULL;tgcry_error_t err;terr = gcry_cipher_open( &h, GCRY_CIPHER_DES, GCRY_CIPHER_MODE_CBC, 0 );tif ( err ) return;#endiftstrncpy( UcasePassword, passwd->bv_val, 14 );tUcasePassword[14] = '0';tldap_pvt_str2upper( UcasePassword );tlmPasswd_to_key( UcasePassword, &key );#ifdef HAVE_GNUTLSterr = gcry_cipher_setkey( h, &key, sizeof(key) );tif ( err == 0 ) {tterr = gcry_cipher_encrypt( h, &hbuf[0], sizeof(key), &StdText, sizeof(key) );ttif ( err == 0 ) {tttgcry_cipher_reset( h );tttlmPasswd_to_key( &UcasePassword[7], &key );ttterr = gcry_cipher_setkey( h, &key, sizeof(key) );tttif ( err == 0 ) {tttterr = gcry_cipher_encrypt( h, &hbuf[1], sizeof(key), &StdText, sizeof(key) );ttt}tt}ttgcry_cipher_close( h );t}#elif defined(HAVE_OPENSSL)tdes_set_key_unchecked( &key, schedule );tdes_ecb_encrypt( &StdText, &hbuf[0], schedule , DES_ENCRYPT );tlmPasswd_to_key( &UcasePassword[7], &key );tdes_set_key_unchecked( &key, schedule );tdes_ecb_encrypt( &StdText, &hbuf[1], schedule , DES_ENCRYPT );#endifthexify( (char *)hbuf, hash );}",2,"cwe119,cwe120"
"parse_check_opts(int argc, char **argv){ int dcode=0, wcode=0, ycode=0;  int dbucket=0, wbucket=0, ybucket=0;  double value = 0;  time_t u_time = 0;  extern char *optarg;  int c, got_time = 0, got_val = 0;  int optindex = 0;while ((c = getopt_long(argc, argv, ""t:V:vhHDEYdwyp:"",                        CHECKOPTIONS, &optindex)) != EOF)   {   switch ((char)c)      {      case 'D':          DEBUG = true;          break;                case 'E':          DEBUGGING = true;          break;                case 'Y':          DEBUGGING2 = true;          break;                case 'v':          VERBOSE = true;          break;                case 'H':          HISTO = true;          break;                case 'p':          strcpy(PATHNAME,optarg);          break;                case 't':          u_time = (time_t) atoi(optarg);          got_time = 1;          break;                case 'V':          value = atof(optarg);          got_val = 1;          break;                case 'd':          daily = true;          break;                case 'w':          weekly = true;          break;                case 'y':          yearly = true;          break;                default:          printf(""Syntax:"");          CheckSyntax();          exit(1);                }   }if (!got_val)   {   printf(""Syntax:"");   CheckSyntax();   exit(1);   }if (!got_time)   {   u_time = time(NULL);   Verbose(""using current time"");   }if (daily)   {   dcode = Check(value, u_time, DAILY, &dbucket);   }if (weekly || (!daily && !yearly))   {   wcode = Check(value, u_time, WEEKLY, &wbucket);   }if (yearly)   {   ycode = Check(value, u_time, YEARLY, &ybucket);   }printf(""yrly=%d,bkt=%d;wkly=%d,bkt=%d;dly=%d,bkt=%d"",        ycode, ybucket, wcode, wbucket, dcode, dbucket);Verbose("""");if (dcode <= wcode && dcode <= ycode)   {   exit(dcode);   }if (wcode <= dcode && wcode <= ycode)   {   exit(wcode);   }if (ycode <= dcode && ycode <= wcode)   {   exit(ycode);   }}",2,"cwe120,cweother"
"add_ipv4(const char *hostname, int flags, struct addrinfo **aip,tint socktype, int port){tstruct addrinfo *ai;tlwres_context_t *lwrctx = NULL;tlwres_gabnresponse_t *by = NULL;tlwres_addr_t *addr;tlwres_result_t lwres;tint result = 0;tlwres = lwres_context_create(&lwrctx, NULL, NULL, NULL, 0);tif (lwres != LWRES_R_SUCCESS)ttSETERROR(EAI_FAIL);t(void) lwres_conf_parse(lwrctx, lwres_resolv_conf);tif (hostname == NULL && (flags & AI_PASSIVE) == 0) {ttai = ai_clone(*aip, AF_INET);ttif (ai == NULL)tttSETERROR(EAI_MEMORY);tt*aip = ai;ttai->ai_socktype = socktype;ttSIN(ai->ai_addr)->sin_port = port;ttmemmove(&SIN(ai->ai_addr)->sin_addr, v4_loop, 4);t} else {ttlwres = lwres_getaddrsbyname(lwrctx, hostname,ttttt     LWRES_ADDRTYPE_V4, &by);ttif (lwres != LWRES_R_SUCCESS) {tttif (lwres == LWRES_R_NOTFOUND)ttttgoto cleanup;tttelsettttSETERROR(EAI_FAIL);tt}ttaddr = LWRES_LIST_HEAD(by->addrs);ttwhile (addr != NULL) {tttai = ai_clone(*aip, AF_INET);tttif (ai == NULL)ttttSETERROR(EAI_MEMORY);ttt*aip = ai;tttai->ai_socktype = socktype;tttSIN(ai->ai_addr)->sin_port = port;tttmemmove(&SIN(ai->ai_addr)->sin_addr,ttttaddr->address, 4);tttif (flags & AI_CANONNAME) {ttttai->ai_canonname = strdup(by->realname);ttttif (ai->ai_canonname == NULL)tttttSETERROR(EAI_MEMORY);ttt}tttaddr = LWRES_LIST_NEXT(addr, link);tt}t} cleanup:tif (by != NULL)ttlwres_gabnresponse_free(lwrctx, &by);tif (lwrctx != NULL) {ttlwres_conf_clear(lwrctx);ttlwres_context_destroy(&lwrctx);t}treturn (result);}",2,"cwe119,cwe120"
"pdfmark_DOCINFO(gx_device_pdf * pdev, gs_param_string * pairs, uint count,                const gs_matrix * pctm, const gs_param_string * no_objname){         cos_dict_t *const pcd = pdev->Info;    int code = 0, i;    gs_memory_t *mem = pdev->pdf_memory;    if (count & 1)        return_error(gs_error_rangecheck);    for (i = 0; code >= 0 && i < count; i += 2) {        const gs_param_string *pair = pairs + i;        gs_param_string alt_pair[2];        const byte *vdata;t         uint vsize;tt         byte *str = 0;        vsize = 0x0badf00d;          if (pdf_key_eq(pairs + i, ""/Producer"")) {                         string_match_params params;            memcpy(alt_pair, pairs + i, sizeof(alt_pair));            vdata = alt_pair[1].data;            vsize = alt_pair[1].size;            params = string_match_params_default;            params.ignore_case = true;            if (string_match(vdata, vsize, (const byte *)""*Distiller*"",                             11, &params) ||                string_match(vdata, vsize,             (const byte *)""*000D000i000s000t000i000l000l000e000r*"",                             20, &params)                ) {                uint j;                char buf[PDF_MAX_PRODUCER];                int len;                for (j = vsize; j > 0 && vdata[--j] != '+'; )                    DO_NOTHING;                if (vsize - j > 2 && vdata[j] == '+') {                    ++j;                    while (j < vsize && vdata[j] == ' ')                        ++j;                }                                 pdf_store_default_Producer(buf);                len = strlen(buf) - 1;                str = gs_alloc_string(mem, j + len, ""Producer"");                if (str == 0)                    return_error(gs_error_VMerror);                memcpy(str, vdata, j);                memcpy(str + j, buf + 1, len);                alt_pair[1].data = str;                alt_pair[1].size = vsize = j + len;                pair = alt_pair;            }        }        code = pdfmark_put_pair(pcd, pair);        if (str)            gs_free_string(mem, str, vsize, ""Producer"");    }    return code;}",2,"cwe119,cwe120"
"__ecereMethod___ecereNameSpace__ecere__sys__BufferedFile_Read(struct __ecereNameSpace__ecere__com__Instance * this, unsigned char * buffer, unsigned int size, unsigned int count){struct __ecereNameSpace__ecere__sys__BufferedFile * __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile = (struct __ecereNameSpace__ecere__sys__BufferedFile *)(this ? (((char *)this) + 40) : 0);if(__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->handle){unsigned int totalBytesRead = 0;unsigned int bufferCount = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferCount;unsigned int bufferPos = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferPos;unsigned char * fileBuffer = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->buffer + bufferPos;unsigned int readCount = count;readCount *= size;while(0x1){unsigned int bytesRead = (bufferCount > bufferPos) ? (bufferCount - bufferPos) : 0;if(bytesRead > readCount)bytesRead = readCount;if(bytesRead){memcpy(buffer + totalBytesRead, fileBuffer, bytesRead);bufferPos += bytesRead;totalBytesRead += bytesRead;readCount -= bytesRead;}if(readCount){unsigned int read;if(readCount < __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferSize){unsigned int __simpleStruct0;read = (__simpleStruct0 = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferRead, (readCount > __simpleStruct0) ? readCount : __simpleStruct0);if(bufferPos > bufferCount){if(bufferPos + readCount - bufferCount > read && (bufferPos + readCount - bufferCount < bufferCount))read = bufferPos + readCount - bufferCount;else{bufferPos = 0;bufferCount = 0;}}if(bufferCount + read > __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferSize){bufferPos = 0;bufferCount = 0;}}else{read = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferSize;bufferPos = 0;bufferCount = 0;}((unsigned int (*)(struct __ecereNameSpace__ecere__com__Instance *, int pos, int mode))__extension__ ({struct __ecereNameSpace__ecere__com__Instance * __internal_ClassInst = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->handle;__internal_ClassInst ? __internal_ClassInst->_vTbl : __ecereClass___ecereNameSpace__ecere__sys__File->_vTbl;})[__ecereVMethodID___ecereNameSpace__ecere__sys__File_Seek])(__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->handle, __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->pos + totalBytesRead - bufferPos + bufferCount, 0);read = ((int (*)(struct __ecereNameSpace__ecere__com__Instance *, void *  buffer, unsigned int size, unsigned int count))__extension__ ({struct __ecereNameSpace__ecere__com__Instance * __internal_ClassInst = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->handle;__internal_ClassInst ? __internal_ClassInst->_vTbl : __ecereClass___ecereNameSpace__ecere__sys__File->_vTbl;})[__ecereVMethodID___ecereNameSpace__ecere__sys__File_Read])(__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->handle, __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->buffer + bufferCount, 1, read);fileBuffer = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->buffer + bufferPos;bufferCount += read;if(!read){__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->eof = 0x1;break;}}elsebreak;}__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferCount = bufferCount;__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferPos = bufferPos;__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->pos += totalBytesRead;return totalBytesRead / size;}return 0;}",3,"cwe120,cwe469,cweother"
"xsh_frame_image_mult_by_fct(cpl_frame* frm,const int fctx, const int fcty){  const char* name=NULL;  cpl_propertylist* plist=NULL;  cpl_propertylist* hext=NULL;  cpl_image* ima_dat=NULL;  cpl_image* ima_datr=NULL;  int next=0;  int prscx=0;  int prscy=0;  int ovscx=0;  int ovscy=0;  int kk=0;  cpl_frame* frm_cor=NULL;  const char* tag=NULL;  const char* basename=NULL;  char new_name[256];  check(name=cpl_frame_get_filename(frm));  check(tag=cpl_frame_get_tag(frm));  next=cpl_frame_get_nextensions(frm);  check(plist=cpl_propertylist_load(name,0));  check(prscx=xsh_pfits_get_prscx(plist));  check(prscy=xsh_pfits_get_prscy(plist));  check(ovscx=xsh_pfits_get_ovscx(plist));  check(ovscy=xsh_pfits_get_ovscy(plist));  xsh_msg(""Prescan: %d,%d Overscan: %d,%d"",prscx,prscy,ovscx,ovscy);  check(basename=xsh_get_basename(name));  sprintf(new_name,""fctx%d_fcty%d_%s"",fctx,fcty,basename);  xsh_msg(""new_name=%s"",new_name);  xsh_plist_mult_by_fct(&plist,fctx,fcty);  for(kk=0;kk<=next;kk++) {    check(ima_dat=cpl_image_load(name,CPL_TYPE_FLOAT,0,kk));    check(hext=cpl_propertylist_load(name,kk));    ima_datr=xsh_image_mult_by_fct(ima_dat,fctx,fcty);    if(kk==0) {      check(cpl_image_save(ima_datr,new_name,XSH_PRE_DATA_BPP,plist,ttt   CPL_IO_DEFAULT));    } else if (kk==1) {      check(cpl_image_save(ima_datr,new_name,XSH_PRE_ERRS_BPP,hext,ttt   CPL_IO_EXTEND));    } else if (kk==2) {      check(cpl_image_save(ima_datr,new_name,XSH_PRE_QUAL_BPP,hext,ttt   CPL_IO_EXTEND));    }    xsh_free_image(&ima_dat);    xsh_free_image(&ima_datr);    xsh_free_propertylist(&plist);    xsh_free_propertylist(&hext);  }  frm_cor=cpl_frame_new();  cpl_frame_set_filename(frm_cor,new_name);  cpl_frame_set_tag(frm_cor,tag);  cpl_frame_set_type(frm_cor,CPL_FRAME_TYPE_IMAGE);  cpl_frame_set_group(frm_cor,CPL_FRAME_GROUP_CALIB);  xsh_add_temporary_file(new_name);cleanup:  return frm_cor;}",2,"cwe119,cwe120"
"_e_int_menus_item_label_set(Efreet_Menu *entry, E_Menu_Item *mi){   Efreet_Desktop *desktop;   char label[4096];   int opt = 0;   if ((!entry) || (!mi)) return;   desktop = entry->desktop;   if ((e_config->menu_eap_name_show) && (entry->name)) opt |= 0x4;   if (desktop)     {        if ((e_config->menu_eap_generic_show) && (desktop->generic_name) &&            (desktop->generic_name[0] != 0))          opt |= 0x2;        if ((e_config->menu_eap_comment_show) && (desktop->comment) &&            (desktop->comment[0] != 0))          opt |= 0x1;     }   if (opt == 0x7)     snprintf(label, sizeof(label), ""%s (%s) [%s]"", entry->name,              desktop->generic_name, desktop->comment);   else if (opt == 0x6)     snprintf(label, sizeof(label), ""%s (%s)"", entry->name,              desktop->generic_name);   else if (opt == 0x5)     snprintf(label, sizeof(label), ""%s [%s]"", entry->name, desktop->comment);   else if (opt == 0x4)     snprintf(label, sizeof(label), ""%s"", entry->name);   else if (opt == 0x3)     snprintf(label, sizeof(label), ""%s [%s]"", desktop->generic_name,              desktop->comment);   else if (opt == 0x2)     snprintf(label, sizeof(label), ""%s"", desktop->generic_name);   else if (opt == 0x1)     snprintf(label, sizeof(label), ""%s"", desktop->comment);   else     snprintf(label, sizeof(label), ""%s"", entry->name);   e_menu_item_label_set(mi, label);}",2,"cwe119,cwe120"
"Bnet_PrintOrder(  BnetNetwork * net,  DdManager *dd){    char **names;tt     inttlevel;ttt     BnetNode *node;tt     int i,j;    int retval;    int nvars;    nvars = Cudd_ReadSize(dd);    names = ALLOC(char *, nvars);    if (names == NULL) return(0);    for (i = 0; i < nvars; i++) {tnames[i] = NULL;    }    for (i = 0; i < net->npis; i++) {tif (!st_lookup(net->hash,net->inputs[i],&node)) {t    FREE(names);t    return(0);t}tif (node->dd == NULL) {t    FREE(names);t    return(0);t}tlevel = Cudd_ReadPerm(dd,node->var);tnames[level] = node->name;    }    for (i = 0; i < net->nlatches; i++) {tif (!st_lookup(net->hash,net->latches[i][1],&node)) {t    FREE(names);t    return(0);t}tif (node->dd == NULL) {t    FREE(names);t    return(0);t}tlevel = Cudd_ReadPerm(dd,node->var);tnames[level] = node->name;    }    for (i = 0, j = 0; i < nvars; i++) {tif (names[i] == NULL) continue;tif ((j%8 == 0)&&j) {t    retval = printf("""");t    if (retval == EOF) {ttFREE(names);ttreturn(0);t    }t}tretval = printf(""%s "",names[i]);tif (retval == EOF) {t    FREE(names);t    return(0);t}tj++;    }    FREE(names);    retval = printf("""");    if (retval == EOF) {treturn(0);    }    return(1);}",2,"cwe119,cwe120"
"report_error(int type, char *msg, char *details, int doexit){    char error[BIG_LINE*4] = {0};tif (msg)t{ttPL_strcatn(error, BIG_LINE*4, msg);ttPL_strcatn(error, BIG_LINE*4, SEPARATOR);t}tif (details)ttPL_strcatn(error, BIG_LINE*4, details);tds_send_error(error, 1);}",2,"cwe119,cwe120"
"sha4_finish( sha4_context *ctx, unsigned char output[64] ){    size_t last, padn;    uint64_t high, low;    unsigned char msglen[16];    high = ( ctx->total[0] >> 61 )         | ( ctx->total[1] <<  3 );    low  = ( ctx->total[0] <<  3 );    PUT_UINT64_BE( high, msglen, 0 );    PUT_UINT64_BE( low,  msglen, 8 );    last = (size_t)( ctx->total[0] & 0x7F );    padn = ( last < 112 ) ? ( 112 - last ) : ( 240 - last );    sha4_update( ctx, sha4_padding, padn );    sha4_update( ctx, msglen, 16 );    PUT_UINT64_BE( ctx->state[0], output,  0 );    PUT_UINT64_BE( ctx->state[1], output,  8 );    PUT_UINT64_BE( ctx->state[2], output, 16 );    PUT_UINT64_BE( ctx->state[3], output, 24 );    PUT_UINT64_BE( ctx->state[4], output, 32 );    PUT_UINT64_BE( ctx->state[5], output, 40 );    if( ctx->is384 == 0 )    {        PUT_UINT64_BE( ctx->state[6], output, 48 );        PUT_UINT64_BE( ctx->state[7], output, 56 );    }}",2,"cwe119,cwe120"
"check_ompi_info(component_file_item_t *target_file,                            opal_list_t *dependencies,                            opal_list_t *found_components){  size_t len;  FILE *fp;  char *depname;  char buffer[BUFSIZ], *p;     len = strlen(target_file->filename) + strlen(ompi_info_suffix) + 16;  depname = (char*)malloc(len);  if (NULL == depname)    return OPAL_ERR_OUT_OF_RESOURCE;  snprintf(depname, len, ""%s%s"", target_file->filename, ompi_info_suffix);     if (NULL == (fp = fopen(depname, ""r""))) {    free(depname);    return 0;  }     opal_output_verbose(40, 0, ""mca: base: component_find: opening ompi_info file: %s"", depname);  while (NULL != fgets(buffer, BUFSIZ, fp)) {         buffer[BUFSIZ - 1] = '0';    len = strlen(buffer);    if ('' == buffer[len - 1])      buffer[len - 1] = '0';         for (p = buffer; '0' != p; ++p)      if (!isspace(*p))        break;    if ('0' == *p)      continue;    else if (*p == '#' || ('/' == *p && '/' == *(p + 1)))      continue;         else if (0 == strncasecmp(p, key_dependency, strlen(key_dependency))) {      if (OPAL_SUCCESS != check_dependency(p + strlen(key_dependency),                                           target_file, dependencies,                                           found_components)) {        fclose(fp);        free(depname);                 free_dependency_list(dependencies);        return OPAL_ERR_OUT_OF_RESOURCE;      }    }  }  opal_output_verbose(40, 0, ""mca: base: component_find: ompi_info file closed (%s)"",                      target_file->basename);     fclose(fp);  free(depname);  return 0;}",3,"cwe119,cwe120,cweother"
"tclhandleIndex(tblHeader_pt tblHdrPtr, char *handle,tt   unsigned long *entryIdxPtr){    unsigned long entryIdx;    if ((sscanf(handle, tblHdrPtr->handleFormat, &entryIdx)) != 1)treturn TCL_ERROR;    if (entryIdxPtr)t*entryIdxPtr = entryIdx;    return TCL_OK;}",2,"cwe120,cweother"
"get_credential(UINT32 type, UINT32 *size, BYTE **cred){tint rc, fd;tchar *path = NULL;tvoid *file = NULL;tstruct stat stat_buf;tsize_t file_size;tswitch (type) {ttcase TSS_TCS_CREDENTIAL_PLATFORMCERT:tttpath = tcsd_options.platform_cred;tttbreak;ttcase TSS_TCS_CREDENTIAL_TPM_CC:tttpath = tcsd_options.conformance_cred;tttbreak;ttcase TSS_TCS_CREDENTIAL_EKCERT:tttpath = tcsd_options.endorsement_cred;tttbreak;ttdefault:tttLogDebugFn(""Bad credential type"");tttbreak;t}tif (path == NULL)ttgoto done;tif ((fd = open(path, O_RDONLY)) < 0) {ttLogError(""open(%s): %s"", path, strerror(errno));ttgoto done;t}tif ((rc = fstat(fd, &stat_buf)) == -1) {ttLogError(""Error stating credential: %s: %s"", path, strerror(errno));ttclose(fd);ttgoto done;t}tfile_size = (size_t)stat_buf.st_size;tLogDebugFn(""%s, (%zd bytes)"", path, file_size);tfile = mmap(0, file_size, PROT_READ, MAP_PRIVATE, fd, 0);tif (file == MAP_FAILED) {ttLogError(""Error reading credential: %s: %s"", path, strerror(errno));ttclose(fd);ttgoto done;t}tclose(fd);tif ((*cred = malloc(file_size)) == NULL) {ttLogError(""malloc of %zd bytes failed."", file_size);ttmunmap(file, file_size);ttgoto done;t}tmemcpy(*cred, file, file_size);t*size = file_size;tmunmap(file, file_size);treturn;done:t*cred = NULL;t*size = 0;}",2,"cwe120,cweother"
"meh_hash_file(MehHash hash, FILE* fd){    int count;    meh_error_t error;    unsigned char buffer[8192];    if (NULL == fd || NULL == hash)      return meh_error(""null reference passed to meh_hash_file"",tt       MEH_INVALID_ARGUMENT);    while ((count = fread(buffer, sizeof (unsigned char), 8192, fd)) != 0)    {        if ((error = meh_update_hash(hash, buffer, count)) != MEH_OK)            return error;    }        return MEH_OK;}",3,"cwe119,cwe120,cweother"
"echo_input(char *txt){    char out[BUFFER_SIZE],*cptr,*optr;    static int c=7;    if (ui_own_output)    {        user_textout("""");        c=lastcolor;    }    optr=out;    if (ui_own_output)        optr+=sprintf(optr, ECHO_COLOR);    cptr=txt;    while (*cptr)    {        if ((*optr++=*cptr++)=='~')            optr+=sprintf(optr, ""~:~"");        if (optr-out > BUFFER_SIZE-10)            break;    }    if (ui_own_output)        optr+=sprintf(optr, ""~%d~"", c);    else    {        *optr++='';        *optr=0;    }    user_textout(out);}",3,"cwe119,cwe120,cweother"
"getspell(int *spell_no){    int nspells, idx;    char ilet, lets[BUFSZ], qbuf[QBUFSZ];    if (spellid(0) == NO_SPELL)  {        You(""don't know any spells right now."");        return false;    }    if (flags.menu_style == MENU_TRADITIONAL)    {                 for (nspells = 1; nspells < MAXSPELL             && spellid(nspells) != NO_SPELL; nspells++)                continue;        if (nspells == 1)  strcpy(lets, ""a"");        else if (nspells < 27)  sprintf(lets, ""a-%c"", 'a' + nspells - 1);        else if (nspells == 27)  sprintf(lets, ""a-zA"");        else sprintf(lets, ""a-zA-%c"", 'A' + nspells - 27);        for(;;)  {            sprintf(qbuf, ""Cast which spell? [%s ?]"", lets);            if ((ilet = yn_function(qbuf, (char *)0, '0')) == '?')                    break;            if (index(quitchars, ilet))                    return false;            idx = spell_let_to_idx(ilet);            if (idx >= 0 && idx < nspells)            {                *spell_no = idx;                return true;            }            else                    You(""don't know that spell."");        }    }    return dospellmenu(""Choose which spell to cast"",                       SPELLMENU_CAST, spell_no);}",2,"cwe119,cwe120"
"""decode_macroblock(Escape124Context* s, GetBitContext* gb,                                    int* codebook_index, int superblock_index){    // This function reads a maximum of 22 bits; the callers    // guard this function appropriately    unsigned block_index, depth;    if (get_bits1(gb)) {        static const char transitions[3][2] = { {2, 1}, {0, 2}, {1, 0} };        *codebook_index = transitions[*codebook_index][get_bits1(gb)];    }    depth = s->codebooks[*codebook_index].depth;    // depth = 0 means that this shouldn't read any bits;    // in theory, this is the same as get_bits(gb, 0), but    // that doesn't actually work.    block_index = depth ? get_bits(gb, depth) : 0;    if (*codebook_index == 1) {        block_index += superblock_index << s->codebooks[1].depth;    }    // This condition can occur with invalid bitstreams and    // *codebook_index == 2    if (block_index >= s->codebooks[*codebook_index].size)        return (MacroBlock) { { 0 } };    return s->codebooks[*codebook_index].blocks[block_index];}""",2,"cwe119,cwe120"
"ClearSaveSlot(int slot){    int i;    char fileName[100];    for (i = 0; i < MAX_MAPS; i++)    {        sprintf(fileName, ""%shex%d%02d.hxs"", SavePath, slot, i);        remove(fileName);    }    sprintf(fileName, ""%shex%d.hxs"", SavePath, slot);    remove(fileName);}",2,"cwe119,cwe120"
"setuplf(){ INT i;    char command[100];    vari *v;        lfhome = getenv(""LFHOME"");    initdb();        ofile = NULL;    lf.tw = lf.xxev = lf.L = lf.iw = des.dw = lf.pc.wk = NULL;    des.index = NULL;    lf.mg = calloc(MXDIM,sizeof(INT));        v = createvar(""mi"",STSYSPEC,LENM,VINT); v->dpr = (double *)lf.mi;    v = createvar(""dp"",STSYSPEC,LEND,VDOUBLE); v->dpr = lf.dp;    v = createvar(""alpha"",STSYSPEC,1,VDOUBLE); v->dpr = &lf.dp[DALP];    v = createvar(""h"",    STSYSPEC,1,VDOUBLE); v->dpr = &lf.dp[DFXH];    v = createvar(""pen"",  STSYSPEC,1,VDOUBLE); v->dpr = &lf.dp[DADP];    v = createvar(""infl"", STSYSPEC,1,VDOUBLE); v->dpr = &lf.dp[DT0];    v = createvar(""vari"", STSYSPEC,1,VDOUBLE); v->dpr = &lf.dp[DT1];    v = createvar(""like"", STSYSPEC,1,VDOUBLE); v->dpr = &lf.dp[DLK];    v = createvar(""resv"", STSYSPEC,1,VDOUBLE); v->dpr = &lf.dp[DRV];        for (i=0; i<MAXWIN; i++)    { pl[i].xyzs = NULL;        pl[i].id = i;        pl[i].ty = PLNONE;        pl[i].track = NULL;    }                                                      lfcm[0] = 0;    for (i=CAXI; i<=CPA1; i++) lfcm[i] = 1;    lfcm[CPA2] = 2;    rseed(""LocalFit"");    if (setfilename(""LFInit"",""cmd"",""r"",0))    { sprintf(command,""run %s"",filename);        locfit_dispatch(command);    }}",3,"cwe119,cwe120,cweother"
"BlockHeapCreate(const char *const name, size_t elemsize, int elemsperblock){  BlockHeap *bh = NULL;  assert(elemsize > 0 && elemsperblock > 0);     if ((elemsize <= 0) || (elemsperblock <= 0))    outofmemory();          if ((bh = calloc(1, sizeof(BlockHeap))) == NULL)    outofmemory();       if ((elemsize % sizeof(void *)) != 0)  {         elemsize += sizeof(void *);    elemsize &= ~(sizeof(void *) - 1);  }  bh->name = name;  bh->elemSize = elemsize;  bh->elemsPerBlock = elemsperblock;     if (newblock(bh))  {    if (bh != NULL)      free(bh);     outofmemory();       }  bh->next = heap_list;  heap_list = bh;  return bh;}",2,"cwe476,cweother"
"Init_Record (RECORD *rec, int size, char *name, Object *var) {    Object list, tail, cell;    register int i;    char buf[128];    GC_Node2;    GC_Link2 (list, tail);    for (list = tail = Null, i = 1; i < size; tail = cell, i++, rec++) {        cell = Intern (rec->name);        cell = Cons (cell, Make_Integer (i));        cell = Cons (cell, Null);        if (Nullp (list))            list = cell;        else            P_Set_Cdr (tail, cell);    }    sprintf (buf, ""%s-slots"", name);    Define_Variable (var, buf, list);    GC_Unlink;}",2,"cwe119,cwe120"
"us_example_mudp_rx (    const char *multicast_address,    const char *multicast_service,    const char *interface){    int fd;    bool r = false;    struct addrinfo *multicastgroup;    multicastgroup = us_net_get_addrinfo ( multicast_address, multicast_service, SOCK_DGRAM, true );    {        char multicastgroup_name[1024];        char multicastgroup_serv[256];        if ( us_net_get_nameinfo ( multicastgroup, multicastgroup_name, sizeof ( multicastgroup_name ) - 1, multicastgroup_serv, sizeof ( multicastgroup_serv ) - 1 ) )        {            us_log_info ( ""multicastgroup: %s port %s"", multicastgroup_name, multicastgroup_serv );        }        else        {            perror ( ""getnameinfo:"" );        }    }    fd = us_net_create_multicast_rx_udp_socket ( 0, multicastgroup, interface );    if ( fd > 0 )    {        while ( 1 )        {            struct sockaddr_storage remote_addr;            socklen_t remote_addr_len = sizeof ( remote_addr );            char buf[2048];            int len;            len = recvfrom ( fd, buf, sizeof ( buf ), 0, ( struct sockaddr * ) &remote_addr, &remote_addr_len );            if ( len > 0 )            {                us_log_info ( ""got packet %d bytes"", len );            }            else            {                perror ( ""recvfrom:"" );                break;            }        }    }    return r;}",2,"cwe119,cwe120"
"remove_all_selected_lines(){    FILE *fp;    long file_size = 0;    char *line, *tmp;    long num = 0, x = 0;    struct dirent **namelist;    gchar *conf, *connections_path;    connections_path = g_strdup_printf(""%s/client/"", OPENVPN_SYSCONF_DIR);    num = scandir(connections_path, &namelist, 0, alphasort);    if( num < 0 )    {t         g_free(connections_path);        return;    }         for(x=0; x<num; x++)    {t tif( x > 1 )t{t     t    conf = g_strdup_printf(""%s/client/%s/gadmin-openvpn-client.conf"", OPENVPN_SYSCONF_DIR, namelist[x]->d_name);t    if((fp=fopen(conf, ""r""))==NULL)t    {ttg_free(conf);ttfree(namelist[x]);ttcontinue;t    }t    fseek(fp, 0, SEEK_END);t    file_size = ftell(fp);t    rewind(fp);t    line = allocate(file_size+1);t    tmp  = allocate(file_size+1);t    if( file_size > 1 )t    while(fgets(line, file_size, fp)!=NULL)t    {tt ttif( cmplowercase(line, ""connection_selected"") && commented(line) )tt{tt    continue;tt}ttstrcat(tmp, line);t    }t    fclose(fp);t    free(line);t     t    if((fp=fopen(conf, ""w+""))==NULL)t    {ttfree(namelist[x]);ttfree(line);ttfree(tmp);ttg_free(conf);ttcontinue;t    }t    fputs(tmp, fp);t    fclose(fp);t    g_free(conf);t    free(tmp);t}        free(namelist[x]);    }    g_free(connections_path);    free(namelist);}",2,"cwe120,cweother"
"rb_inet_pton(int af, const char *src, void *dst){tswitch (af)t{tcase AF_INET:ttreturn (inet_pton4(src, dst));#ifdef RB_IPV6tcase AF_INET6:tt ttif(inet_pton4(src, dst))tt{tttchar tmp[HOSTIPLEN];tttrb_sprintf(tmp, ""::ffff:%s"", src);tttreturn (inet_pton6(tmp, dst));tt}ttelsetttreturn (inet_pton6(src, dst));#endiftdefault:ttreturn (-1);t}t }",2,"cwe119,cwe120"
"dns_resolver_printbadcache(dns_resolver_t *resolver, FILE *fp) {tchar namebuf[DNS_NAME_FORMATSIZE];tchar typebuf[DNS_RDATATYPE_FORMATSIZE];tdns_badcache_t *bad, *next, *prev;tisc_time_t now;tunsigned int i;tisc_uint64_t t;tLOCK(&resolver->lock);tfprintf(fp, "";; Bad cache;"");tif (resolver->badcache == NULL)ttgoto unlock;tTIME_NOW(&now);tfor (i = 0; i < resolver->badhash; i++) {ttprev = NULL;ttfor (bad = resolver->badcache[i]; bad != NULL; bad = next) {tttnext = bad->next;tttif (isc_time_compare(&bad->expire, &now) < 0) {ttttif (prev != NULL)tttttprev->next = bad->next;ttttelsetttttresolver->badcache[i] = bad->next;ttttisc_mem_put(resolver->mctx, bad, sizeof(*bad) +ttttt    bad->name.length);ttttresolver->badcount--;ttttcontinue;ttt}tttprev = bad;tttdns_name_format(&bad->name, namebuf, sizeof(namebuf));tttdns_rdatatype_format(bad->type, typebuf,ttttt     sizeof(typebuf));tttt = isc_time_microdiff(&bad->expire, &now);tttt /= 1000;tttfprintf(fp, ""; %s/%s [ttl ""tttt""%"" ISC_PLATFORM_QUADFORMAT ""u]"",ttttnamebuf, typebuf, t);tt}t} unlock:tUNLOCK(&resolver->lock);}",2,"cwe119,cwe120"
"scarlett_ctl_meter_get(struct snd_kcontrol *kctl,tttt  struct snd_ctl_elem_value *ucontrol){tstruct usb_mixer_elem_info *elem = kctl->private_data;tstruct snd_usb_audio *chip = elem->head.mixer->chip;tunsigned char buf[2 * MAX_CHANNELS] = {0, };tint wValue = (elem->control << 8) | elem->idx_off;tint idx = snd_usb_ctrl_intf(chip) | (elem->head.id << 8);tint err;terr = snd_usb_ctl_msg(chip->dev,ttttusb_rcvctrlpipe(chip->dev, 0),ttttUAC2_CS_MEM,ttttUSB_RECIP_INTERFACE | USB_TYPE_CLASS |ttttUSB_DIR_IN, wValue, idx, buf, elem->channels);tif (err < 0)ttreturn err;tucontrol->value.enumerated.item[0] = clamp((int)buf[0], 0, 1);treturn 0;}",2,"cwe119,cwe120"
"mixer_write_attr(struct ng_attribute *attr, int val){    struct mixer_handle *h = attr->handle;    switch (attr->id) {    case ATTR_ID_VOLUME:tval &= 0x7f;th->volume = val | (val << 8);tif (-1 == ioctl(h->mix,MIXER_WRITE(h->volctl),&h->volume))t    perror(""oss mixer write volume"");th->muted = 0;tbreak;    case ATTR_ID_MUTE:th->muted = val;tif (h->muted) {t    int zero = 0;t    if (-1 == ioctl(h->mix,MIXER_READ(h->volctl),&h->volume))ttperror(""oss mixer read volume"");t    if (-1 == ioctl(h->mix,MIXER_WRITE(h->volctl),&zero))ttperror(""oss mixer write volume"");t} else {t    if (-1 == ioctl(h->mix,MIXER_WRITE(h->volctl),&h->volume))ttperror(""oss mixer write volume"");t}tbreak;    }}",2,"cwe120,cweother"
"""ipmi_pef_print_field(const char * fmt[2], const char * label, unsigned long val){t/*t// print a 'field' (observes 'verbose' flag)t*/tif (verbose)ttprintf(fmt[0], KYWD_LENGTH, label, val);telse if (first_field)ttprintf(&fmt[1][2], val);t/* skip field separator */telsettprintf(fmt[1], val);tfirst_field = 0;}""",3,"cwe119,cwe120,cweother"
"""MakeSavedImage(GifFileType * GifFile,               const SavedImage * CopyFrom) {    SavedImage *sp;    if (GifFile->SavedImages == NULL)        GifFile->SavedImages = (SavedImage *)malloc(sizeof(SavedImage));    else        GifFile->SavedImages = (SavedImage *)realloc(GifFile->SavedImages,                               sizeof(SavedImage) * (GifFile->ImageCount + 1));    if (GifFile->SavedImages == NULL)        return ((SavedImage *)NULL);    else {        sp = &GifFile->SavedImages[GifFile->ImageCount++];        memset((char *)sp, '0', sizeof(SavedImage));        if (CopyFrom) {            memcpy((char *)sp, CopyFrom, sizeof(SavedImage));            /*              * Make our own allocated copies of the heap fields in the             * copied record.  This guards against potential aliasing             * problems.             */            /* first, the local color map */            if (sp->ImageDesc.ColorMap) {                sp->ImageDesc.ColorMap = MakeMapObject(                                         CopyFrom->ImageDesc.ColorMap->ColorCount,                                         CopyFrom->ImageDesc.ColorMap->Colors);                if (sp->ImageDesc.ColorMap == NULL) {                    FreeLastSavedImage(GifFile);                    return (SavedImage *)(NULL);                }            }            /* next, the raster */            sp->RasterBits = (unsigned char *)malloc(sizeof(GifPixelType) *                                                   CopyFrom->ImageDesc.Height *                                                   CopyFrom->ImageDesc.Width);            if (sp->RasterBits == NULL) {                FreeLastSavedImage(GifFile);                return (SavedImage *)(NULL);            }            memcpy(sp->RasterBits, CopyFrom->RasterBits,                   sizeof(GifPixelType) * CopyFrom->ImageDesc.Height *                   CopyFrom->ImageDesc.Width);            /* finally, the extension blocks */            if (sp->ExtensionBlocks) {                sp->ExtensionBlocks = (ExtensionBlock *)malloc(                                      sizeof(ExtensionBlock) *                                      CopyFrom->ExtensionBlockCount);                if (sp->ExtensionBlocks == NULL) {                    FreeLastSavedImage(GifFile);                    return (SavedImage *)(NULL);                }                memcpy(sp->ExtensionBlocks, CopyFrom->ExtensionBlocks,                       sizeof(ExtensionBlock) * CopyFrom->ExtensionBlockCount);                /*                  * For the moment, the actual blocks can take their                 * chances with free().  We'll fix this later.                  *** FIXME: [Better check this out... Toshio]                 * 2004 May 27: Looks like this was an ESR note.                 * It means the blocks are shallow copied from InFile to                 * OutFile.  However, I don't see that in this code....                 * Did ESR fix it but never remove this note (And other notes                 * in gifspnge?)                 */            }        }        return (sp);    }}""",2,"cwe120,cweother"
"_sdr_cache_get_cache_filename (pstdout_state_t pstate,ttt       const char *hostname,ttt       const char *cache_dir,ttt       const char *cache_file,ttt       char *buf,ttt       unsigned int buflen){  char sdrcachebuf[MAXPATHLEN+1];  char *ptr;  int ret;  assert (buf);  assert (buflen);  if (!cache_file)    {      char hostnamebuf[MAXHOSTNAMELEN+1];      memset (hostnamebuf, '0', MAXHOSTNAMELEN+1);      if (gethostname (hostnamebuf, MAXHOSTNAMELEN) < 0)tsnprintf (hostnamebuf, MAXHOSTNAMELEN, ""localhost"");             if ((ptr = strchr (hostnamebuf, '.')))t*ptr = '0';            if (_sdr_cache_get_cache_directory (pstate,ttttt  cache_dir,ttttt  sdrcachebuf,ttttt  MAXPATHLEN) < 0)treturn (-1);      if ((ret = snprintf (buf,ttt   buflen,ttt   ""%s/%s-%s.%s"",ttt   sdrcachebuf,ttt   SDR_CACHE_FILENAME_PREFIX,ttt   hostnamebuf,ttt   hostname ? hostname : ""localhost"")) < 0)tt{t  PSTDOUT_PERROR (pstate, ""snprintf"");t  return (-1);t}      if (ret >= buflen)t{t  PSTDOUT_FPRINTF (pstate,ttt   stderr,ttt   ""snprintf invalid bytes written"");t  return (-1);t}    }  else    {      if (strlen (cache_file) > (MAXPATHLEN - 1))        {          PSTDOUT_FPRINTF (pstate,                           stderr,                           ""internal overflow error"");          return (-1);        }            if (access (cache_file, R_OK) < 0)        {t  if (errno != ENOENT)t    {t      PSTDOUT_FPRINTF (pstate,ttt       stderr,ttt       ""Cannot access cache file: %s"",ttt       cache_file);t      return (-1);t    }t  elset    {t       t      char cachedirbuf[MAXPATHLEN+1];t      char *cachedirptr;t      strcpy (cachedirbuf, cache_file);t      cachedirptr = dirname (cachedirbuf);t      t      if (_sdr_cache_get_cache_directory (pstate,tttttt  cachedirptr,tttttt  sdrcachebuf,tttttt  MAXPATHLEN) < 0)ttreturn (-1);t    }        }            if ((ret = snprintf (buf,                           buflen,ttt   ""%s"",ttt   cache_file)) < 0)        {          PSTDOUT_PERROR (pstate, ""snprintf"");          return (-1);        }      if (ret >= buflen)        {          PSTDOUT_FPRINTF (pstate,                           stderr,                           ""snprintf invalid bytes written"");          return (-1);t}    }  return (0);}",3,"cwe119,cwe120,cweother"
"""ultodec(long unsigned int value, char *result, int length){  int place;  /* determine number of places to be used */  if (value == 0) {    place = 1;  } else {    for (place = 1; value > powers[place]; place++);  }  if (place < length) {    int rc = place + 1;tt/* return code */    while (place-- > 0) {      unsigned long p = powers[place] + 1;      int v;      for (v = 0; value >= p; value -= p, v++);      *result++ = digits[v];    }    *result = '0';    return rc;  } else {    /* insufficent space in caller provided string */    return -1;  }  /* NOTREACHED */}""",3,"cwe119,cwe120,cweother"
"auth_connect_callback(fde_t *fd, int error, void *data){  struct AuthRequest *auth = data;  struct irc_ssaddr us;  struct irc_ssaddr them;  char authbuf[32];  socklen_t ulen = sizeof(struct irc_ssaddr);  socklen_t tlen = sizeof(struct irc_ssaddr);  uint16_t uport, tport;#ifdef IPV6  struct sockaddr_in6 *v6;#else  struct sockaddr_in *v4;#endif  if (error != COMM_OK)  {    auth_error(auth);    return;  }  if (getsockname(auth->client->localClient->fd.fd, (struct sockaddr *)&us,      &ulen) ||      getpeername(auth->client->localClient->fd.fd, (struct sockaddr *)&them,      &tlen))  {    ilog(L_INFO, ""auth get{sock,peer}name error for %s"",        get_client_name(auth->client, SHOW_IP));    auth_error(auth);    return;  }#ifdef IPV6  v6 = (struct sockaddr_in6 *)&us;  uport = ntohs(v6->sin6_port);  v6 = (struct sockaddr_in6 *)&them;  tport = ntohs(v6->sin6_port);  remove_ipv6_mapping(&us);  remove_ipv6_mapping(&them);#else  v4 = (struct sockaddr_in *)&us;  uport = ntohs(v4->sin_port);  v4 = (struct sockaddr_in *)&them;  tport = ntohs(v4->sin_port);  us.ss_len = ulen;  them.ss_len = tlen;#endif    snprintf(authbuf, sizeof(authbuf), ""%u , %ur"", tport, uport);  if (send(fd->fd, authbuf, strlen(authbuf), 0) == -1)  {    auth_error(auth);    return;  }  read_auth_reply(&auth->fd, auth);}",2,"cwe119,cwe120"
"dump_hexfile2(struct hexdata *hexdata, const char *outfile, uint8_t maxwidth){tFILEtt*fp;tuint8_ttttt;tunsigned intti;tstruct hexlinet*line;tif(report_func)ttreport_func(LOG_INFO,ttt""Dumping hex data into '%s' (maxwidth=%d)"",tttoutfile, maxwidth);tif(!outfile || strcmp(outfile, ""-"") == 0)ttfp = stdout;telse if((fp = fopen(outfile, ""w"")) == NULL) {ttperror(outfile);ttexit(1);t}tif(maxwidth == 0)ttmaxwidth = UINT8_MAX;tfor(i = 0; i <= hexdata->last_line; i++) {ttintttbytesleft = 0;ttintttextra_offset = 0;ttintttbase_offset;ttuint8_ttt*base_data;ttttline = hexdata->lines[i];ttif(!line) {tttif(report_func)ttttreport_func(LOG_ERR, ""Missing line at #%d"", i);tttreturn -EINVAL;tt}ttbytesleft = line->d.content.header.ll;tt tttt = line->d.content.header.tt;ttbase_offset = line->d.content.header.offset;ttbase_data = line->d.content.tt_data.data;ttwhile (bytesleft > 0) {tttstruct hexlinet*extraline;tttuint8_tttnew_chksum;tttunsigned inttcurr_bytes = (bytesleft >= maxwidth) ? maxwidth : bytesleft;ttt tttif((extraline = new_hexline(curr_bytes, base_offset + extra_offset, tt)) == NULL) {ttttif(report_func)tttttreport_func(LOG_ERR, ""No more memory for hexfile lines"");ttttreturn -EINVAL;ttt}tttmemcpy(extraline->d.content.tt_data.data, base_data + extra_offset, curr_bytes);tttnew_chksum = 0xFF - hexline_checksum(extraline) + 1;tttextraline->d.content.tt_data.data[curr_bytes] = new_chksum;ttt tttdump_hexline(i, extraline, fp);ttt tttfree(extraline);tttextra_offset += curr_bytes;tttbytesleft -= curr_bytes;tt}t}tif(tt != TT_EOF) {ttif(report_func)tttreport_func(LOG_ERR, ""Missing EOF record"");ttreturn -EINVAL;t}tdump_hexline(i, line, fp);treturn 0;}",2,"cwe469,cweother"
"""clearCallbacks(htscallbacks * chain_) {  htscallbacks *chain;  chain = chain_;  while(chain != NULL) {    if (chain->exitFnc != NULL) {      (void) chain->exitFnc();  /* result ignored */      chain->exitFnc = NULL;    }    chain = chain->next;  }  chain = chain_;  while(chain != NULL) {    if (chain->moduleHandle != NULL) {#ifdef _WIN32      FreeLibrary(chain->moduleHandle);#else      dlclose(chain->moduleHandle);#endif    }    chain = chain->next;  }  chain = chain_->next;         // Don't free the block #0  while(chain != NULL) {    htscallbacks *nextchain = chain->next;    freet(chain);    chain = nextchain;  }  chain_->next = NULL;          // Empty}""",2,"cwe120,cwe476"
"lua_dobuffer (char *buff, int size, char *name) {  char newname[SIZE_PREF+25];  ZIO z;  int status;  if (name==NULL) {    build_name(buff, newname);    name = newname;  }  luaZ_mopen(&z, buff, size, name);  status = do_main(&z, buff[0]==ID_CHUNK);  return status;}",2,"cwe119,cwe120"
"inputline_make_tag(GtkEntry *entry, enum text_tag_type type){  char buf[MAX_LEN_MSG];  GtkEditable *editable = GTK_EDITABLE(entry);  gint start_pos, end_pos;  gchar *selection;  if (!gtk_editable_get_selection_bounds(editable, &start_pos, &end_pos)) {         start_pos = end_pos = gtk_editable_get_position(editable);  }  selection = gtk_editable_get_chars(editable, start_pos, end_pos);  if (type == TTT_COLOR) {         char fg_color_text[32], bg_color_text[32];    GdkColor *fg_color = g_object_get_data(G_OBJECT(entry), ""fg_color"");    GdkColor *bg_color = g_object_get_data(G_OBJECT(entry), ""bg_color"");    if (!fg_color && !bg_color) {      goto CLEAN_UP;    }    color_to_string(fg_color, fg_color_text, sizeof(fg_color_text));    color_to_string(bg_color, bg_color_text, sizeof(bg_color_text));    if (0 == featured_text_apply_tag(selection, buf, sizeof(buf),                                     TTT_COLOR, 0, FT_OFFSET_UNSET,                                     ft_color(fg_color_text,                                              bg_color_text))) {      goto CLEAN_UP;    }  } else if (0 == featured_text_apply_tag(selection, buf, sizeof(buf),                                          type, 0, FT_OFFSET_UNSET)) {    goto CLEAN_UP;  }     gtk_editable_delete_text(editable, start_pos, end_pos);  end_pos = start_pos;  gtk_editable_insert_text(editable, buf, -1, &end_pos);  gtk_editable_select_region(editable, start_pos, end_pos);CLEAN_UP:  g_free(selection);}",2,"cwe119,cwe120"
"pixBestCorrelation(PIX        *pix1,                   PIX        *pix2,                   l_int32     area1,                   l_int32     area2,                   l_int32     etransx,                   l_int32     etransy,                   l_int32     maxshift,                   l_int32    *tab8,                   l_int32    *pdelx,                   l_int32    *pdely,                   l_float32  *pscore,                   l_int32     debugflag){l_int32    shiftx, shifty, delx, dely;l_int32   *tab;l_float32  maxscore, score;FPIX      *fpix;PIX       *pix3, *pix4;    PROCNAME(""pixBestCorrelation"");    if (pdelx) *pdelx = 0;    if (pdely) *pdely = 0;    if (pscore) *pscore = 0.0;    if (!pix1 || pixGetDepth(pix1) != 1)        return ERROR_INT(""pix1 not defined or not 1 bpp"", procName, 1);    if (!pix2 || pixGetDepth(pix2) != 1)        return ERROR_INT(""pix2 not defined or not 1 bpp"", procName, 1);    if (!area1 || !area2)        return ERROR_INT(""areas must be > 0"", procName, 1);    if (debugflag > 0)        fpix = fpixCreate(2 * maxshift + 1, 2 * maxshift + 1);    if (!tab8)        tab = makePixelSumTab8();    else        tab = tab8;             maxscore = 0;    delx = etransx;    dely = etransy;    for (shifty = -maxshift; shifty <= maxshift; shifty++) {        for (shiftx = -maxshift; shiftx <= maxshift; shiftx++) {            pixCorrelationScoreShifted(pix1, pix2, area1, area2,                                       etransx + shiftx,                                       etransy + shifty, tab, &score);            if (debugflag > 0) {                fpixSetPixel(fpix, maxshift + shiftx, maxshift + shifty,                             1000.0 * score);             }            if (score > maxscore) {                maxscore = score;                delx = etransx + shiftx;                dely = etransy + shifty;            }        }    }    if (debugflag > 0) {        char buf[128];        lept_mkdir(""lept"");        pix3 = fpixDisplayMaxDynamicRange(fpix);        pix4 = pixExpandReplicate(pix3, 20);        snprintf(buf, sizeof(buf), ""/tmp/lept/correl_%d.png"", debugflag);        pixWrite(buf, pix4, IFF_PNG);        pixDestroy(&pix3);        pixDestroy(&pix4);        fpixDestroy(&fpix);    }    if (pdelx) *pdelx = delx;    if (pdely) *pdely = dely;    if (pscore) *pscore = maxscore;    if (!tab8) FREE(tab);    return 0;}",2,"cwe119,cwe120"
"interactive_pass(const char *prompt, char *pass, size_t maxlen,ttlong timeout){tstruct termios orig, tmp;tint failed = -1;tint infd = STDIN_FILENO, outfd;tif (maxlen < 1)ttgoto out_err;t tif ((infd = outfd = open(""/dev/tty"", O_RDWR)) == -1) {ttinfd = STDIN_FILENO;ttoutfd = STDERR_FILENO;t}tif (tcgetattr(infd, &orig))ttgoto out_err;tmemcpy(&tmp, &orig, sizeof(tmp));ttmp.c_lflag &= ~ECHO;tif (write(outfd, prompt, strlen(prompt)) < 0)ttgoto out_err;ttcsetattr(infd, TCSAFLUSH, &tmp);tif (timeout)ttfailed = timed_read(infd, pass, maxlen, timeout);telsettfailed = untimed_read(infd, pass, maxlen);ttcsetattr(infd, TCSAFLUSH, &orig);out_err:tif (!failed && write(outfd, """", 1));tif (infd != STDIN_FILENO)ttclose(infd);treturn failed;}",2,"cwe120,cweother"
"G3d_range_updateFromTile(G3D_Map * map, const void *tile, int rows, int cols,ttt int depths, int xRedundant, int yRedundant,ttt int zRedundant, int nofNum, int type){    int y, z, cellType;    struct FPRange *range;    range = &(map->range);    cellType = G3d_g3dType2cellType(type);    if (nofNum == map->tileSize) {tG_row_update_fp_range(tile, map->tileSize, range, cellType);treturn;    }    if (xRedundant) {tfor (z = 0; z < depths; z++) {t    for (y = 0; y < rows; y++) {ttG_row_update_fp_range(tile, cols, range, cellType);tttile = G_incr_void_ptr(tile, map->tileX * G3d_length(type));t    }t    if (yRedundant)tttile =tt    G_incr_void_ptr(tile,tttt    map->tileX * yRedundant *tttt    G3d_length(type));t}treturn;    }    if (yRedundant) {tfor (z = 0; z < depths; z++) {t    G_row_update_fp_range(tile, map->tileX * rows, range, cellType);t    tile = G_incr_void_ptr(tile, map->tileXY * G3d_length(type));t}treturn;    }    G_row_update_fp_range(tile, map->tileXY * depths, range, cellType);}",3,"cwe119,cwe120,cweother"
"mono_assembly_try_decode_skip_verification (const char *p, const char *endn){tint i, j, num, len, params_len;tif (*p == MONO_DECLSEC_FORMAT_10) {ttgsize read, written;ttchar *res = g_convert (p, endn - p, ""UTF-8"", ""UTF-16LE"", &read, &written, NULL);ttif (res) {tttgboolean found = strstr (res, SKIP_VISIBILITY_XML_ATTRIBUTE) != NULL;tttg_free (res);tttreturn found;tt}ttreturn FALSE;t}tif (*p++ != MONO_DECLSEC_FORMAT_20)ttreturn FALSE;t tnum = mono_metadata_decode_value (p, &p);tfor (i = 0; i < num; ++i) {ttgboolean is_valid = FALSE;ttgboolean abort_decoding = FALSE;tt ttlen =  mono_metadata_decode_value (p, &p);tt ttis_valid = len >= SKIP_VISIBILITY_ATTRIBUTE_SIZE && !memcmp (p, SKIP_VISIBILITY_ATTRIBUTE_NAME, SKIP_VISIBILITY_ATTRIBUTE_SIZE);ttp += len;tt ttparams_len =  mono_metadata_decode_value (p, &p);ttif (is_valid) {tttconst char *params_end = p + params_len;tttttt tttlen = mono_metadata_decode_value (p, &p);ttttfor (j = 0; j < len; ++j) {ttttif (mono_assembly_try_decode_skip_verification_param (p, &p, &abort_decoding))tttttreturn TRUE;ttttif (abort_decoding)tttttbreak;ttt}tttp = params_end;tt} else {tttp += params_len;tt}t}ttreturn FALSE;}",2,"cwe120,cweother"
"add_variant(tDBusMessage *m,tint type,tconst void *data) {tDBusMessageIter iter, sub;tchar t[2];tt[0] = (char) type;tt[1] = 0;tdbus_message_iter_init_append(m, &iter);tif (!dbus_message_iter_open_container(&iter, DBUS_TYPE_VARIANT, t, &sub))ttreturn FALSE;tif (!dbus_message_iter_append_basic(&sub, type, data))ttreturn FALSE;tif (!dbus_message_iter_close_container(&iter, &sub))ttreturn FALSE;treturn TRUE;}",2,"cwe119,cwe120"
"ff_rdt_calc_response_and_checksum(char response[41], char chksum[9],                                  const char *challenge){    int ch_len = strlen (challenge), i;    unsigned char zres[16],        buf[64] = { 0xa1, 0xe9, 0x14, 0x9d, 0x0e, 0x6b, 0x3b, 0x59 };#define XOR_TABLE_SIZE 37    const unsigned char xor_table[XOR_TABLE_SIZE] = {        0x05, 0x18, 0x74, 0xd0, 0x0d, 0x09, 0x02, 0x53,        0xc0, 0x01, 0x05, 0x05, 0x67, 0x03, 0x19, 0x70,        0x08, 0x27, 0x66, 0x10, 0x10, 0x72, 0x08, 0x09,        0x63, 0x11, 0x03, 0x71, 0x08, 0x08, 0x70, 0x02,        0x10, 0x57, 0x05, 0x18, 0x54 };         if (ch_len == 40)          ch_len = 32;    else if (ch_len > 56)        ch_len = 56;    memcpy(buf + 8, challenge, ch_len);         for (i = 0; i < XOR_TABLE_SIZE; i++)        buf[8 + i] ^= xor_table[i];    av_md5_sum(zres, buf, 64);    ff_data_to_hex(response, zres, 16);    for (i=0;i<32;i++) response[i] = tolower(response[i]);         strcpy (response + 32, ""01d0a8e3"");         for (i = 0; i < 8; i++)        chksum[i] = response[i * 4];    chksum[8] = 0;}",2,"cwe119,cwe120"
"pop3_get_flags(mailmessage * msg_info,    struct mail_flags ** result){  int r;  struct mail_flags * flags;  struct mail_cache_db * cache_db_flags;  char filename_flags[PATH_MAX];  int res;  struct pop3_cached_session_state_data * cached_data;  MMAPString * mmapstr;  if (msg_info->msg_flags != NULL) {    * result = msg_info->msg_flags;        return MAIL_NO_ERROR;  }  cached_data = get_cached_session_data(msg_info);  flags = mail_flags_store_get(cached_data->pop3_flags_store,      msg_info->msg_index);    if (flags == NULL) {    snprintf(filename_flags, PATH_MAX, ""%s/%s"",        cached_data->pop3_flags_directory, FLAGS_NAME);        r = mail_cache_db_open_lock(filename_flags, &cache_db_flags);    if (r < 0) {      res = MAIL_ERROR_FILE;      goto err;    }        mmapstr = mmap_string_new("""");    if (mmapstr == NULL) {      res = MAIL_ERROR_MEMORY;      goto close_db_flags;    }        r = pop3driver_get_cached_flags(cache_db_flags, mmapstr,        msg_info->msg_session, msg_info->msg_index, &flags);    if (r != MAIL_NO_ERROR) {      flags = mail_flags_new_empty();      if (flags == NULL) {tres = MAIL_ERROR_MEMORY;tgoto free_mmapstr;      }    }    mmap_string_free(mmapstr);    mail_cache_db_close_unlock(filename_flags, cache_db_flags);  }  msg_info->msg_flags = flags;  * result = flags;  return MAIL_NO_ERROR; free_mmapstr:  mmap_string_free(mmapstr); close_db_flags:  mail_cache_db_close_unlock(filename_flags, cache_db_flags); err:  return res;}",2,"cwe119,cwe120"
"folder_lister_fullname(FSTATE_S *fs, char *name){    if(fs->context->dir->status & CNTXT_SUBDIR){tchar tmp[2*MAILTMPLEN], tmp2[2*MAILTMPLEN], *p;tif(fs->context->dir->ref){t    snprintf(tmp, sizeof(tmp), ""%.*s%.*s"",tt  sizeof(tmp)/2,tt  ((fs->relative_path || (fs->context->use & CNTXT_SAVEDFLT))tt   && (p = strstr(fs->context->context, ""%s"")) && !*(p+2)tt   && !strncmp(fs->context->dir->ref, fs->context->context,ttt       p - fs->context->context))tt    ? fs->context->dir->ref + (p - fs->context->context)tt    : fs->context->dir->ref,tt  sizeof(tmp)/2, name);t    tmp[sizeof(tmp)-1] = '0';t}t tif(context_isambig(tmp)t   && !fs->relative_patht   && !(fs->context->use & CNTXT_SAVEDFLT)){t     t    if(fs->context->dir->ref){ttif(IS_REMOTE(fs->context->context)tt   && (p = strrindex(fs->context->context, '}'))){tt    snprintf(tmp2, sizeof(tmp2), ""%.*s%.*s"",ttt  MIN(p - fs->context->context + 1, sizeof(tmp2)/2),ttt  fs->context->context,ttt  sizeof(tmp2)/2, tmp);tt    tmp2[sizeof(tmp2)-1] = '0';tt}ttelsett  build_path(tmp2, ps_global->ui.homedir, tmp, sizeof(tmp2));t    }t    elset      (void) context_apply(tmp2, fs->context, tmp, sizeof(tmp2));t    return(cpystr(tmp2));t}treturn(cpystr(tmp));    }    return(cpystr(name));}",2,"cwe119,cwe120"
"standard(void){tint n,i,p[10];tswitch (code[ic].f1) {tcase -1:ttpush(getchar());ttrestore(0);ttbreak;tcase -2:ttputchar(top(0));ttpush(0);ttrestore(0);ttbreak;tcase -3:ttn=code[ic].f2;ttif(n>10*sizeof(int))tttrunerror(""too many arguments for printf"");ttfor (i=0; sizeof(int)*i<n; i++)tttp[i]=pop();ttprintf((char *)p[0],p[1],p[2],p[3],p[4],tt       p[5],p[6],p[7],p[8],p[9]);ttpush(0);ttbreak;tdefault:ttrunerror(""system error: standard function"");t}}",3,"cwe119,cwe120,cweother"
"""ParseURL(char * input){int c;char ch;int len = strlen(input);char * output = __ecereNameSpace__ecere__com__eSystem_New(sizeof(char) * (len + 1));len = 0;for(c = 0; (ch = input[c]); c++){if(ch == '%' && isalnum(input[c + 1]) && isalnum(input[c + 2])){char hex[3] = {input[c + 1], input[c + 2], (char)0};char * end;int v = (int)strtoul(hex, &end, 16);if(v && end == hex + 2){output[len++] = (char)v;c += 2;continue;}}output[len++] = ch;}output[len++] = (unsigned char)0;return __ecereNameSpace__ecere__com__eSystem_Renew(output, sizeof(char) * (len));}""",2,"cwe119,cwe120"
"input_read(input_ty *fp, void *data, long len){    if (len <= 0)        return 0;    if (fp->pushback_len > 0)    {        fp->pushback_len--;        *(char *)data = fp->pushback_buf[fp->pushback_len];        return 1;    }    return fp->vptr->read(fp, data, len);}",2,"cwe120,cweother"
"archive_run_script(slurmdb_archive_cond_t *arch_cond,tt   char *cluster_name, time_t last_submit){tchar * args[] = {arch_cond->archive_script, NULL};tstruct stat st;tchar **env = NULL;ttime_t curr_end;tif (stat(arch_cond->archive_script, &st) < 0) {tterrno = errno;tterror(""archive_run_script: failed to stat %s: %m"",tt      arch_cond->archive_script);ttreturn SLURM_ERROR;t}tif (!(st.st_mode & S_IFREG)) {tterrno = EACCES;tterror(""archive_run_script: %s isn't a regular file"",tt      arch_cond->archive_script);ttreturn SLURM_ERROR;t}tif (access(arch_cond->archive_script, X_OK) < 0) {tterrno = EACCES;tterror(""archive_run_script: %s is not executable"",tt      arch_cond->archive_script);ttreturn SLURM_ERROR;t}tenv = env_array_create();tenv_array_append_fmt(&env, ""SLURM_ARCHIVE_CLUSTER"", ""%s"",ttt     cluster_name);tif(arch_cond->purge_event != NO_VAL) {ttif(!(curr_end = archive_setup_end_time(ttt     last_submit, arch_cond->purge_event))) {ttterror(""Parsing purge events failed"");tttreturn SLURM_ERROR;tt}ttenv_array_append_fmt(&env, ""SLURM_ARCHIVE_EVENTS"", ""%u"",tttt     SLURMDB_PURGE_ARCHIVE_SET(ttttt     arch_cond->purge_event));ttenv_array_append_fmt(&env, ""SLURM_ARCHIVE_LAST_EVENT"", ""%ld"",tttt     (long)curr_end);t}tif(arch_cond->purge_job != NO_VAL) {ttif(!(curr_end = archive_setup_end_time(ttt     last_submit, arch_cond->purge_job))) {ttterror(""Parsing purge job failed"");tttreturn SLURM_ERROR;tt}ttenv_array_append_fmt(&env, ""SLURM_ARCHIVE_JOBS"", ""%u"",tttt     SLURMDB_PURGE_ARCHIVE_SET(ttttt     arch_cond->purge_job));ttenv_array_append_fmt(&env, ""SLURM_ARCHIVE_LAST_JOB"", ""%ld"",tttt     (long)curr_end);t}tif(arch_cond->purge_step != NO_VAL) {ttif(!(curr_end = archive_setup_end_time(ttt     last_submit, arch_cond->purge_step))) {ttterror(""Parsing purge step"");tttreturn SLURM_ERROR;tt}ttenv_array_append_fmt(&env, ""SLURM_ARCHIVE_STEPS"", ""%u"",tttt     SLURMDB_PURGE_ARCHIVE_SET(ttttt     arch_cond->purge_step));ttenv_array_append_fmt(&env, ""SLURM_ARCHIVE_LAST_STEP"", ""%ld"",tttt     (long)curr_end);t}tif(arch_cond->purge_suspend != NO_VAL) {ttif(!(curr_end = archive_setup_end_time(ttt     last_submit, arch_cond->purge_suspend))) {ttterror(""Parsing purge suspend"");tttreturn SLURM_ERROR;tt}ttenv_array_append_fmt(&env, ""SLURM_ARCHIVE_SUSPEND"", ""%u"",tttt     SLURMDB_PURGE_ARCHIVE_SET(ttttt     arch_cond->purge_suspend));ttenv_array_append_fmt(&env, ""SLURM_ARCHIVE_LAST_SUSPEND"", ""%ld"",tttt     (long)curr_end);t}#ifdef _PATH_STDPATHtenv_array_append (&env, ""PATH"", _PATH_STDPATH);#elsetenv_array_append (&env, ""PATH"", ""/bin:/usr/bin"");#endiftexecve(arch_cond->archive_script, args, env);tenv_array_free(env);treturn SLURM_SUCCESS;}",3,"cwe119,cwe120,cweother"
"uild_cpuinfo(void){tchar line[1024] = { 0 }, *s, *e;tFILE *f;tint ncpu = 0;tif (!(f = fopen(""/proc/cpuinfo"", ""r""))) {ttIBWARN(""couldn't open /proc/cpuinfo"");ttreturn 0;t}twhile (fgets(line, sizeof(line) - 1, f)) {ttif (!strncmp(line, ""processort"", 10)) {tttncpu++;tttif (ncpu > MAX_CPUS)ttttreturn MAX_CPUS;tttcontinue;tt}ttif (!ncpu || !(s = strchr(line, ':')))tttcontinue;ttif ((e = strchr(s, '')))ttt*e = 0;ttif (!strncmp(line, ""model namet"", 11))tttcpus[ncpu - 1].model = strdup(s + 1);ttelse if (!strncmp(line, ""cpu MHzt"", 8))tttcpus[ncpu - 1].mhz = strdup(s + 1);t}tfclose(f);tDEBUG(""ncpu %d"", ncpu);treturn ncpu;}",3,"cwe119,cwe120,cweother"
"""main(int argc, char **argv) {ttchar *str, *out;tint i, len;tif (argc == 1)t  return 0; // Not putting up with that craptlen = strlen(argv[1]);tstr = malloc(len+2);tstrcpy(str+1, argv[1]);t//len = atoi(argv[1]);t//str = malloc(len+2);t//for(i = 1; i < len+1; ++i)t//tstr[i] = '0'+(rand()&3);t*str = 0; // Prepend a EOF. This will be sorted before any othert// charactertout = bwt(str, len+1);t// Replace the EOF with a $ for output purposestfor (i = 0; i < len+1; ++i)ttif (!out[i]) {tttout[i] = '$';tttbreak;tt}tputs(out);tfree(str);tfree(out);treturn 0;}""",2,"cwe120,cweother"
"__vswscanf (const wchar_t *string, const wchar_t *format, _IO_va_list args){  int ret;  _IO_strfile sf;  struct _IO_wide_data wd;#ifdef _IO_MTSAFE_IO  sf._sbf._f._lock = NULL;#endif  _IO_no_init (&sf._sbf._f, _IO_USER_LOCK, 0, &wd, &_IO_wstr_jumps);  _IO_fwide (&sf._sbf._f, 1);  _IO_wstr_init_static (&sf._sbf._f, (wchar_t *)string, 0, NULL);  ret = _IO_vfwscanf ((_IO_FILE *) &sf._sbf, format, args, NULL);  return ret;}",2,"cwe120,cweother"
"do_sign(struct strbuf *buffer){tstruct child_process gpg;tconst char *args[4];tchar *bracket;tint len;tint i, j;tif (!*signingkey) {ttif (strlcpy(signingkey, git_committer_info(IDENT_ERROR_ON_NO_NAME),ttttsizeof(signingkey)) > sizeof(signingkey) - 1)tttreturn error(""committer info too long."");ttbracket = strchr(signingkey, '>');ttif (bracket)tttbracket[1] = '0';t}t tsignal(SIGPIPE, SIG_IGN);tmemset(&gpg, 0, sizeof(gpg));tgpg.argv = args;tgpg.in = -1;tgpg.out = -1;targs[0] = ""gpg"";targs[1] = ""-bsau"";targs[2] = signingkey;targs[3] = NULL;tif (start_command(&gpg))ttreturn error(""could not run gpg."");tif (write_in_full(gpg.in, buffer->buf, buffer->len) != buffer->len) {ttclose(gpg.in);ttclose(gpg.out);ttfinish_command(&gpg);ttreturn error(""gpg did not accept the tag data"");t}tclose(gpg.in);tlen = strbuf_read(buffer, gpg.out, 1024);tclose(gpg.out);tif (finish_command(&gpg) || !len || len < 0)ttreturn error(""gpg failed to sign the tag"");t tfor (i = j = 0; i < buffer->len; i++)ttif (buffer->buf[i] != 'r') {tttif (i != j)ttttbuffer->buf[j] = buffer->buf[i];tttj++;tt}tstrbuf_setlen(buffer, j);treturn 0;}",2,"cwe119,cwe120"
"dir_add_monitors(char *path, struct dirent **namelist, int flags, ttttnotifier_t *notifier) {tstatic int rec_depth = 0;tt tstatic int rec_count = 0;tt tchar dir_path[MAX_DIR_PATH];tchar *dir_name;tint ndirs;tttttt tstatic int tidx = 0;ttt tstatic pthread_t tid[MAX_DIR_NUMBER]; tint i;tif (rec_depth >= RECUR_DEPTH) {tt--rec_depth;ttreturn 0;t}t++rec_depth;tmemset(dir_path, 0, sizeof dir_path);tmemset(tid, 0, sizeof tid);t tndirs = scandir(path, &namelist, filter_dir, alphasort);tif (ndirs < 0) {ttperror(""scandir"");ttreturn -1;t}t#if DEBUGtprintf(""ndirs: %d"", ndirs);tprintf(""tidx: %d"", tidx);t#endift tif (ndirs == 0) {ttcreate_monitor(&tid[tidx++], path, flags, notifier);ttreturn 0;t}trec_count++;t twhile (ndirs--) {ttdir_name = namelist[ndirs]->d_name;tt#if DEBUGttprintf(""(%d) %s/%s"", ndirs, path, dir_name);tt#endifttsnprintf(dir_path, sizeof dir_path, ""%s/%s"", path, dir_name);ttdir_add_monitors(dir_path, namelist, flags, notifier);ttif (namelist[ndirs]) free(namelist[ndirs]);tttt tttcreate_monitor(&tid[tidx++], dir_path, flags, notifier);t}trec_count--;tif (namelist) free(namelist);t tif (rec_count == 0) {ttwhile (tidx--) {tttpthread_join(tid[tidx], NULL);tt}t}treturn 0;}",2,"cwe119,cwe120"
"generate_transmitted_iv(char *transmitted_iv){        FILE *fp;        int x;        int seed=0;                                             fp=fopen(""/dev/urandom"",""r"");        if(fp!=NULL){                seed=fgetc(fp);                fclose(fp);                }                 else                seed=(int)time(NULL);                 srand(seed);        for(x=0;x<TRANSMITTED_IV_SIZE;x++)                transmitted_iv[x]=(int)((256.0*rand())/(RAND_MAX+1.0));        return;        }",2,"cwe120,cweother"
"copy_file(const char* from, const char* to, const char* logkey, int may_link){  fdtype fd_from;  fdtype fd_to;  int ret, pending, wrote;  char buf[4096];  char* p;#ifndef MINGW  switch (may_link) {  case 2:    ret = symlink(from, to);    goto linkrest;  case 1:    ret = link(from, to);linkrest:    if (ret) {      perror(""{hard|sym}link"");      ERR(""%s: Error linking(%d) from(%s) to(%s) euid=%d egid=%d"", logkey, may_link, from, to, geteuid(), getegid());      return -1;    }    return 0;  }#endif  fd_from = openfile_ro(from);  if (fd_from == BADFD) {      perror(""openfile_ro"");      ERR(""%s: Error opening from(%s) euid=%d egid=%d"", logkey, from, geteuid(), getegid());      return BADFD;  }#ifdef MINGW  fd_to = zx_CreateFile(to, MINGW_RW_PERM, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);#else  fd_to = open(to, O_RDWR | O_CREAT, 0666);#endif  if (fd_to == BADFD) {      perror(""openfile_ro"");      ERR(""%s: Error opening to(%s) euid=%d egid=%d"", logkey, to, geteuid(), getegid());      return BADFD;  }#ifdef USE_STDIO  while (1) {    pending = fread(buf, 1, sizeof(buf), (FILE*)fd_from);    if (pending <= 0) break;      p = buf;    while (pending) {      wrote = fwrite(p, 1, pending, fd_to);      if (wrote <= 0) return 0;      pending -= wrote;      p += wrote;    }  }#elif defined(MINGW)  while (1) {    DWORD wrot;    DWORD pend;    if (!ReadFile(fd_from, buf, sizeof(buf), &pend, 0))      return -1;    if (!pend)      break;    p = buf;    while (pend) {      if (!WriteFile(fd_to, p, pend, &wrot, 0))treturn BADFD;      pend -= wrot;      p += wrot;    }  }  FlushFileBuffers(fd_to);#else  while (1) {    pending = read(fd_from, buf, sizeof(buf));    if (!pending) break;      p = buf;    while (pending) {      wrote = write(fd_to, p, pending);      if (wrote <= 0) return 0;      pending -= wrote;      p += wrote;    }  }#endif  close_file(fd_to, logkey);  closefile(fd_from);  return 0;}",3,"cwe119,cwe120,cweother"
"show_cat(int width, int mwidth,t     char *name, char *mapset, int cat, char *label,t     int terse, char *fs, RASTER_MAP_TYPE map_type){    char *fname;    char buf[100];    CELL cell_val;    cell_val = cat;    if (map_type != CELL_TYPE)tsprintf(buf, "", quant  "");    elsetsprintf(buf, "" "");    if (terse) {tfname = G_fully_qualified_name(name, mapset);tif (G_is_c_null_value(&cell_val)) {t    if (!isatty(fileno(stdout)))ttfprintf(stdout, ""%s%s%sNull%s%s"", fname, buf, fs, fs,tttlabel);t    fprintf(stderr, ""%s%s%sNull%s%s"", fname, buf, fs, fs, label);t}telse {t    if (!isatty(fileno(stdout)))ttfprintf(stdout, ""%s%s%s%d%s%s"", fname, buf, fs, cat, fs,tttlabel);t    fprintf(stderr, ""%s%s%s%d%s%s"", fname, buf, fs, cat, fs, label);t}    }    else {tif (G_is_c_null_value(&cell_val)) {t    if (!isatty(fileno(stdout)))ttfprintf(stdout, ""%*s in %-*s%s (Null)%s"", width, name,tttmwidth, mapset, buf, label);t    fprintf(stderr, ""%*s in %-*s%s (Null)%s"", width, name, mwidth,tt    mapset, buf, label);t}telse {t    if (!isatty(fileno(stdout)))ttfprintf(stdout, ""%*s in %-*s%s (%d)%s"", width, name, mwidth,tttmapset, buf, cat, label);t    fprintf(stderr, ""%*s in %-*s%s (%d)%s"", width, name, mwidth,tt    mapset, buf, cat, label);t}    }    nlines += 1;    return 0;}",2,"cwe119,cwe120"
"var_file_table(struct variable *vp,               oid * name,               size_t * length,               int exact, size_t * var_len, WriteMethod ** write_method){    static long     long_ret;    static char     error[256];    int             iindex;    struct filestat *file;    if (header_simple_table        (vp, name, length, exact, var_len, write_method, fileCount))        return (NULL);    iindex = name[*length - 1] - 1;    updateFile(iindex);    file = &fileTable[iindex];    switch (vp->magic) {    case FILE_INDEX:        long_ret = iindex + 1;        return (u_char *) & long_ret;    case FILE_NAME:        *var_len = strlen(file->name);        return (u_char *) file->name;    case FILE_SIZE:        long_ret = file->size;        return (u_char *) & long_ret;    case FILE_MAX:        long_ret = file->max;        return (u_char *) & long_ret;    case FILE_ERROR:        if (file->max >= 0 && file->size > file->max)            long_ret = 1;        else            long_ret = 0;        return (u_char *) & long_ret;    case FILE_MSG:        if (file->max >= 0 && file->size > file->max)            snprintf(error, sizeof(error), FILE_ERROR_MSG, file->name,ttfile->max, file->size);        else            strcpy(error, """");        *var_len = strlen(error);        return (u_char *) error;    default:        DEBUGMSGTL((""snmpd"", ""unknown sub-id %d in var_file_table"",                    vp->magic));    }    return NULL;}",3,"cwe119,cwe120,cweother"
"exist_db(const char *name, long count, long cache, int wflags, tm_t *done){tDBM *db = open_db(name, shrink ? TRUE : FALSE, cache, wflags);tlong i;tchar buf[1024];tdatum key;tlong cpage = 0 == cache ? 64 : cache; tprintf(""Starting existence test (%ld item%s), cache=%ld page%s..."",ttcount, 1 == count ? """" : ""s"", cpage, 1 == cpage ? """" : ""s"");tkey.dsize = large_keys ? sizeof buf : NORMAL_KEY_LEN;tkey.dptr = buf;tfor (i = 0; i < count; i++) {ttint res;ttif (progress && 0 == i % 500)tttshow_progress(i, count);ttfill_key(buf, sizeof buf, i);ttres = sdbm_exists(db, key);ttif (res <= 0) {tttif (sdbm_error(db))ttttoops(""read error at item #%ld"", i);tttoops(""item #%ld not found"", i);tt}t}tshow_done(done);tsdbm_close(db);}",2,"cwe119,cwe120"
"httpc_mime_end(httpc_conn_t * conn, hresponse_t ** out){  herror_t status;  char buffer[512];  char boundary[75];     _httpc_mime_get_boundary(conn, boundary);  sprintf(buffer, ""r--%s--rr"", boundary);     status = http_output_stream_write(conn->out,                                    (const byte_t *) buffer, strlen(buffer));  if (status != H_OK)    return status;  if ((status = http_output_stream_flush(conn->out)) != H_OK)    return status;  if ((status = hresponse_new_from_socket(&(conn->sock), out)) != H_OK)    return status;  return H_OK;}",2,"cwe119,cwe120"
"esci_request_identity2(SANE_Handle handle, unsigned char **buf){tEpson_Scanner *s = (Epson_Scanner *) handle;tSANE_Status status;tsize_t len;tunsigned char params[2];tDBG(8, ""%s"", __func__);tif (s->hw->cmd->request_identity2 == 0)ttreturn SANE_STATUS_UNSUPPORTED;tparams[0] = ESC;tparams[1] = s->hw->cmd->request_identity2;tstatus = e2_cmd_info_block(s, params, 2, 0, buf, &len);tif (status != SANE_STATUS_GOOD)ttreturn status;treturn status;}",2,"cwe119,cwe120"
"_trigger_run_program(trig_mgr_info_t *trig_in){tchar program[1024], arg0[1024], arg1[1024], user_name[1024];tchar *pname, *uname;tuid_t uid;tgid_t gid;tpid_t child_pid;tif (!_validate_trigger(trig_in))ttreturn;tstrncpy(program, trig_in->program, sizeof(program));tpname = strrchr(program, '/');tif (pname == NULL)ttpname = program;telsettpname++;tstrncpy(arg0, pname, sizeof(arg0));tstrncpy(arg1, trig_in->res_id, sizeof(arg1));tuid = trig_in->user_id;tgid = trig_in->group_id;tuname = uid_to_string(uid);tsnprintf(user_name, sizeof(user_name), ""%s"", uname);txfree(uname);tchild_pid = fork();tif (child_pid > 0) {tttrig_in->child_pid = child_pid;t} else if (child_pid == 0) {ttint i;ttbool run_as_self = (uid == getuid());ttfor (i=0; i<128; i++)tttclose(i);#ifdef SETPGRP_TWO_ARGSttsetpgrp(0, 0);#elsettsetpgrp();#endifttsetsid();ttif ((initgroups(user_name, gid) == -1) && !run_as_self) {ttterror(""trigger: initgroups: %m"");tttexit(1);tt}ttif ((setgid(gid) == -1) && !run_as_self){ttterror(""trigger: setgid: %m"");tttexit(1);tt}ttif ((setuid(uid) == -1) && !run_as_self) {ttterror(""trigger: setuid: %m"");tttexit(1);tt}ttexecl(program, arg0, arg1, NULL);ttexit(1);t} elsetterror(""fork: %m"");}",3,"cwe119,cwe120,cweother"
"prune_stratum_shares(struct pool *pool){tstruct stratum_share *sshare, *tmpshare;ttime_t current_time = time(NULL);tint cleared = 0;tmutex_lock(&sshare_lock);tHASH_ITER(hh, stratum_shares, sshare, tmpshare) {ttif (sshare->work->pool == pool && current_time > sshare->sshare_time + 120) {tttHASH_DEL(stratum_shares, sshare);tttfree_work(sshare->work);tttfree(sshare);tttcleared++;tt}t}tmutex_unlock(&sshare_lock);tif (cleared) {ttapplog(LOG_WARNING, ""Lost %d shares due to no stratum share response from pool %d"",tt       cleared, pool->pool_no);ttpool->stale_shares += cleared;tttotal_stale += cleared;t}}",2,"cwe119,cwe120"
"ouvre_nomenc (void){tchar filename[256];tsprintf (filename, ""%s%s"", system_dir, INF_SYS);tif ((fichi = fopen (filename, ""rb"")) == NULL)t{#ifdef ENGLISHttfprintf (stderr, ""Cannot find %s !!     "", filename);#elsettfprintf (stderr, ""Erreur ouverture %s !!"", filename);#endifttexit (1);t}}",4,"cwe119,cwe120,cwe476,cweother"
"parse_uri(const char *uri, UrlParseData *upd){tgchar *scheme;tg_assert(upd != NULL);tg_log(LOG_DOMAIN, G_LOG_LEVEL_DEBUG, ""Trying url: %s"", uri);t tif (uri == NULL)t{ttupd->result_callback(upd->result, upd->user_data);tturl_parse_data_free(upd);ttreturn;t}t tscheme = g_uri_parse_scheme(uri);tif (scheme == NULL)t{tt ttif (g_file_test(uri, G_FILE_TEST_EXISTS | G_FILE_TEST_IS_REGULAR))tt{tttFILE *fp = g_fopen(uri, ""r"");tttif (fp)ttt{ttttchar buffer[MAX_PLAYLIST_SIZE];ttttssize_t t = fread(buffer, 1, MAX_PLAYLIST_SIZE - 1, fp);tttt ttttbuffer[t] = '0';ttttupd->result = parse_data(buffer, (guint) t, uri);ttttupd->result_callback(upd->result, upd->user_data);tttturl_parse_data_free(upd);ttttfclose(fp);ttt}tt} elsett{tttgchar *temp = g_strdup_printf(""%s: '%s'"", _(""Failed to open local file""), uri);tttif(upd->error_callback != NULL)ttttupd->error_callback(temp, upd->user_data);ttturl_parse_data_free(upd);tttg_free(temp);tt}t}telset{tt ttif (url_validate_url(uri))tt{tttif (strcasecmp(scheme, ""http"") == 0)ttt{ttttgmpc_easy_async_downloader(uri, url_fetcher_download_callback, upd);ttt} elsettt{ttttupd->result = g_list_append(NULL, g_strdup(uri)); ttttupd->result_callback(upd->result, upd->user_data);tttturl_parse_data_free(upd);ttt}tt} elsett{tttgchar *temp = g_strdup_printf(""%s: '%s'"", _(""Uri scheme not supported""), scheme);tttif(upd->error_callback != NULL)ttttupd->error_callback(temp, upd->user_data);ttturl_parse_data_free(upd);tttg_free(temp);tt}t}tif (scheme)ttg_free(scheme);t treturn;}",2,"cwe119,cwe120"
"dsc_unknown(CDSC *dsc){    if (dsc->debug_print_fn) {tchar line[DSC_LINE_LENGTH];tunsigned int length = min(DSC_LINE_LENGTH-1, dsc->line_length);tsprintf(line, ""Unknown in %s section at line %d:  "", t    dsc_scan_section_name[dsc->scan_section], dsc->line_count);tdsc_debug_print(dsc, line);tstrncpy(line, dsc->line, length);tline[length] = '0';tdsc_debug_print(dsc, line);tdsc_debug_print(dsc, """");    }}",2,"cwe119,cwe120"
"update_child_count (TrayData *data){  guint n_children = 0;  char text[64];  if (!gtk_widget_get_realized (data->window))    return;  gtk_container_foreach (GTK_CONTAINER (data->box), (GtkCallback) do_add, &n_children);  g_snprintf (text, sizeof (text), ""%u icons"", n_children);  gtk_label_set_text (data->count_label, text);}",2,"cwe119,cwe120"
"k_send(KodakAio_Scanner * s, void *buf, size_t buf_size, SANE_Status * status){tchar fmt_buf[25];tkodakaio_com_str(buf, fmt_buf);tDBG(15, ""%s: size = %lu :%s"", __func__, (u_long) buf_size, fmt_buf);tif (DBG_LEVEL >= 125) {ttconst unsigned char *s = buf;ttDBG(125, ""complete buffer:"");ttdump_hex_buffer_dense (125, s, buf_size);t}tif (s->hw->connection == SANE_KODAKAIO_NET) {ttreturn sanei_kodakaio_net_write_raw(s, buf, buf_size, status);t} else if (s->hw->connection == SANE_KODAKAIO_USB) {ttsize_t n;ttn = buf_size;tt*status = sanei_usb_write_bulk(s->fd, buf, &n);ttDBG(50, ""USB: wrote %lu bytes, status: %s"", (unsigned long)n, sane_strstatus(*status));ttreturn n;t}t*status = SANE_STATUS_INVAL;treturn 0;}",2,"cwe119,cwe120"
"maildir_message_remove(struct maildir * md, const char * uid){  chashdatum key;  chashdatum value;  char filename[PATH_MAX];  struct maildir_msg * msg;  char * dir;  int r;  int res;  key.data = (void *) uid;  key.len = strlen(uid);  r = chash_get(md->mdir_msg_hash, &key, &value);  if (r < 0) {    res = MAILDIR_ERROR_NOT_FOUND;    goto err;  }    msg = value.data;  if ((msg->msg_flags & MAILDIR_FLAG_NEW) != 0)    dir = ""new"";  else    dir = ""cur"";    snprintf(filename, sizeof(filename), ""%s/%s/%s"",      md->mdir_path, dir, msg->msg_filename);    r = unlink(filename);  if (r < 0) {    res = MAILDIR_ERROR_FILE;    goto err;  }    return MAILDIR_NO_ERROR;   err:  return res;}",2,"cwe119,cwe120"
"rsyncsum_file(char *filename){    FILE *file = NULL;    char buf[BUF_SIZE];    unsigned long long rsum = 0;    char *base64_sum = NULL;    int done = 0;    int bytes_read = 0;         if (!strcmp(""-"", filename))        file = stdin;    else    {        fprintf(stderr, ""r %-75.75s"", filename);        file = fopen(filename, ""rb"");        if (!file)        {            switch (errno)            {                case EACCES:                case EISDIR:                    break;                default:                    fprintf(stderr, ""Unable to open file %s; error %d"", filename, errno);                    break;            }            return errno;        }    }        while (!done)    {        int used = 0;        memset(buf, 0, BUF_SIZE);        used = fread(buf, 1, BUF_SIZE, file);        bytes_read += used;        if (used)        {            rsum = rsync64((unsigned char *)buf, BUF_SIZE);            done = 1;        }    }        printf(""%llx"", rsum);        base64_sum = base64_dump((unsigned char *)&rsum, 8);    if (file != stdin)    {        fclose(file);        if (bytes_read)            printf(""%s  %s"", base64_sum, filename);    }    else        if (bytes_read)            printf(""%s"", base64_sum);    fflush(stdout);        return 0;}",3,"cwe119,cwe120,cweother"
"main(int argc, char **argv){tint show_absolute_syms, show_absolute_relocs;tint as_text, use_real_mode;tconst char *fname;tFILE *fp;tint i;tunsigned char e_ident[EI_NIDENT];tshow_absolute_syms = 0;tshow_absolute_relocs = 0;tas_text = 0;tuse_real_mode = 0;tfname = NULL;tfor (i = 1; i < argc; i++) {ttchar *arg = argv[i];ttif (*arg == '-') {tttif (strcmp(arg, ""--abs-syms"") == 0) {ttttshow_absolute_syms = 1;ttttcontinue;ttt}tttif (strcmp(arg, ""--abs-relocs"") == 0) {ttttshow_absolute_relocs = 1;ttttcontinue;ttt}tttif (strcmp(arg, ""--text"") == 0) {ttttas_text = 1;ttttcontinue;ttt}tttif (strcmp(arg, ""--realmode"") == 0) {ttttuse_real_mode = 1;ttttcontinue;ttt}tt}ttelse if (!fname) {tttfname = arg;tttcontinue;tt}ttusage();t}tif (!fname) {ttusage();t}tfp = fopen(fname, ""r"");tif (!fp) {ttdie(""Cannot open %s: %s"", fname, strerror(errno));t}tif (fread(&e_ident, 1, EI_NIDENT, fp) != EI_NIDENT) {ttdie(""Cannot read %s: %s"", fname, strerror(errno));t}trewind(fp);tif (e_ident[EI_CLASS] == ELFCLASS64)ttprocess_64(fp, use_real_mode, as_text,ttt   show_absolute_syms, show_absolute_relocs);telsettprocess_32(fp, use_real_mode, as_text,ttt   show_absolute_syms, show_absolute_relocs);tfclose(fp);treturn 0;}",2,"cwe469,cweother"
"ia_pd_nomatch_release(const struct data_string *client_id,tt      const struct data_string *iapref,tt      u_int32_t *ia_pd_id,tt      struct packet *packet,tt      char *reply_data,tt      int *reply_ofs,tt      int reply_len){tchar tmp_addr[INET6_ADDRSTRLEN];tstruct option_state *host_opt_state;tint len;tlog_info(""Client %s releases prefix %s/%u, which is not leased to it."",tt print_hex_1(client_id->len, client_id->data, 60),tt inet_ntop(AF_INET6, iapref->data + 9,ttt   tmp_addr, sizeof(tmp_addr)),tt (unsigned) getUChar(iapref->data + 8));t thost_opt_state = NULL;tif (!option_state_allocate(&host_opt_state, MDL)) {ttlog_error(""ia_pd_nomatch_release: out of memory ""ttt  ""allocating option_state."");ttgoto exit;t}tif (!set_status_code(STATUS_NoBinding, ttt     ""Release for non-leased prefix."",ttt     host_opt_state)) {ttgoto exit;t}t tif (reply_len < (*reply_ofs + 16)) {ttlog_error(""ia_pd_nomatch_release: ""ttt  ""out of space for reply packet."");ttgoto exit;t}t tlen = store_options6(reply_data+(*reply_ofs)+16,ttt     reply_len-(*reply_ofs)-16,ttt     host_opt_state, packet,ttt     required_opts_STATUS_CODE, NULL);t t tputUShort((unsigned char *)reply_data+(*reply_ofs), D6O_IA_PD);t tputUShort((unsigned char *)reply_data+(*reply_ofs)+2, len + 12);t tmemcpy(reply_data+(*reply_ofs)+4, ia_pd_id, 4);t tputULong((unsigned char *)reply_data+(*reply_ofs)+8, 0);tputULong((unsigned char *)reply_data+(*reply_ofs)+12, 0);t t*reply_ofs += (len + 16);exit:toption_state_dereference(&host_opt_state, MDL);}",2,"cwe119,cwe120"
"tcp_seg_make(u_char *pkt, int pktlen, int segsize){  ELEM *new, *list = NULL;  struct ip *iph = (struct ip *)pkt;  int len, ip_hl = iph->ip_hl * 4;  struct tcphdr *tcph = (struct tcphdr *)(pkt + ip_hl);  int tcp_hl = tcph->th_off * 4;  u_char *tcp_blob = pkt + ip_hl + tcp_hl;  int tcp_bloblen = ntohs(iph->ip_len) - ip_hl - tcp_hl;  u_char *tcp_end = tcp_blob + tcp_bloblen;  u_long tcp_newseq = ntohl(tcph->th_seq);  u_char *p, *data;  if (iph->ip_p != IPPROTO_TCP || tcp_bloblen <= segsize ||      (tcph->th_flags & TH_ACK) == 0)    return NULL;  for (p = tcp_blob ; p < tcp_end ; p += len) {    len = MIN(tcp_end - p, segsize);    if (!(data = malloc(ip_hl + tcp_hl + len)))      return NULL;         memcpy(data, pkt, ip_hl + tcp_hl);    memcpy(data + ip_hl + tcp_hl, p, len);         ((struct ip *)data)->ip_len = htons(ip_hl + tcp_hl + len);    ((struct tcphdr *)(data + ip_hl))->th_seq = htonl(tcp_newseq);    libnet_do_checksum(data, IPPROTO_TCP, tcp_hl + len);        tcp_newseq += len;         new = list_elem(data, ip_hl + tcp_hl + len);    free(data);        if (!(list = list_add(list, new)))      return NULL;  }  return (list->head);}",2,"cwe120,cwe476"
"main(int argc, char **argv){tint c;tint fd;tSHA1Context ctx;tstruct sha1 digest;tbool done;t textern int optind;textern char *optarg;tmingw_early_init();tprogname = filepath_basename(argv[0]);twhile ((c = getopt(argc, argv, ""h"")) != EOF) {ttswitch (c) {ttcase 'h':ttt ttdefault:tttusage();tttbreak;tt}t}tif ((argc -= optind) != 1)ttusage();targv += optind;tfd = file_open(argv[0], O_RDONLY, 0);tif (-1 == fd)ttexit(EXIT_FAILURE);tSHA1Reset(&ctx);tfor (done = FALSE; !done;  ) {ttchar buf[512];ttint r;ttr = read(fd, buf, sizeof buf);ttif (-1 == r)ttts_fatal_exit(EXIT_FAILURE, ""read() error: %m"");ttdone = r != sizeof buf;ttSHA1Input(&ctx, buf, r);t}tSHA1Result(&ctx, &digest);tclose(fd);tprintf(""%s"", sha1_base16(&digest));treturn 0;}",3,"cwe119,cwe120,cweother"
"async_redirect_stdin (){  int fd;  fd = open (""/dev/null"", O_RDONLY);  if (fd > 0)    {      dup2 (fd, 0);      close (fd);    }  else if (fd < 0)    internal_error (_(""cannot redirect standard input from /dev/null: %s""), strerror (errno));}",3,"cwe119,cwe120,cweother"
"Symbol_hack(const char *a0){tchar buf[BUFSIZ], *p, *e;tFILE *fi;tuintptr_t a;tstruct symbols *s;tbprintf(buf, ""nm -an %s 2>/dev/null"", a0);tfi = popen(buf, ""r"");tif (fi == NULL)ttreturn;twhile (fgets(buf, sizeof buf, fi)) {ttif (buf[0] == ' ')tttcontinue;ttp = NULL;tta = strtoul(buf, &p, 16);ttif (p == NULL)tttcontinue;ttif (a == 0)tttcontinue;ttif (*p++ != ' ')tttcontinue;ttp++;ttif (*p++ != ' ')tttcontinue;ttif (*p <= ' ')tttcontinue;tte = strchr(p, '0');ttAN(e);ttwhile (e > p && isspace(e[-1]))ttte--;tt*e = '0';tts = malloc(sizeof *s + strlen(p) + 1);ttAN(s);tts->a = a;tts->n = (void*)(s + 1);ttstrcpy(s->n, p);ttVTAILQ_INSERT_TAIL(&symbols, s, list);t}t(void)pclose(fi);}",3,"cwe119,cwe120,cweother"
"_applog(int prio, const char *str, bool force){#ifdef HAVE_SYSLOG_Htif (use_syslog) {ttsyslog(LOG_LOCAL0 | prio, ""%s"", str);t}#elsetif (0) {}#endiftelse {ttchar datetime[64];ttstruct timeval tv = {0, 0};ttstruct tm *tm;ttcgtime(&tv);ttconst time_t tmp_time = tv.tv_sec;tttm = localtime(&tmp_time);ttsnprintf(datetime, sizeof(datetime), "" [%d-%02d-%02d %02d:%02d:%02d] "",ttttm->tm_year + 1900,ttttm->tm_mon + 1,ttttm->tm_mday,ttttm->tm_hour,ttttm->tm_min,ttttm->tm_sec);tt ttif (!isatty(fileno((FILE *)stderr))) {tttfprintf(stderr, ""%s%s"", datetime, str);t tttfflush(stderr);tt}tttif(g_logfile_enable) {tttif(!g_log_file) {ttttg_log_file = fopen(g_logfile_path, g_logfile_openflag);ttt}tttif(g_log_file) {ttttfwrite(datetime, strlen(datetime), 1, g_log_file);ttttfwrite(str, strlen(str), 1, g_log_file);ttttfwrite("""", 1, 1, g_log_file);ttttfflush(g_log_file);ttt}tt}ttmy_log_curses(prio, datetime, str, force);t}}",3,"cwe119,cwe120,cweother"
"fz_draw_fill_image_mask(fz_device *devp, fz_image *image, fz_matrix ctm,tfz_colorspace *colorspace, float *color, float alpha){tfz_draw_device *dev = devp->user;tunsigned char colorbv[FZ_MAX_COLORS + 1];tfloat colorfv[FZ_MAX_COLORS];tfz_pixmap *scaled = NULL;tfz_pixmap *pixmap;tfz_pixmap *orig_pixmap;tint dx, dy;tint i;tfz_context *ctx = dev->ctx;tfz_draw_state *state = &dev->stack[dev->top];tfz_colorspace *model = state->dest->colorspace;tfz_bbox clip = fz_pixmap_bbox(ctx, state->dest);tclip = fz_intersect_bbox(clip, state->scissor);tif (image->w == 0 || image->h == 0)ttreturn;tdx = sqrtf(ctm.a * ctm.a + ctm.b * ctm.b);tdy = sqrtf(ctm.c * ctm.c + ctm.d * ctm.d);tpixmap = fz_image_to_pixmap(ctx, image, dx, dy);torig_pixmap = pixmap;tfz_try(ctx)t{ttif (state->blendmode & FZ_BLEND_KNOCKOUT)tttstate = fz_knockout_begin(dev);ttif (dx < pixmap->w && dy < pixmap->h)tt{tttint gridfit = alpha == 1.0f && !(dev->flags & FZ_DRAWDEV_FLAGS_TYPE3);tttscaled = fz_transform_pixmap(dev->ctx, pixmap, &ctm, state->dest->x, state->dest->y, dx, dy, gridfit, &clip);tttif (!scaled)ttt{ttttif (dx < 1)tttttdx = 1;ttttif (dy < 1)tttttdy = 1;ttttscaled = fz_scale_pixmap(dev->ctx, pixmap, pixmap->x, pixmap->y, dx, dy, NULL);ttt}tttif (scaled)ttttpixmap = scaled;tt}ttfz_convert_color(dev->ctx, model, colorfv, colorspace, color);ttfor (i = 0; i < model->n; i++)tttcolorbv[i] = colorfv[i] * 255;ttcolorbv[i] = alpha * 255;ttfz_paint_image_with_color(state->dest, state->scissor, state->shape, pixmap, ctm, colorbv);ttif (scaled)tttfz_drop_pixmap(dev->ctx, scaled);ttif (state->blendmode & FZ_BLEND_KNOCKOUT)tttfz_knockout_end(dev);t}tfz_always(ctx)t{ttfz_drop_pixmap(dev->ctx, orig_pixmap);t}tfz_catch(ctx)t{ttfz_rethrow(ctx);t}}",2,"cwe119,cwe120"
"glusterfs_handle_defrag (rpcsvc_request_t *req){        int32_t                  ret     = -1;        gd1_mgmt_brick_op_req    xlator_req = {0,};        dict_t                   *dict    = NULL;        xlator_t                 *xlator = NULL;        xlator_t                 *any = NULL;        dict_t                   *output = NULL;        char                     msg[2048] = {0};        glusterfs_ctx_t          *ctx = NULL;        glusterfs_graph_t        *active = NULL;        xlator_t                 *this = NULL;        GF_ASSERT (req);        this = THIS;        GF_ASSERT (this);        ctx = glusterfsd_ctx;        GF_ASSERT (ctx);        active = ctx->active;        if (!active) {                req->rpc_err = GARBAGE_ARGS;                goto out;        }        any = active->first;        ret = xdr_to_generic (req->msg[0], &xlator_req,                              (xdrproc_t)xdr_gd1_mgmt_brick_op_req);        if (ret < 0) {                                 req->rpc_err = GARBAGE_ARGS;                goto out;        }        dict = dict_new ();        if (!dict)                goto out;        ret = dict_unserialize (xlator_req.input.input_val,                                xlator_req.input.input_len,                                &dict);        if (ret < 0) {                gf_log (this->name, GF_LOG_ERROR,                        ""failed to ""                        ""unserialize req-buffer to dictionary"");                goto out;        }        xlator = xlator_search_by_name (any, xlator_req.name);        if (!xlator) {                snprintf (msg, sizeof (msg), ""xlator %s is not loaded"",                          xlator_req.name);                goto out;        }        output = dict_new ();        if (!output) {                ret = -1;                goto out;        }        ret = xlator->notify (xlator, GF_EVENT_VOLUME_DEFRAG, dict, output);        ret = glusterfs_translator_info_response_send (req, ret,                                                       msg, output);out:        if (dict)                dict_unref (dict);        free (xlator_req.input.input_val);          if (output)                dict_unref (output);        free (xlator_req.name);          return ret;}",3,"cwe119,cwe120,cwe476"
"get_essid(const char *dev, const char *key){         struct iwreq req;    char key_buffer[32];    char essid_buffer[IW_ESSID_MAX_SIZE + 1];    int age;    qprintf(key_buffer, sizeof(key_buffer), ""%s.%s"", dev, key);    age = hash_age(&wireless, key);         if (age > 0 && age <= HASH_TTL) {treturn (0);    }    if (get_ifname(&req, dev) != 0) {treturn (-1);    }    memset(essid_buffer, 0, sizeof(essid_buffer));    req.u.essid.pointer = (caddr_t) essid_buffer;    req.u.essid.length = IW_ESSID_MAX_SIZE + 1;    req.u.essid.flags = 0;    if (do_ioctl(sock, dev, SIOCGIWESSID, &req) < 0) {tioctl_error(__LINE__);treturn -1;    }    hash_put(&wireless, key_buffer, essid_buffer);    return (0);}",2,"cwe119,cwe120"
"evutil_read_file(const char *filename, char **content_out, size_t *len_out,    int is_binary){tint fd, r;tstruct stat st;tchar *mem;tsize_t read_so_far=0;tint mode = O_RDONLY;tEVUTIL_ASSERT(content_out);tEVUTIL_ASSERT(len_out);t*content_out = NULL;t*len_out = 0;#ifdef O_BINARYtif (is_binary)ttmode |= O_BINARY;#endiftfd = open(filename, mode);tif (fd < 0)ttreturn -1;tif (fstat(fd, &st) || st.st_size < 0 ||t    st.st_size > EV_SSIZE_MAX-1 ) {ttclose(fd);ttreturn -2;t}tmem = mm_malloc((size_t)st.st_size + 1);tif (!mem) {ttclose(fd);ttreturn -2;t}tread_so_far = 0;#ifdef WIN32#define N_TO_READ(x) ((x) > INT_MAX) ? INT_MAX : ((int)(x))#else#define N_TO_READ(x) (x)#endiftwhile ((r = read(fd, mem+read_so_far, N_TO_READ(st.st_size - read_so_far))) > 0) {ttread_so_far += r;ttif (read_so_far >= (size_t)st.st_size)tttbreak;ttEVUTIL_ASSERT(read_so_far < (size_t)st.st_size);t}tclose(fd);tif (r < 0) {ttmm_free(mem);ttreturn -2;t}tmem[read_so_far] = 0;t*len_out = read_so_far;t*content_out = mem;treturn 0;}",2,"cwe120,cweother"
"jk_map_get_int_list(jk_map_t *m,                        const char *name,                        int *list,                        unsigned int list_len,                        const char *def){    const char *l = jk_map_get_string(m, name, def);#ifdef _MT_CODE_PTHREAD    char *lasts;#endif    if (!list_len)        return 0;    if (l) {        unsigned int capacity = list_len;        unsigned int index = 0;        char *p;        char *v = jk_pool_strdup(&m->p, l);        if (!v) {            return 0;        }         #ifdef _MT_CODE_PTHREAD        for (p = strtok_r(v, "" t,"", &lasts);             p; p = strtok_r(NULL, "" t,"", &lasts))#else        for (p = strtok(v, "" t,""); p; p = strtok(NULL, "" t,""))#endif        {            if (index < capacity) {                list[index] = atoi(p);                index++;            }            else                break;        }        return index;    }    return 0;}",2,"cwe469,cweother"
"drainSelfPipe(void){t tchar buf[16];tint rc;tfor (;;)t{ttrc = read(selfpipe_readfd, buf, sizeof(buf));ttif (rc < 0)tt{tttif (errno == EAGAIN || errno == EWOULDBLOCK)ttttbreak;tt tttelse if (errno == EINTR)ttttcontinue;t tttelsettttelog(ERROR, ""read() on self-pipe failed: %m"");tt}ttelse if (rc == 0)tttelog(ERROR, ""unexpected EOF on self-pipe"");t}}",3,"cwe119,cwe120,cweother"
"eapmd5_compose(EAP_DS *eap_ds, MD5_PACKET *reply){tuint8_t *ptr;tunsigned short name_len;t tif (reply->code < 3) {tteap_ds->request->type.type = PW_EAP_MD5;ttrad_assert(reply->length > 0);tteap_ds->request->type.data = malloc(reply->length);ttif (eap_ds->request->type.data == NULL) {ttteapmd5_free(&reply);tttradlog(L_ERR, ""rlm_eap_md5: out of memory"");tttreturn 0;tt}ttptr = eap_ds->request->type.data;tt*ptr++ = (uint8_t)(reply->value_size & 0xFF);ttmemcpy(ptr, reply->value, reply->value_size);tt tteap_ds->request->type.length = reply->value_size + 1;tt ttname_len = reply->length - (reply->value_size + 1);ttif (name_len && reply->name) {tttptr += reply->value_size;tttmemcpy(ptr, reply->name, name_len);ttt ttteap_ds->request->type.length += name_len;tt}t} else {tteap_ds->request->type.length = 0;tt t}teap_ds->request->code = reply->code;teapmd5_free(&reply);treturn 1;}",2,"cwe120,cweother"
"ossl_connect_step2(struct connectdata *conn, int sockindex){  struct SessionHandle *data = conn->data;  int err;  struct ssl_connect_data *connssl = &conn->ssl[sockindex];  DEBUGASSERT(ssl_connect_2 == connssl->connecting_state             || ssl_connect_2_reading == connssl->connecting_state             || ssl_connect_2_writing == connssl->connecting_state);  ERR_clear_error();  err = SSL_connect(connssl->handle);     if(1 != err) {    int detail = SSL_get_error(connssl->handle, err);    if(SSL_ERROR_WANT_READ == detail) {      connssl->connecting_state = ssl_connect_2_reading;      return CURLE_OK;    }    else if(SSL_ERROR_WANT_WRITE == detail) {      connssl->connecting_state = ssl_connect_2_writing;      return CURLE_OK;    }    else {             unsigned long errdetail;      char error_buffer[256];        CURLcode rc;      const char *cert_problem = NULL;      long lerr;      connssl->connecting_state = ssl_connect_2;        errdetail = ERR_get_error();        switch(errdetail) {      case 0x1407E086:                        case 0x14090086:                 rc = CURLE_SSL_CACERT;        lerr = SSL_get_verify_result(connssl->handle);        if(lerr != X509_V_OK) {          snprintf(error_buffer, sizeof(error_buffer),                   ""SSL certificate problem: %s"",                   X509_verify_cert_error_string(lerr));        }        else          cert_problem = ""SSL certificate problem, verify that the CA cert is""            "" OK."";        break;      default:        rc = CURLE_SSL_CONNECT_ERROR;        SSL_strerror(errdetail, error_buffer, sizeof(error_buffer));        break;      }                    if(CURLE_SSL_CONNECT_ERROR == rc && errdetail == 0) {        failf(data, ""Unknown SSL protocol error in connection to %s:%ld "",              conn->host.name, conn->remote_port);        return rc;      }             failf(data, ""%s%s"", cert_problem ? cert_problem : """", error_buffer);      return rc;    }  }  else {         connssl->connecting_state = ssl_connect_3;         infof (data, ""SSL connection using %s"",           SSL_get_cipher(connssl->handle));    return CURLE_OK;  }}",2,"cwe119,cwe120"
"ScaKwdTab(GmfMshSct *msh){    int KwdCod, NexPos, CurPos, EndPos;    char str[ GmfStrSiz ];    if(msh->typ & Asc)    {                 while(fscanf(msh->hdl, ""%s"", str) != EOF)        {                         if(isalpha(str[0]))            {                                 for(KwdCod=1; KwdCod<= GmfMaxKwd; KwdCod++)                    if(!strcmp(str, KwdFmt[ KwdCod ][0]))                    {                        ScaKwdHdr(msh, KwdCod);                        break;                    }            }            else if(str[0] == '#')                while(fgetc(msh->hdl) != '');        }    }    else    {                 CurPos = ftell(msh->hdl);        fseek(msh->hdl, 0, SEEK_END);        EndPos = ftell(msh->hdl);        fseek(msh->hdl, CurPos, SEEK_SET);                 do        {                         ScaWrd(msh, (unsigned char *)&KwdCod);            ScaWrd(msh, (unsigned char *)&NexPos);            if(NexPos > EndPos)                return(0);                         if( (KwdCod >= 1) && (KwdCod <= GmfMaxKwd) )                ScaKwdHdr(msh, KwdCod);                         if(NexPos)                fseek(msh->hdl, NexPos, SEEK_SET);        }while(NexPos && (KwdCod != GmfEnd));    }    return(1);}",3,"cwe119,cwe120,cweother"
"dev_ioctl_send_ready(unsigned int logopt,ttttint ioctlfd, unsigned int token){tstruct autofs_dev_ioctl param;tif (token == 0) {tterrno = EINVAL;ttreturn -1;t}tdebug(logopt, ""token = %d"", token);tinit_autofs_dev_ioctl(&param);tparam.ioctlfd = ioctlfd;tparam.ready.token = token;tif (ioctl(ctl.devfd, AUTOFS_DEV_IOCTL_READY, &param) == -1) {ttchar *estr, buf[MAX_ERR_BUF];ttint save_errno = errno;ttestr = strerror_r(errno, buf, MAX_ERR_BUF);ttlogerr(""AUTOFS_DEV_IOCTL_READY: error %s"", estr);tterrno = save_errno;ttreturn -1;t}treturn 0;}",2,"cwe119,cwe120"
"get_key_info_from_public_key(const char *filename,                                        knot_dname_t **name,                                        knot_binary_t *rdata){tif (!filename || !name || !rdata) {ttreturn KNOT_EINVAL;t}tFILE *keyfile = fopen(filename, ""r"");tif (!keyfile) {ttreturn KNOT_KEY_EPUBLIC_KEY_OPEN;t}tscanner_t *scanner = scanner_create(filename, ""."", KNOT_CLASS_IN, 0,t                                    NULL, NULL, NULL);tif (!scanner) {ttfclose(keyfile);ttreturn KNOT_ENOMEM;t}tbool scan_done = false;tbool last_block = false;tscanner->process_record = key_scan_set_done;tscanner->process_error = key_scan_set_done;tscanner->default_ttl = 0;tscanner->default_class = KNOT_CLASS_IN;tscanner->zone_origin[0] = '0';tscanner->zone_origin_length = 1;tscanner->data = (void *)&scan_done;tchar *buffer = NULL;tsize_t buffer_size;tssize_t read;tint result = 0;twhile (!scan_done && !last_block && result == 0) {ttread = knot_getline(&buffer, &buffer_size, keyfile);ttif (read <= 0) {tttlast_block = true;tttread = 0;tt}ttresult = scanner_process(buffer, buffer + read, last_block,tt                         scanner);t}tfree(buffer);tfclose(keyfile);tif (scanner->r_type != KNOT_RRTYPE_DNSKEY) {ttscanner_free(scanner);ttreturn KNOT_KEY_EPUBLIC_KEY_INVALID;t}tknot_dname_t *owner = knot_dname_copy(scanner->r_owner);tif (!owner) {ttscanner_free(scanner);ttreturn KNOT_ENOMEM;t}tknot_dname_to_lower(owner);tknot_binary_t rdata_bin = { 0 };tresult = knot_binary_from_string(scanner->r_data, scanner->r_data_length,t                                 &rdata_bin);tif (result != KNOT_EOK) {ttscanner_free(scanner);ttknot_dname_free(&owner);ttreturn result;t}t*name = owner;t*rdata = rdata_bin;tscanner_free(scanner);treturn KNOT_EOK;}",2,"cwe120,cweother"
"copy_templates_1(char *path, int baselen,ttt     char *template, int template_baselen,ttt     DIR *dir){tstruct dirent *de;t tsafe_create_dir(path, 1);twhile ((de = readdir(dir)) != NULL) {ttstruct stat st_git, st_template;ttint namelen;ttint exists = 0;ttif (de->d_name[0] == '.')tttcontinue;ttnamelen = strlen(de->d_name);ttif ((PATH_MAX <= baselen + namelen) ||tt    (PATH_MAX <= template_baselen + namelen))tttdie(""insanely long template name %s"", de->d_name);ttmemcpy(path + baselen, de->d_name, namelen+1);ttmemcpy(template + template_baselen, de->d_name, namelen+1);ttif (lstat(path, &st_git)) {tttif (errno != ENOENT)ttttdie_errno(""cannot stat '%s'"", path);tt}ttelsetttexists = 1;ttif (lstat(template, &st_template))tttdie_errno(""cannot stat template '%s'"", template);ttif (S_ISDIR(st_template.st_mode)) {tttDIR *subdir = opendir(template);tttint baselen_sub = baselen + namelen;tttint template_baselen_sub = template_baselen + namelen;tttif (!subdir)ttttdie_errno(""cannot opendir '%s'"", template);tttpath[baselen_sub++] =tttttemplate[template_baselen_sub++] = '/';tttpath[baselen_sub] =tttttemplate[template_baselen_sub] = 0;tttcopy_templates_1(path, baselen_sub,ttttt template, template_baselen_sub,ttttt subdir);tttclosedir(subdir);tt}ttelse if (exists)tttcontinue;ttelse if (S_ISLNK(st_template.st_mode)) {tttchar lnk[256];tttint len;tttlen = readlink(template, lnk, sizeof(lnk));tttif (len < 0)ttttdie_errno(""cannot readlink '%s'"", template);tttif (sizeof(lnk) <= len)ttttdie(""insanely long symlink %s"", template);tttlnk[len] = 0;tttif (symlink(lnk, path))ttttdie_errno(""cannot symlink '%s' '%s'"", lnk, path);tt}ttelse if (S_ISREG(st_template.st_mode)) {tttif (copy_file(path, template, st_template.st_mode))ttttdie_errno(""cannot copy '%s' to '%s'"", template,ttttt  path);tt}ttelsettterror(""ignoring template %s"", template);t}}",3,"cwe119,cwe120,cweother"
"UintFromPhone( const char *zhuin ){tconst char *iter;tchar *pos;tchar buf[ MAX_UTF8_SIZE + 1 ];tint len, result = 0;tint zhuin_index = 0;titer = zhuin;twhile ( *iter ) {ttlen = ueStrNCpy( buf, iter, 1, STRNCPY_CLOSE );ttfor (; zhuin_index < ZUIN_SIZE; ++zhuin_index ) {tttpos = strstr( zhuin_tab[ zhuin_index ], buf );tttif ( pos ) {ttttbreak;ttt}tt}ttif ( zhuin_index >= ZUIN_SIZE ) {tttreturn 0;tt}ttresult |= (zhuin_tab_num[ zhuin_index ] - ueStrLen( pos )) << shift[ zhuin_index ];tt++zhuin_index;ttiter += len;t}treturn result;}",2,"cwe119,cwe120"
"chirp_multi_update(const char *volume, const char *path, struct file_info *info, time_t stoptime){tchar buffer[CHIRP_PATH_MAX * 2 + 2];tif(!chirp_multi_lpath(volume, path, info->lpath, stoptime))ttreturn 0;tsprintf(buffer, ""%s%s"", info->rhost, info->rpath);treturn chirp_reli_putfile_buffer(current_volume->host, info->lpath, buffer, 0700, strlen(buffer), stoptime);}",2,"cwe119,cwe120"
"lc_collate_is_c(Oid collation){t tif (!OidIsValid(collation))ttreturn false;t tif (collation == DEFAULT_COLLATION_OID)t{ttstatic inttresult = -1;ttchart   *localeptr;ttif (result >= 0)tttreturn (bool) result;ttlocaleptr = setlocale(LC_COLLATE, NULL);ttif (!localeptr)tttelog(ERROR, ""invalid LC_COLLATE setting"");ttif (strcmp(localeptr, ""C"") == 0)tttresult = true;ttelse if (strcmp(localeptr, ""POSIX"") == 0)tttresult = true;ttelsetttresult = false;ttreturn (bool) result;t}t tif (collation == C_COLLATION_OID ||ttcollation == POSIX_COLLATION_OID)ttreturn true;t treturn (lookup_collation_cache(collation, true))->collate_is_c;}",3,"cwe476,cwe469,cweother"
"ujfs_put_logsuper(FILE *fp, struct logsuper *logsup){tchar buf[sizeof (struct logsuper)];tint rc = 0;tmemcpy(buf, logsup, sizeof (struct logsuper));t tujfs_swap_logsuper((struct logsuper *) buf);trc = ujfs_rw_diskblocks(fp, LOGPSIZE, sizeof (struct logsuper), buf, PUT);treturn rc;}",2,"cwe119,cwe120"
"read_proc_pid_status(unsigned int pid, struct pid_stats *pst,ttt unsigned int tgid){tFILE *fp;tchar filename[128], line[256];tif (tgid) {ttsprintf(filename, TASK_STATUS, tgid, pid);t}telse {ttsprintf(filename, PID_STATUS, pid);t}tif ((fp = fopen(filename, ""r"")) == NULL)tt ttreturn 1;twhile (fgets(line, 256, fp) != NULL) {ttif (!strncmp(line, ""Uid:"", 4)) {tttsscanf(line + 5, ""%d"", &pst->uid);tt}ttelse if (!strncmp(line, ""Threads:"", 8)) {tttsscanf(line + 9, ""%d"", &pst->threads);tt}ttelse if (!strncmp(line, ""voluntary_ctxt_switches:"", 24)) {tttsscanf(line + 25, ""%lu"", &pst->nvcsw);tt}ttelse if (!strncmp(line, ""nonvoluntary_ctxt_switches:"", 27)) {tttsscanf(line + 28, ""%lu"", &pst->nivcsw);tt}t}tfclose(fp);tpst->pid = pid;tpst->tgid = tgid;treturn 0;}",3,"cwe119,cwe120,cweother"
"git_format_config(const char *var, const char *value, void *cb){tif (!strcmp(var, ""format.headers"")) {ttif (!value)tttdie(""format.headers without value"");ttadd_header(value);ttreturn 0;t}tif (!strcmp(var, ""format.suffix""))ttreturn git_config_string(&fmt_patch_suffix, var, value);tif (!strcmp(var, ""format.cc"")) {ttif (!value)tttreturn config_error_nonbool(var);ttALLOC_GROW(extra_cc, extra_cc_nr + 1, extra_cc_alloc);ttextra_cc[extra_cc_nr++] = xstrdup(value);ttreturn 0;t}tif (!strcmp(var, ""diff.color"") || !strcmp(var, ""color.diff"")) {ttreturn 0;t}tif (!strcmp(var, ""format.numbered"")) {ttif (value && !strcasecmp(value, ""auto"")) {tttauto_number = 1;tttreturn 0;tt}ttnumbered = git_config_bool(var, value);ttreturn 0;t}treturn git_log_config(var, value, cb);}",2,"cwe119,cwe120"
"dwc3_testmode_write(struct file *file,ttconst char __user *ubuf, size_t count, loff_t *ppos){tstruct seq_filett*s = file->private_data;tstruct dwc3tt*dwc = s->private;tunsigned longttflags;tu32ttttestmode = 0;tchartttbuf[32];tif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))ttreturn -EFAULT;tif (!strncmp(buf, ""test_j"", 6))tttestmode = TEST_J;telse if (!strncmp(buf, ""test_k"", 6))tttestmode = TEST_K;telse if (!strncmp(buf, ""test_se0_nak"", 12))tttestmode = TEST_SE0_NAK;telse if (!strncmp(buf, ""test_packet"", 11))tttestmode = TEST_PACKET;telse if (!strncmp(buf, ""test_force_enable"", 17))tttestmode = TEST_FORCE_EN;telsetttestmode = 0;tspin_lock_irqsave(&dwc->lock, flags);tdwc3_gadget_set_test_mode(dwc, testmode);tspin_unlock_irqrestore(&dwc->lock, flags);treturn count;}",2,"cwe119,cwe120"
"daemon_pidfile_unlocked(const char *name){tchar pid[32];tint pid_fd;t tif (!name)ttreturn set_errno(EINVAL);t tif (daemon_construct_pidfile(name, &g.pidfile) == -1)ttreturn -1;t tif ((pid_fd = daemon_lock_pidfile(g.pidfile)) == -1)t{ttmem_destroy(&g.pidfile);ttreturn -1;t}t tsnprintf(pid, 32, ""%d"", (int)getpid());tif (write(pid_fd, pid, strlen(pid)) != strlen(pid))t{ttdaemon_close();ttreturn -1;t}t treturn 0;}",2,"cwe119,cwe120"
"""__strsep (char **stringp, const char *delim){  char *begin;  assert (delim[0] != '0');  begin = *stringp;  if (begin != NULL)    {      char *end = begin;      while (*end != '0' || (end = NULL))t{t  const char *dp = delim;t  dot    if (*dp == *end)t      break;t  while (*++dp != '0');t  if (*dp != '0')t    {t      *end++ = '0';t      break;t    }t  ++end;t}      *stringp = end;    }  return begin;}""",2,"cwe119,cwe120"
"_e_fm2_inplace_open(const E_Fm2_Icon *ic){   char buf[PATH_MAX];   if (((!S_ISDIR(ic->info.statinfo.st_mode)) ||         (ic->info.link && (!S_ISDIR(ic->info.statinfo.st_mode))) ||         (!ic->sd->config->view.open_dirs_in_place) ||         (ic->sd->config->view.no_subdir_jump)))     return 0;   if (!_e_fm2_icon_path(ic, buf, sizeof(buf)))     return -1;   e_fm2_path_set(ic->sd->obj, ic->info.link ? ""/"" : ic->sd->dev, buf);   return 1;}",2,"cwe119,cwe120"
"cleanup24DiskList( void ) {tDiskIOInfo* ptr = DiskIO;tDiskIOInfo* last = 0;ttwhile ( ptr ) {ttif ( ptr->alive == 0 ) {tttDiskIOInfo* newPtr;tttchar sensorName[ 128 ];tttttt tttsprintf( sensorName, ""disk/%s_(%d:%d)24/total"", ptr->devname, ptr->major, ptr->minor );tttremoveMonitor( sensorName );tttsprintf( sensorName, ""disk/%s_(%d:%d)24/rio"", ptr->devname, ptr->major, ptr->minor );tttremoveMonitor( sensorName );tttsprintf( sensorName, ""disk/%s_(%d:%d)24/wio"", ptr->devname, ptr->major, ptr->minor );tttremoveMonitor( sensorName );tttsprintf( sensorName, ""disk/%s_(%d:%d)24/rblk"", ptr->devname, ptr->major, ptr->minor );tttremoveMonitor( sensorName );tttsprintf( sensorName, ""disk/%s_(%d:%d)24/wblk"", ptr->devname, ptr->major, ptr->minor );tttremoveMonitor( sensorName );tttif ( last ) {ttttlast->next = ptr->next;ttttnewPtr = ptr->next;ttt}tttelse {ttttDiskIO = ptr->next;ttttnewPtr = DiskIO;ttttlast = 0;ttt}ttttttfree ( ptr );tttptr = newPtr;tt}ttelse {tttptr->alive = 0;tttlast = ptr;tttptr = ptr->next;tt}t}}",2,"cwe119,cwe120"
"xlator_option_validate_sizet (xlator_t *xl, const char *key, const char *value,                              volume_option_t *opt, char **op_errstr){        uint64_t  size = 0;        int       ret = 0;        char      errstr[256];                 if (gf_string2bytesize (value, &size) != 0) {                snprintf (errstr, 256,                          ""invalid number format ""%s"" in option ""%s"""",                          value, key);                gf_log (xl->name, GF_LOG_ERROR, ""%s"", errstr);                ret = -1;                goto out;        }        if ((opt->min == 0) && (opt->max == 0)) {                gf_log (xl->name, GF_LOG_TRACE,                        ""no range check required for 'option %s %s'"",                        key, value);                goto out;        }        if ((size < opt->min) || (size > opt->max)) {                if ((strncmp (key, ""cache-size"", 10) == 0) &&                    (size > opt->max)) {                       snprintf (errstr, 256, ""Cache size %""PRId64"" is out of ""                                 ""range [%.0f - %.0f]"",                                 size, opt->min, opt->max);                       gf_log (xl->name, GF_LOG_WARNING, ""%s"", errstr);                } else {                        snprintf (errstr, 256,                                  ""'%""PRId64""' in 'option %s %s' ""                                  ""is out of range [%.0f - %.0f]"",                                  size, key, value, opt->min, opt->max);                        gf_log (xl->name, GF_LOG_ERROR, ""%s"", errstr);                        ret = -1;                }        }out:        if (ret && op_errstr)                *op_errstr = gf_strdup (errstr);        return ret;}",2,"cwe119,cwe120"
"read_proc_kcore(int fd, void *bufptr, int cnt, ulong addr, physaddr_t paddr) {tint i; tsize_t readcnt;tulong kvaddr;tElf32_Phdr *lp32;tElf64_Phdr *lp64;toff_t offset;tif (!machdep->verify_paddr(paddr)) {ttif (CRASHDEBUG(1))ttterror(INFO, ""verify_paddr(%lx) failed"", paddr);ttreturn READ_ERROR;t}t toffset = UNINITIALIZED;tkvaddr = (ulong)paddr | machdep->kvbase;treadcnt = cnt;tswitch (pkd->flags & (KCORE_ELF32|KCORE_ELF64)) t{tcase KCORE_ELF32:ttfor (i = 0; i < pkd->segments; i++) {tttlp32 = pkd->load32 + i;tttif ((kvaddr >= lp32->p_vaddr) &&ttt    (kvaddr < (lp32->p_vaddr + lp32->p_memsz))) {ttttoffset = (off_t)(kvaddr - lp32->p_vaddr) + ttttt(off_t)lp32->p_offset;ttttbreak;ttt}tt}tt ttif (pc->curcmd_flags & MEMTYPE_KVADDR)tttpc->curcmd_flags &= ~MEMTYPE_KVADDR;ttelsetttbreak;ttfor (i = 0; i < pkd->segments; i++) {tttlp32 = pkd->load32 + i;tttif ((addr >= lp32->p_vaddr) &&ttt    (addr < (lp32->p_vaddr + lp32->p_memsz))) {ttttoffset = (off_t)(addr - lp32->p_vaddr) + ttttt(off_t)lp32->p_offset;ttttbreak;ttt}tt}ttbreak;tcase KCORE_ELF64:ttfor (i = 0; i < pkd->segments; i++) {tttlp64 = pkd->load64 + i;tttif ((kvaddr >= lp64->p_vaddr) &&ttt    (kvaddr < (lp64->p_vaddr + lp64->p_memsz))) {ttttoffset = (off_t)(kvaddr - lp64->p_vaddr) + ttttt(off_t)lp64->p_offset;ttttbreak;ttt}tt}ttbreak;t}tif (offset == UNINITIALIZED)ttreturn SEEK_ERROR;        if (lseek(fd, offset, SEEK_SET) != offset)ttperror(""lseek"");tif (read(fd, bufptr, readcnt) != readcnt)ttreturn READ_ERROR;treturn cnt;}",2,"cwe120,cweother"
"""pdf_compute_encryption_key(pdf_crypt *crypt, unsigned char *password, int pwlen, unsigned char *key){tunsigned char buf[32];tunsigned int p;tint i, n;tfz_md5 md5;tn = crypt->length / 8;t/* Step 1 - copy and pad password string */tif (pwlen > 32)ttpwlen = 32;tmemcpy(buf, password, pwlen);tmemcpy(buf + pwlen, padding, 32 - pwlen);t/* Step 2 - init md5 and pass value of step 1 */tfz_md5_init(&md5);tfz_md5_update(&md5, buf, 32);t/* Step 3 - pass O value */tfz_md5_update(&md5, crypt->o, 32);t/* Step 4 - pass P value as unsigned int, low-order byte first */tp = (unsigned int) crypt->p;tbuf[0] = (p) & 0xFF;tbuf[1] = (p >> 8) & 0xFF;tbuf[2] = (p >> 16) & 0xFF;tbuf[3] = (p >> 24) & 0xFF;tfz_md5_update(&md5, buf, 4);t/* Step 5 - pass first element of ID array */tfz_md5_update(&md5, (unsigned char *)pdf_to_str_buf(crypt->id), pdf_to_str_len(crypt->id));t/* Step 6 (revision 4 or greater) - if metadata is not encrypted pass 0xFFFFFFFF */tif (crypt->r >= 4)t{ttif (!crypt->encrypt_metadata)tt{tttbuf[0] = 0xFF;tttbuf[1] = 0xFF;tttbuf[2] = 0xFF;tttbuf[3] = 0xFF;tttfz_md5_update(&md5, buf, 4);tt}t}t/* Step 7 - finish the hash */tfz_md5_final(&md5, buf);t/* Step 8 (revision 3 or greater) - do some voodoo 50 times */tif (crypt->r >= 3)t{ttfor (i = 0; i < 50; i++)tt{tttfz_md5_init(&md5);tttfz_md5_update(&md5, buf, n);tttfz_md5_final(&md5, buf);tt}t}t/* Step 9 - the key is the first 'n' bytes of the result */tmemcpy(key, buf, n);}""",3,"cwe119,cwe120,cweother"
"_fill_tlist(E_Config_Dialog_Data *cfdata){   Config_Type *tmp;   Eina_List *l;   Evas_Coord w, h;   evas_event_freeze(evas_object_evas_get(cfdata->gui.tlist));   edje_freeze();   e_widget_ilist_freeze(cfdata->gui.tlist);   e_widget_ilist_clear(cfdata->gui.tlist);   EINA_LIST_FOREACH(types, l, tmp)     {        Evas_Object *icon;        char buf[4096];        char *t;        if (!tmp) continue;        t = strdup(tmp->name);        t[0] = tolower(t[0]);        icon = edje_object_add(evas_object_evas_get(cfdata->gui.tlist));        snprintf(buf, sizeof(buf), ""e/icons/fileman/mime/%s"", t);        if (!e_theme_edje_object_set(icon, ""base/theme/fileman"", buf))          e_theme_edje_object_set(icon, ""base/theme/fileman"", ""e/icons/fileman/file"");        e_widget_ilist_append(cfdata->gui.tlist, icon, tmp->name, _tlist_cb_change, cfdata, tmp->type);        free(t);     }   e_widget_ilist_go(cfdata->gui.tlist);   e_widget_size_min_get(cfdata->gui.tlist, &w, &h);   e_widget_size_min_set(cfdata->gui.tlist, w, 225);   e_widget_ilist_thaw(cfdata->gui.tlist);   edje_thaw();   evas_event_thaw(evas_object_evas_get(cfdata->gui.tlist));}",2,"cwe119,cwe120"
"ldogetlinks(struct dolink **ppdol, int4 *pndol){tstruct doreqt*pdoq;tt tstruct doreplyt*pdor;tt tstruct nmsgtrequest;t tstruct nmsgtreply;tt tinttteps;tt tintttnum;tt tintttseg;tt tintttlen;tt tcharttpacket[MAXNMSGLEN];  tLAM_ZERO_ME(request);tLAM_ZERO_ME(reply);t tpdoq = (struct doreq *) request.nh_data;tpdoq->doq_req = DOQGETLINKS;tpdoq->doq_src_event = -lam_getpid();t tnum = seg = 0;trequest.nh_node = LOCAL;trequest.nh_event = EVDL0;trequest.nh_type = DLCTL;trequest.nh_flags = NOBUF;trequest.nh_length = 0;trequest.nh_msg = 0;tpdor = (struct doreply *) reply.nh_data;treply.nh_node = LOCAL;treply.nh_event = pdoq->doq_src_event;treply.nh_type = 0;treply.nh_flags = 0;treply.nh_length = MAXNMSGLEN;treply.nh_msg = packet;teps = MAXNMSGLEN / sizeof(struct dolink);t tdo {t  pdoq->doq_extra = seg;t   t  if (nsend(&request)) t    return(LAMERROR);t   t  if (nrecv(&reply)) t    return(LAMERROR);t  if (pdor->dor_reply != 0) {t    errno = pdor->dor_reply;t    return(LAMERROR);t  }t   t  if (seg == 0) {t    num = *pndol = pdor->dor_nlinks;t    *ppdol = (struct dolink *) malloc((unsigned) num * ttttt      sizeof(struct dolink));t    if (*ppdol == 0) t      return(LAMERROR);t  }t   t  if (num > eps)t    len = eps * sizeof(struct dolink);t  elset    len = num * sizeof(struct dolink);t  t   t  memcpy(*ppdol + (*pndol - num), packet, len);t  num -= eps;t  ++seg;t} while (num > 0);treturn 0;}",2,"cwe119,cwe120"
"gateway_close(struct audio_device *device){tGError *gerr = NULL;tstruct gateway *gw = device->gateway;tint sock;tif (gw->rfcomm) {ttsock = g_io_channel_unix_get_fd(gw->rfcomm);ttshutdown(sock, SHUT_RDWR);ttg_io_channel_shutdown(gw->rfcomm, TRUE, NULL);ttg_io_channel_unref(gw->rfcomm);ttgw->rfcomm = NULL;t}tif (gw->sco) {ttg_io_channel_shutdown(gw->sco, TRUE, NULL);ttg_io_channel_unref(gw->sco);ttgw->sco = NULL;t}tchange_state(device, GATEWAY_STATE_DISCONNECTED);tg_set_error(&gerr, GATEWAY_ERROR,tttGATEWAY_ERROR_DISCONNECTED, ""Disconnected"");trun_connect_cb(device, gerr);tg_error_free(gerr);treturn 0;}",2,"cwe119,cwe120"
"""xflag_apply(unsigned int in, const char *name){tunsigned int out, flag;tint status = FLAGS_ADD;tout = in;tswitch (*name)t{tcase '+':ttstatus = FLAGS_ADD;ttname++;ttbreak;tcase '-':ttstatus = FLAGS_DEL;ttname++;ttbreak;t}tflag = xflag_lookup(name);tif (status == FLAGS_ADD)ttout |= flag;telsettout &= ~flag;ttreturn out;}""",2,"cwe119,cwe120"
"cmd_timer(void){        int c;tint rflag;trflag = 0;        while ((c = getopt(argcnt, args, ""r"")) != EOF) {                switch(c)                {ttcase 'r':tttrflag = 1;tttbreak;                default:                        argerrs++;                        break;                }        }        if (argerrs)                cmd_usage(pc->curcmd, SYNOPSIS);tif (rflag)ttdump_hrtimer_data();telsettdump_timer_data();}",2,"cwe120,cweother"
"qquota_usage(FILE *fp){   dstring ds;   char buffer[256];   DENTER(TOP_LAYER, ""qquota_usage"");   if (fp == NULL) {      DRETURN(false);   }   sge_dstring_init(&ds, buffer, sizeof(buffer));   fprintf(fp, ""%s"", feature_get_product_name(FS_SHORT_VERSION, &ds));   fprintf(fp,""%s qquota [options]"", MSG_SRC_USAGE);   fprintf(fp, ""  [-help]                              %s"", MSG_COMMON_help_OPT_USAGE);   fprintf(fp, ""  [-h wc_host_list|wc_hostgroup_list]  %s"", MSG_QQUOTA_h_OPT_USAGE);   fprintf(fp, ""  [-l resource_attributes]             %s"", MSG_QQUOTA_l_OPT_USAGE);   fprintf(fp, ""  [-u wc_user]                         %s"", MSG_QQUOTA_u_OPT_USAGE);   fprintf(fp, ""  [-pe wc_pe_list]                     %s"", MSG_QQUOTA_pe_OPT_USAGE);   fprintf(fp, ""  [-P wc_project_list]                 %s"", MSG_QQUOTA_P_OPT_USAGE);    fprintf(fp, ""  [-q wc_cqueue_list]                  %s"", MSG_QQUOTA_q_OPT_USAGE);    fprintf(fp, ""  [-xml]                               %s"", MSG_COMMON_xml_OPT_USAGE);   fprintf(fp, """");   fprintf(fp, ""resource_attributes      resource_name,resource_name,..."");   fprintf(fp, ""wc_cqueue                %s"", MSG_QSTAT_HELP_WCCQ);   fprintf(fp, ""wc_cqueue_list           wc_cqueue[,wc_cqueue,...]"");   fprintf(fp, ""wc_host                  %s"", MSG_QSTAT_HELP_WCHOST);   fprintf(fp, ""wc_host_list             wc_host[,wc_host,...]"");   fprintf(fp, ""wc_hostgroup             %s"", MSG_QSTAT_HELP_WCHG);   fprintf(fp, ""wc_hostgroup_list        wc_hostgroup[,wc_hostgroup,...]"");   fprintf(fp, ""wc_pe                    %s"", MSG_QQUOTA_HELP_WCPE);   fprintf(fp, ""wc_pe_list               wc_pe[,wc_pe,...]"");   fprintf(fp, ""wc_project               %s"", MSG_QQUOTA_HELP_WCPROJECT);   fprintf(fp, ""wc_project_list          wc_project[,wc_project,...]"");   DRETURN(true);}",2,"cwe119,cwe120"
"print_crl(crl_t *crl){tenumerator_t *enumerator;ttime_t ts;tcrl_reason_t reason;tchunk_t chunk;tint count = 0;tbool first;tchar buf[64];tstruct tm tm;tx509_cdp_t *cdp;tchunk = chunk_skip_zero(crl->get_serial(crl));tprintf(""serial:    %#B"", &chunk);tif (crl->is_delta_crl(crl, &chunk))t{ttchunk = chunk_skip_zero(chunk);ttprintf(""delta CRL: for serial %#B"", &chunk);t}tchunk = crl->get_authKeyIdentifier(crl);tprintf(""authKeyId: %#B"", &chunk);tfirst = TRUE;tenumerator = crl->create_delta_crl_uri_enumerator(crl);twhile (enumerator->enumerate(enumerator, &cdp))t{ttif (first)tt{tttprintf(""freshest:  %s"", cdp->uri);tttfirst = FALSE;tt}ttelsett{tttprintf(""           %s"", cdp->uri);tt}ttif (cdp->issuer)tt{tttprintf("" (CRL issuer: %Y)"", cdp->issuer);tt}ttprintf("""");t}tenumerator->destroy(enumerator);tenumerator = crl->create_enumerator(crl);twhile (enumerator->enumerate(enumerator, &chunk, &ts, &reason))t{ttcount++;t}tenumerator->destroy(enumerator);tprintf(""%d revoked certificate%s%s"", count,tt   count == 1 ? """" : ""s"", count ? "":"" : """");tenumerator = crl->create_enumerator(crl);twhile (enumerator->enumerate(enumerator, &chunk, &ts, &reason))t{ttchunk = chunk_skip_zero(chunk);ttlocaltime_r(&ts, &tm);ttstrftime(buf, sizeof(buf), ""%F %T"", &tm);ttprintf(""    %#B %N %s"", &chunk, crl_reason_names, reason, buf);ttcount++;t}tenumerator->destroy(enumerator);}",2,"cwe119,cwe120"
"ath10k_tpc_config_disp_tables(struct ath10k *ar,ttttt  struct wmi_pdev_tpc_config_event *ev,ttttt  struct ath10k_tpc_stats *tpc_stats,ttttt  u8 *rate_code, u16 *pream_table, u8 type){tu32 i, j, pream_idx, flags;tu8 tpc[WMI_TPC_TX_N_CHAIN];tchar tpc_value[WMI_TPC_TX_N_CHAIN * WMI_TPC_BUF_SIZE];tchar buff[WMI_TPC_BUF_SIZE];tflags = __le32_to_cpu(ev->flags);tswitch (type) {tcase WMI_TPC_TABLE_TYPE_CDD:ttif (!(flags & WMI_TPC_CONFIG_EVENT_FLAG_TABLE_CDD)) {tttath10k_dbg(ar, ATH10K_DBG_WMI, ""CDD not supported"");ttttpc_stats->flag[type] = ATH10K_TPC_TABLE_TYPE_FLAG;tttreturn;tt}ttbreak;tcase WMI_TPC_TABLE_TYPE_STBC:ttif (!(flags & WMI_TPC_CONFIG_EVENT_FLAG_TABLE_STBC)) {tttath10k_dbg(ar, ATH10K_DBG_WMI, ""STBC not supported"");ttttpc_stats->flag[type] = ATH10K_TPC_TABLE_TYPE_FLAG;tttreturn;tt}ttbreak;tcase WMI_TPC_TABLE_TYPE_TXBF:ttif (!(flags & WMI_TPC_CONFIG_EVENT_FLAG_TABLE_TXBF)) {tttath10k_dbg(ar, ATH10K_DBG_WMI, ""TXBF not supported"");ttttpc_stats->flag[type] = ATH10K_TPC_TABLE_TYPE_FLAG;tttreturn;tt}ttbreak;tdefault:ttath10k_dbg(ar, ATH10K_DBG_WMI,ttt   ""invalid table type in wmi tpc event: %d"", type);ttreturn;t}tpream_idx = 0;tfor (i = 0; i < __le32_to_cpu(ev->rate_max); i++) {ttmemset(tpc_value, 0, sizeof(tpc_value));ttmemset(buff, 0, sizeof(buff));ttif (i == pream_table[pream_idx])tttpream_idx++;ttfor (j = 0; j < WMI_TPC_TX_N_CHAIN; j++) {tttif (j >= __le32_to_cpu(ev->num_tx_chain))ttttbreak;ttttpc[j] = ath10k_tpc_config_get_rate(ar, ev, i, j + 1,ttttttt    rate_code[i],ttttttt    type);tttsnprintf(buff, sizeof(buff), ""%8d "", tpc[j]);tttstrncat(tpc_value, buff, strlen(buff));tt}tttpc_stats->tpc_table[type].pream_idx[i] = pream_idx;tttpc_stats->tpc_table[type].rate_code[i] = rate_code[i];ttmemcpy(tpc_stats->tpc_table[type].tpc_value[i],tt       tpc_value, sizeof(tpc_value));t}}",2,"cwe119,cwe120"
"series_greatest_index (const DATASET *dset, const char *varname){    const char *s = varname;    int fd = 0, ret = -1;    if (dset != NULL) {tint i;ttret = dset->v;tif (s == NULL || *s == '0' || isdigit(*s)) {t    goto bailout;t}tif (strcmp(s, ""const"") == 0) {t    ret = 0;t    goto bailout;t}tif (strchr(s, '.') != NULL) {t    ret = try_for_listvar(dset, s);t    goto bailout;t}tfd = gretl_function_depth();tif (fd == 0) {t     t    for (i=dset->v-1; i>0; i--) { ttif (strcmp(dset->varname[i], s) == 0) {tt    ret = i;tt    break;tt}t    }t} else {t     t    for (i=dset->v-1; i>0; i--) { ttif (fd == series_get_stack_level(dset, i) &&tt    !series_is_listarg(dset, i) && tt    strcmp(dset->varname[i], s) == 0) {tt    ret = i;tt    break;tt}t    }t}    }    if (ret <= 0 && strcmp(s, ""const"")) {tret = dset->v;    } bailout:#if GEN_LEVEL_DEBUG    fprintf(stderr, ""series_index for '%s', fd = %d: got %d (dset->v = %d)"", t    s, fd, ret, dset->v);#endif     return ret;}",2,"cwe469,cwe476"
"auto_drop_var (const MODEL *pmod, ttt  int *list, const int *cands,ttt  DATASET *dset, double alpha_max, ttt  int starting, gretlopt opt,ttt  PRN *prn){    double tstat, pv = 0.0, tmin = 4.0;    int i, k = -1;    int ret = 0;    if (pmod->ncoeff == 1) {treturn 0;    }        for (i=pmod->ifc; i<pmod->ncoeff; i++) {tif (coeff_is_removable(cands, pmod, dset, i)) {t    tstat = fabs(pmod->coeff[i] / pmod->sderr[i]);t    if (tstat < tmin) {tttmin = tstat;ttk = i;t    }t}    }    if (k >= 0) {tpv = coeff_pval(pmod->ci, tmin, pmod->dfd);    }    if (pv > alpha_max) {tchar pname[VNAMELEN];tint err;tif (starting && !(opt & OPT_I)) {t     t    pputc(prn, '');t    pprintf(prn, _(""Sequential elimination using two-sided alpha = %.2f""),tt    alpha_max);t    pputs(prn, """");t}tgretl_model_get_param_name(pmod, dset, k, pname);terr = gretl_list_delete_at_pos(list, k + 2);tif (!err) {t    if (!(opt & OPT_I)) {ttpprintf(prn, _("" Dropping %-16s (p-value %.3f)""), pname, pv);t    }t    ret = 1;t}    }    return ret;}",2,"cwe119,cwe120"
"xsh_predict_create(cpl_plugin *plugin){  cpl_recipe *recipe = NULL;  xsh_clipping_param detarc_clip_param = { 2.0, 10, 0.7, 0, 0.3};  xsh_detect_arclines_param detarc_param = {6, 3, 0, 5, 5, 0, 2, 5.0,    XSH_GAUSSIAN_METHOD, FALSE};  char paramname[256];  cpl_parameter* p=NULL;  const int ival=DECODE_BP_FLAG_DEF;     xsh_init();     assure( plugin != NULL, CPL_ERROR_NULL_INPUT, ""Null plugin"");     assure( cpl_plugin_get_type(plugin) == CPL_PLUGIN_TYPE_RECIPE,          CPL_ERROR_TYPE_MISMATCH,          ""Plugin is not a recipe"");  recipe = (cpl_recipe *)plugin;     recipe->parameters = cpl_parameterlist_new();  assure( recipe->parameters != NULL,          CPL_ERROR_ILLEGAL_OUTPUT,          ""Memory allocation failed!"");     check( xsh_parameters_generic( RECIPE_ID, recipe->parameters ) ) ;  xsh_parameters_decode_bp(RECIPE_ID,recipe->parameters,ival);  check( xsh_parameters_pre_overscan( RECIPE_ID, recipe->parameters ) ) ;      check(xsh_parameters_detect_arclines_create(RECIPE_ID,recipe->parameters,     detarc_param));  check(xsh_parameters_clipping_detect_arclines_create(RECIPE_ID,     recipe->parameters, detarc_clip_param));     check(  xsh_parameters_new_int( recipe->parameters, RECIPE_ID,                                       ""model-maxit"",1000,                                  ""Number/10 of annealing iterations ""                                  ""if in physical model mode.""));  check(  xsh_parameters_new_double( recipe->parameters, RECIPE_ID,                                       ""model-anneal-factor"",1.0,                                  ""Multiplier applied to the automatic ""                                  ""parameter ranges (i.e. when scenario!=0). ""tttt  ""For routine operations should be 1.0. ""                                  ""(physical model mode).""));    sprintf(paramname,""xsh.%s.%s"",RECIPE_ID,""model-scenario"");     check(p=cpl_parameter_new_enum(paramname,CPL_TYPE_INT,tttt ""selects preset flag and range combinations ""                                 ""appropriate to common scenarios: "" tttt "" 0 - No scenario, input cfg flags and limits ""tttt ""used.""tttt "" 1 - scenario appropriate for the startup ""tttt ""recipe (large ranges for parameters ""tttt ""affecting single ph exposures, dist ""tttt ""coeff fixed).""tttt "" 2 - Like 1, but includes parameters ""tttt ""affecting all ph positions.""tttt "" 3 - Scenario for use in fine tuning cfg ""tttt ""to match routine single pinhole exposures. ""tttt ""All parameters affecting 1ph exposures ""tttt ""except dist coeffs are included and ""tttt ""parameter ranges are small. (For use by ""tttt ""predict in 1ph case).""tttt "" 4 - Like 3 but includes parameters  ""tttt ""affecting all ph positions (Standard for ""tttt ""use by predict in 9ph case and 2dmap). ""                                  ,RECIPE_ID,3,9,-1,0,1,2,3,4,5,6,8));  check(cpl_parameter_set_alias(p,CPL_PARAMETER_MODE_CLI,tttt""model-scenario""));  check(cpl_parameterlist_append(recipe->parameters,p));  cleanup:    if ( cpl_error_get_code() != CPL_ERROR_NONE ){      xsh_error_dump(CPL_MSG_ERROR);      return 1;    }    else {      return 0;    }}",2,"cwe119,cwe120"
"ns_os_chroot(const char *root) {tchar strbuf[ISC_STRERRORSIZE];#ifdef HAVE_LIBSCFtns_smf_chroot = 0;#endiftif (root != NULL) {#ifdef HAVE_CHROOTttif (chroot(root) < 0) {tttisc__strerror(errno, strbuf, sizeof(strbuf));tttns_main_earlyfatal(""chroot(): %s"", strbuf);tt}#elsettns_main_earlyfatal(""chroot(): disabled"");#endifttif (chdir(""/"") < 0) {tttisc__strerror(errno, strbuf, sizeof(strbuf));tttns_main_earlyfatal(""chdir(/): %s"", strbuf);tt}#ifdef HAVE_LIBSCFtt ttns_smf_chroot = 1;#endift}}",3,"cwe119,cwe120,cweother"
"stonith_api_device_list(stonith_t * stonith, int call_options, const char *namespace,                        stonith_key_value_t ** devices, int timeout){    int count = 0;    if (devices == NULL) {        crm_err(""Parameter error: stonith_api_device_list"");        return -EFAULT;    }         if (namespace == NULL || safe_str_eq(""heartbeat"", namespace)) {#if HAVE_STONITH_STONITH_H        static gboolean need_init = TRUE;        char **entry = NULL;        char **type_list = NULL;        static char **(*type_list_fn) (void) = NULL;        static void (*type_free_fn) (char **) = NULL;        if (need_init) {            need_init = FALSE;            type_list_fn =                find_library_function(&lha_agents_lib, LHA_STONITH_LIBRARY, ""stonith_types"", FALSE);            type_free_fn =                find_library_function(&lha_agents_lib, LHA_STONITH_LIBRARY, ""stonith_free_hostlist"",                                      FALSE);        }        if (type_list_fn) {            type_list = (*type_list_fn) ();        }        for (entry = type_list; entry != NULL && *entry; ++entry) {            crm_trace(""Added: %s"", *entry);            *devices = stonith_key_value_add(*devices, NULL, *entry);            count++;        }        if (type_list && type_free_fn) {            (*type_free_fn) (type_list);        }#else        if (namespace != NULL) {            return -EINVAL;              }#endif    }         if (namespace == NULL || safe_str_eq(""redhat"", namespace)) {        struct dirent **namelist;        int file_num = scandir(RH_STONITH_DIR, &namelist, 0, alphasort);        if (file_num > 0) {            struct stat prop;            char buffer[FILENAME_MAX + 1];            while (file_num--) {                if ('.' == namelist[file_num]->d_name[0]) {                    free(namelist[file_num]);                    continue;                } else if (0 != strncmp(RH_STONITH_PREFIX,                                        namelist[file_num]->d_name, strlen(RH_STONITH_PREFIX))) {                    free(namelist[file_num]);                    continue;                }                snprintf(buffer, FILENAME_MAX, ""%s/%s"", RH_STONITH_DIR, namelist[file_num]->d_name);                if (stat(buffer, &prop) == 0 && S_ISREG(prop.st_mode)) {                    *devices = stonith_key_value_add(*devices, NULL, namelist[file_num]->d_name);                    count++;                }                free(namelist[file_num]);            }            free(namelist);        }    }    return count;}",2,"cwe119,cwe120"
"slurp(const char *filename){    char *text;    struct stat sbuf;    size_t filesize;    FILE *f = fopen(filename, ""r"");    if (f == NULL) fail(""fopen(""%s"", ""r"")"", filename);    if (fstat(fileno(f), &sbuf) != 0) fail(""fstat(""%s"")"", filename);    filesize = sbuf.st_size;    text = (char *) malloc(filesize + 1);    if (text == NULL) fail(""malloc(text)"");    if (fread(text, 1, filesize, f) != filesize) fail(""fread"");    fclose(f);    text[filesize] = '0';    return text;}",2,"cwe476,cweother"
"rb_vm_bugreport(void){    rb_vm_t *vm = GET_VM();    if (vm) {tint i = 0;tSDR();tif (rb_backtrace_each(bugreport_backtrace, &i)) {t    fputs("""", stderr);t}    }#if HAVE_BACKTRACE || defined(_WIN32)    fprintf(stderr, ""-- C level backtrace information ""t    ""-------------------------------------------"");    {#if defined __MACH__ && defined __APPLE__tfprintf(stderr, """");tfprintf(stderr, ""   See Crash Report log file under ""tt""~/Library/Logs/CrashReporter or"");tfprintf(stderr, ""   /Library/Logs/CrashReporter, for ""tt""the more detail of."");#elif HAVE_BACKTRACE#define MAX_NATIVE_TRACE 1024tstatic void *trace[MAX_NATIVE_TRACE];tint n = backtrace(trace, MAX_NATIVE_TRACE);tchar **syms = backtrace_symbols(trace, n);tif (syms) {#ifdef USE_ELFt    rb_dump_backtrace_with_lines(n, trace, syms);#elset    int i;t    for (i=0; i<n; i++) {ttfprintf(stderr, ""%s"", syms[i]);t    }#endift    free(syms);t}#elif defined(_WIN32)tDWORD tid = GetCurrentThreadId();tHANDLE th = (HANDLE)_beginthread(dump_thread, 0, &tid);tif (th != (HANDLE)-1)t    WaitForSingleObject(th, INFINITE);#endif    }    fprintf(stderr, """");#endif      fprintf(stderr, ""-- Other runtime information ""t    ""-----------------------------------------------"");    {tint i;tfprintf(stderr, ""* Loaded script: %s"", StringValueCStr(vm->progname));tfprintf(stderr, """");tfprintf(stderr, ""* Loaded features:"");tfor (i=0; i<RARRAY_LEN(vm->loaded_features); i++) {t    fprintf(stderr, "" %4d %s"", i, StringValueCStr(RARRAY_PTR(vm->loaded_features)[i]));t}tfprintf(stderr, """");#if __linux__t{t    FILE *fp = fopen(""/proc/self/maps"", ""r"");t    if (fp) {ttfprintf(stderr, ""* Process memory map:"");ttwhile (!feof(fp)) {tt    char buff[0x100];tt    size_t rn = fread(buff, 1, 0x100, fp);tt    fwrite(buff, 1, rn, stderr);tt}ttfclose(fp);ttfprintf(stderr, """");t    }t}#endif      }}",4,"cwe119,cwe120,cwe469,cweother"
"xsh_frame_build_sky_area(cpl_frame* slitmap_frame, const char* tag) {  char name_o[256];  cpl_frame* result = NULL;  cpl_image* ima_slit = NULL;  cpl_image* ima_sky = NULL;  float* pslit = NULL;  float* psky = NULL;  const char* name = NULL;  cpl_propertylist* plist = NULL;  int sx = 0;  int sy = 0;  int i = 0;  int j = 0;  check(name = cpl_frame_get_filename(slitmap_frame));  cpl_frame_dump(slitmap_frame, stdout);  check(ima_slit = cpl_image_load(name, CPL_TYPE_FLOAT, 0, 0));  check(plist = cpl_propertylist_load(name, 0));  pslit = cpl_image_get_data_float(ima_slit);  sx = cpl_image_get_size_x(ima_slit);  sy = cpl_image_get_size_y(ima_slit);  ima_sky = cpl_image_new(sx, sy, CPL_TYPE_FLOAT);  psky = cpl_image_get_data_float(ima_sky);  for (j = 1; j < sy - 1; j++) {    for (i = 1; i < sx - 1; i++) {      psky[j * sx + i] = 0.25 * (pslit[j * sx + i + 1] - pslit[j * sx + i - 1])          * (pslit[(j + 1) * sx + i] - pslit[(j - 1) * sx + i]);    }  }  sprintf(name_o, ""%s.fits"", tag);  check(cpl_image_save(ima_sky, name_o, XSH_PRE_DATA_BPP, plist, CPL_IO_DEFAULT));  result = cpl_frame_duplicate(slitmap_frame);  cpl_frame_set_filename(result, name_o);  cpl_frame_set_tag(result, tag);  cleanup: xsh_free_propertylist(&plist);  xsh_free_image(&ima_slit);  xsh_free_image(&ima_sky);  return result;}",2,"cwe119,cwe120"
"mos_rotate_slits(cpl_table *slits, int rotation, int nx, int ny){    const char *func = ""mos_rotate_slits"";    cpl_error_code error;    char aux_name[] = ""_0"";    int i;    rotation %= 4;    if (rotation < 0)        rotation += 4;    if (rotation == 0)        return CPL_ERROR_NONE;    error = mos_validate_slits(slits);    if (error)        return cpl_error_set(func, error);    if (rotation == 1 || rotation == 3) {                 for (i = 0; i < 77; i++)            if (1 == cpl_table_has_column(slits, aux_name))                aux_name[1]++;        if (1 == cpl_table_has_column(slits, aux_name))            return cpl_error_set(func, CPL_ERROR_CONTINUE);        cpl_table_name_column(slits, ""xtop"", aux_name);        cpl_table_name_column(slits, ""ytop"", ""xtop"");        cpl_table_name_column(slits, aux_name, ""ytop"");        cpl_table_name_column(slits, ""xbottom"", aux_name);        cpl_table_name_column(slits, ""ybottom"", ""xbottom"");        cpl_table_name_column(slits, aux_name, ""ybottom"");    }    if (rotation == 1 || rotation == 2) {        cpl_table_multiply_scalar(slits, ""xtop"", -1.0);        cpl_table_multiply_scalar(slits, ""xbottom"", -1.0);        cpl_table_add_scalar(slits, ""xtop"", nx);        cpl_table_add_scalar(slits, ""xbottom"", nx);    }    if (rotation == 3 || rotation == 2) {        cpl_table_multiply_scalar(slits, ""ytop"", -1.0);        cpl_table_multiply_scalar(slits, ""ybottom"", -1.0);        cpl_table_add_scalar(slits, ""ytop"", ny);        cpl_table_add_scalar(slits, ""ybottom"", ny);    }    return CPL_ERROR_NONE;}",2,"cwe119,cwe120"
"num_stmts(const node *n){    int i, l;    node *ch;    switch (TYPE(n)) {        case single_input:            if (TYPE(CHILD(n, 0)) == NEWLINE)                return 0;            else                return num_stmts(CHILD(n, 0));        case file_input:            l = 0;            for (i = 0; i < NCH(n); i++) {                ch = CHILD(n, i);                if (TYPE(ch) == stmt)                    l += num_stmts(ch);            }            return l;        case stmt:            return num_stmts(CHILD(n, 0));        case compound_stmt:            return 1;        case simple_stmt:            return NCH(n) / 2;          case suite:            if (NCH(n) == 1)                return num_stmts(CHILD(n, 0));            else {                l = 0;                for (i = 2; i < (NCH(n) - 1); i++)                    l += num_stmts(CHILD(n, i));                return l;            }        default: {            char buf[128];            sprintf(buf, ""Non-statement found: %d %d"",                    TYPE(n), NCH(n));            Py_FatalError(buf);        }    }    assert(0);    return 0;}",2,"cwe119,cwe120"
"log_message(struct log_data* data, const char *format, ...){tstatic char logmsg[1024];tstruct tm *tmp;ttime_t t;tva_list args;tssize_t size = 0;tif (data->logmode == mode_file)t{ttt = time(NULL);tttmp = localtime(&t);ttstrftime(logmsg, 32, ""%Y-%m-%d %H:%M:%S "", tmp);ttva_start(args, format);ttsize = vsnprintf(logmsg + 20, 1004, format, args);ttva_end(args);ttif (write(data->fd, logmsg, size + 20) < (size+20))tt{tttfprintf(stderr, ""Unable to write full log. Error=%d: %s"", errno, strerror(errno));tt}ttelsett{#ifdef WIN32ttt_commit(data->fd);#else#if defined _POSIX_SYNCHRONIZED_IO && _POSIX_SYNCHRONIZED_IO > 0tttfdatasync(data->fd);#elsetttfsync(data->fd);#endif#endiftt}t}#ifndef WIN32telset{ttva_start(args, format);ttvsyslog(LOG_INFO, format, args);ttva_end(args);t}#endif}",3,"cwe119,cwe120,cweother"
"alloc_state_create(const char *path, INT64_T size){tchar statepath[CHIRP_PATH_MAX];tFILE *file;tsprintf(statepath, ""%s/.__alloc"", path);tfile = fopen(statepath, ""w"");tif(file) {ttfprintf(file, ""%"" PRId64 "" 0"", size);ttfclose(file);ttreturn 1;t} else {ttreturn 0;t}}",3,"cwe119,cwe120,cweother"
"restore_slotmem(void *ptr, const char *name, apr_size_t size,                                    apr_pool_t *pool){    const char *storename;    apr_file_t *fp;    apr_size_t nbytes = size;    apr_status_t rv = APR_SUCCESS;    unsigned char digest[APR_MD5_DIGESTSIZE];    unsigned char digest2[APR_MD5_DIGESTSIZE];    storename = slotmem_filename(pool, name, 1);    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, APLOGNO(02335)                 ""restoring %s"", storename);    if (storename) {        rv = apr_file_open(&fp, storename, APR_READ | APR_WRITE, APR_OS_DEFAULT,                           pool);        if (rv == APR_SUCCESS) {            rv = apr_file_read(fp, ptr, &nbytes);            if ((rv == APR_SUCCESS || rv == APR_EOF) && nbytes == size) {                rv = APR_SUCCESS;                                     if (apr_file_eof(fp) != APR_EOF) {                    apr_size_t ds = APR_MD5_DIGESTSIZE;                    rv = apr_file_read(fp, digest, &ds);                    if ((rv == APR_SUCCESS || rv == APR_EOF) &&                        ds == APR_MD5_DIGESTSIZE) {                        rv = APR_SUCCESS;                        apr_md5(digest2, ptr, nbytes);                        if (memcmp(digest, digest2, APR_MD5_DIGESTSIZE)) {                            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,                                         APLOGNO(02551) ""bad md5 match"");                            rv = APR_EGENERAL;                        }                    }                }                else {                    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,                                 APLOGNO(02552) ""at EOF... bypassing md5 match check (old persist file?)"");                }            }            else if (nbytes != size) {                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,                             APLOGNO(02553) ""Expected %"" APR_SIZE_T_FMT "": Read %"" APR_SIZE_T_FMT,                             size, nbytes);                rv = APR_EGENERAL;            }            apr_file_close(fp);        }    }    return rv;}",2,"cwe119,cwe120"
"config_copy(CONFIG *src){tCONFIG *dest;tt t tif (src == NULL || src->epsilon == NULL || src->prompt1 == NULL ||t    src->prompt2 == NULL) {ttmath_error(""bad CONFIG value"");tt t}t tdest = (CONFIG *)malloc(sizeof(CONFIG));tif (dest == NULL) {ttmath_error(""malloc of CONFIG failed"");tt t}t tmemcpy((void *)dest, (void *)src, sizeof(CONFIG));t tdest->epsilon = qlink(src->epsilon);tdest->prompt1 = strdup(src->prompt1);tdest->prompt2 = strdup(src->prompt2);tif (src->program == NULL) {ttdest->program = strdup(program);t} else {ttdest->program = strdup(src->program);t}tif (src->base_name == NULL) {ttdest->base_name = strdup(base_name);t} else {ttdest->base_name = strdup(src->base_name);t}t tif (src->version == NULL) {ttdest->version = strdup(version());t} else {ttdest->version = strdup(src->version);t}t treturn dest;}",2,"cwe120,cwe476"
"print_local_addrs(struct iface_data *idata){tunsigned inttti, j;tcharttttpv6addr[INET6_ADDRSTRLEN];tchar ttttplinkaddr[ETHER_ADDR_PLEN];tputs(""List of local interfaces/addresses"");tfor(i=0; i < idata->iflist.nifaces; i++){ttif(ether_ntop(&((idata->iflist).ifaces[i].ether), plinkaddr, sizeof(plinkaddr)) == 0){tttputs(""ether_ntop(): Error converting address"");tttexit(EXIT_FAILURE);tt}ttprintf(""Name: %stIndex: %dt Address: %s"", (idata->iflist.ifaces[i]).iface, (idata->iflist.ifaces[i]).ifindex, plinkaddr);ttputs(""Link-local addresses:"");ttfor(j=0; j < idata->iflist.ifaces[i].ip6_local.nprefix; j++){tttif(inet_ntop(AF_INET6, idata->iflist.ifaces[i].ip6_local.prefix[j], pv6addr, sizeof(pv6addr)) == NULL){ttttputs(""inet_ntop(): Error converting IPv6 address to presentation format"");ttttexit(EXIT_FAILURE);ttt}tttprintf(""t%s"", pv6addr);tt}ttputs(""Global addresses:"");ttfor(j=0; j < idata->iflist.ifaces[i].ip6_global.nprefix; j++){tttif(inet_ntop(AF_INET6, idata->iflist.ifaces[i].ip6_global.prefix[j], pv6addr, sizeof(pv6addr)) == NULL){ttttputs(""inet_ntop(): Error converting IPv6 address to presentation format"");ttttexit(EXIT_FAILURE);ttt}tttprintf(""t%s"", pv6addr);tt}ttputs("""");t}treturn(SUCCESS);}",2,"cwe119,cwe120"
"dospellmenu(const char *prompt,            int splaction,t             int *spell_no){    winid tmpwin;    int i, n, how;    char buf[BUFSZ];    menu_item *selected;    anything any;    tmpwin = create_nhwindow(NHW_MENU);    start_menu(tmpwin);    any.a_void = 0;tt          if (!iflags.menu_tab_sep)            sprintf(buf, ""%-20s     Level  %-12s Fail"", ""    Name"", ""Category"");    else            sprintf(buf, ""NametLeveltCategorytFail"");    add_menu(tmpwin, NO_GLYPH, &any, 0, 0, ATR_BOLD, buf, MENU_UNSELECTED);    for (i = 0; i < MAXSPELL && spellid(i) != NO_SPELL; i++)    {        sprintf(buf, iflags.menu_tab_sep ?                ""%st%-d%st%st%-d%%"" : ""%-20s  %2d%s   %-12s %3d%%"",                spellname(i), spellev(i),                spellknow(i) ? "" "" : ""*"",                spelltypemnemonic(spell_skilltype(spellid(i))),                100 - percent_success(i));        any.a_int = i+1;t         add_menu(tmpwin, NO_GLYPH, &any,                 spellet(i), 0, ATR_NONE, buf,                 (i == splaction) ? MENU_SELECTED : MENU_UNSELECTED);    }    end_menu(tmpwin, prompt);    how = PICK_ONE;    if (splaction == SPELLMENU_VIEW && spellid(1) == NO_SPELL)            how = PICK_NONE;t     n = select_menu(tmpwin, how, &selected);    destroy_nhwindow(tmpwin);    if (n > 0)    {        *spell_no = selected[0].item.a_int - 1;                 if (n > 1 && *spell_no == splaction)                *spell_no = selected[1].item.a_int - 1;        free(selected);                 if (*spell_no == splaction) return false;        return true;    }    else if (splaction >= 0)    {                 *spell_no = splaction;        return true;    }    return false;}",3,"cwe119,cwe120,cweother"
"test_date_rfc2822__format_rfc2822_positive_offset(void){tgit_time t = {1397031663, 120};tchar buf[GIT_DATE_RFC2822_SZ];tcl_git_pass(git__date_rfc2822_fmt(buf, sizeof(buf), &t));tcl_assert(strcmp(buf, ""Wed, 9 Apr 2014 10:21:03 +0200"") == 0);}",2,"cwe119,cwe120"
"getuser (uid_t uid){  register struct userid *tail;  struct passwd *pwent;  char usernum_string[20];  for (tail = user_alist; tail; tail = tail->next)    if (tail->id.u == uid)      return tail->name;  pwent = getpwuid (uid);  tail = (struct userid *) xmalloc (sizeof (struct userid));  tail->id.u = uid;  if (pwent == 0)    {      sprintf (usernum_string, ""%u"", (unsigned) uid);      tail->name = xstrdup (usernum_string);    }  else    tail->name = xstrdup (pwent->pw_name);     tail->next = user_alist;  user_alist = tail;  return tail->name;}",2,"cwe119,cwe120"
"auth_hostname_accept(struct link *link, char **subject, time_t stoptime){tchar addr[LINK_ADDRESS_MAX];tchar name[DOMAIN_NAME_MAX];tint port;tif(!link_address_remote(link, addr, &port)) {ttdebug(D_AUTH, ""hostname: couldn't get address of link"");ttgoto reject;t}tif(!domain_name_cache_lookup_reverse(addr, name)) {ttdebug(D_AUTH, ""hostname: couldn't look up name of %s"", name);ttgoto reject;t}t*subject = strdup(name);tif(!*subject) {ttdebug(D_AUTH, ""hostname: out of memory"");ttgoto reject;t}tlink_putliteral(link, ""yes"", stoptime);treturn 1;      reject:tlink_putliteral(link, ""no"", stoptime);treturn 0;}",2,"cwe119,cwe120"
"doquerysave(BW *bw,int c,struct savereq *req,int *notify){tW *w = bw->parent;tif (c == 'y' || c == 'Y') {ttif (bw->b->name && bw->b->name[0])tttreturn dosave1(bw, vsncpy(NULL,0,sz(bw->b->name)), req, notify);ttelse {tttBW *pbw;tttpbw = wmkpw(bw->parent, US ""Name of file to save (^C to abort): "", &filehist, dosave1, US ""Names"", NULL, cmplt, req, notify, locale_map);tttif (pbw) {ttttreturn 0;ttt} else {ttttjoe_free(req);ttttreturn -1;ttt}tt}t} else if (c == 'n' || c == 'N') {tt ttif (bw->b->changed)tttreq->not_saved = 1;ttnext:ttif (unbuf(bw)) {tttif (notify)tttt*notify = 1;tttrmsavereq(req);tttreturn -1;tt}ttbw = w->object;ttif (bw->b==req->first) {tttif (notify)tttt*notify = 1;tttrmsavereq(req);tttgenexmsgmulti(bw,1,req->not_saved);tttreturn 0;tt}ttif (!bw->b->changed || bw->b->scratch)tttgoto next;ttreturn doquerysave(bw,0,req,notify);t} else {ttunsigned char buf[1024];ttjoe_snprintf_1(buf,1024,""File %s has been modified.  Save it (y,n,^C)? "",bw->b->name ? bw->b->name : US ""(Unnamed)"" );ttif (mkqw(bw->parent, sz(buf), doquerysave, NULL, req, notify)) {tttreturn 0;ttt} else {ttt tttrmsavereq(req);tttreturn -1;tt}t}}",2,"cwe119,cwe120"
"file_read(void){  char                buf[512];  size_t              rc;  struct read_state   st;  int                 fmt;  const char *        tk1_magic     = TK1_MAGIC;  size_t              tk1_magic_len = strlen(tk1_magic) + 1;  state_init(&st);     rc = fread(buf, 1, sizeof(buf), fl);  while (rc != 0) {    buf_write(&st.data, buf, rc);    rc = fread(buf, 1, sizeof(buf), fl);  }  if (!feof(fl)) {    fatal(MYNAME "": Read error"");  }        buf_rewind(&st.data);  buf_read(&st.data, buf, tk1_magic_len);  if (memcmp(buf, tk1_magic, tk1_magic_len) == 0) {    db(1, ""Got TK1 file"");    buf_rewind(&st.data);         buf_read(&st.data, NULL, TK1_DATA_OFFSET);    wbt201_process_chunk(&st);  } else {    db(1, ""Got bin file"");         for (fmt = 0; fmt_version[fmt].reclen != 0; fmt++) {      size_t reclen = fmt_version[fmt].reclen;      if ((st.data.used % reclen) == 0 && is_valid(&st.data, fmt)) {        break;      }    }    if (fmt_version[fmt].reclen == 0) {      fatal(MYNAME "": Can't autodetect data format"");    }    wbt200_process_data(&st, fmt);  }  state_empty(&st);}",3,"cwe119,cwe120,cweother"
"check_grant_db(THD *thd,const char *db){  Security_context *sctx= thd->security_ctx;  char helping [NAME_LEN+USERNAME_LENGTH+2];  uint len;  bool error= TRUE;  size_t copy_length;  copy_length= (size_t) (strlen(sctx->priv_user ? sctx->priv_user : """") +                 strlen(db ? db : """")) + 1;       if (copy_length >= (NAME_LEN+USERNAME_LENGTH+2))    return 1;  len= (uint) (strmov(strmov(helping, sctx->priv_user) + 1, db) - helping) + 1;  mysql_rwlock_rdlock(&LOCK_grant);  for (uint idx=0 ; idx < column_priv_hash.records ; idx++)  {    GRANT_TABLE *grant_table= (GRANT_TABLE*)      my_hash_element(&column_priv_hash,                      idx);    if (len < grant_table->key_length &&t!memcmp(grant_table->hash_key,helping,len) &&        compare_hostname(&grant_table->host, sctx->get_host()->ptr(),                         sctx->get_ip()->ptr()))    {      error= FALSE;        break;    }  }  if (error)    error= check_grant_db_routine(thd, db, &proc_priv_hash) &&           check_grant_db_routine(thd, db, &func_priv_hash);  mysql_rwlock_unlock(&LOCK_grant);  return error;}",2,"cwe476,cweother"
"regTestWritePixAndCheck(L_REGPARAMS  *rp,                        PIX          *pix,                        l_int32       format){char   namebuf[256];    PROCNAME(""regTestWritePixAndCheck"");    if (!rp)        return ERROR_INT(""rp not defined"", procName, 1);    if (!pix) {        rp->success = FALSE;        return ERROR_INT(""pix not defined"", procName, 1);    }    if (format < 0 || format >= NumImageFileFormatExtensions) {        rp->success = FALSE;        return ERROR_INT(""invalid format"", procName, 1);    }             snprintf(namebuf, sizeof(namebuf), ""/tmp/%s.%d.%s"", rp->testname,             rp->index + 1, ImageFileFormatExtensions[format]);             pixWrite(namebuf, pix, format);             regTestCheckFile(rp, namebuf);    return 0;}",2,"cwe119,cwe120"
"""Recount_files(T_Fileselector *list){  T_Fileselector_item *item;  list->Nb_files=0;  list->Nb_directories=0;  list->Nb_elements=0;    for (item = list->First; item != NULL; item = item->Next)  {    if (item->Type == 0)      list->Nb_files ++;    else      list->Nb_directories ++;    list->Nb_elements ++;  }    if (list->Index)  {    free(list->Index);    list->Index = NULL;  }    if (list->Nb_elements>0)  {    int i;        list->Index = (T_Fileselector_item **) malloc(list->Nb_elements * sizeof(T_Fileselector_item **));    if (list->Index)    {      // Fill the index      for (item = list->First, i=0; item != NULL; item = item->Next, i++)      {        list->Index[i] = item;      }    }    // If the malloc failed, we're probably in trouble, but I don't know    // how to recover from that..I'll just make the index bulletproof.  }}""",2,"cwe120,cweother"
"""AcpiDmUpdateResourceName (    ACPI_NAMESPACE_NODE     *ResourceNode){    char                    Name[ACPI_NAME_SIZE];    /* Ignore if a unique name has already been assigned */    if (ResourceNode->Name.Integer != ACPI_DEFAULT_RESNAME)    {        return;    }    /* Generate a new ACPI name for the descriptor */    Name[0] = '_';    Name[1] = AcpiGbl_Prefix[AcpiGbl_NextPrefix];    Name[2] = AcpiUtHexToAsciiChar ((UINT64) AcpiGbl_NextResourceId, 4);    Name[3] = AcpiUtHexToAsciiChar ((UINT64) AcpiGbl_NextResourceId, 0);    /* Update globals for next name */    AcpiGbl_NextResourceId++;    if (AcpiGbl_NextResourceId >= 256)    {        AcpiGbl_NextResourceId = 0;        AcpiGbl_NextPrefix++;        if (AcpiGbl_NextPrefix > ACPI_NUM_RES_PREFIX)        {            AcpiGbl_NextPrefix = 0;        }    }    /* Change the resource descriptor name */    ResourceNode->Name.Integer = *ACPI_CAST_PTR (UINT32, &Name[0]);}""",2,"cwe119,cwe120"
"ivybridge_parity_work(struct work_struct *work){tstruct drm_i915_private *dev_priv =ttcontainer_of(work, struct drm_i915_private, l3_parity.error_work);tu32 error_status, row, bank, subbank;tchar *parity_event[6];tuint32_t misccpctl;tuint8_t slice = 0;t tmutex_lock(&dev_priv->dev->struct_mutex);t tif (WARN_ON(!dev_priv->l3_parity.which_slice))ttgoto out;tmisccpctl = I915_READ(GEN7_MISCCPCTL);tI915_WRITE(GEN7_MISCCPCTL, misccpctl & ~GEN7_DOP_CLOCK_GATE_ENABLE);tPOSTING_READ(GEN7_MISCCPCTL);twhile ((slice = ffs(dev_priv->l3_parity.which_slice)) != 0) {tti915_reg_t reg;ttslice--;ttif (WARN_ON_ONCE(slice >= NUM_L3_SLICES(dev_priv)))tttbreak;ttdev_priv->l3_parity.which_slice &= ~(1<<slice);ttreg = GEN7_L3CDERRST1(slice);tterror_status = I915_READ(reg);ttrow = GEN7_PARITY_ERROR_ROW(error_status);ttbank = GEN7_PARITY_ERROR_BANK(error_status);ttsubbank = GEN7_PARITY_ERROR_SUBBANK(error_status);ttI915_WRITE(reg, GEN7_PARITY_ERROR_VALID | GEN7_L3CDERRST1_ENABLE);ttPOSTING_READ(reg);ttparity_event[0] = I915_L3_PARITY_UEVENT ""=1"";ttparity_event[1] = kasprintf(GFP_KERNEL, ""ROW=%d"", row);ttparity_event[2] = kasprintf(GFP_KERNEL, ""BANK=%d"", bank);ttparity_event[3] = kasprintf(GFP_KERNEL, ""SUBBANK=%d"", subbank);ttparity_event[4] = kasprintf(GFP_KERNEL, ""SLICE=%d"", slice);ttparity_event[5] = NULL;ttkobject_uevent_env(&dev_priv->dev->primary->kdev->kobj,tttt   KOBJ_CHANGE, parity_event);ttDRM_DEBUG(""Parity error: Slice = %d, Row = %d, Bank = %d, Sub bank = %d."",ttt  slice, row, bank, subbank);ttkfree(parity_event[4]);ttkfree(parity_event[3]);ttkfree(parity_event[2]);ttkfree(parity_event[1]);t}tI915_WRITE(GEN7_MISCCPCTL, misccpctl);out:tWARN_ON(dev_priv->l3_parity.which_slice);tspin_lock_irq(&dev_priv->irq_lock);tgen5_enable_gt_irq(dev_priv, GT_PARITY_ERROR(dev_priv));tspin_unlock_irq(&dev_priv->irq_lock);tmutex_unlock(&dev_priv->dev->struct_mutex);}",2,"cwe119,cwe120"
"dbg_gen_printf(int onsyslog,int perr,int from_level,ttt   EpmdVars *g,const char *format, va_list args){  time_t now;  char *timestr;  char buf[DEBUG_BUFFER_SIZE];  if (g->is_daemon)    {#ifdef HAVE_SYSLOG_H      if (onsyslog)t{t  erts_vsnprintf(buf, DEBUG_BUFFER_SIZE, format, args);t  syslog(LOG_ERR,""epmd: %s"",buf);t}#endif    }  else    {      int len;      time(&now);      timestr = (char *)ctime(&now);      erts_snprintf(buf, DEBUG_BUFFER_SIZE, ""epmd: %.*s: "",tt    (int) strlen(timestr)-1, timestr);      len = strlen(buf);      erts_vsnprintf(buf + len, DEBUG_BUFFER_SIZE - len, format, args);      if (perr != 0)tfprintf(stderr,""%s: %sr"",buf,strerror(perr));      elsetfprintf(stderr,""%sr"",buf);    }}",2,"cwe119,cwe120"
"lg_FindRSAPublicKeyAttribute(NSSLOWKEYPublicKey *key, CK_ATTRIBUTE_TYPE type,ttttCK_ATTRIBUTE *attribute){    unsigned char hash[SHA1_LENGTH];    CK_KEY_TYPE keyType = CKK_RSA;    switch (type) {    case CKA_KEY_TYPE:treturn lg_ULongAttribute(attribute, type, keyType);    case CKA_ID:tSHA1_HashBuf(hash,key->u.rsa.modulus.data,key->u.rsa.modulus.len);treturn lg_CopyAttribute(attribute,type,hash,SHA1_LENGTH);    case CKA_DERIVE:treturn LG_CLONE_ATTR(attribute,type,lg_StaticFalseAttr);    case CKA_ENCRYPT:    case CKA_VERIFY:    case CKA_VERIFY_RECOVER:    case CKA_WRAP:treturn LG_CLONE_ATTR(attribute,type,lg_StaticTrueAttr);    case CKA_MODULUS:treturn lg_CopyAttributeSigned(attribute,type,key->u.rsa.modulus.data,tttttkey->u.rsa.modulus.len);    case CKA_PUBLIC_EXPONENT:treturn lg_CopyAttributeSigned(attribute, type,ttttkey->u.rsa.publicExponent.data,ttttkey->u.rsa.publicExponent.len);    default:tbreak;    }    return lg_invalidAttribute(attribute);}",2,"cwe119,cwe120"
esl_stack_Destroy(ESL_STACK *s){  if (s->idata) free(s->idata);  if (s->cdata) free(s->cdata);  if (s->pdata) free(s->pdata);#ifdef HAVE_PTHREAD  if (s->mutex) { pthread_mutex_destroy(s->mutex); free(s->mutex); }  if (s->cond)  { pthread_cond_destroy(s->cond);   free(s->cond);  }#endif  free(s);},2,"cwe476,cweother"
"xsh_parameters_find( cpl_parameterlist* list,  const char* recipe_id, const char* name){  char paramname[256];  cpl_parameter * result = NULL ;   sprintf(paramname,""xsh.%s.%s"",recipe_id, name);  check(result = cpl_parameterlist_find( (cpl_parameterlist *)list, paramname));   cleanup:    return result;}",3,"cwe119,cwe120,cwe469"
"read_gfs1_jiindex(struct gfs2_sbd *sdp){tstruct gfs2_inode *ip = sdp->md.jiinode;tchar buf[sizeof(struct gfs1_jindex)];tunsigned int j;tint error=0;tunsigned int tmp_mode = 0;tif(ip->i_di.di_size % sizeof(struct gfs1_jindex) != 0){ttlog_crit(_(""The size reported in the journal index""tttt"" inode is not a""tttt""tmultiple of the size of a journal index.""));ttreturn -1;t}tif(!(sd_jindex = (struct gfs1_jindex *)malloc(ip->i_di.di_size))) {ttlog_crit(_(""Unable to allocate journal index""));ttreturn -1;t}tif(!memset(sd_jindex, 0, ip->i_di.di_size)) {ttlog_crit(_(""Unable to zero journal index""));ttreturn -1;t}t ttmp_mode = ip->i_di.di_mode;tip->i_di.di_mode &= ~S_IFMT;tip->i_di.di_mode |= S_IFDIR;tfor (j = 0; ; j++) {ttstruct gfs1_jindex *journ;tterror = gfs2_readi(ip, buf, j * sizeof(struct gfs1_jindex),tttttt   sizeof(struct gfs1_jindex));ttif(!error)tttbreak;ttif (error != sizeof(struct gfs1_jindex)){tttlog_crit(_(""An error occurred while reading the""ttttt"" journal index file.""));tttgoto fail;tt}ttjourn = sd_jindex + j;ttgfs1_jindex_in(journ, buf);ttsdp->jsize = (journ->ji_nsegment * 16 * sdp->bsize) >> 20;t}tip->i_di.di_mode = tmp_mode;tif(j * sizeof(struct gfs1_jindex) != ip->i_di.di_size){ttlog_crit(_(""journal inode size invalid""));ttgoto fail;t}tsdp->md.journals = sdp->orig_journals = j;treturn 0; fail:tfree(sd_jindex);treturn -1;}",2,"cwe119,cwe120"
"newsnntp_article(newsnntp * f, uint32_t indx, char ** result,tt     size_t * result_len){  char command[NNTP_STRING_SIZE];  int r;  snprintf(command, NNTP_STRING_SIZE, ""ARTICLE %ir"", indx);  r = send_command(f, command);  if (r == -1)    return NEWSNNTP_ERROR_STREAM;  return newsnntp_get_content(f, result, result_len);}",2,"cwe119,cwe120"
"GetString(FILE *infp){    unsigned int i;    char *stringbuffer;    size_t stringbuffersize;    ASSERT(ch == '""');    stringbuffersize = 5000;    stringbuffer = xmalloc(stringbuffersize);    ch = getc(infp);t/* skip the '""' that begins the string */    i = 0;    while (ch != '""') {        if (ch == EOF) {t        Error(""%s, line %d: EOF when expecting """", hpfile, linenum, ch);        }        else if (i == stringbuffersize - 1) {            stringbuffersize = 2 * stringbuffersize;            stringbuffer = xrealloc(stringbuffer, stringbuffersize);        }        stringbuffer[ i++ ] = ch;        ch = getc(infp);    }    stringbuffer[i] = '0';     thestring = copystring(stringbuffer);    ASSERT(ch == '""');    ch = getc(infp);      /* skip the '""' that terminates the string */}",2,"cwe120,cweother"
"evhttp_parse_headers(struct evhttp_request *req, struct evbuffer* buffer){tenum message_read_status errcode = DATA_CORRUPTED;tchar *line;tenum message_read_status status = MORE_DATA_EXPECTED;tstruct evkeyvalq* headers = req->input_headers;tsize_t line_length;twhile ((line = evbuffer_readln(buffer, &line_length, EVBUFFER_EOL_CRLF))t       != NULL) {ttchar *skey, *svalue;ttreq->headers_size += line_length;ttif (req->evcon != NULL &&tt    req->headers_size > req->evcon->max_headers_size) {ttterrcode = DATA_TOO_LONG;tttgoto error;tt}ttif (*line == '0') {  tttstatus = ALL_DATA_READ;tttmm_free(line);tttbreak;tt}tt ttif (*line == ' ' || *line == 't') {tttif (evhttp_append_to_last_header(headers, line) == -1)ttttgoto error;tttmm_free(line);tttcontinue;tt}tt ttsvalue = line;ttskey = strsep(&svalue, "":"");ttif (svalue == NULL)tttgoto error;ttsvalue += strspn(svalue, "" "");ttif (evhttp_add_header(headers, skey, svalue) == -1)tttgoto error;ttmm_free(line);t}tif (status == MORE_DATA_EXPECTED) {ttif (req->headers_size + evbuffer_get_length(buffer) > req->evcon->max_headers_size)tttreturn (DATA_TOO_LONG);t}treturn (status); error:tmm_free(line);treturn (errcode);}",2,"cwe469,cwe476"
"hydra_recv(int socket, char *buf, int length) {  int ret;  char text[64];  ret = internal__hydra_recv(socket, buf, length);  if (debug) {    sprintf(text, ""[DEBUG] RECV [pid:%d]"", getpid());    hydra_dump_data(buf, ret, text);       }  return ret;}",2,"cwe119,cwe120"
"ffextn(char *url,                       int *extension_num,              int *status){     fitsfile *fptr;    char urltype[20];    char infile[FLEN_FILENAME];    char outfile[FLEN_FILENAME];     char extspec[FLEN_FILENAME];    char extname[FLEN_FILENAME];    char rowfilter[FLEN_FILENAME];    char binspec[FLEN_FILENAME];    char colspec[FLEN_FILENAME];    char imagecolname[FLEN_VALUE], rowexpress[FLEN_FILENAME];    char *cptr;    int extnum, extvers, hdutype, tstatus = 0;    if (*status > 0)        return(*status);         fits_parse_input_url(url, urltype, infile, outfile,             extspec, rowfilter,binspec, colspec, status);    if (*status > 0)        return(*status);    if (*binspec)        {       *extension_num = 1;         return(*status);    }    if (*extspec)        {       ffexts(extspec, &extnum,          extname, &extvers, &hdutype, imagecolname, rowexpress, status);      if (*status > 0)        return(*status);      if (*imagecolname)          {         *extension_num = 1;           return(*status);      }      if (*extname)      {                   if (!strcmp(urltype, ""stdin://""))                         return(*status = URL_PARSE_ERROR);                    infile[0] = '0';t strncat(infile, url, FLEN_FILENAME -1);t          cptr = strchr(infile, ']');            if (!cptr)         {             return(*status = URL_PARSE_ERROR);         }         else         {             cptr++;             *cptr = '0';           }         if (ffopen(&fptr, infile, READONLY, status) > 0)           {            ffclos(fptr, &tstatus);            return(*status);         }         ffghdn(fptr, &extnum);              *extension_num = extnum;         ffclos(fptr, status);         return(*status);      }      else      {         *extension_num = extnum + 1;            return(*status);      }    }    else    {         *extension_num = -99;                                             return(*status);    }}",4,"cwe119,cwe120,cwe476,cweother"
"load_svgs_file(void) {#define BUFSIZE 1024  char * result = NULL;  int fd;  char buf[BUFSIZE];  int size = 0,ret;  fd = open(""testsvgs.xml"",O_RDONLY);  if (fd == -1) {    WARN(""Couldn't open test file"");    exit(-1);  }  while ((ret = read(fd,buf,BUFSIZE)) > 0) {    result = realloc(result,size+ret);    memcpy(result+size,buf,ret);    size += ret;  }  if (ret < 0) {    WARN(""Reading from file failed: %s"",strerror(errno));    exit(-1);  }  close(fd);  result = realloc(result,size+1);  result[size] = '0';  return result;}",3,"cwe119,cwe120,cweother"
"spawn_modems(void){    DIR *cfdir;    struct dirent *cf;    struct stat st;    int len;    int pid = -1;    char *config = NULL;    char filename[256];         cfdir = opendir(""/etc/iaxmodem"");    if (cfdir == NULL) {      printlog(LOG_ERROR, ""Error: could not open configuration directory: %s"", strerror(errno));      return -1;    }    while ((cf = readdir(cfdir)) != NULL)      {t tlen = strlen(cf->d_name);tif ((cf->d_name[0] == '.') || (cf->d_name[0] == '#') || (cf->d_name[len - 1] == '~'))t  continue;t tsnprintf(filename, sizeof(filename), ""/etc/iaxmodem/%s"", cf->d_name);tif (stat(filename, &st) < 0)t  {t    printlog(LOG_INFO, ""Could not stat configuration file %s: %s"", cf->d_name, strerror(errno));t    continue;t  }tif (!S_ISREG(st.st_mode))t  {t    printlog(LOG_INFO, ""bouh !"");t    continue;t  }tconfig = strdup(cf->d_name);t tpid = fork();tif (pid == 0) {t   t  break;t} else if (pid > 0) {t   t  add_modem(pid, config);t} else {t   t  printlog(LOG_ERROR, ""Error: fork failed: %s"", strerror(errno));t  if (numchild > 0) {t    printlog(LOG_ERROR, ""%d children spawned, continuing anyway (stopped at %s)"", numchild, config);t  } else {t    return -1;t  }t  free(config);t  break;t}      }    closedir(cfdir);    if (pid == 0) {             iaxmodem(config, 0);      return 1;    }    return 0;}",2,"cwe119,cwe120"
"swf_skip_data(SWFReader *read, u32 size){twhile (size && !read->ioerr) {ttswf_read_int(read, 8);ttsize --;t}}",2,"cwe120,cweother"
"StripWUSSGivenCC(ESL_MSA *msa, float gapthresh, int first_match, int last_match){  int status;  int *matassign;t   int gaps;  int apos;  int idx;  int cc;  int *ct;tt      if(msa->flags & eslMSA_DIGITAL)    cm_Fail(""ERROR in StripWUSSGivenCC, MSA is digitized."");     ESL_ALLOC(matassign, sizeof(int) * (msa->alen+1));  matassign[0] = 0;    for (apos = 0; apos < msa->alen; apos++)    {      for (gaps = 0, idx = 0; idx < msa->nseq; idx++)tif (esl_abc_CIsGap(msa->abc, msa->aseq[idx][apos])) gaps++;      matassign[apos+1] = ((double) gaps / (double) msa->nseq > gapthresh) ? 0 : 1;    }     ESL_ALLOC(ct, (msa->alen+1) * sizeof(int));  if (esl_wuss2ct(msa->ss_cons, msa->alen, ct) != eslOK)      cm_Fail(""Consensus structure string is inconsistent"");      cc = 0;  for (apos = 1; apos <= msa->alen; apos++)    {      if (! matassign[apos])t{ t  if (ct[apos] != 0)  ct[ct[apos]] = 0;t  ct[apos] = 0;t}      else  t{t  cc++; t  if(cc < first_match || cc > last_match)t    {t      if (ct[apos] != 0)  ct[ct[apos]] = 0;t      ct[apos] = 0;t    }t}    }     for (apos = 1; apos <= msa->alen; apos++)    {      if      (ct[apos] == 0   ) msa->ss_cons[apos-1] = '.';      else if (ct[apos]  > apos) msa->ss_cons[apos-1] = '<';      else if (ct[apos]  < apos) msa->ss_cons[apos-1] = '>';      else cm_Fail(""ERROR: weird error in StripWUSSGivenCC"");    }  return; ERROR:  cm_Fail(""Memory allocation error."");}",2,"cwe120,cweother"
"hcd_buffer_create(struct usb_hcd *hcd){tcharttname[16];tinttti, size;tif (!hcd->self.controller->dma_mask &&t    !(hcd->driver->flags & HCD_LOCAL_MEM))ttreturn 0;tfor (i = 0; i < HCD_BUFFER_POOLS; i++) {ttsize = pool_max[i];ttif (!size)tttcontinue;ttsnprintf(name, sizeof(name), ""buffer-%d"", size);tthcd->pool[i] = dma_pool_create(name, hcd->self.controller,ttttsize, size, 0);ttif (!hcd->pool[i]) {ttthcd_buffer_destroy(hcd);tttreturn -ENOMEM;tt}t}treturn 0;}",2,"cwe119,cwe120"
"snd_pcm_file_readi(snd_pcm_t *pcm, void *buffer, snd_pcm_uframes_t size){tsnd_pcm_file_t *file = pcm->private_data;tsnd_pcm_channel_area_t areas[pcm->channels];tsnd_pcm_sframes_t n;tn = snd_pcm_readi(file->gen.slave, buffer, size);tif (n <= 0)ttreturn n;tif (file->ifd >= 0) {ttn = read(file->ifd, buffer, n * pcm->frame_bits / 8);ttif (n < 0)tttreturn n;ttreturn n * 8 / pcm->frame_bits;t}tsnd_pcm_areas_from_buf(pcm, areas, buffer);tsnd_pcm_file_add_frames(pcm, areas, 0, n);treturn n;}",2,"cwe120,cweother"
sec_asn1d_parent_allows_EOC(sec_asn1d_state *state){         state = sec_asn1d_get_enclosing_construct(state);    if (state) {tsec_asn1d_parse_place place = state->place;         tint eoc_permitted = t    (place == duringGroup ||t     place == duringConstructedString ||t     state->child->optional);treturn (state->indefinite && eoc_permitted) ? PR_TRUE : PR_FALSE;    }    return PR_FALSE;},2,"cwe119,cwe120"
"ecryptfs_compute_root_iv(struct ecryptfs_crypt_stat *crypt_stat){tint rc = 0;tchar dst[MD5_DIGEST_SIZE];tBUG_ON(crypt_stat->iv_bytes > MD5_DIGEST_SIZE);tBUG_ON(crypt_stat->iv_bytes <= 0);tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {ttrc = -EINVAL;ttecryptfs_printk(KERN_WARNING, ""Session key not valid; ""tttt""cannot generate root IV"");ttgoto out;t}trc = ecryptfs_calculate_md5(dst, crypt_stat, crypt_stat->key,tttt    crypt_stat->key_size);tif (rc) {ttecryptfs_printk(KERN_WARNING, ""Error attempting to compute ""tttt""MD5 while generating root IV"");ttgoto out;t}tmemcpy(crypt_stat->root_iv, dst, crypt_stat->iv_bytes);out:tif (rc) {ttmemset(crypt_stat->root_iv, 0, crypt_stat->iv_bytes);ttcrypt_stat->flags |= ECRYPTFS_SECURITY_WARNING;t}treturn rc;}",2,"cwe119,cwe120"
"ChapInput(int linkunit,u_char *inpacket,int packet_len){  int unit = lns[linkunit].chap_unit;    chap_state *cstate = &chap[unit];    u_char *inp;    u_char code, id;    int len;           inp = inpacket;    if (packet_len < CHAP_HEADERLEN) {tCHAPDEBUG((LOG_INFO, ""ChapInput: rcvd short header.""));treturn;    }    GETCHAR(code, inp);    GETCHAR(id, inp);    GETSHORT(len, inp);    if (len < CHAP_HEADERLEN) {tCHAPDEBUG((LOG_INFO, ""ChapInput: rcvd illegal length.""));treturn;    }    if (len > packet_len) {tCHAPDEBUG((LOG_INFO, ""ChapInput: rcvd short packet.""));treturn;    }    len -= CHAP_HEADERLEN;           switch (code) {    case CHAP_CHALLENGE:tChapReceiveChallenge(cstate, inp, id, len);tbreak;        case CHAP_RESPONSE:tChapReceiveResponse(cstate, inp, id, len, linkunit);tbreak;        case CHAP_FAILURE:tChapReceiveFailure(cstate, inp, id, len);tbreak;    case CHAP_SUCCESS:tChapReceiveSuccess(cstate, inp, id, len);tbreak;    default:tttt tsyslog(LOG_WARNING, ""Unknown CHAP code (%d) received."", code);tbreak;    }}",2,"cwe119,cwe120"
"dv_assemble_frame(DVMuxContext *c, AVStream* st,                      uint8_t* data, int data_size, uint8_t** frame){    int i, reqasize;    *frame = &c->frame_buf[0];    reqasize = 4 * dv_audio_frame_size(c->sys, c->frames);    switch (st->codec->codec_type) {    case CODEC_TYPE_VIDEO:                 if (c->has_video)            av_log(st->codec, AV_LOG_ERROR, ""Can't process DV frame #%d. Insufficient audio data or severe sync problem."", c->frames);        memcpy(*frame, data, c->sys->frame_size);        c->has_video = 1;        break;    case CODEC_TYPE_AUDIO:        for (i = 0; i < c->n_ast && st != c->ast[i]; i++);                   if (av_fifo_size(&c->audio_data[i]) + data_size >= 100*AVCODEC_MAX_AUDIO_FRAME_SIZE)            av_log(st->codec, AV_LOG_ERROR, ""Can't process DV frame #%d. Insufficient video data or severe sync problem."", c->frames);        av_fifo_generic_write(&c->audio_data[i], data, data_size, NULL);                 c->has_audio |= ((reqasize <= av_fifo_size(&c->audio_data[i])) << i);        break;    default:        break;    }         if (c->has_video == 1 && c->has_audio + 1 == 1 << c->n_ast) {        dv_inject_metadata(c, *frame);        c->has_audio = 0;        for (i=0; i < c->n_ast; i++) {            dv_inject_audio(c, i, *frame);            av_fifo_drain(&c->audio_data[i], reqasize);            c->has_audio |= ((reqasize <= av_fifo_size(&c->audio_data[i])) << i);        }        c->has_video = 0;        c->frames++;        return c->sys->frame_size;    }    return 0;}",2,"cwe120,cweother"
"""gww_getline(unsigned char *buf, int sz, FILE *fp) {    int ch;    unsigned char *pt=buf;    while ((ch=getc(fp))!=EOF && ch!='' && ch!='r')t*pt++ = ch;    if ( ch=='r' ) {tif ((ch = getc(fp))!='' )t    ungetc(ch,fp);    }    *pt = '0';    if ( ch==EOF && pt==buf )return( 0 );return(1 );}""",2,"cwe120,cweother"
"chirp_client_getfile_buffer(struct chirp_client * c, const char *path, char **buffer, time_t stoptime){tINT64_T length;tINT64_T result;tchar safepath[CHIRP_LINE_MAX];turl_encode(path, safepath, sizeof(safepath));t*buffer = 0;tlength = simple_command(c, stoptime, ""getfile %s"", safepath);tif(length <= 0)ttreturn length;t*buffer = malloc(length + 1);tif(!*buffer) {ttc->broken = 1;tterrno = ENOMEM;ttreturn -1;t}tresult = link_read(c->link, *buffer, length, stoptime);tif(result < 0) {ttfree(*buffer);ttc->broken = 1;ttreturn -1;t}t(*buffer)[length] = 0;treturn result;}",2,"cwe119,cwe120"
"YMF271_sh_start( const struct MachineSound *msound )r{rtchar buf[2][40];rtconst char *name[2];rtint  vol[2];rtstruct YMF271interface *intf;rtint i;rrtintf = msound->sound_interface;rrtfor(i=0; i<intf->num; i++)rt{rttsprintf(buf[0], ""YMF271 %d L"", i);rttsprintf(buf[1], ""YMF271 %d R"", i);rttname[0] = buf[0];rttname[1] = buf[1];rttvol[0]=intf->mixing_level[i] >> 16;rttvol[1]=intf->mixing_level[i] & 0xffff;rttymf271_init(i, memory_region(intf->region[0]), intf->irq_callback[i]);rttstream_init_multi(2, name, vol, Machine->sample_rate, i, ymf271_pcm_update);rt}rrt tfor(i = 0; i < 256; i++)rttvolume[i] = 65536*pow(2.0, (-0.375/6)*i);rtfor(i = 256; i < 256*4; i++)rttvolume[i] = 0;rrtreturn 0;r}",3,"cwe119,cwe120,cweother"
"CheckIncludedText(char *p, int lines){    intti;    for (i = 0; ; p++) {tswitch (*p) {tcase '>':t    i++;t    break;tcase '|':t    i++;t    break;tcase ':':t    i++;t    break;tcase '<':t    i--;t    break;t}tif ((p = strchr(p, '')) == NULL)t    break;    }    if ((i * 2 > lines) && (lines > 40))        die(""more included text than new text"");}",2,"cwe120,cweother"
"""unquote(char *s) {tchar *o = s;twhile (*s) {ttif ((*s == '%') && s[1] && s[2]) {      guint a;      char xl[3]={*(s+1),*(s+2),0};      const char *t=xl;      xtoi(t, &a);ttt*o = a;ttts += 2;tt} else {ttt*o = *s;tt}tto++;tts++;t}t*o = '0';}""",3,"cwe119,cwe120,cweother"
"gmtmggpath_init (void) {tchar file[BUFSIZ], line[BUFSIZ];tFILE *fp = NULL;tGMT_getsharepath (""mgg"", ""gmtfile_paths"", """", file);tn_gmtmgg_paths = 0;tif ((fp = fopen (file, ""r"")) == NULL) {ttfprintf (stderr, ""GMT Warning: path file %s for *.gmt files not found"", file);ttfprintf (stderr, ""(Will only look in current directory for such files)"");ttreturn;t}twhile (fgets (line, BUFSIZ, fp)) {ttif (line[0] == '#') continue;t ttif (line[0] == ' ' || line[0] == '0') continue;t #ifdef WIN32ttDOS_path_fix (line);#endifttgmtmgg_path[n_gmtmgg_paths] = GMT_memory (VNULL, (size_t)1, (size_t)(strlen (line)), ""gmtmggpath_init"");ttline[strlen (line)-1] = 0;ttstrcpy (gmtmgg_path[n_gmtmgg_paths], line);ttn_gmtmgg_paths++;t}tfclose (fp);}",3,"cwe119,cwe120,cweother"
"criaCidade(int numPredios, ...) {tCidade cidade = malloc(sizeof(cidade));tPredio p;tint i;tva_list argp;tva_start(argp, numPredios);ttcidade->predios = malloc(numPredios*sizeof(Predio));tcidade->numPredios = numPredios;ttfor ( i = 0; i < numPredios; i++){ttcidade->predios[i] = va_arg(argp,Predio);t}ttva_end(argp);treturn cidade;}",2,"cwe120,cweother"
"kill_client_ll_serv_butone(struct Client *one, struct Client *source_p,                           const char *pattern, ...){  va_list args;  int have_uid = 0;  dlink_node *ptr = NULL;  char buf_uid[IRCD_BUFSIZE], buf_nick[IRCD_BUFSIZE];  int len_uid = 0, len_nick = 0;  if (HasID(source_p))  {    have_uid = 1;    va_start(args, pattern);    len_uid = ircsprintf(buf_uid, "":%s KILL %s :"", me.id, ID(source_p));    len_uid += send_format(&buf_uid[len_uid], IRCD_BUFSIZE - len_uid, pattern,                           args);    va_end(args);  }  va_start(args, pattern);  len_nick = ircsprintf(buf_nick, "":%s KILL %s :"", me.name, source_p->name);  len_nick += send_format(&buf_nick[len_nick], IRCD_BUFSIZE - len_nick, pattern,                          args);  va_end(args);  DLINK_FOREACH(ptr, serv_list.head)  {    struct Client *client_p = ptr->data;    if (one != NULL && (client_p == one->from))      continue;    if (IsDefunct(client_p))      continue;    if (have_uid && IsCapable(client_p, CAP_TS6))      send_message(client_p, buf_uid, len_uid);    else      send_message(client_p, buf_nick, len_nick);  }}",2,"cwe119,cwe120"
"new_network_connection(char *hostname, int port) {  Network_connection *result;  int sockfd = -1, ret = -1;  struct addrinfo req, *ans, *tmpaddr;  char name[NI_MAXHOST], portname[NI_MAXSERV];  memset(&req, 0, sizeof(req));  req.ai_flags = 0;  req.ai_family = AF_UNSPEC;  req.ai_socktype = SOCK_STREAM;  req.ai_protocol = IPPROTO_TCP;  if (getaddrinfo(hostname, NULL, &req, &ans) != 0) {    NETDEBUG(""getaddrinfo failed: %s"", strerror(errno));    return NULL;  }  tmpaddr = ans;  while (tmpaddr != NULL) {    ((struct sockaddr_in *) tmpaddr->ai_addr)->sin_port = htons(port);    getnameinfo(tmpaddr->ai_addr, tmpaddr->ai_addrlen,                name, sizeof(name), portname, sizeof(portname),                NI_NUMERICHOST | NI_NUMERICSERV);    NETDEBUG( ""Trying %s port %s..."", name, portname);    sockfd =      socket(tmpaddr->ai_family, tmpaddr->ai_socktype, tmpaddr->ai_protocol);    if (sockfd < 0) {      NETDEBUG(""socket failed: %s"", strerror(errno));    } else if ((ret = connect(sockfd, tmpaddr->ai_addr, tmpaddr->ai_addrlen))               < 0) {      NETDEBUG( ""connect failed: %s"", strerror(errno));    } else      break;    tmpaddr = tmpaddr->ai_next;  }  if (ret != 0 || sockfd < 0) {    freeaddrinfo(ans);    return NULL;  }  NETDEBUG(""succeeded"");  result = init_network_connection();  result->fd = sockfd;  freeaddrinfo(ans);  return result;}",2,"cwe119,cwe120"
"sgfAddPlay(SGFNode *node, int who, int movex, int movey){  char move[3];  SGFNode *new;       if (movex == -1 && movey == -1)    move[0] = 0;  else    sprintf(move, ""%c%c"", movey + 'a', movex + 'a');  if (node->child)    new = sgfStartVariantFirst(node->child);  else {    new = sgfNewNode();    node->child = new;    new->parent = node;  }    sgfAddProperty(new, (who == BLACK) ? ""B"" : ""W"", move);  return new;}",2,"cwe119,cwe120"
"DebugBinOut(char *buffer,int len,char *comment){ unsigned char *sp;  char buf[CF_BUFSIZE];  char hexStr[3];   if (len >= (sizeof(buf) / 2))      {   Debug(""Debug binary print is too large (len=%d)"", len);   return;   }memset(buf, 0, sizeof(buf));for (sp = buffer; sp < (unsigned char *)(buffer+len); sp++)   {   snprintf(hexStr, sizeof(hexStr), ""%2.2x"", (int)*sp);   strcat(buf, hexStr);   }CfOut(cf_verbose, """", ""BinaryBuffer(%d bytes => %s) -> [%s]"",len,comment,buf);}",2,"cwe119,cwe120"
"wcs_from_frame(struct ccd_frame *fr, struct wcs *wcs){tint w_ref_count;tdouble lat, lng;tint hla=0, hlo=0;tchar s[80];trescan_fits_wcs(fr, &fr->fim);tw_ref_count = wcs->ref_count;tif (fr->fim.wcsset != WCS_INVALID) {ttmemcpy(wcs, &(fr->fim), sizeof (struct wcs));t} else {ttwcs->wcsset = WCS_INVALID;ttwcs->xrefpix = fr->w / 2;ttwcs->yrefpix = fr->h / 2;tttry_wcs_from_frame_obs(fr, wcs);t}twcs->jd = frame_jdate(fr);tif (wcs->jd != 0.0) ttwcs->flags |= WCS_JD_VALID;telsettwcs->flags &= ~WCS_JD_VALID;tif (fits_get_double(fr, P_STR(FN_LATITUDE), &lat) > 0) {ttd1_printf(""using latitude = %.3f from %s"", ttt  lng, P_STR(FN_LATITUDE));tthla = 1;t} else if (fits_get_string(fr, P_STR(FN_LATITUDE), s, 79) > 0) {ttif (!dms_to_degrees(s, &lat)) {tttd1_printf(""using latitude = %.3f from %s"", tttt  lat, P_STR(FN_LATITUDE));ttthla = 1;tt}t}tif (fits_get_double(fr, P_STR(FN_LONGITUDE), &lng) > 0) {ttd1_printf(""using %s longitude = %.3f from %s"", ttt  P_INT(FILE_WESTERN_LONGITUDES) ? ""western"" : ""eastern"", ttt  lng, P_STR(FN_LONGITUDE));tthlo = 1;t} else if (fits_get_string(fr, P_STR(FN_LONGITUDE), s, 79) > 0) {ttif (!dms_to_degrees(s, &lng)) {tttd1_printf(""using %s longitude = %.3f from %s"", tttt  P_INT(FILE_WESTERN_LONGITUDES) ? ""western"" : ""eastern"", tttt  lng, P_STR(FN_LONGITUDE));ttthlo = 1;tt}t} tif (hlo) {ttif (!P_INT(FILE_WESTERN_LONGITUDES))tttlng = -lng;ttif (hla) {tttwcs->lng = lng;tttwcs->lat = lat;tttwcs->flags |= WCS_LOC_VALID;tt}t}twcs->ref_count = w_ref_count;}",3,"cwe119,cwe120,cweother"
"client_disconnect(){#ifdef NETWORK_ENABLEDtchar buf[128];ttif ( !client_is_connected ) return;tt tsocket_print_stats( &client );tsprintf( buf, _(""disconnected from %s""), tt net_addr_to_string(&client.remote_addr) );tclient_add_chatter( buf, 1 );tbuf[0] = MSG_DISCONNECT;tclient_transmit( CODE_BLUE, 1, buf );tclient_is_connected = 0;tclient_data_clear();tgui_label_set_text( label_channel, ""MAIN"" );#endif}",2,"cwe119,cwe120"
"count_command(char *command) {       char *s = command;   int argc;   int i,end;   char delimiter[2];   snprintf(delimiter, 2, ""%c"", 0xff);       argc = 1;       end =  strlen(command);   for(i = 0; i < end ; i++) {      if (s[i] == delimiter[0]) {         argc++;      }   }    return argc;}",2,"cwe119,cwe120"
"lam_perror(CONST char *umsg){tcharttemsgbuf[LAM_EMSGBUFLEN];tunintttl;tif ((umsg == 0) || (*umsg == '0')) {ttlam_errorstr(emsgbuf, LAM_EMSGBUFLEN - 1);ttstrcat(emsgbuf, """");t}telse {tt*emsgbuf = '0';ttl = strlen(umsg);ttstrncat(emsgbuf, umsg, LAM_EMSGBUFLEN - 2); ttif (l <= (LAM_EMSGBUFLEN - 5)) {tttstrcat(emsgbuf, "": "");tttlam_errorstr(emsgbuf + l + 2,ttttt(LAM_EMSGBUFLEN - (l + 2)) - 1);tt}ttstrcat(emsgbuf, """");t}twrite(2, emsgbuf, strlen(emsgbuf));}",2,"cwe119,cwe120"
"added_to_photoset_cb                    (GObject      *object,                                         GAsyncResult *res,                                         gpointer      user_data){  FspSession *session = FSP_SESSION (object);  GError *error = NULL;  gboolean result = FALSE;  result = fsp_session_add_to_photoset_finish (session, res, &error);  if (error != NULL)    {      g_print (""Error adding to photoset: %s"", error->message);      g_error_free (error);    }  else    {      g_print (""[added_to_photosets_cb]::Success! (%s)"",               result ? ""OK"" : ""FAIL"");             g_print (""Press ENTER to continue..."");      getchar ();             g_print (""Getting list of groups..."");      fsp_session_get_groups (session, NULL,                              get_groups_cb, NULL);    }}",2,"cwe120,cweother"
"read_config_files_in_path(const char *path, struct config_files *ctmp,                          int when, const char *perspath, const char *persfile){    int             done, j;    char            configfile[300];    char           *cptr1, *cptr2, *envconfpath;    struct stat     statbuf;    int             ret = SNMPERR_GENERR;    if ((NULL == path) || (NULL == ctmp))        return SNMPERR_GENERR;    envconfpath = strdup(path);    DEBUGMSGTL((""read_config:path"", "" config path used for %s:%s (persistent path:%s)"",                ctmp->fileHeader, envconfpath, perspath));    cptr1 = cptr2 = envconfpath;    done = 0;    while ((!done) && (*cptr2 != 0)) {        while (*cptr1 != 0 && *cptr1 != ENV_SEPARATOR_CHAR)            cptr1++;        if (*cptr1 == 0)            done = 1;        else            *cptr1 = 0;        DEBUGMSGTL((""read_config:dir"", "" config dir: %s"", cptr2 ));        if (stat(cptr2, &statbuf) != 0) {                         DEBUGMSGTL((""read_config:dir"", "" Directory not present: %s"", cptr2 ));            cptr2 = ++cptr1;            continue;        }#ifdef S_ISDIR        if (!S_ISDIR(statbuf.st_mode)) {                         DEBUGMSGTL((""read_config:dir"", "" Not a directory: %s"", cptr2 ));            cptr2 = ++cptr1;            continue;        }#endif                 if (strncmp(cptr2, perspath, strlen(perspath)) == 0 ||            (persfile != NULL &&             strncmp(cptr2, persfile, strlen(persfile)) == 0)) {            DEBUGMSGTL((""read_config:persist"", "" persist dir: %s"", cptr2 ));                         for (j = 0; j <= NETSNMP_MAX_PERSISTENT_BACKUPS; j++) {                snprintf(configfile, sizeof(configfile),                         ""%s/%s.%d.conf"", cptr2,                         ctmp->fileHeader, j);                configfile[ sizeof(configfile)-1 ] = 0;                if (stat(configfile, &statbuf) != 0) {                                         break;                } else {                                         DEBUGMSGTL((""read_config_files"",                                ""old config file found: %s, parsing"",                                configfile));                    if (read_config(configfile, ctmp->start, when) == SNMPERR_SUCCESS)                        ret = SNMPERR_SUCCESS;                }            }        }        snprintf(configfile, sizeof(configfile),                 ""%s/%s.conf"", cptr2, ctmp->fileHeader);        configfile[ sizeof(configfile)-1 ] = 0;        if (read_config(configfile, ctmp->start, when) == SNMPERR_SUCCESS)            ret = SNMPERR_SUCCESS;        snprintf(configfile, sizeof(configfile),                 ""%s/%s.local.conf"", cptr2, ctmp->fileHeader);        configfile[ sizeof(configfile)-1 ] = 0;        if (read_config(configfile, ctmp->start, when) == SNMPERR_SUCCESS)            ret = SNMPERR_SUCCESS;        if(done)            break;        cptr2 = ++cptr1;    }    SNMP_FREE(envconfpath);    return ret;}",2,"cwe119,cwe120"
"doio_send(isc__socket_t *sock, isc_socketevent_t *dev) {tint cc;tstruct iovec iov[MAXSCATTERGATHER_SEND];tsize_t write_count;tstruct msghdr msghdr;tchar addrbuf[ISC_SOCKADDR_FORMATSIZE];tint attempts = 0;tint send_errno;tchar strbuf[ISC_STRERRORSIZE];tbuild_msghdr_send(sock, dev, &msghdr, iov, &write_count); resend:tcc = sendmsg(sock->fd, &msghdr, 0);tsend_errno = errno;t tif (cc < 0) {ttif (send_errno == EINTR && ++attempts < NRETRIES)tttgoto resend;ttif (SOFT_ERROR(send_errno))tttreturn (DOIO_SOFT);#define SOFT_OR_HARD(_system, _isc) tif (send_errno == _system) { ttif (sock->connected) { tttdev->result = _isc; tttinc_stats(sock->manager->stats, tttt  sock->statsindex[STATID_SENDFAIL]); tttreturn (DOIO_HARD); tt} ttreturn (DOIO_SOFT); t}#define ALWAYS_HARD(_system, _isc) tif (send_errno == _system) { ttdev->result = _isc; ttinc_stats(sock->manager->stats, ttt  sock->statsindex[STATID_SENDFAIL]); ttreturn (DOIO_HARD); t}ttSOFT_OR_HARD(ECONNREFUSED, ISC_R_CONNREFUSED);ttALWAYS_HARD(EACCES, ISC_R_NOPERM);ttALWAYS_HARD(EAFNOSUPPORT, ISC_R_ADDRNOTAVAIL);ttALWAYS_HARD(EADDRNOTAVAIL, ISC_R_ADDRNOTAVAIL);ttALWAYS_HARD(EHOSTUNREACH, ISC_R_HOSTUNREACH);#ifdef EHOSTDOWNttALWAYS_HARD(EHOSTDOWN, ISC_R_HOSTUNREACH);#endifttALWAYS_HARD(ENETUNREACH, ISC_R_NETUNREACH);ttALWAYS_HARD(ENOBUFS, ISC_R_NORESOURCES);ttALWAYS_HARD(EPERM, ISC_R_HOSTUNREACH);ttALWAYS_HARD(EPIPE, ISC_R_NOTCONNECTED);ttALWAYS_HARD(ECONNRESET, ISC_R_CONNECTIONRESET);#undef SOFT_OR_HARD#undef ALWAYS_HARDtt ttisc_sockaddr_format(&dev->address, addrbuf, sizeof(addrbuf));ttisc__strerror(send_errno, strbuf, sizeof(strbuf));ttUNEXPECTED_ERROR(__FILE__, __LINE__, ""internal_send: %s: %s"",tttt addrbuf, strbuf);ttdev->result = isc__errno2result(send_errno);ttinc_stats(sock->manager->stats,ttt  sock->statsindex[STATID_SENDFAIL]);ttreturn (DOIO_HARD);t}tif (cc == 0) {ttinc_stats(sock->manager->stats,ttt  sock->statsindex[STATID_SENDFAIL]);ttUNEXPECTED_ERROR(__FILE__, __LINE__,tttt ""doio_send: send() %s 0"",tttt isc_msgcat_get(isc_msgcat, ISC_MSGSET_GENERAL,ttttttISC_MSG_RETURNED, ""returned""));t}t tdev->n += cc;tif ((size_t)cc != write_count)ttreturn (DOIO_SOFT);t tdev->result = ISC_R_SUCCESS;treturn (DOIO_SUCCESS);}",2,"cwe119,cwe120"
"ipmi_expect(struct ipmi *ipmi, struct Etoken *toklist, int timeout){tint ret;tchar buf[32768];  tdbg_printf(ipmi, 3, ""Looking for: "");tfor (ret = 0; toklist[ret].string; ret++) {ttdbg_printf(ipmi, 3, ""    '%s', val = %d"",ttt   toklist[ret].string,ttt   toklist[ret].toktype);t}tret = ExpectToken(ipmi->i_rdfd, toklist, timeout, buf, sizeof(buf));tdbg_printf(ipmi, 3, ""ExpectToken returned %d"", ret);tif (ret == -1) {ttret = errno;ttdbg_printf(ipmi, 3, ""ExpectToken failed.  Info returned:"");ttdbg_printf(ipmi, 3, "">>>>>%s<<<<<Error = %d (%s)"",ttt   buf,ttt   ret,ttt   strerror(ret));t}treturn ret;}",2,"cwe119,cwe120"
"globus_l_gram_audit_get_username(    char **                             username){    struct passwd                       pwd;    struct passwd *                     res;    int                                 rc;    char                                buffer[128];    rc = globus_libc_getpwuid_r(            getuid(),            &pwd,            buffer,            sizeof(buffer),            &res);    if (rc != 0 || res == NULL)    {        rc = GLOBUS_GRAM_PROTOCOL_ERROR_NO_RESOURCES;        goto out;    }    *username = strdup(pwd.pw_name);    if (*username == NULL)    {        rc = GLOBUS_GRAM_PROTOCOL_ERROR_MALLOC_FAILED;        goto out;    }out:    return rc;}",2,"cwe119,cwe120"
"get_mem_procfs(memory_ext *me){    int fd, nread;    char buffer[4097];    char *bp;    unsigned long value;        me->flag = 0;        if ( (fd = open(MEMINFO, O_RDONLY)) < 0) return -1;    if ( (nread = read(fd, buffer, 4096)) < 0) {        close(fd);treturn -1;    }    close(fd);    buffer[nread] = '0';                 bp = strstr(buffer, ""MemTotal:"");        if (bp != NULL && sscanf(bp, ""MemTotal: %lu kB"", &(me->total)))  me->flag |= F_MEM_TOTAL;    bp = strstr(buffer, ""MemFree:"");        if (bp != NULL && sscanf(bp, ""MemFree: %lu kB"", &(me->free)))    me->flag |= F_MEM_FREE;                 bp = strstr(buffer, ""Buffers:"");        if (bp != NULL && sscanf(bp, ""Buffers: %lu kB"", &(me->buffered))) me->flag |= F_MEM_BUFFERS;        bp = strstr(buffer, ""Cached:"");        if (bp != NULL && sscanf(bp, ""Cached: %lu kB"", &(me->cached)))   me->flag |= F_MEM_CACHED;                 bp = strstr(buffer, ""SwapTotal:"");        if (bp != NULL && sscanf(bp, ""SwapTotal: %lu kB"", &(me->total_swap))) me->flag |= F_SWAP_TOTAL;        bp = strstr(buffer, ""SwapFree:"");        if (bp != NULL && sscanf(bp, ""SwapFree: %lu kB"", &(me->free_swap))) me->flag |= F_SWAP_FREE;        me->pagesize = 1024;          return 1;   }",3,"cwe119,cwe120,cweother"
"shell_command(char *cmd){tFILE *pipe;tchar buf[BUFSIZE];tif ((pipe = popen(cmd, ""r"")) == NULL) {tterror(INFO, ""cannot open pipe: %s"", cmd);ttpc->redirect &= ~REDIRECT_SHELL_COMMAND;                pc->redirect |= REDIRECT_FAILURE;                return REDIRECT_FAILURE;        }        while (fgets(buf, BUFSIZE, pipe))ttfputs(buf, fp);        pclose(pipe);treturn REDIRECT_SHELL_COMMAND;}",3,"cwe119,cwe120,cweother"
"pyramid_init(Driver *drvthis){    char buffer[MAXCOUNT];    int i;    PrivateData *p;         p = (PrivateData *) malloc(sizeof(PrivateData));    if ((p == NULL) || (drvthis->store_private_ptr(drvthis, p) < 0)) {treport(RPT_ERR, ""%s: error allocating memory for modules private data"", drvthis->name);treturn -1;    }         p->width = WIDTH;    p->height = HEIGHT;    p->customchars = CUSTOMCHARS;    p->cellwidth = CELLWIDTH;    p->cellheight = CELLHEIGHT;    p->ccmode = standard;    memset(p->framebuffer, ' ', SCREEN_SIZE);    memset(p->backingstore, ' ', SCREEN_SIZE);    strcpy(p->last_key_pressed, NOKEY);    p->last_key_time = timestamp(p);    p->timeout.tv_sec = 0;    p->timeout.tv_usec = MICROTIMEOUT;              strncpy(p->device, drvthis->config_get_string(drvthis->name, ""Device"", 0, ""/dev/lcd""), sizeof(p->device));    p->device[sizeof(p->device) - 1] = '0';    report(RPT_INFO, ""%s: using Device %s"", drvthis->name, p->device);              p->FD = open(p->device, O_RDWR);    if (p->FD == -1) {treport(RPT_ERR, ""%s: open(%s) failed: %s"", drvthis->name, p->device, strerror(errno));treturn -1;    }    if (initTTY(drvthis, p->FD) != 0)treturn -1;         tcflush(p->FD, TCIFLUSH);t     while (1) {ti = read_tele(p, buffer);tif (i == True)t    send_ACK(p);telset    break;tusleep(600000);    }         send_tele(p, ""R"");    send_tele(p, ""C0101"");    send_tele(p, ""D                                "");    send_tele(p, ""C0101"");    send_tele(p, ""M3"");         for (i = 0; i < 7; i++)tp->led[i] = -1;         pyramid_output(drvthis, 0);t     for (i = 0; i < 7; i++) {tpyramid_output(drvthis, 1 << i);tusleep(10000);    }    for (i = 6; i >= 0; i--) {tpyramid_output(drvthis, 1 << i);tusleep(10000);    }    pyramid_output(drvthis, 0);    report(RPT_DEBUG, ""%s: init() done"", drvthis->name);    return 0;}",3,"cwe119,cwe120,cweother"
"test_read_valid_wireless_connection (void){tNMConnection *connection;tNMSettingConnection *s_con;tNMSettingWireless *s_wireless;tNMSettingIP4Config *s_ip4;tGError *error = NULL;tconst GByteArray *array;tchar expected_bssid[ETH_ALEN] = { 0x00, 0x1a, 0x33, 0x44, 0x99, 0x82 };tconst char *tmp;tconst char *expected_id = ""Test Wireless Connection"";tconst char *expected_uuid = ""2f962388-e5f3-45af-a62c-ac220b8f7baa"";tconst guint64 expected_timestamp = 1226604314;tguint64 timestamp;tconnection = nm_keyfile_plugin_connection_from_file (TEST_WIRELESS_FILE, NULL);tASSERT (connection != NULL,ttt""connection-read"", ""failed to read %s"", TEST_WIRELESS_FILE);tASSERT (nm_connection_verify (connection, &error),t        ""connection-verify"", ""failed to verify %s: %s"", TEST_WIRELESS_FILE, error->message);t ts_con = nm_connection_get_setting_connection (connection);tASSERT (s_con != NULL,t        ""connection-verify-connection"", ""failed to verify %s: missing %s setting"",t        TEST_WIRELESS_FILE,t        NM_SETTING_CONNECTION_SETTING_NAME);t ttmp = nm_setting_connection_get_id (s_con);tASSERT (tmp != NULL,t        ""connection-verify-connection"", ""failed to verify %s: missing %s / %s key"",t        TEST_WIRELESS_FILE,t        NM_SETTING_CONNECTION_SETTING_NAME,t        NM_SETTING_CONNECTION_ID);tASSERT (strcmp (tmp, expected_id) == 0,t        ""connection-verify-connection"", ""failed to verify %s: unexpected %s / %s key value"",t        TEST_WIRELESS_FILE,t        NM_SETTING_CONNECTION_SETTING_NAME,t        NM_SETTING_CONNECTION_ID);t ttmp = nm_setting_connection_get_uuid (s_con);tASSERT (tmp != NULL,t        ""connection-verify-connection"", ""failed to verify %s: missing %s / %s key"",t        TEST_WIRELESS_FILE,t        NM_SETTING_CONNECTION_SETTING_NAME,t        NM_SETTING_CONNECTION_UUID);tASSERT (strcmp (tmp, expected_uuid) == 0,t        ""connection-verify-connection"", ""failed to verify %s: unexpected %s / %s key value"",t        TEST_WIRELESS_FILE,t        NM_SETTING_CONNECTION_SETTING_NAME,t        NM_SETTING_CONNECTION_UUID);t ttimestamp = nm_setting_connection_get_timestamp (s_con);tASSERT (timestamp == expected_timestamp,t        ""connection-verify-connection"", ""failed to verify %s: unexpected %s /%s key value"",t        TEST_WIRELESS_FILE,t        NM_SETTING_CONNECTION_SETTING_NAME,t        NM_SETTING_CONNECTION_TIMESTAMP);t tASSERT (nm_setting_connection_get_autoconnect (s_con) == FALSE,t        ""connection-verify-connection"", ""failed to verify %s: unexpected %s /%s key value"",t        TEST_WIRELESS_FILE,t        NM_SETTING_CONNECTION_SETTING_NAME,t        NM_SETTING_CONNECTION_AUTOCONNECT);t ts_wireless = nm_connection_get_setting_wireless (connection);tASSERT (s_wireless != NULL,t        ""connection-verify-wireless"", ""failed to verify %s: missing %s setting"",t        TEST_WIRELESS_FILE,t        NM_SETTING_WIRED_SETTING_NAME);t tarray = nm_setting_wireless_get_bssid (s_wireless);tASSERT (array != NULL,t        ""connection-verify-wireless"", ""failed to verify %s: missing %s / %s key"",t        TEST_WIRELESS_FILE,t        NM_SETTING_WIRELESS_SETTING_NAME,t        NM_SETTING_WIRELESS_BSSID);tASSERT (array->len == ETH_ALEN,t        ""connection-verify-wireless"", ""failed to verify %s: unexpected %s / %s key value length"",t        TEST_WIRELESS_FILE,t        NM_SETTING_WIRELESS_SETTING_NAME,t        NM_SETTING_WIRELESS_BSSID);tASSERT (memcmp (array->data, &expected_bssid[0], sizeof (expected_bssid)) == 0,t        ""connection-verify-wireless"", ""failed to verify %s: unexpected %s / %s key value"",t        TEST_WIRELESS_FILE,t        NM_SETTING_WIRELESS_SETTING_NAME,t        NM_SETTING_WIRELESS_BSSID);t ts_ip4 = nm_connection_get_setting_ip4_config (connection);tASSERT (s_ip4 != NULL,t        ""connection-verify-ip4"", ""failed to verify %s: missing %s setting"",t        TEST_WIRELESS_FILE,t        NM_SETTING_IP4_CONFIG_SETTING_NAME);t ttmp = nm_setting_ip4_config_get_method (s_ip4);tASSERT (strcmp (tmp, NM_SETTING_IP4_CONFIG_METHOD_AUTO) == 0,t        ""connection-verify-wireless"", ""failed to verify %s: unexpected %s / %s key value"",t        TEST_WIRELESS_FILE,t        NM_SETTING_IP4_CONFIG_SETTING_NAME,t        NM_SETTING_IP4_CONFIG_METHOD);tg_object_unref (connection);}",5,"cwe119,cwe120,cwe476,cwe469,cweother"
"lkid_devno_to_wholedisk(dev_t dev, char *diskname,tttsize_t len, dev_t *diskdevno){tstruct sysfs_cxt cxt;tint is_part = 0;tif (!dev || sysfs_init(&cxt, dev, NULL) != 0)ttreturn -1;tis_part = sysfs_has_attribute(&cxt, ""partition"");tif (!is_part) {tt ttchar *uuid = sysfs_strdup(&cxt, ""dm/uuid"");ttchar *tmp = uuid;ttchar *prefix = uuid ? strsep(&tmp, ""-"") : NULL;ttif (prefix && strncasecmp(prefix, ""part"", 4) == 0)tttis_part = 1;ttfree(uuid);ttif (is_part &&tt    get_dm_wholedisk(&cxt, diskname, len, diskdevno) == 0)ttt tttgoto done;ttis_part = 0;t}tif (!is_part) {tt ttif (diskname && len) {tttif (!sysfs_get_devname(&cxt, diskname, len))ttttgoto err;tt}ttif (diskdevno)ttt*diskdevno = dev;t} else {tt ttchar linkpath[PATH_MAX];ttchar *name;ttint linklen;ttlinklen = sysfs_readlink(&cxt, NULL,ttttlinkpath, sizeof(linkpath) - 1);ttif (linklen < 0)tttgoto err;ttlinkpath[linklen] = '0';ttstripoff_last_component(linkpath);tt ttname = stripoff_last_component(linkpath);t ttif (!name)tttgoto err;ttif (diskname && len) {tttstrncpy(diskname, name, len);tttdiskname[len - 1] = '0';tt}ttif (diskdevno) {ttt*diskdevno = sysfs_devname_to_devno(name, NULL);tttif (!*diskdevno)ttttgoto err;tt}t}done:tsysfs_deinit(&cxt);tDBG(DEBUG_DEVNO,t    printf(""found entire diskname for devno 0x%04llx %s"",t    (long long) dev, diskname ? diskname : """"));treturn 0;err:tsysfs_deinit(&cxt);tDBG(DEBUG_DEVNO,t    printf(""failed to convert 0x%04llx to wholedisk name, errno=%d"",t    (long long) dev, errno));treturn -1;}",2,"cwe119,cwe120"
"main(int argc, char **argv) {  if (argc > 2) return usage(argv[0]);  unsigned long portnum;  if (argc == 2) {    char *endptr;    portnum = strtoul(argv[1], &endptr, 10);    if (*endptr) {      fprintf(stderr, ""Not a valid number: %s"", argv[1]);      return usage(argv[0]);    }    if (portnum < 1 || portnum > 65535) {      fprintf(stderr, ""Not a valid port number (1..65535): %d"", (int) portnum);      return usage(argv[0]);    }  } else {    portnum = 443;  }  char output[512];  const int r = obstcp_advert_base32_create(output, sizeof(output), NULL,                                            OBSTCP_ADVERT_TLSPORT, (int) portnum,                                            OBSTCP_ADVERT_END);  if (r >= sizeof(output)) {    fprintf(stderr, ""Advert too large"");    return 1;  } else if (r < 0) {    perror(""Error creating advert"");    return 1;  }  output[r] = 0;  fprintf(stderr, ""Port: %d"", (int) portnum);  fprintf(stderr, ""Advert: %s"", output);  char dnsadvert[512];  if (obstcp_advert_cname_encode_sz(r) > sizeof(dnsadvert)) {    fprintf(stderr, ""Cannot print DNS advert"");  } else {    obstcp_advert_cname_encode(dnsadvert, output, r);    dnsadvert[obstcp_advert_cname_encode_sz(r)] = 0;    fprintf(stderr, ""DNS Advert: %s"", dnsadvert);  }  return 0;}",2,"cwe119,cwe120"
"fs_tlist_print(fs_tlist *l, FILE *out, int verbosity){    if (!l) {        fprintf(out, ""NULL list"");        return;    }    fprintf(out, ""list of %ld entries"", (long int)(l->offset + l->buffer_pos));    if (l->buffer_pos) {        fprintf(out, ""   (%d buffered)"", l->buffer_pos);    }    if (verbosity > 0) {        char buffer[WIDTH];        lseek(l->fd, sizeof(struct tlist_header), SEEK_SET);        for (int i=0; i<l->offset; i++) {            memset(buffer, 0, WIDTH);            int ret = read(l->fd, buffer, WIDTH);            if (ret == -1) {                fs_error(LOG_ERR, ""error reading entry %d from list: %s"", i, strerror(errno));            } else if (ret != WIDTH) {                fs_error(LOG_ERR, ""error reading entry %d from list, got %d bytes instead of %zd"", i, ret, WIDTH);            }            volatile fs_rid *row = (fs_rid *)buffer;            printf(""%08x"", i);            for (int j=0; j<WIDTH / sizeof(fs_rid); j++) {                printf("" %016llx"", row[j]);            }            printf("""");        }    }}",3,"cwe119,cwe120,cweother"
"add_to_blob_aligned (MonoAotCompile *acfg, const guint8 *data, guint32 data_len, guint32 align){tchar buf [4] = {0};tguint32 count;tif (acfg->blob.alloc_size == 0)ttstream_init (&acfg->blob);tcount = acfg->blob.index % align;t tif (count)ttadd_stream_data (&acfg->blob, buf, 4 - count);treturn add_stream_data (&acfg->blob, (char*)data, data_len);}",2,"cwe119,cwe120"
"main(int argc, char** argv){tinttpriority; tchar*tentity = NULL;tinttc;tchartbuf[BUFSIZE];tconst char* logtype = ""ha-log"";ttwhile (( c =getopt(argc, argv,""t:D:h"")) != -1){ttswitch(c){tttttcase 't':tttentity = optarg;tttbreak;ttcase 'D':tttlogtype=optarg;tttbreak;ttcase 'h':tttusage();tttexit(1);ttttdefault:tttusage();tttexit(1);tt}ttt}tif(!cl_log_test_logd()){ttfprintf(stderr, ""logd is not running"");ttreturn EXIT_FAIL;t}ttargc -=optind;targv += optind;tttif (entity != NULL){ttcl_log_set_entity(entity);ttt}ttif (strcmp(logtype, ""ha-log"") == 0){ttpriority = LOG_INFO;t} else if (strcmp(logtype, ""ha-debug"") == 0){ttpriority = LOG_DEBUG;t}else{ttgoto err_exit;t}tttif (argc > 0){ttregister char *p;ttfor (p = *argv; *argv; argv++, p = *argv) {tttwhile (strlen(p) > BUFSIZE-1) {ttttmemcpy(buf, p, BUFSIZE-1);tttt*(buf+BUFSIZE-1) = '0';ttttif (LogToDaemon(priority,buf,ttttttBUFSIZE,FALSE) != HA_OK){tttttreturn EXIT_FAIL;tttt}ttttp += BUFSIZE-1;ttt}tttif (LogToDaemon(priority,p,tttttstrnlen(p, BUFSIZE),FALSE) != HA_OK){ttttreturn EXIT_FAIL;ttt}tt}ttreturn EXIT_OK;t}else {ttwhile (fgets(buf, sizeof(buf), stdin) != NULL) {ttt tttint len = strlen(buf);ttttttif (len > 0 && buf[len - 1] == '')ttttbuf[len - 1] = '0';ttttttif (LogToDaemon(priority, buf,strlen(buf), FALSE) == HA_OK){ttttcontinue;ttt}else {ttttreturn EXIT_FAIL;ttt}tt}ttttreturn EXIT_OK;t}t err_exit:tusage();treturn(1);}",3,"cwe119,cwe120,cweother"
"iax_unregister(struct iax_session *session, const char *server, const char *peer, const char *secret, const char *reason){t tchar tmp[256];tchar *p;tint portno = IAX_DEFAULT_PORTNO;tstruct iax_ie_data ied;tstruct hostent *hp;ttmp[255] = '0';tstrncpy(tmp, server, sizeof(tmp) - 1);tp = strchr(tmp, ':');tif (p) {tt*p = '0';ttportno = atoi(p+1);t}tmemset(&ied, 0, sizeof(ied));tif (secret)ttstrncpy(session->secret, secret, sizeof(session->secret) - 1);telsettstrcpy(session->secret, """");tif (reason && strlen(reason))ttstrncpy(session->unregreason, reason, sizeof(session->unregreason) - 1);telsettstrcpy(session->unregreason, ""Unspecified"");t thp = gethostbyname(tmp);tif (!hp) {ttsnprintf(iax_errstr, sizeof(iax_errstr), ""Invalid hostname: %s"", tmp);ttreturn -1;t}tmemcpy(&session->peeraddr.sin_addr, hp->h_addr, sizeof(session->peeraddr.sin_addr));tsession->peeraddr.sin_port = htons(portno);tsession->peeraddr.sin_family = AF_INET;tstrncpy(session->username, peer, sizeof(session->username) - 1);tiax_ie_append_str(&ied, IAX_IE_USERNAME, peer);tiax_ie_append_str(&ied, IAX_IE_CAUSE, session->unregreason);treturn send_command(session, AST_FRAME_IAX, IAX_COMMAND_REGREL, 0, ied.buf, ied.pos, -1);}",3,"cwe119,cwe120,cweother"
"_tinytest_set_flag(struct testgroup_t *groups, const char *arg, unsigned long flag){tint i, j;tint length = LONGEST_TEST_NAME;tchar fullname[LONGEST_TEST_NAME];tint found=0;tif (strstr(arg, ""..""))ttlength = strstr(arg,"".."")-arg;tfor (i=0; groups[i].prefix; ++i) {ttfor (j=0; groups[i].cases[j].name; ++j) {tttevutil_snprintf(fullname, sizeof(fullname), ""%s%s"",tttt groups[i].prefix, groups[i].cases[j].name);tttif (!flag)  ttttprintf(""    %s"", fullname);tttif (!strncmp(fullname, arg, length)) {ttttgroups[i].cases[j].flags |= flag;tttt++found;ttt}tt}t}treturn found;}",2,"cwe119,cwe120"
"""pico_is_good_color(char *s){    struct color_table *ct;    struct color_name_list *nl;    int done;    if(!s || !color_tbl)      return(FALSE);    if(!strcmp(s, END_PSEUDO_REVERSE))      return(TRUE);    else if(!struncmp(s, MATCH_NORM_COLOR, RGBLEN) || !struncmp(s, MATCH_NONE_COLOR, RGBLEN))      return(TRUE);    else if(*s == ' ' || isdigit(*s)){t/* check for rgb string instead of name */tfor(ct = color_tbl; ct->rgb; ct++)t  if(!strncmp(ct->rgb, s, RGBLEN))t    break;t/* if no match it's still ok if rgb */tif(!ct->rgb){t    int r = -1, g = -1, b = -1;t    char *p, *comma, scopy[RGBLEN+1];t    strncpy(scopy, s, sizeof(scopy));t    scopy[sizeof(scopy)-1] = '0';t    p = scopy;t    comma = strchr(p, ',');t    if(comma){t      *comma = '0';t      r = atoi(p);t      p = comma+1;t      if(r >= 0 && r <= 255 && *p){ttcomma = strchr(p, ',');ttif(comma){tt  *comma = '0';tt  g = atoi(p);tt  p = comma+1;tt  if(g >= 0 && g <= 255 && *p){tt    b = atoi(p);tt  }tt}t      }t    }t    if(r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255)t      ct = color_tbl;t/* to force TRUE */t}    }    else{tfor(done=0, ct = color_tbl; !done && ct->names; ct++){t  for(nl = ct->names; !done && nl; nl = nl->next)t    if(nl->name && !struncmp(nl->name, s, nl->namelen))t      done++;t  t  if(done)t    break;t}    }        return(ct->names ? TRUE : FALSE);}""",4,"cwe119,cwe120,cwe476,cweother"
"crut_help(FILE *stream){    int i;    fprintf(stream, ""%s"", crut_usage_message);    fprintf(stream, ""Tests available:"");    for (i = 0; i < CRUT_MAX_TESTS && crut_tests[i].test_name[0] != '0'; ++i) {tfprintf(stream, ""  %s: %s"", crut_tests[i].test_name, crut_tests[i].test_description);    }    fprintf(stream, ""Submit bugs to http://mantis.lbl.gov/bugzilla"");}",2,"cwe119,cwe120"
"check_detectedlink(t_hts_callbackarg * carg, httrackp * opt,                              char *link) {  const char *base = (char *) CALLBACKARG_USERDEF(carg);     if (CALLBACKARG_PREV_FUN(carg, linkdetected) != NULL) {    if (!CALLBACKARG_PREV_FUN(carg, linkdetected)        (CALLBACKARG_PREV_CARG(carg), opt, link)) {      return 0;                      }  }     if (strncmp(link, ""http://"", 7) == 0 || strncmp(link, ""https://"", 8) == 0) {    char temp[HTS_URLMAXSIZE * 2];    strcpy(temp, base);    strcat(temp, link);    strcpy(link, temp);  }  return 1;                      }",2,"cwe119,cwe120"
"checkRef(IntegrityCk *pCheck, int iPage, char *zContext){  if( iPage==0 ) return 1;  if( iPage>pCheck->nPage || iPage<0 ){    char zBuf[100];    sprintf(zBuf, ""invalid page number %d"", iPage);    checkAppendMsg(pCheck, zContext, zBuf);    return 1;  }  if( pCheck->anRef[iPage]==1 ){    char zBuf[100];    sprintf(zBuf, ""2nd reference to page %d"", iPage);    checkAppendMsg(pCheck, zContext, zBuf);    return 1;  }  return  (pCheck->anRef[iPage]++)>1;}",2,"cwe119,cwe120"
"OpVerifyProcess(){   cid_verifyprocess_it out ;   cid_verifyprocess_ot in ;      status=system(""clear"") ;   printf(""CID_OP_VERIFY_PROCESS"") ;   printf(""---------------------"") ;tttt    printf(""Enter login : "") ;   status=scanf(""%s"", out.login) ;   getchar() ;   printf(""Enter rlogin : "") ;   status=scanf(""%s"", out.rlogin) ;   getchar() ;   printf(""Enter path : "") ;   status=scanf(""%s"", out.path) ;tttt    printf(""To CID :"") ;   printf(""login : %s"", out.login) ;   printf(""rlogin : %s"", out.rlogin) ;   printf(""path : %s"", out.path) ;tttt    if (!writen(cidsock, (char *)&out, sizeof(out)))    {       printf(""OpVerifyProcess::writen"") ;       getchar() ; getchar() ;       return ;    }   if (!readn(cidsock, (char *)&in, sizeof(in)))    {       printf(""OpVerifyProcess::readn"") ;       getchar() ; getchar() ;       return ;    }tttt    printf(""From CID :"") ;   printf(""status : %d"", ntohs(in.status)) ;   printf(""error : %d"", ntohs(in.error)) ;   getchar() ; getchar() ;}",2,"cwe120,cweother"
"ptys_open(int fdm, char *pts_name){   int      fds;       if ((fds = open(pts_name, O_RDWR)) < 0) {      close(fdm);      return -5;   }#if defined(SOLARIS64) || defined(SOLARIS86) || defined(SOLARISAMD64) || defined(HP11) || defined(HP1164) || defined(IRIX65)   if (ioctl(fds, I_PUSH, ""ptem"") < 0) {      close(fdm);      close(fds);      return -6;   }   if (ioctl(fds, I_PUSH, ""ldterm"") < 0) {      close(fdm);      close(fds);      return -7;   }#if !defined(HP11) && !defined(HP1164) && !defined(IRIX65)   if (ioctl(fds, I_PUSH, ""ttcompat"") < 0) {      close(fdm);      close(fds);      return -8;   }#endif#endif   return fds;}",3,"cwe119,cwe120,cweother"
"draw_field(struct state *st, struct field * f){    unsigned int x, y;    unsigned int rx, ry = 0;t     unsigned int size = 1 << f->cell_size;    unsigned int mask = size - 1;    unsigned int fg_count, bg_count;         for (y = 1; y < f->height - 1; y++) {tfg_count = 0;tbg_count = 0;t tfor (x = 1; x < f->width - 1; x++) {t    rx = random();t    ry = rx >> f->cell_size;t    rx &= mask;t    ry &= mask;t    if (*cell_at(f, x, y)) {ttst->fg_points[fg_count].x = (short) x *size - rx - 1;ttst->fg_points[fg_count].y = (short) y *size - ry - 1;ttfg_count++;t    } else {ttst->bg_points[bg_count].x = (short) x *size - rx - 1;ttst->bg_points[bg_count].y = (short) y *size - ry - 1;ttbg_count++;t    }t}tXDrawPoints(st->dpy, st->window, st->fgc, st->fg_points, fg_count,tt    CoordModeOrigin);tXDrawPoints(st->dpy, st->window, st->bgc, st->bg_points, bg_count,tt    CoordModeOrigin);    }}",2,"cwe120,cweother"
"BytesNormal(iconv_t latin1_2_unicode) {#ifdef UNICHAR_16    union {tshort s;tchar c[2];    } u[8];#else    union {tint32 s;tchar c[4];    } u[8];#endif    char *from = ""A"", *to = &u[0].c[0];    size_t in_left = 1, out_left = sizeof(u);    memset(u,0,sizeof(u));    iconv( latin1_2_unicode, (iconv_arg2_t) &from, &in_left, &to, &out_left);    if ( u[0].s=='A' )return( true );return( false );}",2,"cwe119,cwe120"
"read_map_log(void) {    FILE *fp;    mapstruct *map;    char buf[MAX_BUF];    int do_los, darkness, lock;    long sec = seconds();    snprintf(buf, sizeof(buf), ""%s/temp.maps"", settings.localdir);    if (!(fp = fopen(buf, ""r""))) {        LOG(llevDebug, ""Could not open %s for reading"", buf);        return;    }    while (fgets(buf, MAX_BUF, fp) != NULL) {        char *tmp[3];        map = get_linked_map();                 if (split_string(buf, tmp, sizeof(tmp)/sizeof(*tmp), ':') != 3) {            LOG(llevDebug, ""%s/temp.maps: ignoring invalid line: %s"", settings.localdir, buf);            continue;        }        strcpy(map->path, tmp[0]);        map->tmpname = strdup_local(tmp[1]);                 sscanf(tmp[2], ""%u:%d:%d:%hu:%d:%d"", &map->reset_time, &lock, &lock, &map->difficulty, &do_los, &darkness);        map->in_memory = MAP_SWAPPED;        map->darkness = darkness;        map->timeout = 0;                 map->reset_time += sec;        if (map->reset_time > (sec+MAP_MAXRESET))            map->reset_time = 0;    }    fclose(fp);}",3,"cwe119,cwe120,cweother"
"""usbat_flash_write_data(struct us_data *us,tttttttt  struct usbat_info *info,tttttttt  u32 sector,tttttttt  u32 sectors){tunsigned char registers[7] = {ttUSBAT_ATA_FEATURES,ttUSBAT_ATA_SECCNT,ttUSBAT_ATA_SECNUM,ttUSBAT_ATA_LBA_ME,ttUSBAT_ATA_LBA_HI,ttUSBAT_ATA_DEVICE,ttUSBAT_ATA_STATUS,t};tunsigned char command[7];tunsigned char *buffer;tunsigned char  thistime;tunsigned int totallen, alloclen;tint len, result;tunsigned int sg_offset = 0;tstruct scatterlist *sg = NULL;tresult = usbat_flash_check_media(us, info);tif (result != USB_STOR_TRANSPORT_GOOD)ttreturn result;t/*t * we're working in LBA mode.  according to the ATA spec,t * we can support up to 28-bit addressing.  I don't know if the devicet * supports beyond 24-bit addressing.  It's kind of hard to testt * since it requires > 8GB media.t */tif (sector > 0x0FFFFFFF)ttreturn USB_STOR_TRANSPORT_ERROR;ttotallen = sectors * info->ssize;t/*t * Since we don't write more than 64 KB at a time, we have to createt * a bounce buffer and move the data a piece at a time between thet * bounce buffer and the actual transfer buffer.t */talloclen = min(totallen, 65536u);tbuffer = kmalloc(alloclen, GFP_NOIO);tif (buffer == NULL)ttreturn USB_STOR_TRANSPORT_ERROR;tdo {tt/*tt * loop, never allocate or transfer more than 64k at oncett * (min(128k, 255*info->ssize) is the real limit)tt */ttlen = min(totallen, alloclen);ttthistime = (len / info->ssize) & 0xff;tt/* Get the data from the transfer buffer */ttusb_stor_access_xfer_buf(buffer, len, us->srb,ttttt &sg, &sg_offset, FROM_XFER_BUF);tt/* ATA command 0x30 (WRITE SECTORS) */ttusbat_pack_ata_sector_cmd(command, thistime, sector, 0x30);tt/* Write/execute ATA write command */ttresult = usbat_multiple_write(us, registers, command, 7);ttif (result != USB_STOR_TRANSPORT_GOOD)tttgoto leave;tt/* Write the data */ttresult = usbat_write_blocks(us, buffer, len, 0);ttif (result != USB_STOR_TRANSPORT_GOOD)tttgoto leave;ttsector += thistime;tttotallen -= len;t} while (totallen > 0);tkfree(buffer);treturn result;leave:tkfree(buffer);treturn USB_STOR_TRANSPORT_ERROR;}""",2,"cwe119,cwe120"
"sys_dumpfile_calltf(PLI_BYTE8*name){      vpiHandle callh = vpi_handle(vpiSysTfCall, 0);      vpiHandle argv = vpi_iterate(vpiArgument, callh);      char *path;               if (dumpvars_status != 0) {t    char msg[64];t    snprintf(msg, sizeof(msg), ""VCD warning: %s:%d:"",t             vpi_get_str(vpiFile, callh),t             (int)vpi_get(vpiLineNo, callh));t    msg[sizeof(msg)-1] = 0;t    vpi_printf(""%s %s called after $dumpvars started,"", msg, name);t    vpi_printf(""%*s using existing file (%s)."",t               (int) strlen(msg), "" "", dump_path);t    vpi_free_object(argv);t    return 0;      }      path = get_filename(callh, name, vpi_scan(argv));      vpi_free_object(argv);      if (! path) return 0;      if (dump_path) {t    vpi_printf(""VCD warning: %s:%d: "", vpi_get_str(vpiFile, callh),t               (int)vpi_get(vpiLineNo, callh));t    vpi_printf(""Overriding dump file %s with %s."", dump_path, path);t    free(dump_path);      }      dump_path = path;      return 0;}",2,"cwe119,cwe120"
"decode_maidenhead(unsigned char *element, int element_len) {       char maidenhead[7];   if (element_len > 6 || !element_len) return -1;   strncpy(maidenhead, element, element_len);   maidenhead[element_len] = 0;   lprintf(T_OPENTRAC, ""Grid ID: %sr"", maidenhead);   return 0;}",2,"cwe119,cwe120"
"file_compress(file, mode)    char  *file;    char  *mode;{    local char outfile[MAX_NAME_LEN];    FILE  *in;    gzFile out;    strcpy(outfile, file);    strcat(outfile, GZ_SUFFIX);    in = fopen(file, ""rb"");    if (in == NULL) {        perror(file);        exit(1);    }    out = gzopen(outfile, mode);    if (out == NULL) {        fprintf(stderr, ""%s: can't gzopen %s"", prog, outfile);        exit(1);    }    gz_compress(in, out);    unlink(file);}",2,"cwe469,cweother"
"tds_money_to_string(const TDS_MONEY * money, char *s){#ifdef HAVE_INT64tint frac;tTDS_INT8 mymoney;tTDS_UINT8 n;tchar *p;t t tmymoney = (((TDS_INT8)(((TDS_INT*)money)[0])) << 32) | ((TDS_UINT*) money)[1];tp = s;tif (mymoney < 0) {tt*p++ = '-';tt ttn = -mymoney;t} else {ttn = mymoney;t}tn = (n + 50) / 100;tfrac = (int) (n % 100);tn /= 100;t tsprintf(p, ""%"" PRId64 "".%02d"", n, frac);treturn s;#elsetunsigned char multiplier[MAXPRECISION], temp[MAXPRECISION];tunsigned char product[MAXPRECISION];tconst unsigned char *number;tunsigned char tmpnumber[8];tint i, num_bytes = 8;tint pos, neg = 0;tmemset(multiplier, 0, MAXPRECISION);tmemset(product, 0, MAXPRECISION);tmultiplier[0] = 1;tnumber = (const unsigned char *) money;#ifdef WORDS_BIGENDIANt tmemcpy(tmpnumber, number, 8);#elset tfor (i = 0; i < 4; i++)tttmpnumber[3 - i] = number[i];tfor (i = 4; i < 8; i++)tttmpnumber[7 - i + 4] = number[i];#endiftif (tmpnumber[0] & 0x80) {tt ttneg = 1;ttfor (i = 0; i < 8; i++) {ttttmpnumber[i] = ~tmpnumber[i];tt}ttfor (i = 7; i >= 0; i--) {ttttmpnumber[i] += 1;tttif (tmpnumber[i] != 0)ttttbreak;tt}t}tfor (pos = num_bytes - 1; pos >= 0; pos--) {ttmultiply_byte(product, tmpnumber[pos], multiplier);ttmemcpy(temp, multiplier, MAXPRECISION);ttmemset(multiplier, 0, MAXPRECISION);ttmultiply_byte(multiplier, 256, temp);t}tif (neg) {tts[0] = '-';ttarray_to_string(product, 4, &s[1]);t} else {ttarray_to_string(product, 4, s);t}t tif (s) {ttsprintf(s, ""%.02f"", atof(s));t}treturn s;#endif}",2,"cwe119,cwe120"
"iwl_dbgfs_thermal_throttling_read(struct file *file,ttttchar __user *user_buf,ttttsize_t count, loff_t *ppos){tstruct iwl_priv *priv = file->private_data;tstruct iwl_tt_mgmt *tt = &priv->thermal_throttle;tstruct iwl_tt_restriction *restriction;tchar buf[100];tint pos = 0;tconst size_t bufsz = sizeof(buf);tpos += scnprintf(buf + pos, bufsz - pos,ttt""Thermal Throttling Mode: %s"",ttttt->advanced_tt ? ""Advance"" : ""Legacy"");tpos += scnprintf(buf + pos, bufsz - pos,ttt""Thermal Throttling State: %d"",ttttt->state);tif (tt->advanced_tt) {ttrestriction = tt->restriction + tt->state;ttpos += scnprintf(buf + pos, bufsz - pos,tttt""Tx mode: %d"",ttttrestriction->tx_stream);ttpos += scnprintf(buf + pos, bufsz - pos,tttt""Rx mode: %d"",ttttrestriction->rx_stream);ttpos += scnprintf(buf + pos, bufsz - pos,tttt""HT mode: %d"",ttttrestriction->is_ht);t}treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);}",2,"cwe119,cwe120"
"collect_reflog(const char *ref, const unsigned char *sha1, int unused, void *cb_data){tstruct collected_reflog *e;tstruct collect_reflog_cb *cb = cb_data;tsize_t namelen = strlen(ref);te = xmalloc(sizeof(*e) + namelen + 1);thashcpy(e->sha1, sha1);tmemcpy(e->reflog, ref, namelen + 1);tALLOC_GROW(cb->e, cb->nr + 1, cb->alloc);tcb->e[cb->nr++] = e;treturn 0;}",2,"cwe119,cwe120"
"read_file(char *ifilename, char *ofilename){  char rofilename[80];  maps_processed = 0;#ifdef INCLUDE_REOUTPUT_STUFF     if (o_reoutput)  {    if (ifilename[0] == '-')      sprintf(rofilename, ""stdio.reout"");    else      sprintf(rofilename, ""%s.reout"", ifilename);  }#endif  if (mlevel(5))     fprintf(stderr, ""Opening '%s' for read."", ifilename);     if (ifilename[0] == '-')    in_file = stdin;  else    in_file = fopen(ifilename, ""rb"");     if (!in_file)  {         if (mlevel(1))      fprintf(stderr, ""Error: cannot open input file '%s'."", ifilename);             return;  }  if (mlevel(5))     fprintf(stderr, ""Opening '%s' for write."", ofilename);     if (ofilename[0] == '-')    out_file = stdout;  else    out_file = fopen(ofilename, ""wb"");     if (!out_file)  {    if (ifilename[0] != '-')      fclose(in_file);    if (mlevel(1))      fprintf(stderr, ""Error: cannot open output file '%s'."", ofilename);    return;  }#ifdef INCLUDE_REOUTPUT_STUFF     if (o_reoutput)    reout_file = fopen(rofilename, ""wb"");     if (o_reoutput && !reout_file)  {    if (ifilename[0] != '-')      fclose(in_file);    if (ofilename[0] != '-')      fclose(out_file);    if (mlevel(1))      fprintf(stderr, ""Error: cannot open reoutput file '%s'."", rofilename);    return;  }#endif     while (1)  {         read_blocks_map();         if (!current_map) break;#ifdef INCLUDE_REOUTPUT_STUFF         if (o_reoutput)      write_a_map();#endif    if (!one_family || strcmp(current_map->block_family, one_family) == 0)    {                 graph_all();    }    else        maps_processed--;         dealloc_blocks_map();  }     if (ifilename[0] != '-')    fclose(in_file);     fflush(out_file);     if (ofilename[0] != '-')    fclose(out_file);#ifdef INCLUDE_REOUTPUT_STUFF     if (o_reoutput)    fclose(reout_file);#endif  if (maps_processed)  {   }  else  {    if (mlevel(1))      if (one_family)        fprintf(stderr, ""Error: Family '%s' not found in file '%s'."",                one_family, ifilename);      else        fprintf(stderr, ""Error: no usable data in file '%s'."", ifilename);  } }",3,"cwe119,cwe120,cweother"
"""SetupBaseSpecs(struct Symbol * symbol, struct __ecereNameSpace__ecere__sys__OldList * baseSpecs){if(baseSpecs && baseSpecs->first && ((struct Specifier *)baseSpecs->first)->type == 1){char name[1024];struct Symbol * baseClass;char * tpl;strcpy(name, ((struct Specifier *)baseSpecs->first)->name);tpl = strchr(name, '<');if(tpl)*tpl = (char)0;baseClass = FindClass(name);if(baseClass && baseClass->ctx){struct TemplatedType * copy;for(copy = (struct TemplatedType *)__ecereProp___ecereNameSpace__ecere__sys__BinaryTree_Get_first(&baseClass->ctx->templateTypes); copy; copy = (struct TemplatedType *)__ecereProp___ecereNameSpace__ecere__sys__BTNode_Get_next(copy)){struct TemplatedType * type = (type = __ecereNameSpace__ecere__com__eInstance_New(__ecereClass_TemplatedType), type->key = copy->key, type->param = copy->param, type);if(!__ecereMethod___ecereNameSpace__ecere__sys__BinaryTree_Add(&curContext->templateTypes, (struct __ecereNameSpace__ecere__sys__BTNode *)type))((type ? (__ecereClass_TemplatedType->Destructor ? __ecereClass_TemplatedType->Destructor(type) : 0, __ecereClass___ecereNameSpace__ecere__sys__BTNode->Destructor ? __ecereClass___ecereNameSpace__ecere__sys__BTNode->Destructor(type) : 0, __ecereNameSpace__ecere__com__eSystem_Delete(type)) : 0), type = 0);}}else if(baseClass && baseClass->registered){struct __ecereNameSpace__ecere__com__Class * sClass;for(sClass = baseClass->registered; sClass; sClass = sClass->base){struct __ecereNameSpace__ecere__com__ClassTemplateParameter * p;for(p = sClass->templateParams.first; p; p = p->next){if(p->type == 0){struct TemplateParameter * param = p->param;struct TemplatedType * type;if(!param){p->param = param = __extension__ ({struct TemplateParameter * __ecereInstance1 = __ecereNameSpace__ecere__com__eInstance_New(__ecereClass_TemplateParameter);__ecereInstance1->identifier = MkIdentifier(p->name), __ecereInstance1->type = p->type, __ecereInstance1->dataTypeString = p->dataTypeString, __ecereInstance1;});}type = __extension__ ({struct TemplatedType * __ecereInstance1 = __ecereNameSpace__ecere__com__eInstance_New(__ecereClass_TemplatedType);__ecereInstance1->key = (uintptr_t)p->name, __ecereInstance1->param = param, __ecereInstance1;});if(!__ecereMethod___ecereNameSpace__ecere__sys__BinaryTree_Add(&curContext->templateTypes, (struct __ecereNameSpace__ecere__sys__BTNode *)type))((type ? (__ecereClass_TemplatedType->Destructor ? __ecereClass_TemplatedType->Destructor(type) : 0, __ecereClass___ecereNameSpace__ecere__sys__BTNode->Destructor ? __ecereClass___ecereNameSpace__ecere__sys__BTNode->Destructor(type) : 0, __ecereNameSpace__ecere__com__eSystem_Delete(type)) : 0), type = 0);}}}}}}""",2,"cwe119,cwe120"
"entropy_collect_filesystem(SHA1Context *ctx){tconst char *path[RANDOM_SHUFFLE_MAX];tsize_t i;ti = 0;tpath[i++] = gethomedir();tpath[i++] = ""."";tpath[i++] = "".."";tpath[i++] = ""/"";tg_assert(i <= G_N_ELEMENTS(path));tentropy_array_stat_collect(ctx, path, i);ti = 0;tif (is_running_on_mingw()) {ttpath[i++] = ""C:/"";ttpath[i++] = mingw_get_admin_tools_path();ttpath[i++] = mingw_get_common_appdata_path();ttpath[i++] = mingw_get_common_docs_path();ttpath[i++] = mingw_get_cookies_path();ttpath[i++] = mingw_get_fonts_path();ttpath[i++] = mingw_get_history_path();ttg_assert(i <= G_N_ELEMENTS(path));ttentropy_array_stat_collect(ctx, path, i);tti = 0;ttpath[i++] = mingw_get_home_path();ttpath[i++] = mingw_get_internet_cache_path();ttpath[i++] = mingw_get_mypictures_path();ttpath[i++] = mingw_get_personal_path();ttpath[i++] = mingw_get_program_files_path();ttpath[i++] = mingw_get_startup_path();ttpath[i++] = mingw_get_system_path();ttpath[i++] = mingw_get_windows_path();ttg_assert(i <= G_N_ELEMENTS(path));ttentropy_array_stat_collect(ctx, path, i);t} else {ttpath[i++] = ""/bin"";ttpath[i++] = ""/boot"";ttpath[i++] = ""/dev"";ttpath[i++] = ""/etc"";ttpath[i++] = ""/home"";ttpath[i++] = ""/lib"";ttpath[i++] = ""/mnt"";ttpath[i++] = ""/opt"";ttg_assert(i <= G_N_ELEMENTS(path));ttentropy_array_stat_collect(ctx, path, i);tti = 0;ttpath[i++] = ""/proc"";ttpath[i++] = ""/root"";ttpath[i++] = ""/sbin"";ttpath[i++] = ""/sys"";ttpath[i++] = ""/tmp"";ttpath[i++] = ""/usr"";ttpath[i++] = ""/var"";ttg_assert(i <= G_N_ELEMENTS(path));ttentropy_array_stat_collect(ctx, path, i);t}}",2,"cwe119,cwe120"
"BSMT2000_sh_start(const struct MachineSound *msound)r{rtconst struct BSMT2000interface *intf = msound->sound_interface;rtchar stream_name[2][40];rtconst char *stream_name_ptrs[2];rtint vol[2];rtint i;rtrt rtmemset(&bsmt2000, 0, sizeof(bsmt2000));rtfor (i = 0; i < intf->num; i++)rt{rtt rttbsmt2000[i].voices = intf->voices[i];rttbsmt2000[i].voice = malloc(bsmt2000[i].voices * sizeof(struct BSMT2000Voice));rttif (!bsmt2000[i].voice)rtttreturn 1;rrtt rttsprintf(stream_name[0], ""%s #%d Ch1"", sound_name(msound), i);rttsprintf(stream_name[1], ""%s #%d Ch2"", sound_name(msound), i);rttstream_name_ptrs[0] = stream_name[0];rttstream_name_ptrs[1] = stream_name[1];rrtt rttvol[0] = MIXER(intf->mixing_level[i], MIXER_PAN_LEFT);rttvol[1] = MIXER(intf->mixing_level[i], MIXER_PAN_RIGHT);rrtt rttbsmt2000[i].stream = stream_init_multi(2, stream_name_ptrs, vol, Machine->sample_rate, i, bsmt2000_update);rttif (bsmt2000[i].stream == -1)rtttreturn 1;rrtt rttbsmt2000[i].region_base = (INT8 *)memory_region(intf->region[i]);rttbsmt2000[i].total_banks = memory_region_length(intf->region[i]) / 0x10000;rrtt rttbsmt2000[i].master_clock = (double)intf->baseclock[i];rttbsmt2000[i].output_step = (int)((double)intf->baseclock[i] / 1024.0 * (double)(1 << FRAC_BITS) / (double)Machine->sample_rate);rrtt rttinit_all_voices(&bsmt2000[i]);rt}rrt rtaccumulator = malloc(sizeof(accumulator[0]) * 2 * MAX_SAMPLE_CHUNK);rtscratch = malloc(sizeof(scratch[0]) * 2 * MAX_SAMPLE_CHUNK);rtif (!accumulator || !scratch)rttreturn 1;rrt rtreturn 0;r}",2,"cwe120,cweother"
"convert_standard_to_date(char * standard, char * date_format,                              char * date){  char str[5];  int day,month,year,i;  str[0] = standard[0];  str[1] = standard[1];  str[2] = standard[2];  str[3] = standard[3];  str[4] = 0;  year = atoi((char*)str);  str[0] = standard[5];  str[1] = standard[6];  str[2] = 0;  month = atoi((char*)str);  str[0] = standard[8];  str[1] = standard[9];  str[2] = 0;  day = atoi((char*)str);  sprintf(date,""%s"",date_format);  for (i=0;i<strlen(date_format)-1;i++) {    if (date_format[i]=='%') {      if (date_format[i+1]=='m') {        sprintf((char*)&date[i],""%02d"",month);      }      if (date_format[i+1]=='d') {        sprintf((char*)&date[i],""%02d"",day);      }      if (date_format[i+1]=='Y') {        sprintf((char*)&date[i],""%04d"",year);      }    }  }  for (i=0;i<strlen(date_format);i++) {    if ((date_format[i]=='/') ||        (date_format[i]=='-') ||        (date_format[i]=='.')) {      date[i] = date_format[i];    }  }  date[10]=0;}",3,"cwe119,cwe120,cweother"
"""bitlgte(char *bits1, int oper, char *bits2){ int val1, val2, nextbit; char result; int i, l1, l2, length, ldiff; char stream[256]; char chr1, chr2; l1 = strlen(bits1); l2 = strlen(bits2); if (l1 < l2)   {    length = l2;    ldiff = l2 - l1;    i=0;    while( ldiff-- ) stream[i++] = '0';    while( l1--    ) stream[i++] = *(bits1++);    stream[i] = '0';    bits1 = stream;   } else if (l2 < l1)   {    length = l1;    ldiff = l1 - l2;    i=0;    while( ldiff-- ) stream[i++] = '0';    while( l2--    ) stream[i++] = *(bits2++);    stream[i] = '0';    bits2 = stream;   } else    length = l1; val1 = val2 = 0; nextbit = 1; while( length-- )    {     chr1 = bits1[length];     chr2 = bits2[length];     if ((chr1 != 'x')&&(chr1 != 'X')&&(chr2 != 'x')&&(chr2 != 'X'))       {        if (chr1 == '1') val1 += nextbit;        if (chr2 == '1') val2 += nextbit;        nextbit *= 2;       }    } result = 0; switch (oper)       {        case LT:             if (val1 < val2) result = 1;             break;        case LTE:             if (val1 <= val2) result = 1;             break;        case GT:             if (val1 > val2) result = 1;             break;        case GTE:             if (val1 >= val2) result = 1;             break;       } return (result);}""",2,"cwe119,cwe120"
"make_path_absolute (char *fname, const char *orig){    char thisdir[MAXLEN];    if (getcwd(thisdir, MAXLEN - 1) != NULL) {tif (fname_strstr(fname, thisdir) == NULL) {t    real_make_path_absolute(fname, orig, thisdir);t}    }}",2,"cwe119,cwe120"
"NK7110_MakeCall(gn_data *data, struct gn_statemachine *state){tunsigned char req[100] = {FBUS_FRAME_HEADER, 0x01};tunsigned char voice_end[] = {0x05, 0x01, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00};tint pos = 4, len;tgn_call_active active[2];tgn_data d;tif (!data->call_info) return GN_ERR_INTERNALERROR;tswitch (data->call_info->type) {tcase GN_CALL_Voice:ttbreak;tcase GN_CALL_NonDigitalData:tcase GN_CALL_DigitalData:ttdprintf(""Unsupported call type %d"", data->call_info->type);ttreturn GN_ERR_NOTSUPPORTED;tdefault:ttdprintf(""Invalid call type %d"", data->call_info->type);ttreturn GN_ERR_INTERNALERROR;t}tlen = strlen(data->call_info->number);tif (len > GN_PHONEBOOK_NUMBER_MAX_LENGTH) {ttdprintf(""number too long"");ttreturn GN_ERR_ENTRYTOOLONG;t}tlen = char_unicode_encode(req + pos + 1, data->call_info->number, len);treq[pos++] = len / 2;tpos += len;tswitch (data->call_info->send_number) {tcase GN_CALL_Never:   voice_end[5] = 0x01; break;tcase GN_CALL_Always:  voice_end[5] = 0x00; break;tcase GN_CALL_Default: voice_end[5] = 0x00; break;tdefault: return GN_ERR_INTERNALERROR;t}tmemcpy(req + pos, voice_end, sizeof(voice_end));tpos += sizeof(voice_end);tif (sm_message_send(pos, NK7110_MSG_COMMSTATUS, req, state)) return GN_ERR_NOTREADY;tif (sm_block_ack(state) != GN_ERR_NONE) return GN_ERR_NOTREADY;tmemset(active, 0, sizeof(*active));tgn_data_clear(&d);td.call_active = active;tif (NK7110_GetActiveCalls(&d, state) != GN_ERR_NONE) return GN_ERR_NOTREADY;tdata->call_info->call_id = active[0].call_id;treturn GN_ERR_NONE;}",2,"cwe119,cwe120"
"psfile_get_uuid_by_pub(int fd, TCPA_STORE_PUBKEY *pub, TSS_UUID **ret_uuid){        int rc;        UINT32 file_offset = 0;        struct key_disk_cache *tmp;tchar tmp_buffer[2048];        MUTEX_LOCK(disk_cache_lock);        tmp = key_disk_cache_head;        while (tmp) {tt                 if (pub->keyLength != tmp->pub_data_size || !(tmp->flags & CACHE_FLAG_VALID)) {                        tmp = tmp->next;                        continue;                }tt                                  file_offset = TSSPS_PUB_DATA_OFFSET(tmp);                rc = lseek(fd, file_offset, SEEK_SET);                if (rc == ((off_t) - 1)) {                        LogError(""lseek: %s"", strerror(errno));                        MUTEX_UNLOCK(disk_cache_lock);                        return TCSERR(TSS_E_INTERNAL_ERROR);                }ttDBG_ASSERT(tmp->pub_data_size < 2048);ttif (tmp->pub_data_size > sizeof(tmp_buffer)) {tttLogError(""Source buffer size too big! Size:  %d"",tttt tmp->pub_data_size);tttMUTEX_UNLOCK(disk_cache_lock);tttreturn TCSERR(TSS_E_INTERNAL_ERROR);tt}tt                 if ((rc = read_data(fd, tmp_buffer, tmp->pub_data_size))) {tttLogError(""%s"", __FUNCTION__);                        MUTEX_UNLOCK(disk_cache_lock);                        return rc;                }tt ttif (memcmp(tmp_buffer, pub->key, tmp->pub_data_size)) {ttttmp = tmp->next;tttcontinue;tt}tt*ret_uuid = (TSS_UUID *)malloc(sizeof(TSS_UUID));ttif (*ret_uuid == NULL) {tttLogError(""malloc of %zd bytes failed."", sizeof(TSS_UUID));                        MUTEX_UNLOCK(disk_cache_lock);tttreturn TCSERR(TSS_E_OUTOFMEMORY);tt}tt ttmemcpy(*ret_uuid, &tmp->uuid, sizeof(TSS_UUID));                MUTEX_UNLOCK(disk_cache_lock);                return TSS_SUCCESS;        }        MUTEX_UNLOCK(disk_cache_lock);                 return TCSERR(TSS_E_PS_KEY_NOTFOUND);}",2,"cwe119,cwe120"
"_keyboard(void){    char buf[100], buf1[100], buf2[100];    while (1) {tCurses_prompt_gets(""Enter coordinates as east north: "", buf);tG_strip(buf);tif (*buf == 0) {t    return 0;t}tif (sscanf(buf, ""%s %s"", buf1, buf2) != 2) {t    Beep();t    continue;t}t tif (!(G_lon_scan(buf1, &E) && G_lat_scan(buf2, &N))) {t    if (sscanf(buf, ""%lf %lf"", &E, &N) != 2) {ttBeep();ttcontinue;t    }t}tCurses_clear_window(INFO_WINDOW);tsprintf(buf, ""East:   %f"", E);tCurses_write_window(INFO_WINDOW, 2, 2, buf);tsprintf(buf, ""North:  %f"", N);tCurses_write_window(INFO_WINDOW, 3, 2, buf);tCurses_write_window(INFO_WINDOW, 5, 1, ""Look ok? (y/n) "");twhile (1) {t    int c;t    c = Curses_getch(0);t    if (c == 'y' || c == 'Y')ttreturn 1;t    if (c == 'n' || c == 'N')ttbreak;t    Beep();t}    }    return 0;}",3,"cwe119,cwe120,cweother"
"convertPy(IoObject *self, PyObject *obj) {t t t tIoObject *ret = NULL;   t ttif(obj == Py_None) {ttret = IONIL(self); t} else if(PyString_Check(obj)) {tt ttIoSeq *ret = IoSeq_newWithCString_(IOSTATE, PyString_AsString(obj));ttreturn ret;tt t} else if(PyFloat_Check(obj)) {ttret = IoNumber_newWithDouble_(IOSTATE, PyFloat_AS_DOUBLE(obj));tt t} else if(PyInt_Check(obj)) {ttret = IoNumber_newWithDouble_(IOSTATE, PyInt_AS_LONG(obj));tt t} else if(PyList_Check(obj)) {tt ttint i;ttint len = PyList_GET_SIZE(obj);ttret = IoList_new(IOSTATE);ttfor(i=0;i<len;i++) {tttPyObject *o = PyList_GET_ITEM(obj, i);tttIoObject *x = convertPy(self, o);ttt tttIoList_rawAppend_(ret, x);tt}        } else if(PyTuple_Check(obj)) {                 int i;                int len = PyTuple_GET_SIZE(obj);                ret = IoList_new(IOSTATE);                for(i=0;i<len;i++) {                        PyObject *o = PyTuple_GET_ITEM(obj, i);                        IoObject *x = convertPy(self, o);                                                 IoList_rawAppend_(ret, x);                }t} else if(PyDict_Check(obj)) {tt tt tt t} else if(PyCallable_Check(obj)) {tt tt t} else {ttret = wrap(self, obj);t}treturn ret;}",2,"cwe476,cweother"
"mo_links(struct Client *client_p, struct Client *source_p, int parc, const char *parv[]){tconst char *mask = """";tstruct Client *target_p;tchar clean_mask[2 * HOSTLEN + 4];thook_data hd;trb_dlink_node *ptr;tif(parc > 2)t{ttif(strlen(parv[2]) > HOSTLEN)tttreturn 0;ttif(hunt_server(client_p, source_p, "":%s LINKS %s :%s"", 1, parc, parv)tt   != HUNTED_ISME)tttreturn 0;ttmask = parv[2];t}telse if(parc == 2)ttmask = parv[1];tif(*mask)tt ttmask = collapse(clean_string(clean_mask, (const unsigned char *)mask, 2 * HOSTLEN));thd.client = source_p;thd.arg1 = mask;thd.arg2 = NULL;tcall_hook(doing_links_hook, &hd);tSetCork(source_p);tRB_DLINK_FOREACH(ptr, global_serv_list.head)t{tttarget_p = ptr->data;ttif(*mask && !match(mask, target_p->name))tttcontinue;tt ttsendto_one_numeric(source_p, RPL_LINKS, form_str(RPL_LINKS),tttt   target_p->name, target_p->servptr->name,tttt   target_p->hopcount,tttt   target_p->info[0] ? target_p->info : ""(Unknown Location)"");t}tClearCork(source_p);tsendto_one_numeric(source_p, RPL_ENDOFLINKS, form_str(RPL_ENDOFLINKS),ttt   EmptyString(mask) ? ""*"" : mask);treturn 0;}",2,"cwe119,cwe120"
"define_macro (name, value, mtype)     char *name, *value;     int mtype;{  char *mt_val = """";  register char *lptr;  if (!(name && *name))    return;  if (!value) value = mt_val;  while (*value && isspace (*value)) value++;  lptr = value;  while (*lptr) lptr++;  if (lptr > value) lptr--;  while (*lptr && isspace (*lptr)) lptr--;  if (*lptr)    *(lptr+1) = '0';  if (!strcmp(name,""RECDEPTH"")) {    rec_do_depth = atoi(value);  }  addHash (name, value, mtype);  if (!strcmp(name,""VPATH""))    insertvpath(value);  if (!strcmp(name,""IMPORT""))    get_macrodefs_from_env();    }",2,"cwe469,cweother"
"readfromchild(struct connection *p){tsize_t bytestoread;tssize_t r;tbytestoread = p->script_input.ceiling - p->script_input.end;tif (p->pipe_params.haslen && bytestoread > p->pipe_params.pmax)ttbytestoread = p->pipe_params.pmax;tif (bytestoread == 0) {ttlog_d(""readfromchild: bytestoread is zero!"");ttreturn 0;t}tr = read(p->rfd, p->script_input.end, bytestoread);tif (debug)ttlog_d(""readfromchild: %d %d %u %d"", p->rfd, (int) (p->script_input.end - p->script_input.floor), (unsigned) bytestoread, (int) r);tswitch (r) {tcase -1:ttif (errno == EAGAIN)tttreturn 0;ttif (debug)tttlerror(""read"");ttclose_connection(p);ttreturn -1;tcase 0:ttif (p->pipe_params.state != 2) {tttlog_d(""readfromchild: premature end of script headers (ipp=%d)"", (int) (p->script_input.end - p->script_input.floor));tttcgi_error(p->r);tttreturn -1;tt}ttif (p->pipe_params.haslen) {tttlog_d(""readfromchild: script went away (pmax=%u)"", (unsigned) p->pipe_params.pmax);tttclose_connection(p);tttreturn -1;tt}ttp->t = current_time;ttp->script_input.state = 2;ttbreak;tdefault:ttp->t = current_time;ttp->script_input.end += r;ttif (p->pipe_params.haslen) {tttp->pipe_params.pmax -= r;tttif (p->pipe_params.pmax == 0)ttttp->script_input.state = 2;tt}ttbreak;t}treturn 0;}",2,"cwe120,cweother"
"process_newnews(char *group, bool AllGroups, time_t date){    int low, high;    char **xrefs;    int count;    void *handle;    char *p;    time_t arrived;    ARTHANDLE *art = NULL;    TOKEN token;    char *data;    int len;    char *grplist[2];    time_t now;    grplist[0] = group;    grplist[1] = NULL;    if (PERMspecified && !PERMmatch(PERMreadlist, grplist))treturn;    if (!AllGroups && !PERMmatch(groups, grplist))treturn;    if (!OVgroupstats(group, &low, &high, &count, NULL))treturn;    ARTlow = low;    ARThigh = high;    if ((handle = OVopensearch(group, ARTlow, ARThigh)) != NULL) {tARTNUM artnum;tunsigned long artcount = 0;tstruct cvector *vector = NULL;tif (innconf->nfsreader) {t    time(&now);t     t    if (date >= (time_t) innconf->nfsreaderdelay)ttdate -= innconf->nfsreaderdelay;t}twhile (OVsearch(handle, &artnum, &data, &len, &token, &arrived)) {t    if (innconf->nfsreader != 0 && (time_t) (arrived + innconf->nfsreaderdelay) > now)ttcontinue;t    if (len == 0 || date > arrived)ttcontinue;t    vector = overview_split(data, len, NULL, vector);t    if (overhdr_xref == -1) {ttif ((art = SMretrieve(token, RETR_HEAD)) == NULL)tt    continue;ttp = GetXref(art);ttSMfreearticle(art);t    } else {ttif (PERMaccessconf->nnrpdcheckart && tt    !ARTinstorebytoken(token))tt    continue;tt ttp = overview_get_extra_header(vector, xref_header);t    }t    if (p == NULL)ttcontinue;t    xrefs = GetGroups(p);t    free(p);t    if (xrefs == NULL)ttcontinue;t    if (HaveSeen(AllGroups, group, groups, xrefs))ttcontinue;t    p = overview_get_standard_header(vector, OVERVIEW_MESSAGE_ID);t    if (p == NULL)ttcontinue;t    ++artcount;t    cache_add(HashMessageID(p), token);t    Printf(""%sr"", p);t    free(p);t}tOVclosesearch(handle);tnotice(""%s newnews %s %lu"", Client.host, group, artcount);tif (vector)t    cvector_free(vector);    }}",3,"cwe119,cwe120,cwe469"
"cert_callback (gnutls_session_t session,               const gnutls_datum_t * req_ca_rdn, int nreqs,               const gnutls_pk_algorithm_t * sign_algos,               int sign_algos_length, gnutls_retr2_st * st){  char issuer_dn[256];  int i, ret;  size_t len;  gnutls_certificate_type_t type;     if (nreqs > 0)    printf (""- Server's trusted authorities:"");  else    printf (""- Server did not send us any trusted authorities names."");     for (i = 0; i < nreqs; i++)    {      len = sizeof (issuer_dn);      ret = gnutls_x509_rdn_get (&req_ca_rdn[i], issuer_dn, &len);      if (ret >= 0)        {          printf (""   [%d]: "", i);          printf (""%s"", issuer_dn);        }    }     type = gnutls_certificate_type_get (session);  if (type == GNUTLS_CRT_X509)    {             gnutls_sign_algorithm_t cert_algo, req_algo;      int i, match = 0;      ret = gnutls_x509_crt_get_signature_algorithm (crt);      if (ret < 0)        {                     return -1;        }      cert_algo = ret;      i = 0;      do        {          ret = gnutls_sign_algorithm_get_requested (session, i, &req_algo);          if (ret >= 0 && cert_algo == req_algo)            {              match = 1;              break;            }                     if (i == 0 && ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE)            {              match = 1;              break;            }          i++;        }      while (ret >= 0);      if (match == 0)        {          printf            (""- Could not find a suitable certificate to send to server"");          return -1;        }      st->cert_type = type;      st->ncerts = 1;      st->cert.x509 = &crt;      st->key.x509 = key;      st->key_type = GNUTLS_PRIVKEY_X509;      st->deinit_all = 0;    }  else    {      return -1;    }  return 0;}",2,"cwe119,cwe120"
"track_save(const char *address, int status){tchar namebuf[sizeof(TRACKDIR) + NUMBUFSIZE+2];tchar buf2[NUMBUFSIZE];tFILE *fp;ttime_t curTime=time(NULL);ttime_t t=curTime / 3600;tchar *addrbuf=strdup(address);tif (!addrbuf)ttreturn;tdomainlower(addrbuf);tstrcat(strcpy(namebuf, TRACKDIR ""/""), libmail_str_time_t(t, buf2));tlibmail_str_time_t(curTime, buf2);tfp=fopen(namebuf, ""a"");tif (fp)t{ttfprintf(fp, ""%s %c%s"", buf2, (char)status, addrbuf);ttfclose(fp);t}tfree(addrbuf);}",3,"cwe119,cwe120,cweother"
"punt (const DatabaseInfo database, int die, ...){  va_list args;  char *fmt;  FILE *fp;  char hostname[MAXHOSTNAMELEN];  VA_START (args, die);  fmt = va_arg (args, char *);  if (database != NULL)    {      fp = open_mail_file (database);      if (fp == NULL)t{t  char *lastDitchTry;t  asprintf (&lastDitchTry, ""mail %s"", gnatsAdminMailAddr (database));t  fp = popen (lastDitchTry, ""w"");t  free (lastDitchTry);t}      if (fp == NULL)t{t  fprintf (stderr, ""%s: cannot open mail file for errors"",tt   program_name);t  client_unlock_gnats ();t  exit (3);t}      if (gethostname (hostname, MAXHOSTNAMELEN) != 0)t{t  strcpy (hostname, ""(hostname unavailable)"");t}      fprintf (fp, ""From: %s (GNATS Management)"",t       gnatsAdminMailAddr (database));      fprintf (fp, ""To: %s"", gnatsAdminMailAddr (database));      fprintf (fp, ""Subject: problem with %s on host %s"", program_name,t       hostname);      fprintf (fp, """");t       vfprintf (fp, fmt, args);      close_mail_file (fp);    }  else  {           fprintf (stderr, ""Problem with %s"", program_name);      vfprintf (stderr, fmt, args);      fprintf (stderr, """");  }  va_end (args);  if (die)    {      client_unlock_gnats ();      exit (2);    }}",3,"cwe119,cwe120,cweother"
"ReorderBufferToastReset(ReorderBuffer *rb, ReorderBufferTXN *txn){tHASH_SEQ_STATUS hstat;tReorderBufferToastEnt *ent;tif (txn->toast_hash == NULL)ttreturn;t thash_seq_init(&hstat, txn->toast_hash);twhile ((ent = (ReorderBufferToastEnt *) hash_seq_search(&hstat)) != NULL)t{ttdlist_mutable_iter it;ttif (ent->reconstructed != NULL)tttpfree(ent->reconstructed);ttdlist_foreach_modify(it, &ent->chunks)tt{tttReorderBufferChange *change =tttdlist_container(ReorderBufferChange, node, it.cur);tttdlist_delete(&change->node);tttReorderBufferReturnChange(rb, change);tt}t}thash_destroy(txn->toast_hash);ttxn->toast_hash = NULL;}",2,"cwe119,cwe120"
"client3_3_finodelk (call_frame_t *frame, xlator_t *this,                    void *data){        clnt_args_t       *args     = NULL;        gfs3_finodelk_req  req      = {{0,},};        int32_t            gf_cmd   = 0;        int32_t            gf_type  = 0;        int64_t            remote_fd = -1;        clnt_conf_t       *conf     = NULL;        int                op_errno = ESTALE;        int                ret      = 0;        if (!frame || !this || !data)                goto unwind;        args = data;        conf = this->private;        CLIENT_GET_REMOTE_FD (this, args->fd, FALLBACK_TO_ANON_FD,                              remote_fd, op_errno, unwind);        ret = client_fd_fop_prepare_local (frame, args->fd, remote_fd);        if (ret) {                op_errno = -ret;                goto unwind;        }        if (args->cmd == F_GETLK || args->cmd == F_GETLK64)                gf_cmd = GF_LK_GETLK;        else if (args->cmd == F_SETLK || args->cmd == F_SETLK64)                gf_cmd = GF_LK_SETLK;        else if (args->cmd == F_SETLKW || args->cmd == F_SETLKW64)                gf_cmd = GF_LK_SETLKW;        else {                gf_log (this->name, GF_LOG_WARNING,                        ""Unknown cmd (%d)!"", gf_cmd);                goto unwind;        }        switch (args->flock->l_type) {        case F_RDLCK:                gf_type = GF_LK_F_RDLCK;                break;        case F_WRLCK:                gf_type = GF_LK_F_WRLCK;                break;        case F_UNLCK:                gf_type = GF_LK_F_UNLCK;                break;        }        req.volume = (char *)args->volume;        req.fd    = remote_fd;        req.cmd   = gf_cmd;        req.type  = gf_type;        gf_proto_flock_from_flock (&req.flock, args->flock);        memcpy (req.gfid, args->fd->inode->gfid, 16);        GF_PROTOCOL_DICT_SERIALIZE (this, args->xdata, (&req.xdata.xdata_val),                                    req.xdata.xdata_len, op_errno, unwind);        ret = client_submit_request (this, &req, frame, conf->fops,                                     GFS3_OP_FINODELK,                                     client3_3_finodelk_cbk, NULL,                                     NULL, 0, NULL, 0,                                     NULL, (xdrproc_t)xdr_gfs3_finodelk_req);        if (ret) {                gf_log (this->name, GF_LOG_WARNING, ""failed to send the fop"");        }        GF_FREE (req.xdata.xdata_val);        return 0;unwind:        CLIENT_STACK_UNWIND (finodelk, frame, -1, op_errno, NULL);        GF_FREE (req.xdata.xdata_val);        return 0;}",2,"cwe120,cwe476"
update_topline_cursor(){    check_cursor();tt     update_topline();    if (!curwin->w_p_wrap)tvalidate_cursor();    update_curswant();},2,"cwe120,cweother"
"DispatchMethodReply(){ char label[CF_BUFSIZE];   char ipaddress[CF_SMALLBUF],clientip[CF_SMALLBUF];Verbose(""DispatchMethodReply()"");if (strcmp(METHODREPLYTO,""localhost"") == 0 || strcmp(METHODREPLYTO,""::1"") == 0 || strcmp(METHODREPLYTO,""127.0.0.1"") == 0)   {       snprintf(label,CF_BUFSIZE-1,""%s/rpc_in/localhost+localhost+%s:Reply+%s"",VLOCKDIR,METHODNAME,METHODMD5);   EncapsulateReply(label);   }else   {   strncpy(clientip,Hostname2IPString(METHODREPLYTO),63);   strncpy(ipaddress,Hostname2IPString(VFQNAME),63);        Verbose(""Dispatch method %s:%s to %s/rpc_out"",METHODREPLYTO,METHODNAME,VLOCKDIR);   snprintf(label,CF_BUFSIZE-1,""%s/rpc_out/%s+%s+%s:Reply+%s"",VLOCKDIR,clientip,ipaddress,METHODNAME,METHODMD5);   EncapsulateReply(label);   }}",4,"cwe119,cwe120,cwe476,cweother"
"verify_tag(const char *name, int verbose){tenum object_type type;tunsigned char sha1[20];tchar *buf;tunsigned long size;tint ret;tif (get_sha1(name, sha1))ttreturn error(""tag '%s' not found."", name);ttype = sha1_object_info(sha1, NULL);tif (type != OBJ_TAG)ttreturn error(""%s: cannot verify a non-tag object of type %s."",ttttname, typename(type));tbuf = read_sha1_file(sha1, &type, &size);tif (!buf)ttreturn error(""%s: unable to read file."", name);tret = run_gpg_verify(buf, size, verbose);tfree(buf);treturn ret;}",3,"cwe119,cwe120,cwe469"
"sync_log_base(const char *channel, const char *string){    int fd;    struct stat sbuffile, sbuffd;    int retries = 0;    const char *fname;         if (!sync_log_enabled) return;    if (channel && suppressed_channel && !strcmp(channel, suppressed_channel))treturn;    fname = sync_log_fname(channel);    while (retries++ < SYNC_LOG_RETRIES) {tfd = open(fname, O_WRONLY|O_APPEND|O_CREAT, 0640);tif (fd < 0 && errno == ENOENT) {t    if (!cyrus_mkdir(fname, 0755)) {ttfd = open(fname, O_WRONLY|O_APPEND|O_CREAT, 0640);t    }t}tif (fd < 0) {t    syslog(LOG_ERR, ""sync_log(): Unable to write to log file %s: %s"",tt   fname, strerror(errno));t    return;t}tif (lock_blocking(fd) == -1) {t    syslog(LOG_ERR, ""sync_log(): Failed to lock %s for %s: %m"",tt   fname, string);t    close(fd);t    return;t}t tif ((fstat(fd, &sbuffd) == 0) &&t    (stat(fname, &sbuffile) == 0) &&t    (sbuffd.st_ino == sbuffile.st_ino))t    break;tclose(fd);    }    if (retries >= SYNC_LOG_RETRIES) {tclose(fd);tsyslog(LOG_ERR,t       ""sync_log(): Failed to lock %s for %s after %d attempts"",t       fname, string, retries);treturn;    }    if (retry_write(fd, string, strlen(string)) < 0)tsyslog(LOG_ERR, ""write() to %s failed: %s"",t       fname, strerror(errno));    (void)fsync(fd);      close(fd);}",3,"cwe119,cwe120,cweother"
"exit_protocol(){  int fd;  char server[LAM_PATH_MAX];t     if (lam_mktmpid((int) -pq.pq_src_event, server, sizeof(server)) == 0) {    if ((fd = sfh_sock_open_clt_unix_stm(server)) >= 0) {      close(fd);    }  }}",2,"cwe119,cwe120"
"_e_fm2_cb_drag_finished(E_Drag *drag, int dropped __UNUSED__){   E_Fm2_Uri *uri;   const char *p;   char buf[PATH_MAX * 3 + 7];   Evas_Object *fm;   int i;   memset(buf, 0, sizeof(buf));   for (p = drag->data, i = 0; p && *p != '0'; p++, i++)     {        if (*p == 'r')          {             p++;             i = -1;             uri = _e_fm2_uri_parse(buf);             memset(buf, 0, sizeof(buf));             if (!uri) continue;             fm = _e_fm2_file_fm2_find(uri->path);             if (fm)               {                  const char *file;                  E_Fm2_Icon *ic;                  file = ecore_file_file_get(uri->path);                  if (file)                    {                       ic = _e_fm2_icon_find(fm, file);                       if (ic)                         {                            ic->drag.dnd = EINA_FALSE;                            if (ic->sd->dnd_scroller) ecore_animator_del(ic->sd->dnd_scroller);                            ic->sd->dnd_scroller = NULL;                            if (ic->drag.dnd_end_timer) ecore_timer_reset(ic->drag.dnd_end_timer);                            else ic->drag.dnd_end_timer = ecore_timer_add(0.2, (Ecore_Task_Cb)_e_fm2_cb_drag_finished_show, ic);                                                         evas_object_smart_callback_call(ic->sd->obj, ""dnd_end"", &ic->info);                         }                    }               }             if (uri->hostname) eina_stringshare_del(uri->hostname);             eina_stringshare_del(uri->path);             E_FREE(uri);          }        else          buf[i] = *p;     }   free(drag->data);}",2,"cwe119,cwe120"
"ccolamd_need (Int nnz, Int n_row, Int n_col, int *ok){         size_t s, c, r, t ;         s = t_mult (nnz, 2, ok) ;t         t = t_mult (n_col, 4, ok) ;t         s = MAX (s,t) ;    s = t_add (s, n_col, ok) ;t              c = CCOLAMD_C (n_col, ok) ;t         r = CCOLAMD_R (n_row, ok) ;t         s = t_add (s, c, ok) ;    s = t_add (s, r, ok) ;    c = t_mult (n_col, 3, ok) ;t         c = t_add (c, 1, ok) ;    s = t_add (s, c, ok) ;    c = t_add (n_col, 1, ok) ;t         c = t_mult (c, 5, ok) ;    s = t_add (s, c, ok) ;    s = t_add (s, n_row, ok) ;t         return (ok ? s : 0) ;}",3,"cwe119,cwe120,cweother"
"T1_PrintLog( char *func_ident, char *msg_txt, int level, ...){  va_list vararg;  static char levelid[4]={ 'E', 'W', 'S', 'D'};  time_t s_clock, *tp;    if (t1lib_log_file==NULL)    return;  if ((level>t1lib_log_level) || (level<1)){    return;  }  else{         va_start( vararg, level);        tp=&s_clock;    s_clock=time( tp);              fprintf( t1lib_log_file, ""(%c) %s: "", levelid[level-1], func_ident );    vfprintf( t1lib_log_file, msg_txt, vararg );    fprintf( t1lib_log_file, """");    fflush( t1lib_log_file);         va_end( vararg);        return;  }}",3,"cwe119,cwe120,cweother"
"gusb_id_unit(garmin_unit_info_t* gu){  static const char  oid[12] =  {20, 0, 0, 0, 0xfe, 0, 0, 0, 0, 0, 0, 0};  garmin_usb_packet iresp;  int i;  gusb_cmd_send((garmin_usb_packet*)oid, sizeof(oid));  for (i = 0; i < 25; i++) {    iresp.gusb_pkt.type = 0;    if (gusb_cmd_get(&iresp, sizeof(iresp)) < 0) {      return;    }    if (le_read16(iresp.gusb_pkt.pkt_id) == 0xff) {      gu->product_identifier = xstrdup((char*) iresp.gusb_pkt.databuf+4);      gu->unit_id = le_read16(iresp.gusb_pkt.databuf+0);      gu->unit_version = le_read16(iresp.gusb_pkt.databuf+2);    }         if (le_read16(iresp.gusb_pkt.pkt_id) == 0xfd) {      return;    }  }  fatal(""Unable to sync with Garmin USB device in %d attempts."", i);}",2,"cwe119,cwe120"
"main(int argc,char *argv[]) {  char *name = NULL;  char *src,*dest;  int c;  int oflag = NXT_OWLINE;  int force = 0;  while ((c = getopt(argc,argv,"":ho:fn:""))!=-1) {    switch(c) {      case 'h':        usage(argv[0],0);        break;      case 'o':        if (strcmp(optarg,""fragment"")==0 || strcmp(optarg,""f"")==0) oflag = NXT_OWFRAG;        else if (strcmp(optarg,""linear"")==0 || strcmp(optarg,""l"")==0) oflag = NXT_OWLINE;        else if (strcmp(optarg,""append"")==0 || strcmp(optarg,""a"")==0) oflag = NXT_OAPPND;        break;      case 'f':        force = 1;        break;      case 'n':        name = strdup(optarg);        break;      case ':':        fprintf(stderr,""Option -%c requires an operand"",optopt);        usage(argv[0],1);        break;      case '?':        fprintf(stderr,""Unrecognized option: -%c"", optopt);        usage(argv[0],1);        break;    }  }  nxt_t *nxt = nxt_open(name);  if (nxt==NULL) {    fprintf(stderr,""Could not find NXT"");    return 1;  }  if (optind<argc) {    src = argv[optind];    optind++;    if (optind<argc) dest = argv[optind];    else dest = basename(src);    oflag |= (force && oflag!=NXT_OAPPND)?NXT_OWOVER:0;    nxt_upload(nxt,src,dest,oflag);  }  else {    fprintf(stderr,""No input file"");    usage(argv[0],1);  }  int ret = nxt_error(nxt);  if (name!=NULL) free(name);  nxt_close(nxt);  return ret;}",2,"cwe120,cweother"
"JimSubstOneToken(Jim_Interp *interp, const ScriptToken *token, Jim_Obj **objPtrPtr){    Jim_Obj *objPtr;    switch (token->type) {        case JIM_TT_STR:        case JIM_TT_ESC:            objPtr = token->objPtr;            break;        case JIM_TT_VAR:            objPtr = Jim_GetVariable(interp, token->objPtr, JIM_ERRMSG);            break;        case JIM_TT_DICTSUGAR:            objPtr = JimExpandDictSugar(interp, token->objPtr);            break;        case JIM_TT_EXPRSUGAR:            objPtr = JimExpandExprSugar(interp, token->objPtr);            break;        case JIM_TT_CMD:            switch (Jim_EvalObj(interp, token->objPtr)) {                case JIM_OK:                case JIM_RETURN:                    objPtr = interp->result;                    break;                case JIM_BREAK:                                        return JIM_BREAK;                case JIM_CONTINUE:                                        return JIM_CONTINUE;                default:                    return JIM_ERR;            }            break;        default:            JimPanic((1,                ""default token type (%d) reached "" ""in Jim_SubstObj()."", token->type));            objPtr = NULL;            break;    }    if (objPtr) {        *objPtrPtr = objPtr;        return JIM_OK;    }    return JIM_ERR;}",2,"cwe120,cwe476"
"set_addr(struct sockaddr_atmsvc *addr,void *num,void *sub,  int num_tl,int sub_tl){    memset(addr,0,sizeof(struct sockaddr_atmsvc));    addr->sas_family = AF_ATMSVC;    if (num_tl & TL_E164)tif ((num_tl & TL_LEN) > ATM_E164_LEN)t    diag(COMPONENT,DIAG_ERROR,""bad E.164 length (%d)"",num_tl &t      TL_LEN);telse {t    memcpy(addr->sas_addr.pub,num,num_tl & TL_LEN);t    if (sub) {ttif (sub_tl != ATM_ESA_LEN) {tt    diag(COMPONENT,DIAG_ERROR,""bad ESA length (%d)"",sub_tl);tt    *addr->sas_addr.pub = 0;tt}ttelse memcpy(addr->sas_addr.prv,sub,ATM_ESA_LEN);t    }t}    else if (num) {t    if (num_tl != ATM_ESA_LEN)ttdiag(COMPONENT,DIAG_ERROR,""bad ESA length (%d)"",num_tl);t    else memcpy(addr->sas_addr.prv,num,ATM_ESA_LEN);t}}",2,"cwe120,cweother"
"read_mb(unsigned int *data, void *map, size_t length, size_t *position){   int ac = 0, ct;   unsigned char buf;   for (ct = 0;;)     {        if ((ct++) == 5) return -1;tif (*position > length) return -1;tbuf = ((unsigned char *) map)[(*position)++];        ac = (ac << 7) | (buf & 0x7f);        if ((buf & 0x80) == 0) break;     }   *data = ac;   return 0;}",2,"cwe119,cwe120"
"imap_address_to_mailbox(struct mailimap_address * imap_addr,ttt    struct mailimf_mailbox ** result){  char * dsp_name;  char * addr;  struct mailimf_mailbox * mb;  int res;  if (imap_addr->ad_personal_name == NULL)    dsp_name = NULL;  else {    dsp_name = strdup(imap_addr->ad_personal_name);    if (dsp_name == NULL) {      res = MAIL_ERROR_MEMORY;      goto err;    }  }  if (imap_addr->ad_host_name == NULL) {    if (imap_addr->ad_mailbox_name == NULL) {      addr = strdup("""");    }    else {      addr = strdup(imap_addr->ad_mailbox_name);    }    if (addr == NULL) {      res = MAIL_ERROR_MEMORY;      goto free_name;    }  }  else if (imap_addr->ad_mailbox_name == NULL) {         addr = strdup(imap_addr->ad_host_name);     if (addr == NULL) {      res = MAIL_ERROR_MEMORY;      goto free_name;    }  }  else {    addr = malloc(strlen(imap_addr->ad_mailbox_name) +        strlen(imap_addr->ad_host_name) + 2);    if (addr == NULL) {      res = MAIL_ERROR_MEMORY;      goto free_name;    }    strcpy(addr, imap_addr->ad_mailbox_name);    strcat(addr, ""@"");    strcat(addr, imap_addr->ad_host_name);  }  mb = mailimf_mailbox_new(dsp_name, addr);  if (mb == NULL) {    res = MAIL_ERROR_MEMORY;    goto free_addr;  }  * result = mb;  return MAIL_NO_ERROR; free_addr:  free(addr); free_name:  free(dsp_name); err:  return res;}",2,"cwe120,cwe469"
"generic_cache_store(char * filename, char * content, size_t length){  int fd;  char * str;  fd = open(filename, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);  if (fd == -1)    return MAIL_ERROR_FILE;  if (ftruncate(fd, length) < 0)    return MAIL_ERROR_FILE;    str = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);  if (str == (char *)MAP_FAILED)    return MAIL_ERROR_FILE;  memcpy(str, content, length);  msync(str, length, MS_SYNC);  munmap(str, length);  close(fd);  return MAIL_NO_ERROR;}",2,"cwe120,cweother"
"dispell_lexize(PG_FUNCTION_ARGS){tDictISpell *d = (DictISpell *) PG_GETARG_POINTER(0);tchart   *in = (char *) PG_GETARG_POINTER(1);tint32ttlen = PG_GETARG_INT32(2);tchart   *txt;tTSLexeme   *res;tTSLexeme   *ptr,ttt   *cptr;tif (len <= 0)ttPG_RETURN_POINTER(NULL);ttxt = lowerstr_with_len(in, len);tres = NINormalizeWord(&(d->obj), txt);tif (res == NULL)ttPG_RETURN_POINTER(NULL);tptr = cptr = res;twhile (ptr->lexeme)t{ttif (searchstoplist(&(d->stoplist), ptr->lexeme))tt{tttpfree(ptr->lexeme);tttptr->lexeme = NULL;tttptr++;tt}ttelsett{tttmemcpy(cptr, ptr, sizeof(TSLexeme));tttcptr++;tttptr++;tt}t}tcptr->lexeme = NULL;tPG_RETURN_POINTER(res);}",2,"cwe120,cweother"
"set_date_label(void){   struct tm now;   char str[50];   char datef[50];   const char *svalue;   now.tm_sec=0;   now.tm_min=0;   now.tm_hour=11;   now.tm_isdst=-1;   now.tm_wday=0;   now.tm_yday=0;   now.tm_mday = current_day;   now.tm_mon = current_month;   now.tm_year = current_year;   mktime(&now);   get_pref(PREF_LONGDATE, NULL, &svalue);   if (svalue==NULL) {      strcpy(datef, ""%x"");   } else {      sprintf(datef, _(""%%a., %s""), svalue);   }        if (now.tm_mday == get_highlighted_today(&now))      strcat(datef, _("" (TODAY)""));    jp_strftime(str, sizeof(str), datef, &now);   gtk_label_set_text(GTK_LABEL(dow_label), str);}",2,"cwe119,cwe120"
"cbf_write_itemname (cbf_handle handle, const cbf_node *column, cbf_file *file)    {        char itemname[81];                char buffer[255];                char * temptag;                                 if ( cbf_compose_itemname (handle, column, itemname, (size_t )80)) {                        strcpy (itemname+77,""..."");                        sprintf (buffer, ""output line %u(%u) column name too long or invalid         converted to ""%s"""",                     1+file->line, 1+file->column,                     itemname);                        cbf_log(handle,buffer,CBF_LOGWARNING|CBF_LOGCURRENTLOC);                    }                cbf_failnez( cbf_require_tag_root(handle,(const char *)itemname,(const char **)&temptag))                                                         cbf_failnez (cbf_write_string (file, temptag))                                         return 0;    }",2,"cwe119,cwe120"
"get_random(){tstatic uint8_t buf[128];tstatic int pos = 0;tint r;tif (pos == 0)ttread(urandom_fd, buf, 128);ttr = buf[pos++];tif (pos == 128)ttpos = 0;ttreturn r;}",2,"cwe120,cweother"
from_sdf_tctyp(int32 sdf_tctyp){ switch ((byte) sdf_tctyp) {  case SDF_SETUP: return(TCHK_SETUP);  case SDF_HOLD: return(TCHK_HOLD);  case SDF_RECOVERY: return(TCHK_RECOVERY);  case SDF_SKEW: return(TCHK_SKEW);  case SDF_SETUPHOLD: return(TCHK_SETUPHOLD);  case SDF_NOCHANGE: return(TCHK_NOCHANGE);  case SDF_WIDTH: return(TCHK_WIDTH);   case SDF_PERIOD: return(TCHK_PERIOD);     case SDF_FULLSKEW: return(TCHK_FULLSKEW);  case SDF_REMOVAL: return(TCHK_REMOVAL);  case SDF_RECREM: return(TCHK_RECREM);  case SDF_TIMESKEW: return(TCHK_TIMESKEW); } return(-1);},2,"cwe119,cwe120"
"main_loop (int local_in, int local_out, int sock) { int    len = 1; char   buf[1024]; fd_set sl; struct timeval tv; int maxfh = (local_in > sock ? local_in : sock) + 1; while (len > 0) {  FD_ZERO(&sl);  FD_SET(local_in, &sl);  FD_SET(sock, &sl);  tv.tv_sec  = 1;  tv.tv_usec = 0;  if (select(maxfh, &sl, NULL, NULL, &tv) > 0) {   if ( FD_ISSET(sock, &sl) ) {    if ( (len = read(sock, buf, 1024)) == -1 )     return -1;    if ( write(local_out, buf, len) != len )     return -1;   } else {    if ( (len = read(local_in, buf, 1024)) == -1 )     return -1;    if ( write(sock, buf, len) != len )     return -1;   }  } } return 0;}",4,"cwe119,cwe120,cwe476,cweother"
"get_xpm_stuff( IconInfo * in,               FILE     * fp ){    char buf[ 128 ],         *p;    int done = 0;    while ( fgets( buf, sizeof buf - 1, fp ) && ! done )    {        if ( ( p = strstr( buf, ""static char"" ) ) )        {            char *q = in->data;            *p += 11;            while ( *p && *++p != '*' )                  ;            while ( *p && *++p != '[' )                  if ( ! isspace( ( int ) *p ) )                    *q++ = *p;            *q = '0';        }    }}",2,"cwe119,cwe120"
"_free_data(E_Config_Dialog *cfd, E_Config_Dialog_Data *cfdata){   const char *bg_file = NULL;   if (cfdata->bg) bg_file = strdup(cfdata->bg);   E_FREE(cfdata->bg);   E_FREE(cfdata);   e_int_config_desklock_fsel_done(cfd->data, e_object_data_get(E_OBJECT(cfd)), bg_file);}",2,"cwe119,cwe120"
"edfwrite_annotation_latin1(int handle, long long onset, long long duration, const char *description){  struct edf_write_annotationblock *list_annot,                                   *tmp_annot;  char str[EDFLIB_WRITE_MAX_ANNOTATION_LEN + 1];  if(handle<0)  {    return(-1);  }  if(handle>=EDFLIB_MAXFILES)  {    return(-1);  }  if(hdrlist[handle]==NULL)  {    return(-1);  }  if(!(hdrlist[handle]->writemode))  {    return(-1);  }  if(onset<0LL)  {    return(-1);  }  list_annot = (struct edf_write_annotationblock *)calloc(1, sizeof(struct edf_write_annotationblock));  if(list_annot==NULL)  {    return(-1);  }  list_annot->onset = onset;  list_annot->duration = duration;  strncpy(str, description, EDFLIB_WRITE_MAX_ANNOTATION_LEN);  str[EDFLIB_WRITE_MAX_ANNOTATION_LEN] = 0;  edflib_latin12utf8(str, strlen(str));  strncpy(list_annot->annotation, str, EDFLIB_WRITE_MAX_ANNOTATION_LEN);  list_annot->annotation[EDFLIB_WRITE_MAX_ANNOTATION_LEN] = 0;  list_annot->next_annotation = NULL;  list_annot->former_annotation = NULL;  if(write_annotationslist[handle]==NULL)  {    write_annotationslist[handle] = list_annot;  }  else  {    tmp_annot = write_annotationslist[handle];    while(tmp_annot->next_annotation!=NULL)    {      tmp_annot = tmp_annot->next_annotation;    }    tmp_annot->next_annotation = list_annot;    list_annot->former_annotation = tmp_annot;  }  return(0);}",2,"cwe119,cwe120"
"pidfile_create(const char *pidFile, pid_t pid){tchar buf[20];tstruct flock lock;tint fd, value;tif((fd = open(pidFile, O_WRONLY | O_CREAT,tt       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH))) < 0) {ttcondlog(0, ""Cannot open pidfile [%s], error was [%s]"",tttpidFile, strerror(errno));ttreturn 1;t}tlock.l_type = F_WRLCK;tlock.l_start = 0;tlock.l_whence = SEEK_SET;tlock.l_len = 0;tif (fcntl(fd, F_SETLK, &lock) < 0) {ttif (errno != EACCES && errno != EAGAIN)tttcondlog(0, ""Cannot lock pidfile [%s], error was [%s]"",ttttpidFile, strerror(errno));ttelsetttcondlog(0, ""process is already running"");ttgoto fail;t}tif (ftruncate(fd, 0) < 0) {ttcondlog(0, ""Cannot truncate pidfile [%s], error was [%s]"",tttpidFile, strerror(errno));ttgoto fail;t}tmemset(buf, 0, sizeof(buf));tsnprintf(buf, sizeof(buf)-1, ""%u"", pid);tif (write(fd, buf, strlen(buf)) != strlen(buf)) {ttcondlog(0, ""Cannot write pid to pidfile [%s], error was [%s]"",tttpidFile, strerror(errno));ttgoto fail;t}tif ((value = fcntl(fd, F_GETFD, 0)) < 0) {ttcondlog(0, ""Cannot get close-on-exec flag from pidfile [%s], ""ttt""error was [%s]"", pidFile, strerror(errno));ttgoto fail;t}tvalue |= FD_CLOEXEC;tif (fcntl(fd, F_SETFD, value) < 0) {ttcondlog(0, ""Cannot set close-on-exec flag from pidfile [%s], ""ttt""error was [%s]"", pidFile, strerror(errno));ttgoto fail;t}treturn 0;fail:tclose(fd);treturn 1;}",3,"cwe119,cwe120,cweother"
"HpmfwupgValidateImageIntegrity(struct HpmfwupgUpgradeCtx* pFwupgCtx){   int rc = HPMFWUPG_SUCCESS;   struct HpmfwupgImageHeader* pImageHeader = (struct HpmfwupgImageHeader*)                                                         pFwupgCtx->pImageData;   md5_state_t ctx;tstatic unsigned char md[HPMFWUPG_MD5_SIGNATURE_LENGTH];   unsigned char* pMd5Sig = pFwupgCtx->pImageData +                            (pFwupgCtx->imageSize -                             HPMFWUPG_MD5_SIGNATURE_LENGTH);                                                    memset(md, 0, HPMFWUPG_MD5_SIGNATURE_LENGTH);   memset(&ctx, 0, sizeof(md5_state_t));   md5_init(&ctx);   md5_append(&ctx, pFwupgCtx->pImageData, pFwupgCtx->imageSize -                                            HPMFWUPG_MD5_SIGNATURE_LENGTH);   md5_finish(&ctx, md);   if ( memcmp(md, pMd5Sig,HPMFWUPG_MD5_SIGNATURE_LENGTH) != 0 )   {      lprintf(LOG_NOTICE,""    Invalid MD5 signature"");      rc = HPMFWUPG_ERROR;   }      if ( rc == HPMFWUPG_SUCCESS )   {             if( strncmp(pImageHeader->signature, HPMFWUPG_IMAGE_SIGNATURE, HPMFWUPG_HEADER_SIGNATURE_LENGTH) == 0 )      {                   if ( pImageHeader->formatVersion == HPMFWUPG_IMAGE_HEADER_VERSION )         {                         if ( HpmfwupgCalculateChecksum((unsigned char*)pImageHeader,                                            sizeof(struct HpmfwupgImageHeader) +                                            pImageHeader->oemDataLength +                                            sizeof(unsigned char) ) != 0 )            {               lprintf(LOG_NOTICE,""    Invalid header checksum"");               rc = HPMFWUPG_ERROR;            }         }         else         {            lprintf(LOG_NOTICE,""    Unrecognized image version"");            rc = HPMFWUPG_ERROR;         }      }      else      {         lprintf(LOG_NOTICE,""    Invalid image signature"");         rc = HPMFWUPG_ERROR;      }   }   return rc;}",2,"cwe119,cwe120"
"snd_intel8x0_pcm1(struct intel8x0 *chip, int device,ttt     struct ich_pcm_table *rec){tstruct snd_pcm *pcm;tint err;tchar name[32];tif (rec->suffix)ttsprintf(name, ""Intel ICH - %s"", rec->suffix);telsettstrcpy(name, ""Intel ICH"");terr = snd_pcm_new(chip->card, name, device,ttt  rec->playback_ops ? 1 : 0,ttt  rec->capture_ops ? 1 : 0, &pcm);tif (err < 0)ttreturn err;tif (rec->playback_ops)ttsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, rec->playback_ops);tif (rec->capture_ops)ttsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, rec->capture_ops);tpcm->private_data = chip;tpcm->info_flags = 0;tif (rec->suffix)ttsprintf(pcm->name, ""%s - %s"", chip->card->shortname, rec->suffix);telsettstrcpy(pcm->name, chip->card->shortname);tchip->pcm[device] = pcm;tsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,ttttt      snd_dma_pci_data(chip->pci),ttttt      rec->prealloc_size, rec->prealloc_max_size);tif (rec->playback_ops &&t    rec->playback_ops->open == snd_intel8x0_playback_open) {ttstruct snd_pcm_chmap *chmap;ttint chs = 2;ttif (chip->multi8)tttchs = 8;ttelse if (chip->multi6)tttchs = 6;ttelse if (chip->multi4)tttchs = 4;tterr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,ttttt     snd_pcm_alt_chmaps, chs, 0,ttttt     &chmap);ttif (err < 0)tttreturn err;ttchmap->channel_mask = SND_PCM_CHMAP_MASK_2468;ttchip->ac97[0]->chmaps[SNDRV_PCM_STREAM_PLAYBACK] = chmap;t}treturn 0;}",2,"cwe119,cwe120"
"read_atoms_labels(FILE* file){tgint len = BSIZE;tgchar buffer[BSIZE];tgchar buffer1[BSIZE];tgint i;t tif(!fgets(buffer,len,file))return FALSE;tif(Ncenters<1)ttreturn FALSE;tfor(i=0;i<Ncenters;i++)t{ttif(!fgets(buffer,len,file))return FALSE;ttif(1 != sscanf(buffer,""%s"",buffer1))tttreturn FALSE;ttif(!fgets(buffer,len,file))return FALSE;  ttGeomOrb[i].Symb = g_strdup(buffer1);tt ttGeomOrb[i].Prop = prop_atom_get(GeomOrb[i].Symb);ttGeomOrb[i].partialCharge = 0.0;ttGeomOrb[i].variable = TRUE;ttGeomOrb[i].nuclearCharge = get_atomic_number_from_symbol(GeomOrb[i].Symb);t}treturn TRUE;}",2,"cwe120,cweother"
"glk_main (){tif (gStartupError)ttfatalError(gStartupError);    if (gStream == NULL)        fatalError (""could not open game file"");tgHasInited = 1;    gitWithStream (gStream, CACHE_SIZE, UNDO_SIZE);}",2,"cwe120,cweother"
"doHourlyLoad(EventSelector *es, int fd, int cmd){    int msgs_1, msgs_4, msgs_12, msgs_24;    double ams_1, ams_4, ams_12, ams_24;    double avg_1, avg_4, avg_12, avg_24;    int secs_1, secs_4, secs_12, secs_24;    int slaves, ms;    char ans[1024];    time_t now = time(NULL);    get_hourly_history_totals(cmd, now, 1, &msgs_1, &slaves, &ms, &secs_1);    if (msgs_1) {tavg_1 = ((double) slaves) / ((double) msgs_1);tams_1 = ((double) ms) / ((double) msgs_1);    } else {tavg_1 = 0.0;tams_1 = 0.0;    }    get_hourly_history_totals(cmd, now, 4, &msgs_4, &slaves, &ms, &secs_4);    if (msgs_4) {tavg_4 = ((double) slaves) / ((double) msgs_4);tams_4 = ((double) ms) / ((double) msgs_4);    } else {tavg_4 = 0.0;tams_4 = 0.0;    }    get_hourly_history_totals(cmd, now, 12, &msgs_12, &slaves, &ms, &secs_12);    if (msgs_12) {tavg_12 = ((double) slaves) / ((double) msgs_12);tams_12 = ((double) ms) / ((double) msgs_12);    } else {tavg_12 = 0.0;tams_12 = 0.0;    }    get_hourly_history_totals(cmd, now, 24, &msgs_24, &slaves, &ms, &secs_24);    if (msgs_24) {tavg_24 = ((double) slaves) / ((double) msgs_24);tams_24 = ((double) ms) / ((double) msgs_24);    } else {tavg_24 = 0.0;tams_24 = 0.0;    }    snprintf(ans, sizeof(ans), ""%d %d %d %d %f %f %f %f %f %f %f %f %d %d %d %d"",t     msgs_1, msgs_4, msgs_12, msgs_24,t     avg_1, avg_4, avg_12, avg_24,t     ams_1, ams_4, ams_12, ams_24,t     secs_1, secs_4, secs_12, secs_24);    reply_to_mimedefang(es, fd, ans);}",2,"cwe119,cwe120"
"""init_netaddr(struct in_addr *net, const char *string){tchar *p;tif ((p = strchr(string, '/')) != NULL) {ttchar *host = xallocc(p - string + 1);ttmemcpy(host, string, p - string + 1);tthost[p - string] = '0';ttinit_sockaddr((struct in_addr *)net, host);ttfree(host);ttif (strchr(p + 1, '.') != NULL)tttinit_sockaddr(net + 1, p + 1);ttelse {tttint bits = atoi(p + 1);tttunsigned long mask = (1 << bits) - 1;tttmemcpy((char *)(net + 1), (char *)&mask, 4);tt}t} else {ttmemset((char *)net, 0, 8);t}}""",2,"cwe120,cweother"
"net_resolve (netstore * ns, char *hostname, int port, char **real_host){tstruct addrinfo hints;tchar ipstring[MAX_HOSTNAME];tchar portstring[MAX_HOSTNAME];tint ret; tsprintf (portstring, ""%d"", port);tmemset (&hints, 0, sizeof (struct addrinfo));thints.ai_family = PF_UNSPEC;  thints.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;thints.ai_socktype = SOCK_STREAM;tif (port == 0)ttret = getaddrinfo (hostname, NULL, &hints, &ns->ip6_hostent);telsettret = getaddrinfo (hostname, portstring, &hints, &ns->ip6_hostent);tif (ret != 0)ttreturn NULL;#ifdef LOOKUPDt tstruct addrinfo *tmp;tint count = 0;tfor (tmp = ns->ip6_hostent; tmp; tmp = tmp->ai_next)ttcount ++;tcount = RAND_INT(count);ttwhile (count--) ns->ip6_hostent = ns->ip6_hostent->ai_next;#endift tipstring[0] = 0;tgetnameinfo (ns->ip6_hostent->ai_addr, ns->ip6_hostent->ai_addrlen,ttttt ipstring, sizeof (ipstring), NULL, 0, NI_NUMERICHOST);tif (ns->ip6_hostent->ai_canonname)tt*real_host = strdup (ns->ip6_hostent->ai_canonname);telsett*real_host = strdup (hostname);treturn strdup (ipstring);}",2,"cwe119,cwe120"
"knet_read(knetFile *fp, void *buf, off_t len){toff_t l = 0;tif (fp->fd == -1) return 0;tif (fp->type == KNF_TYPE_FTP) {ttif (fp->is_ready == 0) {tttif (!fp->no_reconnect) kftp_reconnect(fp);tttkftp_connect_file(fp);tt}t} else if (fp->type == KNF_TYPE_HTTP) {ttif (fp->is_ready == 0)tttkhttp_connect_file(fp);t}tif (fp->type == KNF_TYPE_LOCAL) {  ttoff_t rest = len, curr;ttwhile (rest) {tttdo {ttttcurr = read(fp->fd, buf + l, rest);ttt} while (curr < 0 && EINTR == errno);tttif (curr < 0) return -1;tttif (curr == 0) break;tttl += curr; rest -= curr;tt}t} else l = my_netread(fp->fd, buf, len);tfp->offset += l;treturn l;}",2,"cwe120,cweother"
"finished_digest(SSL *ssl, const char *label, uint8_t *digest){    uint8_t mac_buf[128];     uint8_t *q = mac_buf;    MD5_CTX md5_ctx = ssl->dc->md5_ctx;    SHA1_CTX sha1_ctx = ssl->dc->sha1_ctx;    if (label)    {        strcpy((char *)q, label);        q += strlen(label);    }    MD5_Final(q, &md5_ctx);    q += MD5_SIZE;        SHA1_Final(q, &sha1_ctx);    q += SHA1_SIZE;    if (label)    {        prf(ssl->dc->master_secret, SSL_SECRET_SIZE, mac_buf, (int)(q-mac_buf),            digest, SSL_FINISHED_HASH_SIZE);    }    else         {        memcpy(digest, mac_buf, MD5_SIZE + SHA1_SIZE);    }#if 0    printf(""label: %s"", label);    print_blob(""master secret"", ssl->dc->master_secret, 48);    print_blob(""mac_buf"", mac_buf, q-mac_buf);    print_blob(""finished digest"", digest, SSL_FINISHED_HASH_SIZE);#endif}",2,"cwe120,cweother"
"""repo_init_structure(repo_init *results){tconst int mode = 0755; /* or 0777 ? */tchar temp_path[GIT_PATH_MAX];tint path_len;tchar *git_dir = results->path_repository;tif (gitfo_mkdir_recurs(git_dir, mode))ttreturn GIT_ERROR;tpath_len = strlen(git_dir);tstrcpy(temp_path, git_dir);t/* Does HEAD file already exist ? */tstrcpy(temp_path + path_len, GIT_HEAD_FILE);tif (gitfo_exists(temp_path) == GIT_SUCCESS)ttreturn repo_init_reinit(results);tif (repo_init_createhead(temp_path) < GIT_SUCCESS)ttreturn GIT_ERROR;t/* Creates the '/objects/' directory */tstrcpy(temp_path + path_len, GIT_OBJECTS_DIR);tif (gitfo_mkdir(temp_path, mode))ttreturn GIT_ERROR;t/* Creates the '/refs/' directory */tstrcpy(temp_path + path_len, GIT_REFS_DIR);tif (gitfo_mkdir(temp_path, mode))ttreturn GIT_ERROR;t/* Creates the '/refs/heads/' directory */tstrcpy(temp_path + path_len, GIT_REFS_HEADS_DIR);tif (gitfo_mkdir(temp_path, mode))ttreturn GIT_ERROR;t/* Creates the '/refs/tags/' directory */tstrcpy(temp_path + path_len, GIT_REFS_TAGS_DIR);tif (gitfo_mkdir(temp_path, mode))ttreturn GIT_ERROR;t/* TODO: what's left? templates? */treturn GIT_SUCCESS;}""",2,"cwe119,cwe120"
"GResourceSetProg(char *prog) {    char filename[1025], *pt;    extern char *_GFile_find_program_dir(char *prog);    if ( prog!=NULL ) {tif ( GResourceProgramName!=NULL && strcmp(prog,GResourceProgramName)==0 )return;tgfree(GResourceProgramName);tif (( pt=strrchr(prog,'/'))!=NULL )t    ++pt;telset    pt = prog;tGResourceProgramName = copy(pt);    } else if ( GResourceProgramName==NULL )tGResourceProgramName = copy(""gdraw"");    elsereturn;    gfree(GResourceProgramDir);    GResourceProgramDir = _GFile_find_program_dir(prog);    if ( GResourceProgramDir==NULL ) {tGFileGetAbsoluteName(""."",filename,sizeof(filename));tGResourceProgramDir = copy(filename);    }    gfree(GResourceFullProgram);    GResourceFullProgram = copy(t    GFileBuildName(GResourceProgramDir,GResourceProgramName,filename,sizeof(filename)));}",2,"cwe119,cwe120"
"guestimate_outlet_count(const char *OID_template){tint base_index = 0;tchar test_OID[SU_INFOSIZE];tint base_count;tupsdebugx(1, ""guestimate_outlet_count(%s)"", OID_template);t tsprintf(test_OID, OID_template, base_index);tif (nut_snmp_get(test_OID) == NULL)ttbase_index++;t tfor (base_count = 0 ;  ; base_count++) {ttsprintf(test_OID, OID_template, base_index + base_count);ttif (nut_snmp_get(test_OID) == NULL)tttbreak;t}tupsdebugx(3, ""guestimate_outlet_count: %i"", base_count);treturn base_count;}",3,"cwe119,cwe120,cweother"
"test_enum(hid_t UNUSED fid, const char * string){     typedef enum {    E1_RED,    E1_GREEN,    E1_BLUE,    E1_WHITE  } c_e1;     c_e1 val;  herr_t ret;  hid_t type_id;  char readbuf[MAX_STRING_LENGTH];     type_id = H5Tcreate(H5T_ENUM, sizeof(c_e1));  CHECK(type_id, FAIL, ""H5Tcreate"");  val = E1_RED;  ret = H5Tenum_insert(type_id, ""RED"", &val);  CHECK(ret, FAIL, ""H5Tenum_insert"");  val = E1_GREEN;  ret = H5Tenum_insert(type_id, ""GREEN"", &val);  CHECK(ret, FAIL, ""H5Tenum_insert"");  val = E1_BLUE;  ret = H5Tenum_insert(type_id, ""BLUE"", &val);  CHECK(ret, FAIL, ""H5Tenum_insert"");  val = E1_WHITE;  ret = H5Tenum_insert(type_id, string, &val);  CHECK(ret, FAIL, ""H5Tenum_insert"");     ret = H5Tenum_valueof(type_id, string, &val);  CHECK(ret, FAIL, ""H5Tenum_valueof"");  VERIFY(val, E1_WHITE, ""H5Tenum_valueof"");  ret = H5Tenum_nameof(type_id, &val, readbuf, (size_t)MAX_STRING_LENGTH);  CHECK(ret, FAIL, ""H5Tenum_nameof"");  ret = strcmp(readbuf, string);  VERIFY(ret, 0, ""strcmp"");     ret = H5Tclose(type_id);  CHECK(ret, FAIL, ""H5Tclose"");}",2,"cwe119,cwe120"
"writeDriverDescriptorMap(int pNum, AbstractFile* file, DriverDescriptorRecord* DDM, unsigned int BlockSize, ChecksumFunc dataForkChecksum, void* dataForkToken,ttttResourceKey **resources) {  AbstractFile* bufferFile;  BLKXTable* blkx;  ChecksumToken uncompressedToken;  DriverDescriptorRecord* buffer;    buffer = (DriverDescriptorRecord*) malloc(DDM_SIZE * BlockSize);  memcpy(buffer, DDM, DDM_SIZE * BlockSize);  memset(&uncompressedToken, 0, sizeof(uncompressedToken));    flipDriverDescriptorRecord(buffer, TRUE);  bufferFile = createAbstractFileFromMemory((void**)&buffer, DDM_SIZE * BlockSize);    blkx = insertBLKX(file, bufferFile, DDM_OFFSET, DDM_SIZE, DDM_DESCRIPTOR, CHECKSUM_CRC32, &CRCProxy, &uncompressedToken,tttdataForkChecksum, dataForkToken, NULL, 0);                blkx->checksum.data[0] = uncompressedToken.crc;    char pName[100];  sprintf(pName, ""Driver Descriptor Map (DDM : %d)"", pNum + 1);t  *resources = insertData(*resources, ""blkx"", pNum, pName, (const char*) blkx, sizeof(BLKXTable) + (blkx->blocksRunCount * sizeof(BLKXRun)), ATTRIBUTE_HDIUTIL);    free(buffer);  bufferFile->close(bufferFile);  free(blkx);  pNum++;  if((DDM_SIZE * BlockSize / SECTOR_SIZE) - DDM_SIZE > 0)    pNum = writeFreePartition(pNum, file, DDM_SIZE, (DDM_SIZE * BlockSize / SECTOR_SIZE) - DDM_SIZE, resources);  return pNum;}",2,"cwe119,cwe120"
"packet_add_int_parm(struct packet *packet, int parmno, long value, SMSCConn *conn){    char buf[128];    Octstr *valuestr;    gw_assert(parm_in_range(parmno, value));    sprintf(buf, ""%ld"", value);    valuestr = octstr_create(buf);    packet_add_parm(packet, P_INT, parmno, valuestr, conn);    octstr_destroy(valuestr);}",2,"cwe119,cwe120"
"do_btrfs_filesystem_sync (const char *fs){  const size_t MAX_ARGS = 64;  const char *argv[MAX_ARGS];  size_t i = 0;  CLEANUP_FREE char *fs_buf = NULL;  CLEANUP_FREE char *err = NULL;  int r;  fs_buf = sysroot_path (fs);  if (fs_buf == NULL) {    reply_with_perror (""malloc"");    return -1;  }  ADD_ARG (argv, i, str_btrfs);  ADD_ARG (argv, i, ""filesystem"");  ADD_ARG (argv, i, ""sync"");  ADD_ARG (argv, i, fs_buf);  ADD_ARG (argv, i, NULL);  r = commandv (NULL, &err, argv);  if (r == -1) {    reply_with_error (""%s: %s"", fs, err);    return -1;  }  return 0;}",2,"cwe119,cwe120"
"AlterDatabase(AlterDatabaseStmt *stmt){tRelationtrel;tHeapTuplettuple,ttttnewtuple;tScanKeyData scankey;tSysScanDesc scan;tListCell   *option;tinttttconnlimit = -1;tDefElem    *dconnlimit = NULL;tDatumttnew_record[Natts_pg_database];tcharttnew_record_nulls[Natts_pg_database];tcharttnew_record_repl[Natts_pg_database];t tforeach(option, stmt->options)t{ttDefElem    *defel = (DefElem *) lfirst(option);ttif (strcmp(defel->defname, ""connectionlimit"") == 0)tt{tttif (dconnlimit)ttttereport(ERROR,tttttt(errcode(ERRCODE_SYNTAX_ERROR),tttttt errmsg(""conflicting or redundant options"")));tttdconnlimit = defel;tt}ttelsetttelog(ERROR, ""option ""%s"" not recognized"",tttt defel->defname);t}tif (dconnlimit)ttconnlimit = intVal(dconnlimit->arg);t trel = heap_open(DatabaseRelationId, RowExclusiveLock);tScanKeyInit(&scankey,ttttAnum_pg_database_datname,ttttBTEqualStrategyNumber, F_NAMEEQ,ttttNameGetDatum(stmt->dbname));tscan = systable_beginscan(rel, DatabaseNameIndexId, true,ttttttt  SnapshotNow, 1, &scankey);ttuple = systable_getnext(scan);tif (!HeapTupleIsValid(tuple))ttereport(ERROR,tttt(errcode(ERRCODE_UNDEFINED_DATABASE),tttt errmsg(""database ""%s"" does not exist"", stmt->dbname)));tif (!pg_database_ownercheck(HeapTupleGetOid(tuple), GetUserId()))ttaclcheck_error(ACLCHECK_NOT_OWNER, ACL_KIND_DATABASE,ttttt   stmt->dbname);t tMemSet(new_record, 0, sizeof(new_record));tMemSet(new_record_nulls, ' ', sizeof(new_record_nulls));tMemSet(new_record_repl, ' ', sizeof(new_record_repl));tif (dconnlimit)t{ttnew_record[Anum_pg_database_datconnlimit - 1] = Int32GetDatum(connlimit);ttnew_record_repl[Anum_pg_database_datconnlimit - 1] = 'r';t}tnewtuple = heap_modifytuple(tuple, RelationGetDescr(rel), new_record,ttttttttnew_record_nulls, new_record_repl);tsimple_heap_update(rel, &tuple->t_self, newtuple);t tCatalogUpdateIndexes(rel, newtuple);tsystable_endscan(scan);t theap_close(rel, NoLock);t }",4,"cwe119,cwe120,cwe476,cwe469"
"""canonicalize(char *original, char *resolved, int len){    if (len < PATH_MAX) {        errno = EINVAL;        return -1;    }    if (strlen(original) > PATH_MAX) {        errno = ENAMETOOLONG;        return -1;    }    /* First try realpath() on the entire path */    if (realpath(original, resolved)) {        /* That worked, so return it */        collapse(resolved);        return 0;    }    else {        /* Something's bogus in the original path, so remove names from the end           until either some subpath works or we run out of names */        char *p, *end, *r = NULL;        char path[PATH_MAX + 1];        strncpy(path, original, sizeof(path));        if (path[PATH_MAX] != '0') {            errno = ENAMETOOLONG;            return -1;        }        end = path + strlen(path);        for (p = end; p > path;) {            /* Skip last element */            while ((--p > path) && (*p != '/'));            if (p == path) break;            /* Try realpath() on this subpath */            *p = '0';            r = realpath(path, resolved);            *p = (p == end) ? '0' : '/';            if (r != NULL) {                /* The subpath has a canonical path */                break;            }            else if (errno == ENOENT || errno == ENOTDIR || errno == EACCES) {                /* If the lookup of a particular subpath fails because the file                   does not exist, because it is of the wrong type, or because                   access is denied, then remove its last name and try again.                   Other I/O problems cause an error return. */                continue;            }            else {                return -1;            }        }        if (r != NULL) {            /* Append unresolved subpath to resolved subpath */            int rn = strlen(r);            if (rn + (int)strlen(p) >= len) {                /* Buffer overflow */                errno = ENAMETOOLONG;                return -1;            }            if ((rn > 0) && (r[rn - 1] == '/') && (*p == '/')) {                /* Avoid duplicate slashes */                p++;            }            strcpy(r + rn, p);            collapse(r);            return 0;        }        else {            /* Nothing resolved, so just return the original path */            strcpy(resolved, path);            collapse(resolved);            return 0;        }    }}""",2,"cwe119,cwe120"
"warn_if_metadata_device_too_big(struct block_device *bdev){tsector_t metadata_dev_size = get_dev_size(bdev);tchar buffer[BDEVNAME_SIZE];tif (metadata_dev_size > THIN_METADATA_MAX_SECTORS_WARNING)ttDMWARN(""Metadata device %s is larger than %u sectors: excess space will not be used."",tt       bdevname(bdev, buffer), THIN_METADATA_MAX_SECTORS);}",2,"cwe119,cwe120"
"emit_relocs(int as_text){tint i;t treloc_count = 0;twalk_relocs(count_reloc);trelocs = malloc(reloc_count * sizeof(relocs[0]));tif (!relocs) {ttdie(""malloc of %d entries for relocs failed"",tttreloc_count);t}t treloc_idx = 0;twalk_relocs(collect_reloc);t tqsort(relocs, reloc_count, sizeof(relocs[0]), cmp_relocs);t tif (as_text) {tt ttprintf("".section "".data.reloc"",""a"""");ttprintf("".balign 4"");ttfor (i = 0; i < reloc_count; i++) {tttprintf(""t .long 0x%08lx"", relocs[i]);tt}ttprintf("""");t}telse {ttunsigned char buf[4];tt ttfor (i = 0; i < reloc_count; i++) {tttbuf[0] = (relocs[i] >>  0) & 0xff;tttbuf[1] = (relocs[i] >>  8) & 0xff;tttbuf[2] = (relocs[i] >> 16) & 0xff;tttbuf[3] = (relocs[i] >> 24) & 0xff;tttfwrite(buf, 4, 1, stdout);tt}tt ttmemset(buf, 0, sizeof buf);ttfwrite(buf, 4, 1, stdout);t}}",3,"cwe119,cwe120,cweother"
"client3_1_opendir (call_frame_t *frame, xlator_t *this,                   void *data){        clnt_local_t     *local    = NULL;        clnt_conf_t      *conf     = NULL;        clnt_args_t      *args     = NULL;        gfs3_opendir_req  req      = {{0,},};        int               ret      = 0;        int               op_errno = ESTALE;        if (!frame || !this || !data)                goto unwind;        args = data;        local = GF_CALLOC (1, sizeof (*local), gf_client_mt_clnt_local_t);        if (!local) {                op_errno = ENOMEM;                goto unwind;        }        if (!(args->loc && args->loc->inode))                goto unwind;        local->fd = fd_ref (args->fd);        loc_copy (&local->loc, args->loc);        frame->local = local;        if (!uuid_is_null (args->loc->inode->gfid))                memcpy (req.gfid,  args->loc->inode->gfid, 16);        else                memcpy (req.gfid, args->loc->gfid, 16);        GF_ASSERT_AND_GOTO_WITH_ERROR (this->name,                                       !uuid_is_null (*((uuid_t*)req.gfid)),                                       unwind, op_errno, EINVAL);        req.path = (char *)args->loc->path;        conf = this->private;        ret = client_submit_request (this, &req, frame, conf->fops,                                     GFS3_OP_OPENDIR, client3_1_opendir_cbk,                                     NULL, NULL, 0, NULL, 0, NULL,                                     (xdrproc_t)xdr_gfs3_opendir_req);        if (ret) {                op_errno = ENOTCONN;                goto unwind;        }        return 0;unwind:        gf_log (this->name, GF_LOG_WARNING, ""failed to send the fop: %s"", strerror (op_errno));        if (frame)                frame->local = NULL;        STACK_UNWIND_STRICT (opendir, frame, -1, op_errno, NULL);        client_local_wipe (local);        return 0;}",2,"cwe120,cwe476"
"uwb_rsv_dump(char *text, struct uwb_rsv *rsv){tstruct device *dev = &rsv->rc->uwb_dev.dev;tstruct uwb_dev_addr devaddr;tchar owner[UWB_ADDR_STRSIZE], target[UWB_ADDR_STRSIZE];tuwb_dev_addr_print(owner, sizeof(owner), &rsv->owner->dev_addr);tif (rsv->target.type == UWB_RSV_TARGET_DEV)ttdevaddr = rsv->target.dev->dev_addr;telsettdevaddr = rsv->target.devaddr;tuwb_dev_addr_print(target, sizeof(target), &devaddr);tdev_dbg(dev, ""rsv %s %s -> %s: %s"",tttext, owner, target, uwb_rsv_state_str(rsv->state));}",2,"cwe119,cwe120"
"ui_draw_status_timeonly(void){static char buf[32];if(!window) return;g_snprintf(buf,sizeof(buf),""%2d:%02d"",tunetime.min,tunetime.sec);gtk_label_set_text(GTK_LABEL(label_for_time),buf);}",2,"cwe119,cwe120"
"proc_status_get(sigar_t *sigar, sigar_pid_t pid,                           sigar_proc_state_t *procstate){    char buffer[BUFSIZ], *ptr;    int status = SIGAR_PROC_FILE2STR(buffer, pid, PROC_PSTATUS);    if (status != SIGAR_OK) {        return status;    }    ptr = strstr(buffer, ""Threads:"");    if (ptr) {                 ptr = sigar_skip_token(ptr);        procstate->threads = sigar_strtoul(ptr);    }    else {        procstate->threads = SIGAR_FIELD_NOTIMPL;    }    return SIGAR_OK;}",2,"cwe119,cwe120"
"logger_queue_init(void){tast_unload_realtime(""queue_log"");tif (logfiles.queue_log) {ttchar qfname[PATH_MAX];ttif (logger_queue_rt_start()) {tttreturn;tt}tt ttsnprintf(qfname, sizeof(qfname), ""%s/%s"", ast_config_AST_LOG_DIR,tttqueue_log_name);ttif (qlog) {ttt tttfclose(qlog);tt}ttqlog = fopen(qfname, ""a"");ttif (!qlog) {tttast_log(LOG_ERROR, ""Unable to create queue log: %s"", strerror(errno));tt}t}}",3,"cwe119,cwe120,cweother"
"confucius_copy_file (char *infile, char *outfile, int plain){  FILE *in;  int in_is_stdin = 0;  FILE *out;  int out_is_stdout = 0;  char data[CONFUCIUS_BUFSIZE];  ssize_t data_len;  if (infile[0] == '-' && infile[1] == '0')    {             in = stdin;      in_is_stdin = 1;    }  else    {      in = fopen (infile, ""rb"");      if (!in)t{t  log_error (_(""could not open %s for writing: %s""),tt     infile, strerror (errno));t  return 1;t}    }  if (outfile[0] == '-' && outfile[1] == '0')    {             out = stdout;      out_is_stdout = 1;    }  else    {      out = fopen (outfile, ""wb"");      if (!out)t{t  log_error (_(""could not open %s for writing: %s""),tt     infile, strerror (errno));t  return 1;t}    }     while ((data_len = fread (data, 1, sizeof (data), in)) > 0)    {      if (fwrite (data, 1, data_len, out) != data_len)t{t  log_error (_(""error writing to %s: %s""), outfile,tt     strerror (errno));t  goto copy_err;t}    }  if (data_len < 0 || ferror (in))    {      log_error (_(""error reading from %s: %s""), infile, strerror (errno));      goto copy_err;    }     if (!in_is_stdin && fclose (in) && ferror (in))    {      log_error (_(""error closing %s: %s""), infile, strerror (errno));      goto copy_err;    }     if (!out_is_stdout && fclose (out) && ferror (out))    {      log_error (_(""error closing %s: %s""), infile, strerror (errno));      goto copy_err;    }  return 0; copy_err:  if (!out_is_stdout)    remove_file (outfile, plain);  return 1;}",2,"cwe469,cweother"
"InitOurBFonts(void){#define ALL_BFONTS_WE_LOAD 7#define PARA_FONT_FILE tt""font/parafont""#define MENU_FONT_FILE tt""font/cpuFont""#define MESSAGEVAR_FONT_FILE t""font/small_white""#define MESSAGESTAT_FONT_FILE t""font/small_blue""#define RED_FONT_FILE tt""font/font05_red""#define BLUE_FONT_FILE tt""font/font05_white""#define FPS_FONT_FILE tt""font/font05""tchar fpath[2048];tint i;tconst char *MenuFontFiles[ALL_BFONTS_WE_LOAD] = {ttMENU_FONT_FILE,ttMESSAGEVAR_FONT_FILE,ttMESSAGESTAT_FONT_FILE,ttPARA_FONT_FILE,ttFPS_FONT_FILE,ttRED_FONT_FILE,ttBLUE_FONT_FILE,t};tBFont_Info **MenuFontPointers[ALL_BFONTS_WE_LOAD] = {tt&Menu_BFont,tt&Messagevar_BFont,tt&Messagestat_BFont,tt&Para_BFont,tt&FPS_Display_BFont,tt&Red_BFont,tt&Blue_BFontt};tfor (i = 0; i < ALL_BFONTS_WE_LOAD; i++) {ttchar constructed_fname[2048];ttsprintf(constructed_fname, ""%s"", MenuFontFiles[i]);ttstrcat(constructed_fname, "".png"");ttif (find_file(constructed_fname, GRAPHICS_DIR, fpath, 0) != 0) {t tttsprintf(constructed_fname, ""%s.png"", MenuFontFiles[i]);tttif (find_file(constructed_fname, GRAPHICS_DIR, fpath, 0) != 0) {ttttfprintf(stderr, ""Font file: '%s'."", MenuFontFiles[i]);ttttErrorMessage(__FUNCTION__, ""A font file for the BFont library was not found."", PLEASE_INFORM, IS_FATAL);ttt}tt}ttif ((*MenuFontPointers[i] = LoadFont(constructed_fname)) == NULL) {tttfprintf(stderr, ""Font file: '%s'."", MenuFontFiles[i]);tttErrorMessage(__FUNCTION__, ""A font file for the BFont library could not be loaded."", PLEASE_INFORM, IS_FATAL);tt} else {tttDebugPrintf(1, ""SDL Menu Font initialisation successful."");tt}t}}",2,"cwe119,cwe120"
"handleSlaveStderr(EventSelector *es,tt  int fd,tt  unsigned int flags,tt  void *data){    Slave *s = (Slave *) data;    char buffer[512];    int n;    char const *qid;    while ( (n=read(fd, buffer, sizeof(buffer)-1)) > 0) {tbuffer[n] = 0;tif (buffer[n-1] == '') {t    buffer[n-1] = 0;t}t tif (strstr(buffer, ""Out of memory!"")) {t    s->oom = 1;t}tqid = s->qid;tif (DOLOG) {t     t    char *str, *nl;t    str = buffer;t    while ( (nl = strchr(str, '')) ) {tt*nl = 0;ttif (*str) {tt    if (qid && *qid) {tttsyslog(LOG_INFO, ""%s: Slave %d stderr: %s"", qid, SLAVENO(s), str);tt    } else {tttsyslog(LOG_INFO, ""Slave %d stderr: %s"", SLAVENO(s), str);tt    }tt}ttstr = nl+1;t    }t    if (str && *str) {ttif (qid && *qid) {tt    syslog(LOG_INFO, ""%s: Slave %d stderr: %s"", qid, SLAVENO(s), str);tt} else {tt    syslog(LOG_INFO, ""Slave %d stderr: %s"", SLAVENO(s), str);tt}t    }t}    }    if (n == 0 || (n < 0 && errno != EAGAIN)) {t tif (n < 0) {t    if (DOLOG) {ttsyslog(LOG_WARNING,tt       ""handleSlaveStderr: Error reading from slave %d's stderr: %m"", SLAVENO(s));t    }t}tclose(s->slaveStderr);tEvent_DelHandler(s->es, s->errHandler);ts->errHandler = NULL;ts->slaveStderr = -1;    }}",3,"cwe119,cwe120,cweother"
"loadMPQCBasis(){        gchar *filename =  g_strdup_printf(""%s/mpqcBasis"",gabedit_directory());  tFILE* file = FOpen(filename,""r"");tgchar t[BSIZE];tgchar dump[BSIZE];tgchar symb[BSIZE];tgchar basisName[BSIZE];tgint nbas = 0;tgint natoms = 0;tgchar* point = NULL;tgint i;tgint j;tgint n;tif(!file)t{ttcreate_mpqc_basis_file();ttfile = FOpen(filename,""r"");t}tif(!file)t{ttprintf(_(""Sorry the mpqcbasis is corrupted.Please reinstall gabedit""));ttreturn;t}    t{ char* e = fgets(t,BSIZE,file);}  tpoint = strstr(t,""="");tif(!point)t{ttfreeMPQCBasis();ttreturn;t}tpoint = strstr(t,""="")+1;tsscanf(point,""%d"",&natoms);tif(natoms<1 || natoms>200)ttreturn;tmpqcBasis.numberOfAtoms = natoms;tmpqcBasis.atoms = g_malloc(natoms*sizeof(MPQCAtom));tfor(i=0;i<natoms;i++)t{ttif(!fgets(t,BSIZE,file))tt{tttprintf(_(""Sorry the mpqcbasis is corrupted.Please reinstall gabedit""));tttfreeMPQCBasis();tttbreak;tt}ttn = sscanf(t,""%s %s"",dump,symb);ttif(n!=2)tt{tttprintf(_(""Sorry the mpqcbasis is corrupted.Please reinstall gabedit""));tttfreeMPQCBasis();tttreturn;tt}ttmpqcBasis.atoms[i].symbol = g_strdup(symb);ttif(!fgets(t,BSIZE,file))tttbreak;ttsscanf(t,""%d"",&nbas);ttmpqcBasis.atoms[i].numberOfBasis = nbas;ttmpqcBasis.atoms[i].basis = g_malloc(nbas*sizeof(MPQCOneBasis));ttfor(j=0;j<nbas;j++)tt{tttgint k;tttif(!fgets(t,BSIZE,file))ttt{ttttprintf(_(""Sorry the mpqcbasis is corrupted.Please reinstall gabedit""));ttttfreeMPQCBasis();ttttbreak;ttt}tttn = sscanf(t,""%s %s"",symb, basisName);tttif(n<2)ttt{ttttprintf(_(""Sorry the mpqcbasis is corrupted.Please reinstall gabedit""));ttttfreeMPQCBasis();ttttreturn;ttt}tttfor(k=0;k<(gint)strlen(basisName);k++) if(basisName[k]=='#') basisName[k]=' ';tttmpqcBasis.atoms[i].basis[j].basisName = g_strdup(basisName);tt}t}tfclose(file);}",2,"cwe120,cweother"
"print_timestamp (int dupflag, void *closure _GL_UNUSED_PARAMETER,tt struct sockaddr_in *dest _GL_UNUSED_PARAMETER,tt struct sockaddr_in *from,tt struct ip *ip _GL_UNUSED_PARAMETER,tt icmphdr_t * icmp, int datalen){  char timestr[16];  printf (""%d bytes from %s: icmp_seq=%u"", datalen,t  inet_ntoa (*(struct in_addr *) &from->sin_addr.s_addr),t  ntohs (icmp->icmp_seq));  if (dupflag)    printf ("" (DUP!)"");  printf ("""");  printf (""icmp_otime = %s"",t  ping_cvt_time (timestr, sizeof (timestr),ttt ntohl (icmp->icmp_otime)));  printf (""icmp_rtime = %s"",t  ping_cvt_time (timestr, sizeof (timestr),ttt ntohl (icmp->icmp_rtime)));  printf (""icmp_ttime = %s"",t  ping_cvt_time (timestr, sizeof (timestr),ttt ntohl (icmp->icmp_ttime)));  if ((options & OPT_VERBOSE)      && is_normed_time (ntohl (icmp->icmp_otime))      && is_normed_time (ntohl (icmp->icmp_otime)))    printf (""difference = %d ms"",t    ntohl (icmp->icmp_ttime) - ntohl (icmp->icmp_otime));  return;}",2,"cwe119,cwe120"
"MallocFailed(){    char *cp, buf[256];    char tn[32];    if (CDStatusInt != CDMALLOCFAILED)        return;    strcpy(tn, ""KcXXXXXX"");    cp = mktemp(tn);    FBEnd();    strcpy(buf, ""Memory allocation error.  "");    if (Parameters.kpCellName[0] != EOS) {        if (Not CDUpdate(Parameters.kpCellDesc,cp))            strcat(buf,""Sorry, couldn't save current cell."");        else {            strcat(buf,""Current cell saved in "");            strcat(buf,cp);            strcat(buf,""."");        }    }    fatal_error(buf);}",3,"cwe119,cwe120,cweother"
"ftp_checkfile (char *urltype, char *infile, char *outfile1){  char newinfile[MAXLEN];  FILE *ftpfile;  FILE *command;  int sock;           strcpy(urltype,""ftp://"");  if (strlen(outfile1)) {              if (!strncmp(outfile1, ""file://"", 7) )       strcpy(netoutfile,outfile1+7);    else       strcpy(netoutfile,outfile1);    if (!strncmp(outfile1, ""mem:"", 4) )  {               strcpy(urltype, ""ftpmem://"");          return 0;    }    if (!ftp_open_network(infile,&ftpfile,&command,&sock)) {      fclose(ftpfile);      fclose(command);             if (strstr(infile,"".gz"") || (strstr(infile,"".Z""))) {t tif (strstr(outfile1,"".gz"") || (strstr(outfile1,"".Z""))) {t  strcpy(urltype,""ftpcompress://"");t} else {t  strcpy(urltype,""ftpfile://"");t}      } else {tstrcpy(urltype,""ftpfile://"");      }      return 0;    }         strcpy(newinfile,infile);    strcat(newinfile,"".gz"");    if (!ftp_open_network(newinfile,&ftpfile,&command,&sock)) {      fclose(ftpfile);      fclose(command);      strcpy(infile,newinfile);             if (strstr(outfile1,"".gz"") || (strstr(outfile1,"".Z""))) {tstrcpy(urltype,""ftpcompress://"");      } else {tstrcpy(urltype,""ftpfile://"");      }      return 0;    }             strcpy(newinfile,infile);    strcat(newinfile,"".Z"");    if (!ftp_open_network(newinfile,&ftpfile,&command,&sock)) {      fclose(ftpfile);      fclose(command);      strcpy(infile,newinfile);      if (strstr(outfile1,"".gz"") || (strstr(outfile1,"".Z""))) {tstrcpy(urltype,""ftpcompress://"");      } else {tstrcpy(urltype,""ftpfile://"");      }      return 0;    }      }   return 0;}",2,"cwe119,cwe120"
"set_work_target(struct work *work, double diff){tunsigned char target[32];tuint64_t *data64, h64;tdouble d64;td64 = diffone;td64 /= diff;th64 = d64;tmemset(target, 0, 32);tif (h64) {ttunsigned char rtarget[32];ttmemset(rtarget, 0, 32);ttif (opt_scrypt)tttdata64 = (uint64_t *)(rtarget + 2);ttelsetttdata64 = (uint64_t *)(rtarget + 4);tt*data64 = htobe64(h64);ttswab256(target, rtarget);t} else {tt ttif (opt_scrypt)tttmemset(target, 0xff, 30);ttelsetttmemset(target, 0xff, 28);t}tif (opt_debug) {ttchar *htarget = bin2hex(target, 32);ttapplog(LOG_DEBUG, ""Generated target %s"", htarget);ttfree(htarget);t}tmemcpy(work->target, target, 32);}",2,"cwe119,cwe120"
"try_pager(FILE *fp){tlongtlines = 0;tinttc;tchart*cp;tfflush(fp);trewind(fp);twhile ((c = getc(fp)) != EOF)ttif (c == '')tttlines++;trewind(fp);tif (is_a_tty[0] && is_a_tty[1] && (cp = value(""crt"")) != NULL &&tttlines > (*cp ? atol(cp) : scrnheight))ttrun_command(get_pager(), 0, fileno(fp), -1, NULL, NULL, NULL);telsettwhile ((c = getc(fp)) != EOF)tttputchar(c);}",2,"cwe120,cweother"
"_elm_hoversel_smart_theme(Evas_Object *obj){   char buf[4096];   const char *style;   ELM_HOVERSEL_DATA_GET(obj, sd);   style = eina_stringshare_add(elm_widget_style_get(obj));   if (sd->horizontal)     snprintf(buf, sizeof(buf), ""hoversel_horizontal/%s"", style);   else     snprintf(buf, sizeof(buf), ""hoversel_vertical/%s"", style);       eina_stringshare_replace(&(ELM_WIDGET_DATA(sd)->style), buf);   if (!ELM_WIDGET_CLASS(_elm_hoversel_parent_sc)->theme(obj))     return EINA_FALSE;   eina_stringshare_replace(&(ELM_WIDGET_DATA(sd)->style), style);   eina_stringshare_del(style);   if (sd->hover)     elm_widget_mirrored_set(sd->hover, elm_widget_mirrored_get(obj));   elm_hoversel_hover_end(obj);   return EINA_TRUE;}",2,"cwe119,cwe120"
"programmer_erase_chip(int port) {tunsigned char command;tunsigned char buffer;tcommand = 14;twrite(port,&command,1);tread(port,&buffer,1);tif (buffer != 'Y') {ttDEBUG_p(""DEBUG: erase: bad response: %c"", buffer);ttreturn -1;t}treturn 0;}",2,"cwe120,cweother"
"usb_dev_add(pcap_if_t** alldevsp, int n, char *err_str){tchar dev_name[10];tchar dev_descr[30]; tsnprintf(dev_name, 10, USB_IFACE""%d"", n);tsnprintf(dev_descr, 30, ""USB bus number %d"", n);tif (pcap_add_if(alldevsp, dev_name, 0, t    dev_descr, err_str) < 0)ttreturn -1;treturn 0; }",3,"cwe119,cwe120,cweother"
"app_parse_args (int argc, char **argv, GromitData *data){   gint      i;   gchar    *arg;   gboolean  wrong_arg = FALSE;   gboolean  activate = FALSE;   data->hot_keyval = DEFAULT_HOTKEY;   data->hot_keycode = 0;   for (i=1; i < argc ; i++)     {       arg = argv[i];       if (strcmp (arg, ""-a"") == 0 ||           strcmp (arg, ""--active"") == 0)         {           activate = TRUE;         }       else if (strcmp (arg, ""-d"") == 0 ||                strcmp (arg, ""--debug"") == 0)         {           data->debug = 1;         }       else if (strcmp (arg, ""-k"") == 0 ||                strcmp (arg, ""--key"") == 0)         {           if (i+1 < argc)             {               data->hot_keyval = argv[i+1];               data->hot_keycode = 0;               i++;             }           else             {               g_printerr (""-k requires an Key-Name as argument"");               wrong_arg = TRUE;             }         }       else if (strcmp (arg, ""-K"") == 0 ||                strcmp (arg, ""--keycode"") == 0)         {           if (i+1 < argc && atoi (argv[i+1]) > 0)             {               data->hot_keyval = NULL;               data->hot_keycode = atoi (argv[i+1]);               i++;             }           else             {               g_printerr (""-K requires an keycode > 0 as argument"");               wrong_arg = TRUE;             }         }       else         {           g_printerr (""Unknown Option for Gromit-MPX startup: ""%s"""", arg);           wrong_arg = TRUE;         }       if (wrong_arg)         {           g_printerr (""Please see the Gromit-MPX manpage for the correct usage"");           exit (1);         }     }   return activate;}",2,"cwe469,cweother"
"cli_xml_output_vol_gsync_status (dict_t *dict, xmlTextWriterPtr writer){        char                    master_key[PATH_MAX] = """";        char                    slave_key[PATH_MAX] = """";        char                    status_key[PATH_MAX] = """";        char                    node_key[PATH_MAX] = """";        char                    *master = NULL;        char                    *slave = NULL;        char                    *status = NULL;        char                    *node = NULL;        int                     ret = -1;        int                     gsync_count = 0;        int                     i = 1;        ret = dict_get_int32 (dict, ""gsync-count"", &gsync_count);        if (ret)                goto out;        for (i=1; i <= gsync_count; i++) {                snprintf (node_key, sizeof(node_key), ""node%d"", i);                snprintf (master_key, sizeof(master_key), ""master%d"", i);                snprintf (slave_key, sizeof(slave_key), ""slave%d"", i);                snprintf (status_key, sizeof(status_key), ""status%d"", i);                ret = dict_get_str (dict, node_key, &node);                if (ret)                        goto out;                ret = dict_get_str (dict, master_key, &master);                if (ret)                        goto out;                ret = dict_get_str (dict, slave_key, &slave);                if (ret)                        goto out;                ret = dict_get_str (dict, status_key, &status);                if (ret)                        goto out;                                 ret = xmlTextWriterStartElement (writer, (xmlChar *)""pair"");                XML_RET_CHECK_AND_GOTO (ret, out);                ret = xmlTextWriterWriteFormatElement (writer,                                                       (xmlChar *)""node"",                                                       ""%s"", node);                XML_RET_CHECK_AND_GOTO (ret, out);                ret = xmlTextWriterWriteFormatElement (writer,                                                       (xmlChar *)""master"",                                                       ""%s"", master);                XML_RET_CHECK_AND_GOTO (ret, out);                ret = xmlTextWriterWriteFormatElement (writer,                                                       (xmlChar *)""slave"",                                                       ""%s"", slave);                XML_RET_CHECK_AND_GOTO (ret, out);                ret = xmlTextWriterWriteFormatElement (writer,                                                       (xmlChar *)""status"",                                                       ""%s"", status);                XML_RET_CHECK_AND_GOTO (ret, out);                                 ret = xmlTextWriterEndElement (writer);                XML_RET_CHECK_AND_GOTO (ret, out);        }out:        gf_log (""cli"",GF_LOG_DEBUG, ""Returning %d"", ret);        return ret;}",2,"cwe119,cwe120"
"print_read_type (SANE_Int i) {  static char buf[32];  SANE_Int n;     if (i == BH_SCSI_READ_TYPE_FRONT)    {      strcpy(buf, ""front page"");    }  else if (i == BH_SCSI_READ_TYPE_BACK)    {      strcpy(buf, ""back page"");    }  else if (i > BH_SCSI_READ_TYPE_FRONT &&t   i <= BH_SCSI_READ_TYPE_FRONT + NUM_SECTIONS)    {      n = i - BH_SCSI_READ_TYPE_FRONT;      sprintf(buf, ""front section %d"", n);    }  else if (i > BH_SCSI_READ_TYPE_BACK &&t   i <= BH_SCSI_READ_TYPE_BACK + NUM_SECTIONS)    {      n = i - BH_SCSI_READ_TYPE_BACK;      sprintf(buf, ""back section %d"", n);    }  else if (i == BH_SCSI_READ_TYPE_FRONT_BARCODE)    {      strcpy(buf, ""front page barcode"");    }  else if (i == BH_SCSI_READ_TYPE_BACK_BARCODE)    {      strcpy(buf, ""back page barcode"");    }  else if (i > BH_SCSI_READ_TYPE_FRONT_BARCODE &&t   i <= BH_SCSI_READ_TYPE_FRONT_BARCODE + NUM_SECTIONS)    {      n = i - BH_SCSI_READ_TYPE_FRONT_BARCODE;      sprintf(buf, ""front barcode section %d"", n);    }  else if (i > BH_SCSI_READ_TYPE_BACK_BARCODE &&t   i <= BH_SCSI_READ_TYPE_BACK_BARCODE + NUM_SECTIONS)    {      n = i - BH_SCSI_READ_TYPE_BACK_BARCODE;      sprintf(buf, ""back barcode section %d"", n);    }  else if (i == BH_SCSI_READ_TYPE_FRONT_PATCHCODE)    {      strcpy(buf, ""front page patchcode"");    }  else if (i == BH_SCSI_READ_TYPE_BACK_PATCHCODE)    {      strcpy(buf, ""back page patchcode"");    }  else if (i > BH_SCSI_READ_TYPE_FRONT_PATCHCODE &&t   i <= BH_SCSI_READ_TYPE_FRONT_PATCHCODE + NUM_SECTIONS)    {      n = i - BH_SCSI_READ_TYPE_FRONT_PATCHCODE;      sprintf(buf, ""front patchcode section %d"", n);    }  else if (i > BH_SCSI_READ_TYPE_BACK_PATCHCODE &&t   i <= BH_SCSI_READ_TYPE_BACK_PATCHCODE + NUM_SECTIONS)    {      n = i - BH_SCSI_READ_TYPE_BACK_PATCHCODE;      sprintf(buf, ""back patchcode section %d"", n);    }  else if (i == BH_SCSI_READ_TYPE_FRONT_ICON)    {      strcpy(buf, ""front page icon"");    }  else if (i == BH_SCSI_READ_TYPE_BACK_ICON)    {      strcpy(buf, ""back page icon"");    }  else if (i == BH_SCSI_READ_TYPE_SENDBARFILE)    {      strcpy(buf, ""transmit bar/patch codes"");    }  else    {      strcpy(buf, ""unknown"");    }  return buf;}",2,"cwe119,cwe120"
"list_fmts(void (*get_fmt_string)(char *buf, int buf_size, int fmt), int nb_fmts){    int i;    char fmt_str[128];    for (i=-1; i < nb_fmts; i++) {        get_fmt_string (fmt_str, sizeof(fmt_str), i);        fprintf(stdout, ""%s"", fmt_str);    }}",2,"cwe119,cwe120"
"target_wwn_vpd_unit_serial_store(struct config_item *item,ttconst char *page, size_t count){tstruct t10_wwn *t10_wwn = to_t10_wwn(item);tstruct se_device *dev = t10_wwn->t10_dev;tunsigned char buf[INQUIRY_VPD_SERIAL_LEN];t tif (dev->dev_flags & DF_FIRMWARE_VPD_UNIT_SERIAL) {ttpr_err(""Underlying SCSI device firmware provided VPD""ttt"" Unit Serial, ignoring request"");ttreturn -EOPNOTSUPP;t}tif (strlen(page) >= INQUIRY_VPD_SERIAL_LEN) {ttpr_err(""Emulated VPD Unit Serial exceeds""tt"" INQUIRY_VPD_SERIAL_LEN: %d"", INQUIRY_VPD_SERIAL_LEN);ttreturn -EOVERFLOW;t}t tif (dev->export_count) {ttpr_err(""Unable to set VPD Unit Serial while""ttt"" active %d $FABRIC_MOD exports exist"",tttdev->export_count);ttreturn -EINVAL;t}t tmemset(buf, 0, INQUIRY_VPD_SERIAL_LEN);tsnprintf(buf, INQUIRY_VPD_SERIAL_LEN, ""%s"", page);tsnprintf(dev->t10_wwn.unit_serial, INQUIRY_VPD_SERIAL_LEN,ttt""%s"", strstrip(buf));tdev->dev_flags |= DF_EMULATED_VPD_UNIT_SERIAL;tpr_debug(""Target_Core_ConfigFS: Set emulated VPD Unit Serial:""ttt"" %s"", dev->t10_wwn.unit_serial);treturn count;}",2,"cwe119,cwe120"
"mnt_chdir_to_parent(const char *target, char **filename){tchar *path, *last = NULL;tchar cwd[PATH_MAX];tint rc = -EINVAL;tif (!target || *target != '/')ttreturn -EINVAL;tpath = strdup(target);tif (!path)ttreturn -ENOMEM;tif (*(path + 1) != '0') {ttlast = stripoff_last_component(path);ttif (!last)tttgoto err;t}tif (!*path)tt*path = '/';t tif (chdir(path) == -1) {ttDBG(UTILS, mnt_debug(""failed to chdir to %s: %m"", path));ttrc = -errno;ttgoto err;t}tif (!getcwd(cwd, sizeof(cwd))) {ttDBG(UTILS, mnt_debug(""failed to obtain current directory: %m""));ttrc = -errno;ttgoto err;t}tif (strcmp(cwd, path) != 0) {ttDBG(UTILS, mnt_debug(""path moved (%s -> %s)"", path, cwd));ttgoto err;t}tDBG(CXT, mnt_debug(""current directory moved to %s"", path));t*filename = path;tif (!last || !*last)ttmemcpy(*filename, ""."", 2);telsettmemcpy(*filename, last, strlen(last) + 1);treturn 0;err:tfree(path);treturn rc;}",2,"cwe119,cwe120"
"ntpwdhash (uint8_t *szHash, const char *szPassword){tchar szUnicodePass[513];tchar nPasswordLen;tint i;t tnPasswordLen = strlen(szPassword);tfor (i = 0; i < nPasswordLen; i++) {ttszUnicodePass[i << 1] = szPassword[i];ttszUnicodePass[(i << 1) + 1] = 0;t}t tfr_md4_calc(szHash, (uint8_t *) szUnicodePass, (nPasswordLen<<1) );}",3,"cwe119,cwe120,cweother"
"argus_lookupnet(char *device, unsigned int *netp, unsigned int *maskp, char *ebuf){   int fd;   struct sockaddr_in *sin;   struct ifreq ifr;   fd = socket(AF_INET, SOCK_DGRAM, 0);   if (fd < 0) {      (void)sprintf(ebuf, ""socket: %s"", argus_strerror(errno));      return (-1);   }   (void)strncpy(ifr.ifr_name, device, sizeof(ifr.ifr_name));   if (ioctl(fd, SIOCGIFADDR, (char *)&ifr) < 0) {      (void)sprintf(ebuf, ""SIOCGIFADDR: %s: %s"",          device, argus_strerror(errno));      (void)close(fd);      return (-1);   }   sin = (struct sockaddr_in *)&ifr.ifr_addr;   *netp = sin->sin_addr.s_addr;   if (ioctl(fd, SIOCGIFNETMASK, (char *)&ifr) < 0) {      (void)sprintf(ebuf, ""SIOCGIFNETMASK: %s: %s"",          device, argus_strerror(errno));      (void)close(fd);      return (-1);   }   (void)close(fd);   *maskp = sin->sin_addr.s_addr;   if (*maskp == 0) {      if (IN_CLASSA(*netp))         *maskp = IN_CLASSA_NET;      else if (IN_CLASSB(*netp))         *maskp = IN_CLASSB_NET;      else if (IN_CLASSC(*netp))         *maskp = IN_CLASSC_NET;      else {         (void)sprintf(ebuf, ""inet class for 0x%x unknown"",             *netp);         return (-1);      }   }   *netp &= *maskp;   return (0);}",2,"cwe119,cwe120"
"_sasl_locate_entry(void *library, const char *entryname,tt       void **entry_point) {#ifdef DO_DLOPEN #if defined(DLSYM_NEEDS_UNDERSCORE) || (defined(__OpenBSD__) && !defined(__ELF__))    char adj_entryname[1024];#else#define adj_entryname entryname#endif    if(!entryname) {t_sasl_log(NULL, SASL_LOG_ERR,tt  ""no entryname in _sasl_locate_entry"");treturn SASL_BADPARAM;    }    if(!library) {t_sasl_log(NULL, SASL_LOG_ERR,tt  ""no library in _sasl_locate_entry"");treturn SASL_BADPARAM;    }    if(!entry_point) {t_sasl_log(NULL, SASL_LOG_ERR,tt  ""no entrypoint output pointer in _sasl_locate_entry"");treturn SASL_BADPARAM;    }#if defined(DLSYM_NEEDS_UNDERSCORE) || (defined(__OpenBSD__) && !defined(__ELF__))    snprintf(adj_entryname, sizeof adj_entryname, ""_%s"", entryname);#endif    *entry_point = NULL;    *entry_point = dlsym(library, adj_entryname);    if (*entry_point == NULL) {#if 0  t_sasl_log(NULL, SASL_LOG_DEBUG,tt  ""unable to get entry point %s: %s"", adj_entryname,tt  dlerror());#endiftreturn SASL_FAIL;    }    return SASL_OK;#else    return SASL_FAIL;#endif  }",2,"cwe119,cwe120"
calc_jump_sline(){tif (jump_sline_fraction < 0)ttreturn;tjump_sline = sc_height * jump_sline_fraction / NUM_FRAC_DENOM;},2,"cwe119,cwe120"
"config_data_compatible(struct config_data *config1, struct config_data *config2){    if(!!config1->ipv4_address != !!config2->ipv4_address ||       !!config1->ipv6_address != !!config2->ipv6_address ||       !!config1->ipv6_prefix != !!config2->ipv6_prefix ||       !!config1->ipv4_prefix_delegation != !!config2->ipv4_prefix_delegation ||       !!config1->ipv6_prefix_delegation != !!config2->ipv6_prefix_delegation)        return 0;    if(config1->ipv4_address) {        if(!prefix_list_eq(config1->ipv4_address, config2->ipv4_address) != 0)            return 0;    }    if(config1->ipv6_address) {        if(!prefix_list_eq(config1->ipv6_address, config2->ipv6_address) != 0)            return 0;    }    if(config1->ipv6_prefix) {        if(!prefix_list_eq(config1->ipv6_prefix, config2->ipv6_prefix) != 0)            return 0;    }    if(config1->ipv4_prefix_delegation) {        if(!prefix_list_eq(config1->ipv4_prefix_delegation,                           config2->ipv4_prefix_delegation) != 0)            return 0;    }    if(config1->ipv6_prefix_delegation) {        if(!prefix_list_eq(config1->ipv6_prefix_delegation,                           config2->ipv6_prefix_delegation) != 0)            return 0;    }    return 1;}",2,"cwe119,cwe120"
"read_packed_refs(FILE *f, struct cached_refs *cached_refs){tstruct ref_list *list = NULL;tstruct ref_list *last = NULL;tchar refline[PATH_MAX];tint flag = REF_ISPACKED;twhile (fgets(refline, sizeof(refline), f)) {ttunsigned char sha1[20];ttconst char *name;ttstatic const char header[] = ""# pack-refs with:"";ttif (!strncmp(refline, header, sizeof(header)-1)) {tttconst char *traits = refline + sizeof(header) - 1;tttif (strstr(traits, "" peeled ""))ttttflag |= REF_KNOWS_PEELED;ttt tttcontinue;tt}ttname = parse_ref_line(refline, sha1);ttif (name) {tttlist = add_ref(name, sha1, flag, list, &last);tttcontinue;tt}ttif (last &&tt    refline[0] == '^' &&tt    strlen(refline) == 42 &&tt    refline[41] == '' &&tt    !get_sha1_hex(refline + 1, sha1))ttthashcpy(last->peeled, sha1);t}tcached_refs->packed = sort_ref_list(list);}",2,"cwe119,cwe120"
"simple_object_mach_o_write_header (simple_object_write *sobj, int descriptor,tttt   size_t nsects, const char **errmsg,tttt   int *err){  struct simple_object_mach_o_attributes *attrs =    (struct simple_object_mach_o_attributes *) sobj->data;  void (*set_32) (unsigned char *, unsigned int);  unsigned char hdrbuf[sizeof (struct mach_o_header_64)];  unsigned char *hdr;  size_t wrsize;  set_32 = (attrs->is_big_endiant    ? simple_object_set_big_32t    : simple_object_set_little_32);  memset (hdrbuf, 0, sizeof hdrbuf);     hdr = &hdrbuf[0];  set_32 (hdr + offsetof (struct mach_o_header_32, magic), attrs->magic);  set_32 (hdr + offsetof (struct mach_o_header_32, cputype), attrs->cputype);  set_32 (hdr + offsetof (struct mach_o_header_32, cpusubtype),t  attrs->cpusubtype);  set_32 (hdr + offsetof (struct mach_o_header_32, filetype), MACH_O_MH_OBJECT);  set_32 (hdr + offsetof (struct mach_o_header_32, ncmds), 1);  set_32 (hdr + offsetof (struct mach_o_header_32, flags), attrs->flags);  if (attrs->magic == MACH_O_MH_MAGIC)    {      wrsize = sizeof (struct mach_o_header_32);      set_32 (hdr + offsetof (struct mach_o_header_32, sizeofcmds),t      (sizeof (struct mach_o_segment_command_32)t       + nsects * sizeof (struct mach_o_section_32)));    }  else    {      set_32 (hdr + offsetof (struct mach_o_header_64, sizeofcmds),t      (sizeof (struct mach_o_segment_command_64)t       + nsects * sizeof (struct mach_o_section_64)));      set_32 (hdr + offsetof (struct mach_o_header_64, reserved),t      attrs->reserved);      wrsize = sizeof (struct mach_o_header_64);    }  return simple_object_internal_write (descriptor, 0, hdrbuf, wrsize,tttt       errmsg, err);}",2,"cwe119,cwe120"
"set_workdir (const char *s){    int err = 0;    if (gretl_function_depth() > 0) {tgretl_errmsg_set(""set workdir: cannot be done inside a function"");treturn 1;    }         s += 11;    s += strspn(s, "" "");    if (*s == '0') {terr = E_DATA;    } else {tchar workdir[MAXLEN];tif (*s == '""') {t    sscanf(s+1, ""%511[^""]"", workdir);t} else {t    sscanf(s, ""%511s"", workdir);t}tif (workdir_callback != NULL) {t    err = (*workdir_callback)(workdir);t} else {t    err = set_gretl_work_dir(workdir);t}    }     return err;}",3,"cwe119,cwe120,cwe469"
"pxenv_file_open ( struct s_PXENV_FILE_OPEN *file_open ) {tuserptr_t filename;tsize_t filename_len;tint fd;tDBG ( ""PXENV_FILE_OPEN"" );t tfilename = real_to_user ( file_open->FileName.segment,ttt      file_open->FileName.offset );tfilename_len = strlen_user ( filename, 0 );t{ttchar uri_string[ filename_len + 1 ];ttcopy_from_user ( uri_string, filename, 0,tttt sizeof ( uri_string ) );ttDBG ( "" %s"", uri_string );ttfd = open ( uri_string );t}tif ( fd < 0 ) {ttfile_open->Status = PXENV_STATUS ( fd );ttreturn PXENV_EXIT_FAILURE;t}tDBG ( "" as file %d"", fd );tfile_open->FileHandle = fd;tfile_open->Status = PXENV_STATUS_SUCCESS;treturn PXENV_EXIT_SUCCESS;}",3,"cwe119,cwe120,cweother"
"""js_strtod(JSContext *cx, const jschar *s, const jschar *send,          const jschar **ep, jsdouble *dp){    const jschar *s1;    size_t length, i;    char cbuf[32];    char *cstr, *istr, *estr;    JSBool negative;    jsdouble d;    s1 = js_SkipWhiteSpace(s, send);    length = send - s1;    /* Use cbuf to avoid malloc */    if (length >= sizeof cbuf) {        cstr = (char *) cx->malloc(length + 1);        if (!cstr)           return JS_FALSE;    } else {        cstr = cbuf;    }    for (i = 0; i != length; i++) {        if (s1[i] >> 8)            break;        cstr[i] = (char)s1[i];    }    cstr[i] = 0;    istr = cstr;    if ((negative = (*istr == '-')) != 0 || *istr == '+')        istr++;    if (*istr == 'I' && !strncmp(istr, js_Infinity_str, sizeof js_Infinity_str - 1)) {        d = *(negative ? cx->runtime->jsNegativeInfinity : cx->runtime->jsPositiveInfinity);        estr = istr + 8;    } else {        int err;        d = JS_strtod(cstr, &estr, &err);        if (d == HUGE_VAL)            d = *cx->runtime->jsPositiveInfinity;        else if (d == -HUGE_VAL)            d = *cx->runtime->jsNegativeInfinity;    }    i = estr - cstr;    if (cstr != cbuf)        cx->free(cstr);    *ep = i ? s1 + i : s;    *dp = d;    return JS_TRUE;}""",2,"cwe119,cwe120"
"""ast_cc_is_recall(struct ast_channel *chan, int *core_id, const char * const monitor_type){tstruct ast_datastore *recall_datastore;tstruct cc_recall_ds_data *recall_data;tstruct cc_monitor_tree *interface_tree;tchar device_name[AST_CHANNEL_NAME];tstruct ast_cc_monitor *device_monitor;tint core_id_candidate;tast_assert(core_id != NULL);t*core_id = -1;tast_channel_lock(chan);tif (!(recall_datastore = ast_channel_datastore_find(chan, &recall_ds_info, NULL))) {tt/* Obviously not a recall if the datastore isn't present */ttast_channel_unlock(chan);ttreturn 0;t}trecall_data = recall_datastore->data;tif (recall_data->ignore) {tt/* Though this is a recall, the call to this particular interface is not part of thett * recall either because this is a call forward or because this is not the firsttt * invocation of Dial during this calltt */ttast_channel_unlock(chan);ttreturn 0;t}tif (!recall_data->nested) {tt/* If the nested flag is not set, then this means thattt * the channel passed to this function is the caller makingtt * the recall. This means that we shouldn't look throughtt * the monitor tree for the channel because it shouldn't bett * there. However, this is a recall though, so return true.tt */tt*core_id = recall_data->core_id;ttast_channel_unlock(chan);ttreturn 1;t}tif (ast_strlen_zero(monitor_type)) {tt/* If someone passed a NULL or empty monitor type, then it is cleartt * the channel they passed in was an incoming channel, and so searchingtt * the list of dialed interfaces is not going to be helpful. Just returntt * false immediately.tt */ttast_channel_unlock(chan);ttreturn 0;t}tinterface_tree = recall_data->interface_tree;tast_channel_get_device_name(chan, device_name, sizeof(device_name));t/* We grab the value of the recall_data->core_id so that wet * can unlock the channel before we start looking through thet * interface list. That way we don't have to worry about a possiblet * clash between the channel lock and the monitor tree lock.t */tcore_id_candidate = recall_data->core_id;tast_channel_unlock(chan);t/*t * Now we need to find out if the channel device namet * is in the list of interfaces in the called tree.t */tAST_LIST_LOCK(interface_tree);tAST_LIST_TRAVERSE(interface_tree, device_monitor, next) {ttif (!strcmp(device_monitor->interface->device_name, device_name) &&tttt!strcmp(device_monitor->interface->monitor_type, monitor_type)) {ttt/* BOOM! Device is in the tree! We have a winner! */ttt*core_id = core_id_candidate;tttAST_LIST_UNLOCK(interface_tree);tttreturn 1;tt}t}tAST_LIST_UNLOCK(interface_tree);treturn 0;}""",2,"cwe119,cwe120"
"pdf_dict_putp(pdf_obj *obj, const char *keys, pdf_obj *val){tfz_context *ctx = obj->ctx;tchar buf[256];tchar *k, *e;tpdf_obj *cobj = NULL;tif (strlen(keys)+1 > 256)ttfz_throw(obj->ctx, ""buffer overflow in pdf_dict_getp"");tstrcpy(buf, keys);te = buf;twhile (*e)t{ttk = e;ttwhile (*e != '/' && *e != '0')ttte++;ttif (*e == '/')tt{ttt*e = '0';ttte++;tt}ttif (*e)tt{ttt tttcobj = pdf_dict_gets(obj, k);tttif (cobj == NULL)ttt{ttttcobj = pdf_new_dict(ctx, 1);ttttfz_try(ctx)tttt{tttttpdf_dict_puts(obj, k, cobj);tttt}ttttfz_always(ctx)tttt{tttttpdf_drop_obj(cobj);tttt}ttttfz_catch(ctx)tttt{tttttfz_rethrow(ctx);tttt}ttt}ttt tttobj = cobj;tt}ttelsett{ttt tttpdf_dict_puts(obj, k, val);tt}t}}",2,"cwe119,cwe120"
"get_drawmode(int type, int id, Nv_data * data, Tcl_Interp * interp){    int mode;    char surf[32], wire[32], shade[32];    char *list[4];         if (type != SURF) {tTcl_SetResult(interp,tt      ""Error: map object must be a surface in order to use get_drawmode"",tt      TCL_VOLATILE);treturn (TCL_ERROR);    }    if (GS_get_drawmode(id, &mode) == -1) {tTcl_SetResult(interp, ""Error: id in get_drawmode is invalid."",tt      TCL_VOLATILE);treturn (TCL_ERROR);    }         G_debug(3, ""drawmode: %d"", mode);    if (mode & DM_GOURAUD || mode == 2308)t tstrcpy(shade, ""gouraud"");    else if (mode & DM_FLAT)tstrcpy(shade, ""flat"");    else {tTcl_SetResult(interp,tt      ""Internal Error map_obj.c: unknown shade style returned in get_drawmode"",tt      TCL_VOLATILE);treturn (TCL_ERROR);    }    if (mode & DM_POLY)tstrcpy(surf, ""poly"");    else if (mode & DM_WIRE)tstrcpy(surf, ""wire"");    else if (mode & DM_WIRE_POLY)tstrcpy(surf, ""wire_poly"");    else if (mode & DM_COL_WIRE)tstrcpy(surf, ""col_wire"");    else {tTcl_SetResult(interp,tt      ""Internal Error: unknown surface style returned in get_drawmode"",tt      TCL_VOLATILE);treturn (TCL_ERROR);    }    if (mode & DM_GRID_WIRE)tstrcpy(wire, ""grid_wire"");    else if (mode & DM_GRID_SURF)tstrcpy(wire, ""grid_surf"");    else {tTcl_SetResult(interp,tt      ""Internal Error: unknown surface style returned in get_drawmode"",tt      TCL_VOLATILE);treturn (TCL_ERROR);    }    list[0] = shade;    list[1] = surf;    list[2] = wire;    list[3] = NULL;    Tcl_SetResult(interp, Tcl_Merge(3, list), TCL_DYNAMIC);    return (TCL_OK);}",3,"cwe119,cwe120,cwe469"
mte_close(TermEnum *te){    int i;    const int size = MTE(te)->size;    for (i = 0; i < size; i++) {        tew_destroy(&(MTE(te)->tews[i]));    }    free(MTE(te)->tews);    free(MTE(te)->tis);    free(MTE(te)->ti_indexes);    pq_destroy(MTE(te)->tew_queue);    free(te);},2,"cwe119,cwe120"
"setup_edd_info(struct x86_linux_param_header *real_mode){tDIR *edd_dir;tstruct dirent *cursor;tint current_edd = 0;tint current_mbr = 0;tedd_dir = opendir(EDD_SYFS_DIR);tif (!edd_dir) {ttdbgprintf(EDD_SYFS_DIR "" does not exist."");ttreturn;t}tzero_edd(real_mode);twhile ((cursor = readdir(edd_dir))) {ttchar full_dir_name[PATH_MAX];tt ttif (strstr(cursor->d_name, ""int13_dev"") != cursor->d_name)tttcontinue;ttsnprintf(full_dir_name, PATH_MAX, ""%s/%s"",ttttEDD_SYFS_DIR, cursor->d_name);ttfull_dir_name[PATH_MAX-1] = 0;ttif (add_edd_entry(real_mode, full_dir_name, &current_edd,ttttt&current_mbr) != 0) {tttzero_edd(real_mode);tttgoto out;tt}t}treal_mode->eddbuf_entries = current_edd;treal_mode->edd_mbr_sig_buf_entries = current_mbr;out:tclosedir(edd_dir);tdbgprintf(""Added %d EDD MBR entries and %d EDD entries."",ttreal_mode->edd_mbr_sig_buf_entries,ttreal_mode->eddbuf_entries);}",2,"cwe119,cwe120"
"matrix_invm_double (double* Y,double* M,double* B,size_t n,size_t m){tdouble d, *c;tsize_t i,j;tsize_t* idx = (size_t*)malloc(n*sizeof(size_t));tif (!matrix_lu_double (M,idx,&d,n)) {ttfree (idx);ttreturn 0;t}tc = (double*)malloc(n*sizeof(double));tfor (j=0;j<m;j++)t{ttfor (i=0;i<n;i++)tttc[i] = B[i+j*n];ttmatrix_lub_double (c,M,idx,n);ttfor (i=0;i<n;i++)tttY[i+j*n] = c[i];t}tfree (idx);tfree (c);treturn 1;}",2,"cwe120,cweother"
"make_pref_menu(GtkWidget **pref_menu, int pref_num){   GtkWidget *menu_item;   GtkWidget *menu;   GSList    *group;   int i, r;   long ivalue;   const char *svalue;   char format_text[MAX_PREF_LEN];   char human_text[MAX_PREF_LEN];   time_t ltime;   struct tm *now;   time(&ltime);   now = localtime(&ltime);   *pref_menu = gtk_option_menu_new();   menu = gtk_menu_new();   group = NULL;   get_pref(pref_num, &ivalue, &svalue);   for (i=0; i<MAX_NUM_PREFS; i++) {      r = get_pref_possibility(pref_num, i, format_text);      if (r) {         break;      }      switch (pref_num) {       case PREF_SHORTDATE:       case PREF_TIME:         jp_strftime(human_text, MAX_PREF_LEN, format_text, now);         break;       case PREF_LONGDATE:         jp_strftime(human_text, MAX_PREF_LEN, _(format_text), now);         break;       default:         strncpy(human_text, format_text, MAX_PREF_LEN);         break;      }      menu_item = gtk_radio_menu_item_new_with_label(                     group, human_text);      group = gtk_radio_menu_item_group(GTK_RADIO_MENU_ITEM(menu_item));      gtk_menu_append(GTK_MENU(menu), menu_item);      if (ivalue == i) {         gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(menu_item), ivalue);      }      gtk_signal_connect(GTK_OBJECT(menu_item), ""activate"", GTK_SIGNAL_FUNC(cb_pref_menu),                         GINT_TO_POINTER(((pref_num*0x100) + (i & 0xFF))));      gtk_widget_show(menu_item);   }   gtk_option_menu_set_menu(GTK_OPTION_MENU(*pref_menu), menu);   return EXIT_SUCCESS;}",3,"cwe119,cwe120,cwe469"
"fresh_symbol(char *prefix, int arity){  char name[MAX_NAME+20];  int i = 0;  if (strlen(prefix) > MAX_NAME) {    fatal_error(""fresh_symbol, prefix is too big."");  }  do {    sprintf(name, ""%s%d"", prefix, i);    i++;  } while (str_exists(name));  return str_to_sn(name, arity);}",2,"cwe119,cwe120"
"ack_data_unserialize(FILE * fp, void **str, size_t * size) {  *str = NULL;  if (fread(size, 1, sizeof(*size), fp) == sizeof(*size)) {    if (*size == 0)                    return 0;    *str = malloct(*size + 1);    if (*str == NULL)      return 1;                      ((char *) *str)[*size] = 0;      if (fread(*str, 1, *size, fp) == *size)      return 0;  }  return 1;                      }",2,"cwe119,cwe120"
"ExecuteRecoveryEndCommand(void){tcharttxlogRecoveryEndCmd[MAXPGPATH];tcharttlastRestartPointFname[MAXPGPATH];tchart   *dp;tchart   *endp;tconst char *sp;tinttttrc;tboolttsignaled;tuint32ttrestartLog;tuint32ttrestartSeg;tAssert(recoveryEndCommand);t tLWLockAcquire(ControlFileLock, LW_SHARED);tXLByteToSeg(ControlFile->checkPointCopy.redo,ttttrestartLog, restartSeg);tXLogFileName(lastRestartPointFname,tttt ControlFile->checkPointCopy.ThisTimeLineID,tttt restartLog, restartSeg);tLWLockRelease(ControlFileLock);t tdp = xlogRecoveryEndCmd;tendp = xlogRecoveryEndCmd + MAXPGPATH - 1;t*endp = '0';tfor (sp = recoveryEndCommand; *sp; sp++)t{ttif (*sp == '%')tt{tttswitch (sp[1])ttt{ttttcase 'r':ttttt tttttsp++;tttttStrNCpy(dp, lastRestartPointFname, endp - dp);tttttdp += strlen(dp);tttttbreak;ttttcase '%':ttttt tttttsp++;tttttif (dp < endp)tttttt*dp++ = *sp;tttttbreak;ttttdefault:ttttt tttttif (dp < endp)tttttt*dp++ = *sp;tttttbreak;ttt}tt}ttelsett{tttif (dp < endp)tttt*dp++ = *sp;tt}t}t*dp = '0';tereport(DEBUG3,ttt(errmsg_internal(""executing recovery end command ""%s"""",ttttttt xlogRecoveryEndCmd)));t trc = system(xlogRecoveryEndCmd);tif (rc != 0)t{tt ttsignaled = WIFSIGNALED(rc) || WEXITSTATUS(rc) > 125;ttereport(signaled ? FATAL : WARNING,tttt(errmsg(""recovery_end_command ""%s"": return code %d"",ttttttxlogRecoveryEndCmd, rc)));t}}",3,"cwe119,cwe120,cweother"
"cmd_map(void){tint c;tint append, file, specified;tchar *mapfile;tappend = file = specified = 0;tmapfile = NULL;        while ((c = getopt(argcnt, args, ""af"")) != EOF) {                switch(c)tt{ttcase 'a':tttappend++;tttbreak;ttcase 'f':tttfile++;tttbreak;ttdefault:tttargerrs++;tttbreak;tt}t}tif (argerrs)ttcmd_usage(pc->curcmd, SYNOPSIS);        while (args[optind]) {ttif (!mapfile) {tttmapfile = args[optind];ttttspecified++;tt} elsetttcmd_usage(pc->curcmd, SYNOPSIS);ttoptind++;t}tif (file && !specified) {ttmapfile = GETBUF(strlen(pc->dumpfile)+10);ttsprintf(mapfile, ""%s.map"", pc->dumpfile);t}tif (append)ttkvmdump_mapfile_append();tif (file) {ttkvmdump_mapfile_create(mapfile);ttif (!specified)tttFREEBUF(mapfile);t}tif (!file && !append)ttfprintf(fp, ""MAP FILE IN USE: %s"", mapfile_in_use());}",2,"cwe120,cweother"
"process_parameters(int argc, char **argv, struct gfs2_options *opts){tint c;topts->yes = 0;topts->no = 0;tif (argc == 1) {ttusage(argv[0]);ttexit(0);t}tmemset(device, 0, sizeof(device));twhile((c = getopt(argc, argv, ""hnqvyV"")) != -1) {ttswitch(c) {ttcase 'h':tttusage(argv[0]);tttexit(0);tttbreak;ttcase 'n':tttopts->no = 1;tttbreak;ttcase 'q':tttdecrease_verbosity();tttbreak;ttcase 'v':tttincrease_verbosity();tttbreak;ttcase 'V':tttexit(0);ttcase 'y':tttopts->yes = 1;tttbreak;ttdefault:tttfprintf(stderr,_(""Parameter not understood: %c""), c);tttusage(argv[0]);tttexit(0);tt}t}tif(argc > optind) {ttstrcpy(device, argv[optind]);ttopts->device = device;ttif(!opts->device) {tttfprintf(stderr, _(""No device specified. Please use '-h' for help""));tttexit(1);tt}t} else {ttfprintf(stderr, _(""No device specified. Please use '-h' for help""));ttexit(1);t}}",2,"cwe120,cweother"
"write_file_combine_primary_alpha(jxr_image_t image, FILE *fpPrimary, FILE *fpAlpha){    context *con = (context*) jxr_get_user_data(image);    int i;    if(isOutputYUV444(image) || isOutputYUV422(image) || isOutputYUV420(image) || isOutputCMYKDirect(image))    {        concatenate_primary_alpha(image, fpPrimary, fpAlpha);        return;    }    if (con->file==0)    {        set_pad_bytes(con, image);                 con->alpha = 1;                start_output_file(con, jxr_get_EXTENDED_IMAGE_WIDTH(image), jxr_get_EXTENDED_IMAGE_HEIGHT(image),             jxr_get_IMAGE_WIDTH(image), jxr_get_IMAGE_HEIGHT(image),            jxr_get_IMAGE_CHANNELS(image) + 1, jxr_get_OUTPUT_BITDEPTH(image), jxr_get_pixel_format(image));    }    int numPixels = jxr_get_IMAGE_WIDTH(image) * jxr_get_IMAGE_HEIGHT(image);    int nPrimaryComp = jxr_get_IMAGE_CHANNELS(image);    if(con->padBytes)        nPrimaryComp ++;     if (con->bpi == 8) {        for (i=0; i<numPixels; i++) {            unsigned char combine[MAX_CHANNELS + 1 + 1];             fread(&combine[0],sizeof(char),nPrimaryComp, fpPrimary);            fread(&(combine[nPrimaryComp]),sizeof(char), 1,fpAlpha);            write_uint8(con, combine, nPrimaryComp+1);               }    }    else if(con->bpi == 16)    {        for (i=0; i<numPixels; i++) {            uint16_t combine[MAX_CHANNELS + 1 + 1];             fread(&combine[0],sizeof(uint16_t),nPrimaryComp, fpPrimary);            fread(&(combine[nPrimaryComp]),sizeof(uint16_t), 1,fpAlpha);            write_uint16(con, combine, nPrimaryComp+1);               }    }    else if(con->bpi == 32)    {        for (i=0; i<numPixels; i++) {            uint32_t combine[MAX_CHANNELS + 1 + 1];             fread(&combine[0],sizeof(uint32_t),nPrimaryComp, fpPrimary);            fread(&(combine[nPrimaryComp]),sizeof(uint32_t), 1,fpAlpha);            write_uint32(con, combine,nPrimaryComp+1);               }    }    else        assert(!""Unsupported bitdepth"");}",3,"cwe119,cwe120,cweother"
"pages_unmap(void *addr, size_t size){#ifdef _WIN32tif (VirtualFree(addr, 0, MEM_RELEASE) == 0)#elsetif (munmap(addr, size) == -1)#endift{ttchar buf[BUFERROR_BUF];ttbuferror(buf, sizeof(buf));ttmalloc_printf(""<jemalloc>: Error in ""#ifdef _WIN32tt              ""VirtualFree""#elsett              ""munmap""#endiftt              ""(): %s"", buf);ttif (opt_abort)tttabort();t}}",2,"cwe119,cwe120"
"""c_getchar(int quote){tint c;tint space = 0;tdo {ttc = (unsigned char)c_buffer_getchar();ttif (quote || c_EOF) return c;ttif (c <= ' ') space = 1; elsettif (c == '/')ttswitch ((c = c_buffer_getchar())) {ttcase '/':tttdo {ttttc = c_buffer_getchar();ttt} while (!c_EOF && c != '' && c != 'r');tttc = ' '; space = 1;tttbreak;ttcase '*':tttdo {ttttif ((c = c_buffer_getchar()) == '*')ttttif ((c = c_buffer_getchar()) == '/')tttttbreak;ttt} while (!c_EOF);tttc = ' '; space = 1;tttbreak;ttdefault:tttc_ungetchar(c);tttc = '/';tt}t} while (c <= ' ');tif (space) {ttc_ungetchar(c);ttc = ' ';t}treturn c;}""",3,"cwe119,cwe120,cwe469"
"gf_export_hint(GF_MediaExporter *dumper){#ifndef GPAC_DISABLE_ISOM_HINTINGtGF_Err e;tchar szName[1000], szType[5];tchar *pck;tFILE *out;tu32 track, i, size, m_stype, sn, count;tif (!(track = gf_isom_get_track_by_id(dumper->file, dumper->trackID))) {ttGF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""Wrong track ID %d for file %s "", dumper->trackID, gf_isom_get_filename(dumper->file)));ttreturn GF_BAD_PARAM;t}tm_stype = gf_isom_get_media_subtype(dumper->file, track, 1);te = gf_isom_reset_hint_reader(dumper->file, track, dumper->sample_num ? dumper->sample_num : 1, 0, 0, 0);tif (e) return gf_export_message(dumper, e, ""Error initializing hint reader"");tgf_export_message(dumper, GF_OK, ""Extracting hint track samples - type %s"", szType);tcount = gf_isom_get_sample_count(dumper->file, track);tif (dumper->sample_num) count = 0;ti = 1;twhile (1) {tte = gf_isom_next_hint_packet(dumper->file, track, &pck, &size, NULL, NULL, NULL, &sn);ttif (e==GF_EOS) break;ttif (dumper->sample_num && (dumper->sample_num != sn)) {tttgf_free(pck);tttbreak;tt}ttif (e) return gf_export_message(dumper, e, ""Error fetching hint packet %d"", i);ttsprintf(szName, ""%s_pck_%04d.%s"", dumper->out_name, i, gf_4cc_to_str(m_stype));ttout = gf_f64_open(szName, ""wb"");ttgf_fwrite(pck, size, 1, out);ttfclose(out);ttgf_free(pck);tti++;ttif (count) gf_set_progress(""Hint Export"", sn, count);t}tif (count) gf_set_progress(""Hint Export"", count, count);treturn GF_OK;#elsetreturn GF_NOT_SUPPORTED;#endif}",2,"cwe119,cwe120"
"""generate_special_channels(const stp_vars_t *v){  stpi_channel_group_t *cg = get_channel_group(v);  int i, j;  const unsigned short *input_cache = NULL;  const unsigned short *output_cache = NULL;  const unsigned short *input;  unsigned short *output;  int offset;  int outbytes;  if (!cg)    return;  input = cg->input_data;  output = cg->multi_tmp;  offset = (cg->black_channel >= 0 ? 0 : -1);  outbytes = cg->aux_output_channels * sizeof(unsigned short);  for (i = 0; i < cg->width;       input += cg->input_channels, output += cg->aux_output_channels, i++)    {      if (input_cache && short_eq(input_cache, input, cg->input_channels))t{t  memcpy(output, output_cache, outbytes);t}      elset{t  int c = input[STP_ECOLOR_C + offset];t  int m = input[STP_ECOLOR_M + offset];t  int y = input[STP_ECOLOR_Y + offset];t  int min = FMIN(c, FMIN(m, y));t  int max = FMAX(c, FMAX(m, y));t  if (max > min)t/* Otherwise it's gray, and we don't care */t    {t      double hue;t      /*t       * We're only interested in converting color componentst       * to special inks.  We want to compute the hue andt       * luminosity to determine what we want to convert.t       * Since we're eliminating all grayscale component, thet       * computations become simpler.t       */t      c -= min;t      m -= min;t      y -= min;t      max -= min;t      if (offset == 0)ttoutput[STP_ECOLOR_K] = input[STP_ECOLOR_K];t      hue = compute_hue(c, m, y, max);t      for (j = 1; j < cg->aux_output_channels - offset; j++)tt{tt  stpi_channel_t *ch = &(cg->c[j]);tt  if (ch->hue_map)tt    output[j + offset] =tt      max * interpolate_value(ch->hue_map,ttttt      hue * ch->h_count / 6.0);tt  elsett    output[j + offset] = 0;tt}t      output[STP_ECOLOR_C + offset] += min;t      output[STP_ECOLOR_M + offset] += min;t      output[STP_ECOLOR_Y + offset] += min;t    }t  elset    {t      for (j = 0; j < 4 + offset; j++)ttoutput[j] = input[j];t      for (j = 4 + offset; j < cg->aux_output_channels; j++)ttoutput[j] = 0;t    }t}      input_cache = input;      output_cache = output;    }}""",2,"cwe120,cweother"
"SaveGameConfig(void){tchar fname[5000];tint current_width;tint current_height;tFILE *config_file;t t t t t tif (our_config_dir == NULL) {ttprintf(""It seems that the game couldn't start up at all... therefore we need not save any configuration information."");ttSDL_Quit();#if __WIN32__ttfflush(stdout);ttfflush(stderr);ttchar *cmd = MyMalloc(strlen(our_config_dir) + 20);ttsprintf(cmd, ""notepad %s/stderr.txt"", our_config_dir);ttsystem(cmd);ttsprintf(cmd, ""notepad %s/stdout.txt"", our_config_dir);ttsystem(cmd);ttfree(cmd);#endifttexit(ERR);t}t t t t tif (our_config_dir[0] == '0')ttreturn (ERR);tsprintf(fname, ""%s/fdrpg.cfg"", our_config_dir);tif ((config_file = fopen(fname, ""wb"")) == NULL) {ttfprintf(stderr, ""Unable to open configuration file %s for writing"", fname);ttreturn (ERR);t}t t t t t tif (GameConfig.freedroid_version_string) {ttfree(GameConfig.freedroid_version_string);t}tGameConfig.freedroid_version_string = strdup(VERSION);t t t t tcurrent_width = GameConfig.screen_width;tcurrent_height = GameConfig.screen_height;tGameConfig.screen_width = GameConfig.next_time_width_of_screen;tGameConfig.screen_height = GameConfig.next_time_height_of_screen;t tsavestruct_autostr = alloc_autostr(4096);tsave_freedroid_configuration(savestruct_autostr);tif (fwrite(savestruct_autostr->value, savestruct_autostr->length, 1, config_file) != 1) {ttErrorMessage(__FUNCTION__, ""Failed to write configuration file: %s"", NO_NEED_TO_INFORM, IS_WARNING_ONLY, fname);ttfree_autostr(savestruct_autostr);tttreturn ERR;t}tfree_autostr(savestruct_autostr);tGameConfig.screen_width = current_width;tGameConfig.screen_height = current_height;tfclose(config_file);treturn (OK);}",4,"cwe119,cwe120,cwe476,cweother"
"lam_ssi_boot_globus_inetexec(struct lamnode *node, char **argv){  char **cmdv;ttt   int cmdc;ttt   int i;ttt   char printable[BUFSIZ];t   char remote_host[BUFSIZ];t   char *cmdv0;ttt   ELEM search;  ELEM *contact;  snprintf(remote_host, BUFSIZ, ""%s"", node->lnd_hname);  remote_host[BUFSIZ - 1] = '0';     cmdc = 0;  cmdv = 0;  add_globusrun(&cmdc, &cmdv, argv[0]);     search.key = ""contact"";  contact = al_find(node->lnd_keyval, &search);  if (contact != NULL) {         sfh_argv_add(&cmdc, &cmdv, contact->value);  } else {    sfh_argv_add(&cmdc, &cmdv, node->lnd_hname);  }   for (i = 1; argv[i]; ++i)    sfh_argv_add(&cmdc, &cmdv, argv[i]);  if (lam_ssi_boot_verbose >= 1)    lam_debug(lam_ssi_boot_did,t      ""globus: attempting to execute ""%s"""",t      sfh_argv_glue(cmdv, ' ', 0));     printable[0] = '0';  for (i = 0; i < cmdc; i++) {    strncat(printable, cmdv[i], BUFSIZ);    strncat(printable, "" "", BUFSIZ);  }  cmdv0 = strdup(cmdv[0]);  i = lam_ssi_boot_base_ioexecvp(cmdv, 1, (char *) 0, 0, 1);     if (i) {    show_help_file(""lam-ssi-boot-globus-helpfile"", ""boot"", tt   ""remote-boot-fail-globus"", remote_host, cmdv0,tt   argv[1], printable, NULL);    free(cmdv0);    return (LAMERROR);  }  free(cmdv0);  return 0;}",3,"cwe119,cwe120,cweother"
"trans_logic_symbols(struct term *t){  if (special_is_symbol(t, ""TRUE"", 0)) {    t->sym_num = str_to_sn(""$T"", 0);    t->type = NAME;  }  else if (special_is_symbol(t, ""FALSE"", 0)) {    t->sym_num = str_to_sn(""$F"", 0);    t->type = NAME;  }  else if (is_symbol(t, ""NOT"", 1)) {    t->sym_num = str_to_sn(""-"", 1);    trans_logic_symbols(t->farg->argval);  }  else if (is_symbol(t, ""OR"", 2)) {    t->sym_num = str_to_sn(""|"", 2);    trans_logic_symbols(t->farg->argval);    trans_logic_symbols(t->farg->narg->argval);  }}",2,"cwe119,cwe120"
"mgmt_set_mode(int index, uint16_t opcode, uint8_t val){tchar buf[MGMT_HDR_SIZE + sizeof(struct mgmt_mode)];tstruct mgmt_hdr *hdr = (void *) buf;tstruct mgmt_mode *cp = (void *) &buf[sizeof(*hdr)];tmemset(buf, 0, sizeof(buf));thdr->opcode = htobs(opcode);thdr->index = htobs(index);thdr->len = htobs(sizeof(*cp));tcp->val = val;tif (write(mgmt_sock, buf, sizeof(buf)) < 0)ttreturn -errno;treturn 0;}",2,"cwe119,cwe120"
"OpNull(){   cid_null_ot in ;   long tmp;   status=system(""clear"") ;   printf(""CID_OP_NULL"") ;   printf(""-----------"") ;tttt printf(""CIDTEST. cid_null_ot size=(%ld)"",sizeof(in));   if (!readn(cidsock, (char *)&in, sizeof(in)))    {       printf(""OpNull::readn"") ;       getchar() ; getchar() ;       return ;    }tttt    printf(""From CID :"") ;   printf(""status : %d"", ntohs(in.status)) ;printf(""CIDTEST. in.start_time1  ----(%d)"", in.start_time);   printf(""error : %d"", ntohs(in.error)) ;   in.start_time = ntohl(in.start_time) ;   tmp = in.start_time;printf(""CIDTEST. in.start_time2  ---- (%d)"", in.start_time);   printf(""start_time : %s"", ctime(&tmp)) ;   getchar() ;  getchar() ;}",2,"cwe120,cweother"
"""do_errorlog_format(apr_array_header_t *fmt, ap_errorlog_info *info,                              char *buf, int buflen, int *errstr_start,                              int *errstr_end, const char *err_fmt, va_list args){#ifndef AP_UNSAFE_ERROR_LOG_UNESCAPED    char scratch[MAX_STRING_LEN];#endif    int i;    int len = 0;    int field_start = 0;    int skipping = 0;    ap_errorlog_format_item *items = (ap_errorlog_format_item *)fmt->elts;    AP_DEBUG_ASSERT(fmt->nelts > 0);    for (i = 0; i < fmt->nelts; ++i) {        ap_errorlog_format_item *item = &items[i];        if (item->flags & AP_ERRORLOG_FLAG_FIELD_SEP) {            if (skipping) {                skipping = 0;            }            else {                field_start = len;            }        }        if (item->flags & AP_ERRORLOG_FLAG_MESSAGE) {            /* the actual error message */            *errstr_start = len;#ifndef AP_UNSAFE_ERROR_LOG_UNESCAPED            if (apr_vsnprintf(scratch, MAX_STRING_LEN, err_fmt, args)) {                len += ap_escape_errorlog_item(buf + len, scratch,                                               buflen - len);            }#else            len += apr_vsnprintf(buf + len, buflen - len, err_fmt, args);#endif            *errstr_end = len;        }        else if (skipping) {            continue;        }        else if (info->level != -1 && (int)item->min_loglevel > info->level) {            len = field_start;            skipping = 1;        }        else {            int item_len = (*item->func)(info, item->arg, buf + len,                                         buflen - len);            if (!item_len) {                if (item->flags & AP_ERRORLOG_FLAG_REQUIRED) {                    /* required item is empty. skip whole line */                    buf[0] = '0';                    return 0;                }                else if (item->flags & AP_ERRORLOG_FLAG_NULL_AS_HYPHEN) {                    buf[len++] = '-';                }                else {                    len = field_start;                    skipping = 1;                }            }            else {                len += item_len;            }        }    }    return len;}""",2,"cwe119,cwe120"
"get_path_to_volume(char *newvolbuf, int bufsize, char *basepath, long curvol){    char prefix[PATH_MAX];    int pathlen;        if ((pathlen=strlen(basepath))<4)      {   errprintf(""archive has an invalid basepath: [%s]"", basepath);        return -1;    }        if (curvol==0)      {        if (realpath(basepath, newvolbuf)!=newvolbuf)            snprintf(newvolbuf, bufsize, ""%s"", basepath);    }    else      {        memset(prefix, 0, sizeof(prefix));        memcpy(prefix, basepath, pathlen-2);        snprintf(newvolbuf, bufsize, ""%s%.2ld"", prefix, (long)curvol);    }        return 0;}",2,"cwe119,cwe120"
"gmsg_log_dropped_pmsg(const pmsg_t *mb, const char *reason, ...){tchar rbuf[256];tchar buf[128];tgmsg_infostr_full_to_buf(pmsg_start(mb), pmsg_written_size(mb),ttbuf, sizeof buf);tif (reason) {ttva_list args;ttva_start(args, reason);ttrbuf[0] = ':';ttrbuf[1] = ' ';ttstr_vbprintf(&rbuf[2], sizeof rbuf - 2, reason, args);ttva_end(args);t} else {ttrbuf[0] = '0';t}tg_debug(""DROP %s%s"", buf, rbuf);}",2,"cwe119,cwe120"
"compress_file_name(const char *src, int lsrc, char **dst, int *ldst){  char *p;  static char tpath[PATH_MAX];  char tpath2[PATH_MAX];  int len;  int ind;tstrncpy(tpath, src, lsrc);ttpath[lsrc] = 0;tlen = lsrc;ttif (ARCH_verbose)ttprintf(""%s"", tpath); tttfor(;;)t{ttp = index(tpath + 1, '/');ttif (!p)tttbreak;tttt  if (!TABLE_find_symbol(arch_table, tpath, p - tpath, &ind))t  {t  t*p = 0;t  tTHROW(""&1: not in archive"", tpath);tt}tttlen = snprintf(tpath2, sizeof(tpath2), ""/%d:%s"", ind, p + 1);ttstrcpy(tpath, tpath2);t}tif (ARCH_verbose)ttprintf("" -> %s"", tpath); ttt  *dst = tpath;  *ldst = len;}",2,"cwe119,cwe120"
"view_list(void){  char **az;  int i;  login_check_credentials();  if( !g.okRead ){ login_needed(); return; }  throttle(1,0);  common_standard_menu(""reportlist"", ""search?t=1"");  if( g.okQuery ){    common_add_action_item(""rptnew"", ""New Report Format"");  }  common_add_help_item(""CvstracReport"");  common_header(""Available Report Formats"");  az = db_query(""SELECT rn, title, owner FROM reportfmt ORDER BY title"");  cgi_printf(""<p>Choose a report format from the following list:</p>""         ""<ol>"");  for(i=0; az[i]; i+=3){    cgi_printf(""<li><a href=""rptview?rn=%t""""           ""       rel=""nofollow"">%h</a>&nbsp;&nbsp;&nbsp;"",az[i],az[i+1]);    if( g.okWrite && az[i+2] && az[i+2][0] ){      cgi_printf(""(by <i>%h</i>)"",az[i+2]);    }    if( g.okQuery ){      cgi_printf(""[<a href=""rptedit?rn=%t&amp;copy=1"" rel=""nofollow"">copy</a>]"",az[i]);    }    if( g.okAdmin || (g.okQuery && strcmp(g.zUser,az[i+2])==0) ){      cgi_printf(""[<a href=""rptedit?rn=%t"" rel=""nofollow"">edit</a>]"",az[i]);    }    cgi_printf(""[<a href=""rptsql?rn=%t"" rel=""nofollow"">sql</a>]""           ""</li>"",az[i]);  }  if( g.okQuery ){    cgi_printf(""<p><li><a href=""rptnew"">Create a new report format</a></li></p>"");  }  cgi_printf(""</ol>"");  common_footer();}",3,"cwe119,cwe120,cweother"
"check_emax_aux (mpfr_exp_t e){  mpfr_t x;  char *s1, s2[256];  int i;  mpfr_exp_t emax;  MPFR_ASSERTN (e <= LONG_MAX);  emax = mpfr_get_emax ();  set_emax (e);  mpfr_init2 (x, 16);  mpfr_set_inf (x, 1);  mpfr_nextbelow (x);  i = mpfr_asprintf (&s1, ""%Ra %.2Ra"", x, x);  MPFR_ASSERTN (i > 0);  mpfr_snprintf (s2, 256, ""0x7.fff8p+%ld 0x8.00p+%ld"", e-3, e-3);  if (strcmp (s1, s2) != 0)    {      printf (""Error in check_emax_aux for emax = "");      if (e > LONG_MAX)        printf (""(>LONG_MAX)"");      else        printf (""%ld"", (long) e);      printf (""Expected %s"", s2);      printf (""Got      %s"", s1);      exit (1);    }  mpfr_free_str (s1);  i = mpfr_asprintf (&s1, ""%Rb %.2Rb"", x, x);  MPFR_ASSERTN (i > 0);  mpfr_snprintf (s2, 256, ""1.111111111111111p+%ld 1.00p+%ld"", e-1, e);  if (strcmp (s1, s2) != 0)    {      printf (""Error in check_emax_aux for emax = "");      if (e > LONG_MAX)        printf (""(>LONG_MAX)"");      else        printf (""%ld"", (long) e);      printf (""Expected %s"", s2);      printf (""Got      %s"", s1);      exit (1);    }  mpfr_free_str (s1);  mpfr_clear (x);  set_emax (emax);}",2,"cwe119,cwe120"
"""creg_parse(char **strings, int i, gn_network_info *ninfo, int lac_swapped){tchar tmp[3] = {0, 0, 0};tchar *pos;tint first = 0, second = 1;tsize_t n, len;tif (!strings[i] || strlen(strings[i]) < 4 || !strings[i + 1] || strlen(strings[i + 1]) < 4)ttreturn GN_ERR_FAILED;tpos = strip_quotes(strings[i]);t/*t * Some phones have reverse order of the bytes in LAC.t */tif (lac_swapped) {ttfirst = 1;ttsecond = 0;t}ttmp[0] = pos[0];ttmp[1] = pos[1];tninfo->LAC[first] = strtol(tmp, NULL, 16);ttmp[0] = pos[2];ttmp[1] = pos[3];tninfo->LAC[second] = strtol(tmp, NULL, 16);t/*t * GSM phones usually return 4 hex digits, UMTS phones can return up to 8 with optional leading 0'st */tpos = strip_quotes(strings[i + 1]);tn = 0;tlen = strlen(pos);tif (len & 1) {tttmp[0] = *pos++;tttmp[1] = '0';ttninfo->cell_id[n++] = strtol(tmp, NULL, 16);ttlen--;t}twhile (len) {tttmp[0] = *pos++;tttmp[1] = *pos++;ttninfo->cell_id[n++] = strtol(tmp, NULL, 16);ttlen -= 2;t}treturn GN_ERR_NONE;}""",2,"cwe119,cwe120"
"""my_inputfunc(char *buf, size_t buf_size, void *vp){tFILE *fp=(FILE *)vp;tsize_t n;tif (buf_size <= 0)ttreturn -1;t--buf_size;tfor (n=0; n<buf_size; n++)t{ttint c=fgetc(fp);ttif (c == EOF)tt{tttbuf[n]=0;tttreturn n ? 0:-1;tt}ttbuf[n]=c;ttif (c == '')tt{tttn++;tttbreak;tt}t}tbuf[n]=0;treturn 0;}""",2,"cwe120,cweother"
"rwpipe_read_ppm_header( rwpipe *rw, int *width, int *height ){    char line[ 3 ];    FILE *in = rwpipe_reader( rw );    int max;    if (!fgets( line, 3, in ))        return -1;    if ( !strncmp( line, ""P6"", 2 ) )    {        *width = rwpipe_read_number( rw );        *height = rwpipe_read_number( rw );        max = rwpipe_read_number( rw );        return max != 255 || *width <= 0 || *height <= 0;    }    return 1;}",2,"cwe119,cwe120"
"oss_read(void *self, ref_buffer *rb){    int result;    im_oss_state *s = self;    rb->buf = malloc(BUFSIZE*2*s->channels);    if(!rb->buf)        return -1;    result = read(s->fd, rb->buf, BUFSIZE*2*s->channels);    rb->len = result;    rb->aux_data = s->rate*s->channels*2;    if(s->newtrack)    {        rb->critical = 1;        s->newtrack = 0;    }    if(result == -1 && (errno == EINTR || errno == ERESTART))    {        return 0;      }    else if(result <= 0)    {        if(result == 0)            LOG_INFO0(""Reached EOF, no more data available"");        else            LOG_ERROR1(""Error reading from audio device: %s"", strerror(errno));        free(rb->buf);        return -1;    }    return rb->len;}",2,"cwe120,cweother"
"checkout_paths(struct tree *source_tree, const char **pathspec){tint pos;tstruct checkout state;tstatic char *ps_matched;tunsigned char rev[20];tint flag;tstruct commit *head;tint errs = 0;tint newfd;tstruct lock_file *lock_file = xcalloc(1, sizeof(struct lock_file));tnewfd = hold_locked_index(lock_file, 1);tread_cache();tif (source_tree)ttread_tree_some(source_tree, pathspec);tfor (pos = 0; pathspec[pos]; pos++)tt;tps_matched = xcalloc(1, pos);tfor (pos = 0; pos < active_nr; pos++) {ttstruct cache_entry *ce = active_cache[pos];ttpathspec_match(pathspec, ps_matched, ce->name, 0);t}tif (report_path_error(ps_matched, pathspec, 0))ttreturn 1;t tmemset(&state, 0, sizeof(state));tstate.force = 1;tstate.refresh_cache = 1;tfor (pos = 0; pos < active_nr; pos++) {ttstruct cache_entry *ce = active_cache[pos];ttif (pathspec_match(pathspec, NULL, ce->name, 0)) {ttterrs |= checkout_entry(ce, &state, NULL);tt}t}tif (write_cache(newfd, active_cache, active_nr) ||t    commit_locked_index(lock_file))ttdie(""unable to write new index file"");tresolve_ref(""HEAD"", rev, 0, &flag);thead = lookup_commit_reference_gently(rev, 1);terrs |= post_checkout_hook(head, head, 0);treturn errs;}",3,"cwe119,cwe120,cwe469"
"loadTestModule(MprTestService *sp, cchar *fileName){    MprModule   *mp;    char        *cp, *base, entry[MPR_MAX_FNAME], path[MPR_MAX_FNAME];    mprAssert(fileName && *fileName);    base = mprGetPathBase(fileName);    mprAssert(base);    if ((cp = strrchr(base, '.')) != 0) {        *cp = '0';    }    if (mprLookupModule(base)) {        return 0;    }    mprSprintf(entry, sizeof(entry), ""%sInit"", base);    if (fileName[0] == '/' || (*fileName && fileName[1] == ':')) {        mprSprintf(path, sizeof(path), ""%s%s"", fileName, BLD_SHOBJ);    } else {        mprSprintf(path, sizeof(path), ""./%s%s"", fileName, BLD_SHOBJ);    }    if ((mp = mprCreateModule(base, path, entry, sp)) == 0) {        mprError(""Can't create module %s"", path);        return -1;    }    if (mprLoadModule(mp) < 0) {        mprError(""Can't load module %s"", path);        return -1;    }    return 0;}",3,"cwe119,cwe120,cwe476"
"help_monster_out(struct monst *mtmp, struct trap *ttmp){    int wt;    struct obj *otmp;    bool uprob;         if (!mtmp->mtrapped)    {        pline(""%s isn't trapped."", Monnam(mtmp));        return 0;    }         if (check_capacity((char *)0)) return 1;         if ((uprob = untrap_prob(ttmp)) && !mtmp->msleeping && mtmp->mcanmove)    {        You(""try to reach out your %s, but %s backs away skeptically."",            makeplural(body_part(ARM)),            mon_nam(mtmp));        return 1;    }         if (touch_petrifies(mtmp->data) && !uarmg && !Stone_resistance)    {        You(""grab the trapped %s using your bare %s."",            mtmp->data->mname, makeplural(body_part(HAND)));        if (poly_when_stoned(youmonst.data) && polymon(PM_STONE_GOLEM))                display_nhwindow(WIN_MESSAGE, false);        else        {            char kbuf[BUFSZ];            sprintf(kbuf, ""trying to help %s out of a pit"",                    an(mtmp->data->mname));            instapetrify(kbuf);            return 1;        }    }         if (uprob)    {        You(""try to grab %s, but cannot get a firm grasp."",            mon_nam(mtmp));        if (mtmp->msleeping)        {            mtmp->msleeping = 0;            pline(""%s awakens."", Monnam(mtmp));        }        return 1;    }    You(""reach out your %s and grab %s."",        makeplural(body_part(ARM)), mon_nam(mtmp));    if (mtmp->msleeping)    {        mtmp->msleeping = 0;        pline(""%s awakens."", Monnam(mtmp));    }    else if (mtmp->mfrozen && !rn2(mtmp->mfrozen))    {                 mtmp->mcanmove = 1;        mtmp->mfrozen = 0;        pline(""%s stirs."", Monnam(mtmp));    }         wt = inv_weight() + mtmp->data->cwt;    if (!try_lift(mtmp, ttmp, wt, false)) return 1;         for (otmp = mtmp->minvent; otmp; otmp = otmp->nobj)            wt += otmp->owt;    if (!try_lift(mtmp, ttmp, wt, true)) return 1;    You(""pull %s out of the pit."", mon_nam(mtmp));    mtmp->mtrapped = 0;    fill_pit(mtmp->mx, mtmp->my);    reward_untrap(ttmp, mtmp);    return 1;}",2,"cwe119,cwe120"
"vv_cross3(vectorA, vectorB, v_result)const hvec3_t *vectorA;const hvec3_t *vectorB;hvec3_t *v_result;{   int which_vec;              hvec3_t buf;   if(v_result == vectorA)   {     v_result = &buf;     which_vec = 1;   }   else     if(v_result == vectorB)     {        v_result = &buf;        which_vec = 2;     }     else     {        v_result = gm_ALLOC(hvec3_t, v_result, ""vv_cross3()"");        which_vec = 0;     };   v_x(*v_result) = v_y(*vectorA) * v_z(*vectorB) -            v_z(*vectorA) * v_y(*vectorB);   v_y(*v_result) = v_z(*vectorA) * v_x(*vectorB) -            v_x(*vectorA) * v_z(*vectorB);   v_z(*v_result) = v_x(*vectorA) * v_y(*vectorB) -            v_y(*vectorA) * v_x(*vectorB);   v_w(*v_result) = v_w(*vectorA) * v_w(*vectorB);   switch(which_vec)   {     case 0 : return v_result;     case 1 :                *(hvec3_t *)vectorA = *v_result;              return (hvec3_t *)vectorA;     case 2 :                *(hvec3_t *)vectorB = *v_result;              return (hvec3_t *)vectorB;   };terror_at_line(0, 0, __FILE__, __LINE__, ""This should not happen!"");treturn v_result;t }",2,"cwe476,cweother"
"ocsp_match_issuerid(X509 *cert, OCSP_CERTID *cid,tttSTACK_OF(OCSP_SINGLERESP) *sresp)t{t tif(cid)tt{ttconst EVP_MD *dgst;ttX509_NAME *iname;ttint mdlen;ttunsigned char md[EVP_MAX_MD_SIZE];ttif (!(dgst = EVP_get_digestbyobj(cid->hashAlgorithm->algorithm)))ttt{tttOCSPerr(OCSP_F_OCSP_MATCH_ISSUERID, OCSP_R_UNKNOWN_MESSAGE_DIGEST);tttreturn -1;ttt}ttmdlen = EVP_MD_size(dgst);ttif (mdlen < 0)tt    return -1;ttif ((cid->issuerNameHash->length != mdlen) ||tt   (cid->issuerKeyHash->length != mdlen))tttreturn 0;ttiname = X509_get_subject_name(cert);ttif (!X509_NAME_digest(iname, dgst, md, NULL))tttreturn -1;ttif (memcmp(md, cid->issuerNameHash->data, mdlen))tttreturn 0;ttX509_pubkey_digest(cert, dgst, md, NULL);ttif (memcmp(md, cid->issuerKeyHash->data, mdlen))tttreturn 0;ttreturn 1;tt}telsett{tt ttint i, ret;ttOCSP_CERTID *tmpid;ttfor (i = 0; i < sk_OCSP_SINGLERESP_num(sresp); i++)ttt{ttttmpid = sk_OCSP_SINGLERESP_value(sresp, i)->certId;tttret = ocsp_match_issuerid(cert, tmpid, NULL);tttif (ret <= 0) return ret;ttt}ttreturn 1;tt}tttt}",2,"cwe119,cwe120"
"globus_l_common_env_path( char** bufp, char* name ){    char     errmsg[256];    char *   p;    *bufp = GLOBUS_NULL;    p = globus_libc_getenv(name);    if (!p || strlen(p)==0)    {tglobus_libc_sprintf(errmsg,_GCSL(""Environment variable %s is not set""), name);treturn GLOBUS_COMMON_PATH_ERROR_INSTANCE(errmsg);    }    *bufp = globus_libc_strdup(p);    if (! *bufp)    {treturn GLOBUS_COMMON_PATH_ERROR_INSTANCE(_GCSL(""malloc error""));    }        return GLOBUS_SUCCESS;}",2,"cwe119,cwe120"
"write_merged_jcl_options(FILE *stream,                                    char **original_opts,                                    char **opts,                                    size_t readbinarybytes,                                    const char *jclstr){    char *p = strstr(original_opts[0], jclstr);    char header[128];    char **optsp1 = NULL, **optsp2 = NULL;         if (argv_count(original_opts) == 1)    {        fprintf(stream, ""%s"", jclbegin);        argv_write(stream, opts, """");        write_binary_data(stream, original_opts[0], readbinarybytes);        return 0;    }    if (argv_count(original_opts) == 2)    {                 if (p)            fwrite(original_opts[0], 1, p - original_opts[0], stream);        else            fprintf(stream, ""%s"", original_opts[0]);        argv_write(stream, opts, """");        if (p)            fprintf(stream, ""%s"", p);        write_binary_data(stream, original_opts[1], readbinarybytes);        return 1;    }         strncpy(header, original_opts[0], p - original_opts[0]);    header[p - original_opts[0]] = '0';    fprintf(stream, ""%s"", header);         for (optsp1 = original_opts; *(optsp1 + 1); optsp1++) {        if (optsp2 == NULL &&t    ((strstr(*optsp1, ""ENTER LANGUAGE"") != NULL) ||t     (strncasecmp(*optsp1, ""@PJL SET "", 9) == 0))) {t    for (optsp2 = opts; *optsp2; optsp2++)t        if (!jcl_options_find_keyword(original_opts, *optsp2, jclstr))tt    fprintf(stream, ""%s"", *optsp2);t}        if (optsp1 != original_opts) p = *optsp1;        if (!p)            _log(""write_merged_jcl_options() dereferences NULL pointer p"");        if (jcl_options_find_keyword(opts, p, jclstr))t  fprintf(stream, ""%s"", jcl_options_find_keyword(opts, p, jclstr));telse            fprintf(stream, ""%s"", p);    }    if (optsp2 == NULL)        for (optsp2 = opts; *optsp2; optsp2++)            if (!jcl_options_find_keyword(original_opts, *optsp2, jclstr))t        fprintf(stream, ""%s"", *optsp2);    write_binary_data(stream, *optsp1, readbinarybytes);    return 1;}",2,"cwe119,cwe120"
"trfs_check_super_csum(char *raw_disk_sb){tstruct btrfs_super_block *disk_sb =tt(struct btrfs_super_block *)raw_disk_sb;tu16 csum_type = btrfs_super_csum_type(disk_sb);tint ret = 0;tif (csum_type == BTRFS_CSUM_TYPE_CRC32) {ttu32 crc = ~(u32)0;ttconst int csum_size = sizeof(crc);ttchar result[csum_size];tt ttcrc = btrfs_csum_data(raw_disk_sb + BTRFS_CSUM_SIZE,ttttcrc, BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE);ttbtrfs_csum_final(crc, result);ttif (memcmp(raw_disk_sb, result, csum_size))tttret = 1;t}tif (csum_type >= ARRAY_SIZE(btrfs_csum_sizes)) {ttprintk(KERN_ERR ""BTRFS: unsupported checksum algorithm %u"",ttttcsum_type);ttret = 1;t}treturn ret;}",2,"cwe119,cwe120"
"getPlayerRanking ( PLAYERSTATS player )r{rtFILE* file;rtchar name[34], points[32], frags[32], totalfrags[32], time[16], totaltime[16], ip[32], poll[16], remote_address[21];rtint foundplayer = false;rrt tfile = statsdb_open( ""r"" ) ;rrtif(file != NULL) {rrtt ttwhile(player.ranking < 1000) {rrttt ttt tttcpr = fgets(name, sizeof(name), file);rtttif ( cpr == NULL )rttt{  ttttbreak;rttt}rtttif ( name[strlen(name) - 1] == '' )rttt{rttttname[strlen(name) - 1] = 0;  ttt}rttt tttcpr = fgets(remote_address, sizeof(remote_address), file);rttt tttcpr = fgets(points, sizeof(points), file);rttt tttcpr = fgets(frags, sizeof(frags), file);rttt tttcpr = fgets(totalfrags, sizeof(totalfrags), file);rtttif(!strcmp(player.playername, name))rttttplayer.totalfrags = atoi(totalfrags);rttt tttcpr = fgets(time, sizeof(time), file);rttt tttcpr = fgets(totaltime, sizeof(totaltime), file);rtttif(!strcmp(player.playername, name))rttttplayer.totaltime = atof(totaltime);rttt tttcpr = fgets(ip, sizeof(ip), file);rttt tttcpr = fgets(poll, sizeof(poll), file);rrtttplayer.ranking++;rrtttif(!strcmp(player.playername, name)) {rttttfoundplayer = true;rttttbreak;  ttt}rtt}rttfclose(file);rt}rrtif(!foundplayer) {rttplayer.ranking = 1000;rttplayer.totalfrags = 0;rttplayer.totaltime = 1;rt}rrtreturn player;r}",3,"cwe119,cwe120,cweother"
"gp_open_print(const u_char *dat, int length){tstruct bgp_open bgpo;tstruct bgp_opt bgpopt;tconst u_char *opt;tint i;tchar tokbuf[TOKBUFSIZE];tTCHECK2(dat[0], BGP_OPEN_SIZE);tmemcpy(&bgpo, dat, BGP_OPEN_SIZE);tprintf(""t  Version %d, "", bgpo.bgpo_version);tprintf(""my AS %s, "",t    as_printf(astostr, sizeof(astostr), ntohs(bgpo.bgpo_myas)));tprintf(""Holdtime %us, "", ntohs(bgpo.bgpo_holdtime));tprintf(""ID %s"", getname((u_char *)&bgpo.bgpo_id));tprintf(""t  Optional parameters, length: %u"", bgpo.bgpo_optlen);                 if (length < bgpo.bgpo_optlen+BGP_OPEN_SIZE)             return;t topt = &((const struct bgp_open *)dat)->bgpo_optlen;topt++;ti = 0;twhile (i < bgpo.bgpo_optlen) {ttTCHECK2(opt[i], BGP_OPT_SIZE);ttmemcpy(&bgpopt, &opt[i], BGP_OPT_SIZE);ttif (i + 2 + bgpopt.bgpopt_len > bgpo.bgpo_optlen) {tttprintf(""t     Option %d, length: %u"", bgpopt.bgpopt_type, bgpopt.bgpopt_len);tttbreak;tt}ttprintf(""t    Option %s (%u), length: %u"",tt       tok2strbuf(bgp_opt_values,""Unknown"",tttt  bgpopt.bgpopt_type,tttt  tokbuf, sizeof(tokbuf)),tt       bgpopt.bgpopt_type,tt       bgpopt.bgpopt_len);tt ttswitch(bgpopt.bgpopt_type) {ttcase BGP_OPT_CAP:tttbgp_capabilities_print(&opt[i+BGP_OPT_SIZE],ttt    bgpopt.bgpopt_len);tttbreak;ttcase BGP_OPT_AUTH:ttdefault:tt       printf(""t      no decoder for option %u"",ttt   bgpopt.bgpopt_type);tt       break;tt}tti += BGP_OPT_SIZE + bgpopt.bgpopt_len;t}treturn;trunc:tprintf(""[|BGP]"");}",2,"cwe119,cwe120"
"main(int argc, char **argv){tconst char *socket = OPENNHRP_ADMIN_SOCKET;tchar cmd[1024] = """", *pos = cmd;tint i, fd;tfor (i = 1; i < argc; i++) {ttif (strlen(argv[i]) != 2 || argv[i][0] != '-') {tttpos += snprintf(pos, &cmd[sizeof(cmd)-1]-pos,ttttt"" %s"", argv[i]) - 1;tttcontinue;tt}ttswitch (argv[i][1]) {ttcase 'a':tttif (++i >= argc)ttttreturn usage(argv[0]);tttsocket = argv[i];tttbreak;ttdefault:tttreturn usage(argv[0]);tt}t}tif (cmd == pos)ttreturn usage(argv[0]);tfd = admin_init(socket);tif (fd < 0) {ttfprintf(stderr,ttt""Failed to connect to opennhrp daemon [%s]: %s."",tttsocket, strerror(errno));ttreturn 1;t}tif (admin_send(fd, &cmd[1]) < 0 ||t    admin_receive(fd) < 0) {ttfprintf(stderr, ""Failed to send request: %s."",tttstrerror(errno));ttreturn 2;t}tadmin_close(fd);treturn 0;}",2,"cwe119,cwe120"
"GetPolyCount(char *sensekey){    IndexPtr idx;    int sense_cnt = 0;         idx = index_lookup(GetWORD(sensekey), GetPOS(sensekey));    if (idx) {tsense_cnt = idx->sense_cnt;tfree_index(idx);    }    return(sense_cnt);}",2,"cwe119,cwe120"
"init_define(const char *name, const char *val){tstructtmacrot*hp = lookupcreatename(name);tif  (hp->expansion)ttfree(hp->expansion);thp->expansion = stracpy(val);}",2,"cwe119,cwe120"
"JoinServer_InfoDraw( void ){tchar key[MAX_INFO_KEY];tchar value[MAX_INFO_VALUE];tconst char *info;tint x = s_joinserver_server_list.width + 40;tint y = 80;tint index;tserverStatus_t *server;tplayerStatus_t *player;tint i;t tif( viddef.width < 512 )ttreturn;tindex = s_joinserver_server_list.curvalue;tif( index < 0 || index >= MAX_MENU_SERVERS )ttreturn;tserver = &localServers[sortedSList[index]];tDrawAltString( x, y, ""Name            Score Ping"");ty += 8;tDrawAltString( x, y, ""--------------- ----- ----"");ty += 10;tif( !server->numPlayers ) {ttDrawAltString( x, y, ""No players"");tty += 8;t}telset{ttfor( i=0, player=server->players ; i<server->numPlayers ; i++, player++ ) {tttDrawString( x, y, va( ""%-15s %5i %4i"", player->name, player->score, player->ping ));ttty += 8;tt}t}ty+=8;tDrawAltString( x, y, ""Server info"");ty += 8;tDrawAltString( x, y, ""--------------------------"");ty += 10;tinfo = (const char *)server->infostring;twhile( *info ) {ttInfo_NextPair( &info, key, value );ttif(!key[0] || !value[0])tttbreak;ttif( strlen( key ) > 15 ) {tttstrcpy( key + 12, ""..."" );tt}ttDrawString( x, y, va( ""%-8s"", key ));ttDrawString( x + 16 * 8, y, va( ""%-16s"", value ));tty += 8;t}}",2,"cwe119,cwe120"
"readtoken (FILE *stream,           const char *delim,           size_t n_delim,           token_buffer *tokenbuffer){  char *p;  int c;  size_t i, n;  word isdelim[(UCHAR_MAX + bits_per_word) / bits_per_word];  memset (isdelim, 0, sizeof isdelim);  for (i = 0; i < n_delim; i++)    {      unsigned char ch = delim[i];      set_nth_bit (ch, isdelim);    }     for (c = getc (stream); c >= 0 && get_nth_bit (c, isdelim); c = getc (stream))    {           }  p = tokenbuffer->buffer;  n = tokenbuffer->size;  i = 0;  for (;;)    {      if (c < 0 && i == 0)        return -1;      if (i == n)        p = x2nrealloc (p, &n, sizeof *p);      if (c < 0)        {          p[i] = 0;          break;        }      if (get_nth_bit (c, isdelim))        {          p[i] = 0;          break;        }      p[i++] = c;      c = getc (stream);    }  tokenbuffer->buffer = p;  tokenbuffer->size = n;  return i;}",2,"cwe120,cweother"
"hcrp_credit_request(int sk, uint16_t tid, uint32_t *credit){tstruct hcrp_pdu_hdr hdr;tstruct hcrp_credit_request_rp rp;tunsigned char buf[128];tint len;thdr.pid = htons(HCRP_PDU_CREDIT_REQUEST);thdr.tid = htons(tid);thdr.plen = htons(0);tmemcpy(buf, &hdr, HCRP_PDU_HDR_SIZE);tlen = write(sk, buf, HCRP_PDU_HDR_SIZE);tif (len < 0)ttreturn len;tlen = read(sk, buf, sizeof(buf));tif (len < 0)ttreturn len;tmemcpy(&hdr, buf, HCRP_PDU_HDR_SIZE);tmemcpy(&rp, buf + HCRP_PDU_HDR_SIZE, HCRP_CREDIT_REQUEST_RP_SIZE);tif (ntohs(rp.status) != HCRP_STATUS_SUCCESS) {tterrno = EIO;ttreturn -1;t}tif (credit)tt*credit = ntohl(rp.credit);treturn 0;}",3,"cwe119,cwe120,cweother"
"io_read (void){  FILE *f = getfile(""_INPUT"");  char *buff;  char *p = luaL_opt_string(1, ""[^]*{}"");  int inskip = 0;     int c = NEED_OTHER;  luaI_emptybuff();  while (*p) {    if (*p == '{') {      inskip++;      p++;    }    else if (*p == '}') {      if (inskip == 0)        lua_error(""unbalanced braces in read pattern"");      inskip--;      p++;    }    else {      char *ep = luaL_item_end(p);         int m;         if (c == NEED_OTHER) c = getc(f);      m = (c == EOF) ? 0 : luaL_singlematch((char)c, p);      if (m) {        if (inskip == 0) luaI_addchar(c);        c = NEED_OTHER;      }      switch (*ep) {        case '*':             if (!m) p = ep+1;             break;        case '?':             p = ep+1;             break;        default:          if (m) p = ep;             else            goto break_while;          }    }  } break_while:  if (c >= 0)        ungetc(c, f);  buff = luaI_addchar(0);  if (*buff != 0 || *p == 0)       lua_pushstring(buff);}",2,"cwe120,cweother"
"print_event(struct event *event){t t#define N(str) ((str) ? str : """")t tif (event->type == ET_MACHINE_ID)ttreturn;t tif (!all_events_flag && event->type != ET_START)ttreturn;t tif (all_events_flag)ttprintf(""%-5.5s "", get_rec_type(event));t tprintf(""%-25.25s"", N(event->name));tif (uuid_flag)ttprintf(""t%-36.36s"", N(event->uuid));tprintf(""t%-11.11st%-35.35s"", get_username(event),tttget_time_period(event));t tif (event->type == ET_RES) {ttprintf(""t%-12.12s"", N(event->res_type));ttprintf(""t%-10.10s"", N(event->reason));ttif (strcmp(""cgroup"", event->res_type) != 0) {tttprintf(""t%s"", N(event->res));tt} else {tttprintf(""t%st%st%s"", N(event->cgroup_class),tttttN(event->cgroup_acl),tttttN(event->cgroup_detail));tt}t} else if (event->type == ET_MACHINE_ID) {ttprintf(""t%s"", N(event->seclevel));t} else if (event->type == ET_AVC) {ttprintf(""t%-12.12s"", N(event->avc_operation));ttprintf(""t%-10.10s"", N(event->avc_result));ttprintf(""t%st%st%s"", N(event->comm), N(event->target),ttttN(event->context));t}tprintf("""");t tif (proof_flag) {ttint first = 1;ttint i, len = sizeof(event->proof)/sizeof(event->proof[0]);ttprintf(""    Proof:"");ttfor (i = 0; i < len; i++) {tttif (event->proof[i].time) {ttttprintf(""%s %ld.%03u:%lu"",ttttt(first) ? """" : "","",tttttevent->proof[i].time,tttttevent->proof[i].milli,tttttevent->proof[i].serial);ttttfirst = 0;ttt}tt}ttprintf("""");t}}",2,"cwe469,cweother"
"capi_get_cmsg (_cmsg *cmsg, unsigned applid){    MESSAGE_EXCHANGE_ERROR rtn;    CAPI_MESSAGE msg;    rtn = capi20_get_message(applid, &msg);    if (rtn == 0x0000)        capi_message2cmsg(cmsg, msg);    return rtn;}",2,"cwe119,cwe120"
"""fgetline(char **line, size_t *linesize, size_t *count, size_t *llen,ttFILE *fp, int appendnl){tlong i_llen, sz;tif (count == NULL)tt/*tt * If we have no count, we cannot determine where thett * characters returned by fgets() end if there was nott * newline. We have to read one character at one.tt */ttreturn fgetline_byone(line, linesize, llen, fp, appendnl, 0);tif (*line == NULL || *linesize < LINESIZE)tt*line = srealloc(*line, *linesize = LINESIZE);tsz = *linesize <= *count ? *linesize : *count + 1;tif (sz <= 1 || fgets(*line, sz, fp) == NULL)tt/*tt * Leave llen untouched; it is used to determine whethertt * the last line was -terminated in some callers.tt */ttreturn NULL;ti_llen = length_of_line(*line, sz);t*count -= i_llen;twhile ((*line)[i_llen - 1] != '') {tt*line = srealloc(*line, *linesize += 256);ttsz = *linesize - i_llen;ttsz = (sz <= *count ? sz : *count + 1);ttif (sz <= 1 || fgets(&(*line)[i_llen], sz, fp) == NULL) {tttif (appendnl) {tttt(*line)[i_llen++] = '';tttt(*line)[i_llen] = '0';ttt}tttbreak;tt}ttsz = length_of_line(&(*line)[i_llen], sz);tti_llen += sz;tt*count -= sz;t}tif (llen)tt*llen = i_llen;treturn *line;}""",2,"cwe120,cweother"
"""wiki_job_requeue(struct job_record *job_ptr, char *reason){tint empty = -1, i;tjob_ptr->priority = 0;tfor (i=0; i<REJECT_MSG_MAX; i++) {ttif ((reject_msgs[i].job_id == 0) && (empty == -1)) {tttempty = i;tttif (reject_msg_cnt == 0)ttttbreak;tt} else if (reject_msgs[i].job_id != job_ptr->job_id)tttcontinue;tt/* over-write previous message for this job */ttstrncpy(reject_msgs[i].reason, reason, REJECT_MSG_LEN);ttreject_msgs[i].reason[REJECT_MSG_LEN - 1] = '0';ttreturn;t}tif (empty == -1)t/* no free space */ttreturn;treject_msgs[empty].job_id = job_ptr->job_id;tstrncpy(reject_msgs[i].reason, reason, REJECT_MSG_LEN);treject_msgs[i].reason[REJECT_MSG_LEN - 1] = '0';treject_msg_cnt++;}""",2,"cwe119,cwe120"
"db_lrc_create(void *hv, char *lfn, char *pfn, char *errmsg){  db_handle_tt*h = (db_handle_t *) hv;  charttbuf[BIGBUF];  SQLINTEGERtlfn_id;  SQLINTEGERtpfn_id;  intttrc;  SQLRETURNtr;  intttadjcount[T_NUM];  if (loglevel > 1)    logit(LOG_DEBUG, ""db_lrc_create: %s %s"", lfn, pfn);  if (strlen(lfn) + 1 > MAXDBSTR) {    strncpy(errmsg, lfn, MAXERRMSG);    return GLOBUS_RLS_BADARG;  }  if (strlen(pfn) + 1 > MAXDBSTR) {    strncpy(errmsg, pfn, MAXERRMSG);    return GLOBUS_RLS_BADARG;  }  begintran(h, adjcount);     snprintf(buf, BIGBUF, ""insert into t_lfn (name, ref) values ('%s', 1)"", lfn);  r = SQLExecDirect(h->stmt, (SQLCHAR *) buf, SQL_NTS);  if (!SQLOK(r)) {    rc = seterr_insert(h, r, ""t_lfn"", lfn, GLOBUS_RLS_LFN_EXIST, errmsg);    goto error;  }  adjcount[T_LRCLFN]++;  if ((rc = getid(h, lfn, ""t_lfn"", GLOBUS_RLS_LFN_NEXIST, &lfn_id,tt  errmsg)) != GLOBUS_RLS_SUCCESS)    goto error;     if ((rc = updateref(h, T_LRCPFN, pfn, 1, 1, &pfn_id, NULL,tt      errmsg, adjcount)) != GLOBUS_RLS_SUCCESS)    goto error;     snprintf(buf, BIGBUF, ""insert into t_map (lfn_id,pfn_id) values (%d,%d)"",t   (int) lfn_id, (int) pfn_id);  r = SQLExecDirect(h->stmt, (SQLCHAR *) buf, SQL_NTS);  if (!SQLOK(r)) {    rc = seterr_insertmap(h, r, ""lfn_id"", (int) lfn_id, ""pfn_id"", (int) pfn_id,             NULL, 0, errmsg);    goto error;  }  adjcount[T_LRCMAP]++;  rc = endtran(h, SQL_COMMIT, errmsg, adjcount);  return rc; error:  endtran(h, SQL_ROLLBACK, NULL, NULL);  return rc;}",2,"cwe119,cwe120"
"delete_spooled_data(void){     lList *answer_list = NULL;   lListElem *job;   lListElem *context;   char key[100];   context = spool_get_default_context();       for_each(job, *object_type_get_master_list(SGE_TYPE_JOB)) {      sprintf(key, sge_U32CFormat"".0"", sge_u32c(lGetUlong(job, JB_job_number)));      spool_delete_object(&answer_list, context, SGE_TYPE_JOB, key, true);      answer_list_output(&answer_list);   }   return true;}",3,"cwe119,cwe120,cweother"
"maildb_txt_store_mail(int char_id, struct mail_data *md){tchar filename[1056];tFILE *fp;tunsigned int i;tnullpo_retr(false, md);tsprintf(filename, ""%s%d.txt"", mail_dir, char_id);tfp = fopen(filename, ""a"");tif(fp == NULL)t{ttprintf(""maildb_txt_store_mail: can't write [%s] !!! data is lost !!!"", filename);ttreturn false;t}tfprintf(fp, ""%u,%dt%st%st%st%dt%u,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%ut%ut%ut"",ttmd->mail_num, md->read, md->char_name, md->receive_name, md->title, md->zeny,ttmd->item.id, md->item.nameid, md->item.amount, md->item.equip,ttmd->item.identify, md->item.refine, md->item.attribute,ttmd->item.card[0], md->item.card[1], md->item.card[2], md->item.card[3], md->item.limit,ttmd->times, md->body_size);tfor(i = 0; i < md->body_size; i++) {ttfprintf(fp, ""%02X"", (unsigned char)(md->body[i]));t}tfprintf(fp, NEWLINE);tfclose(fp);treturn true;}",3,"cwe119,cwe120,cweother"
"xsh_cfg_recover_gen_xyg_frame(cpl_frame  *   wave_list,ttt  cpl_frame  *   config_frame,ttt  xsh_instrument* inst, int prescan){  cpl_table*   lines_tab=NULL ;  cpl_frame* result=NULL;  struct xs_3* p_xs_3_config=NULL;  struct xs_3 xs_3_config;  cpl_table* lines_xyg=NULL;  cpl_propertylist* header=NULL;  char name_o[256];  const char* tag=XSH_GET_TAG_FROM_ARM(XSH_MODEL_GUESS_XY,inst);  sprintf(name_o,""%s%s"",tag,"".fits"");     p_xs_3_config=&xs_3_config;  if (xsh_model_config_load_best(config_frame, p_xs_3_config) !=       CPL_ERROR_NONE) {    xsh_msg_error(""Cannot load %s as a config"", tt  cpl_frame_get_filename(config_frame)) ;    return NULL ;  }     check(lines_tab = cpl_table_load(cpl_frame_get_filename(wave_list), 1, 0)) ;      check(xsh_cfg_recover_gen_xyg(lines_tab,p_xs_3_config,inst,prescan,&lines_xyg));        header=cpl_propertylist_new();  check( xsh_pfits_set_pcatg(header,tag));  cpl_table_save(lines_xyg, header, NULL,name_o, CPL_IO_DEFAULT);    result=xsh_frame_product(name_o,tag,CPL_FRAME_TYPE_TABLE,ttttCPL_FRAME_GROUP_PRODUCT,ttttCPL_FRAME_LEVEL_FINAL);  cpl_error_reset(); cleanup:  xsh_free_propertylist(&header);  xsh_free_table(&lines_tab);  xsh_free_table(&lines_xyg);  if (cpl_error_get_code() != CPL_ERROR_NONE) {    return NULL;  } else {    return result;  }}",2,"cwe119,cwe120"
"netbeans_file_opened(buf_T *bufp){    int bufno = nb_getbufno(bufp);    char    buffer[2*MAXPATHL];    char_u  *q;    nbbuf_T *bp = nb_get_buf(nb_getbufno(bufp));    intt    bnum;    if (!NETBEANS_OPEN)treturn;    q = nb_quote(bufp->b_ffname);    if (q == NULL)treturn;    if (bp != NULL)tbnum = bufno;    elsetbnum = 0;    vim_snprintf(buffer, sizeof(buffer), ""%d:fileOpened=%d ""%s"" %s %s"",t    bnum,t    0,t    (char *)q,t    ""T"",   t    ""F"");      vim_free(q);    nbdebug((""EVT: %s"", buffer));    nb_send(buffer, ""netbeans_file_opened"");    if (p_acd && vim_chdirfile(bufp->b_ffname) == OK)tshorten_fnames(TRUE);}",2,"cwe119,cwe120"
"chart_save(){    char file_name[512];    int i;tSet_Chart *chart = 0;    FILE *file = 0;    if ( !chart_loaded ) return;         sprintf( file_name, ""%s/%s"", chart_path, CHART_FILE_NAME );    if (!strcmp(chart_path, HI_DIR) && hi_dir_chart_file) {        file = hi_dir_chart_file;        rewind(hi_dir_chart_file);    }    else {                 if ((file = fopen( file_name, ""r+"" )) == NULL)            file = fopen( file_name, ""w"" );      }    if ( !file ) {        fprintf( stderr, _(""??? Highscore chart loaded properly but cannot save? (%s)""),file_name );        return;    }t tlist_reset( charts );twhile ( ( chart = list_next( charts ) ) !=  0 ) {ttfprintf( file, "">>>%s"", chart->name );    tfor ( i = 0; i < CHART_ENTRY_COUNT; i++ )        tfprintf( file, ""%s%i%i"", chart->entries[i].name, chart->entries[i].level, chart->entries[i].score );t}tt    if (file != hi_dir_chart_file)        fclose( file );}",4,"cwe119,cwe120,cwe476,cweother"
"""heim_ntlm_calculate_ntlm2(const void *key, size_t len,ttt  const char *username,ttt  const char *target,ttt  const unsigned char serverchallenge[8],ttt  const struct ntlm_buf *infotarget,ttt  unsigned char ntlmv2[16],ttt  struct ntlm_buf *answer){    krb5_error_code ret;    krb5_data data;    unsigned char ntlmv2answer[16];    krb5_storage *sp;    unsigned char clientchallenge[8];    uint64_t t;    t = heim_ntlm_unix2ts_time(time(NULL));    if (RAND_bytes(clientchallenge, sizeof(clientchallenge)) != 1)treturn HNTLM_ERR_RAND;    /* calculate ntlmv2 key */    heim_ntlm_ntlmv2_key(key, len, username, target, 0, ntlmv2);    /* calculate and build ntlmv2 answer */    sp = krb5_storage_emem();    if (sp == NULL)treturn ENOMEM;    krb5_storage_set_flags(sp, KRB5_STORAGE_BYTEORDER_LE);    CHECK(krb5_store_uint32(sp, 0x00000101), 0);    CHECK(krb5_store_uint32(sp, 0), 0);    /* timestamp le 64 bit ts */    CHECK(krb5_store_uint32(sp, t & 0xffffffff), 0);    CHECK(krb5_store_uint32(sp, t >> 32), 0);    CHECK_SIZE(krb5_storage_write(sp, clientchallenge, 8), 8);    CHECK(krb5_store_uint32(sp, 0), 0);  /* Z(4) */    CHECK_SIZE(krb5_storage_write(sp, infotarget->data, infotarget->length),t  infotarget->length);    /*     * These last 4 bytes(Z(4)) are not documented by MicroSoft and     * SnowLeopard doesn't send them, Lion expected them to be there,     * so we have to continue to send them. That is ok, since everyone     * else (except Snow) seems to do that too.     */    CHECK(krb5_store_uint32(sp, 0), 0); /* Z(4) */    CHECK(krb5_storage_to_data(sp, &data), 0);    krb5_storage_free(sp);    sp = NULL;    heim_ntlm_derive_ntlm2_sess(ntlmv2, data.data, data.length, serverchallenge, ntlmv2answer);    sp = krb5_storage_emem();    if (sp == NULL) {tkrb5_data_free(&data);treturn ENOMEM;    }    CHECK_SIZE(krb5_storage_write(sp, ntlmv2answer, 16), 16);    CHECK_SIZE(krb5_storage_write(sp, data.data, data.length), data.length);    krb5_data_free(&data);    CHECK(krb5_storage_to_data(sp, &data), 0);    krb5_storage_free(sp);    sp = NULL;    answer->data = data.data;    answer->length = data.length;    return 0;out:    if (sp)tkrb5_storage_free(sp);    return ret;}""",2,"cwe119,cwe120"
"cma_set_parameter(enum attr_city attr, int city_id,tt       const struct cm_parameter *parameter){  char buffer[SAVED_PARAMETER_SIZE];  struct data_out dout;     dio_output_init(&dout, buffer, sizeof(buffer));  dio_put_uint8(&dout, 2);  output_type_iterate(i) {    dio_put_sint16(&dout, parameter->minimal_surplus[i]);    dio_put_sint16(&dout, parameter->factor[i]);  } output_type_iterate_end;  dio_put_sint16(&dout, parameter->happy_factor);  dio_put_uint8(&dout, 0);    dio_put_bool8(&dout, parameter->require_happy);  fc_assert(dio_output_used(&dout) == SAVED_PARAMETER_SIZE);  attr_city_set(attr, city_id, SAVED_PARAMETER_SIZE, buffer);}",2,"cwe119,cwe120"
"GSgetModDate(GopherObj *gs){     chart    dateBuf[256];     chart    *datetime;     struct tmt    *modTime;     if ( (gs->gplus == NULL) || (STRget(gs->gplus->ModDate) == NULL) )          return NULL;     modTime = GSgetModDateTM(gs);     if ( (modTime != NULL) &&t  strftime(dateBuf, sizeof(dateBuf) - 16, ""%c "", modTime) )     {          datetime = strchr(STRget(gs->gplus->ModDate), '<');          if (datetime != NULL)               strncat(dateBuf, datetime, 16);          STRset(gs->gplus->ModDate, dateBuf);     }     return STRget(gs->gplus->ModDate);}",2,"cwe119,cwe120"
"unpack_sha1_header(git_zstream *stream, unsigned char *map, unsigned long mapsize, void *buffer, unsigned long bufsiz){tunsigned long size, used;tstatic const char valid_loose_object_type[8] = {tt0,  tt1, 1, 1, 1,  tt0,  t};tenum object_type type;t tmemset(stream, 0, sizeof(*stream));tstream->next_in = map;tstream->avail_in = mapsize;tstream->next_out = buffer;tstream->avail_out = bufsiz;tif (experimental_loose_object(map)) {tt ttused = unpack_object_header_buffer(map, mapsize, &type, &size);ttif (!used || !valid_loose_object_type[type])tttreturn -1;ttmap += used;ttmapsize -= used;tt ttstream->next_in = map;ttstream->avail_in = mapsize;ttgit_inflate_init(stream);tt ttstream->total_out = 1 + snprintf(buffer, bufsiz, ""%s %lu"",tttttt typename(type), size);ttreturn 0;t}tgit_inflate_init(stream);treturn git_inflate(stream, 0);}",2,"cwe119,cwe120"
"""PrintPattern(FILE *fout,char *pattern){ char *sp;for (sp = pattern; *sp != '0'; sp++)   {   switch (*sp)      {      case '@':      case '{':      case '}':          fputc((int)'@',fout);      default:          fputc((int)*sp,fout);      }   }}""",2,"cwe119,cwe120"
"fpg_open (const char * filename, int * is_16bits)r{rtgzFile * file = gzopen (filename, ""rb"") ;rtchar   buffer[8] ;rrtif (!file) fatal_error (_(""'%s': file does not exist""), filename) ;rrtgzread (file, buffer, 8) ;rtif (strcmp (buffer, ""f16x1Ax0Dx0A"") == 0)rt{rtt*is_16bits = 1 ;rttreturn file ;rt}rtif (strcmp (buffer, ""fpgx1Ax0Dx0A"") == 0)rt{rtt*is_16bits = 0 ;rttreturn file ;rt}rrtfatal_error (_(""'%s' is not an FPG file""), filename) ;rtreturn file ;r}",3,"cwe119,cwe120,cwe469"
"fi_gui_source_get_progress(const struct download *d){tunsigned value;tvalue = 100.0 * guc_download_source_progress(d);tvalue = MIN(value, 100);treturn value;}",2,"cwe119,cwe120"
"compile_using_gcj (const char * const *java_sources,                   unsigned int java_sources_count,                   bool no_assert_option,                   bool fsource_option, const char *source_version,                   bool ftarget_option, const char *target_version,                   const char *directory,                   bool optimize, bool debug,                   bool verbose, bool null_stderr){  bool err;  unsigned int argc;  char **argv;  char **argp;  char *fsource_arg;  char *ftarget_arg;  int exitstatus;  unsigned int i;  argc =    2 + (no_assert_option ? 1 : 0) + (fsource_option ? 1 : 0)    + (ftarget_option ? 1 : 0) + (optimize ? 1 : 0) + (debug ? 1 : 0)    + (directory != NULL ? 2 : 0) + java_sources_count;  argv = (char **) xmalloca ((argc + 1) * sizeof (char *));  argp = argv;  *argp++ = ""gcj"";  *argp++ = ""-C"";  if (no_assert_option)    *argp++ = ""-fno-assert"";  if (fsource_option)    {      fsource_arg = (char *) xmalloca (9 + strlen (source_version) + 1);      memcpy (fsource_arg, ""-fsource="", 9);      strcpy (fsource_arg + 9, source_version);      *argp++ = fsource_arg;    }  else    fsource_arg = NULL;  if (ftarget_option)    {      ftarget_arg = (char *) xmalloca (9 + strlen (target_version) + 1);      memcpy (ftarget_arg, ""-ftarget="", 9);      strcpy (ftarget_arg + 9, target_version);      *argp++ = ftarget_arg;    }  else    ftarget_arg = NULL;  if (optimize)    *argp++ = ""-O"";  if (debug)    *argp++ = ""-g"";  if (directory != NULL)    {      *argp++ = ""-d"";      *argp++ = (char *) directory;    }  for (i = 0; i < java_sources_count; i++)    *argp++ = (char *) java_sources[i];  *argp = NULL;     if (argp - argv != argc)    abort ();  if (verbose)    {      char *command = shell_quote_argv (argv);      printf (""%s"", command);      free (command);    }  exitstatus = execute (""gcj"", ""gcj"", argv, false, false, false, null_stderr,                        true, true, NULL);  err = (exitstatus != 0);  if (ftarget_arg != NULL)    freea (ftarget_arg);  if (fsource_arg != NULL)    freea (fsource_arg);  freea (argv);  return err;}",2,"cwe119,cwe120"
"exchange_history(struct commit_list *list){tint round = 0;twhile (list) {ttwhile (list) {tttstruct commit_list *elem = list;tttstruct commit *commit = elem->item;tttlist = list->next;tttfree(elem);ttt tttif (parse_commit(commit))ttttcontinue;tttsend_ancestors(commit, round);tt}ttpacket_flush(1);  ttsender_wants_more(&list);ttround++;ttif (MAX_ROUND < round) {tttwhile (list) {tttt ttttpacket_flush(1);ttttfree_commit_list(list);ttttlist = NULL;tttt ttttsender_wants_more(&list);ttt}tttbreak;tt}t}}",3,"cwe119,cwe120,cweother"
"xnode_prop_ns_vprintf(xnode_t *element,tconst char *uri, const char *name, const char *fmt, va_list args){tchar buf[1024];tva_list args2;tchar *value;tbool result;tVA_COPY(args2, args);tif (str_vbprintf(buf, sizeof buf, fmt, args2) >= sizeof buf - 1) {ttvalue = h_strdup_vprintf(fmt, args);t} else {ttvalue = buf;t}tva_end(args2);tresult = xnode_prop_ns_set(element, uri, name, value);tif (value != buf)tthfree(value);treturn result;}",2,"cwe119,cwe120"
"""audio_manager_exit(void){t/* Bail out early if we haven't been initialized */tif (connection == NULL)ttreturn;tdbus_connection_unref(connection);tconnection = NULL;tif (config) {ttg_key_file_free(config);ttconfig = NULL;t}tif (enabled.socket)ttunix_exit();tif (enabled.media)ttbtd_unregister_adapter_driver(&media_server_driver);tif (enabled.headset)ttbtd_unregister_adapter_driver(&headset_server_driver);tif (enabled.gateway)ttbtd_unregister_adapter_driver(&gateway_server_driver);tif (enabled.source || enabled.sink)ttbtd_unregister_adapter_driver(&a2dp_server_driver);tif (enabled.control)ttbtd_unregister_adapter_driver(&avrcp_server_driver);tbtd_unregister_device_driver(&audio_driver);}""",2,"cwe119,cwe120"
"main(int ac, char **av) {tint ch;tttt tint i;tttt t twhile((ch = getopt(ac, av, ""nhv"")) != -1)tswitch(ch) {tcase 'n':ttno_validation++;ttbreak;tcase 'v':ttusage(av[0], 1);ttbreak;tcase 'h':tdefault:ttusage(av[0], 0);t}t tif(ac > optind) {ttac -= optind;ttav += optind;t} else {ttfprintf(stderr, ""%s: No input files specified"", av[0]);ttexit(1);t}tsetvbuf(stdout, 0, _IOLBF, 0);t tfor(i = 0; i < ac; i++) {ttif(process(av[i]))tttexit(EX_DATAERR);t}treturn 0;}",2,"cwe120,cweother"
"owl_escape_route(struct local_owl_data *owl){  signed char modified_escape[BOARDMAX];  int pos;  memcpy(modified_escape, owl->escape_values, sizeof(modified_escape));  for (pos = BOARDMIN; pos < BOARDMAX; pos++)    if (ON_BOARD(pos) && owl->cumulative_goal[pos])      modified_escape[pos] = 0;  return dragon_escape(owl->goal, owl->color, modified_escape);}",2,"cwe119,cwe120"
"MD5File (const char *filename, char *buf){    unsigned char buffer[BUFSIZ];    MD5_CTX ctx;    int f,i,j;    MD5Init(&ctx);    f = open(filename,O_RDONLY);    if (f < 0) return 0;    while ((i = read(f,buffer,sizeof buffer)) > 0) {tMD5Update(&ctx,buffer,i);    }    j = errno;    close(f);    errno = j;    if (i < 0) return 0;    return MD5End(&ctx, buf);}",3,"cwe119,cwe120,cweother"
"""hexdump(unsigned char *s, unsigned long l){tchar bfr[80];tchar *pb;tunsigned long i, n = 0;tif (l == 0)ttreturn;twhile (n < l) {ttpb = bfr;ttpb = ltoh (n, pb);tt*(pb++) = ':';tt*(pb++) = ' ';ttfor (i = 0; i < 16; i++) {tttif (n + i >= l) {tttt*(pb++) = ' ';tttt*(pb++) = ' ';ttt} elsettttpb = ctoh (*(s + i), pb);ttt*(pb++) = ' ';tt}tt*(pb++) = ' ';ttfor (i = 0; i < 16; i++) {tttif (n + i >= l)ttttbreak;tttelsetttt*(pb++) = (isprint (*(s + i)) ? *(s + i) : '.');tt}tt*pb = 0;ttn += 16;tts += 16;ttputs(bfr);t}}""",2,"cwe119,cwe120"
"start_daemon(int f_in, int f_out){tchar line[1024];tconst char *addr, *host;tint i;tio_set_sock_fds(f_in, f_out);t tif (!load_config(0))ttexit_cleanup(RERR_SYNTAX);taddr = client_addr(f_in);thost = lp_reverse_lookup(-1) ? client_name(f_in) : undetermined_hostname;trprintf(FLOG, ""connect from %s (%s)"", host, addr);tif (!am_server) {ttset_socket_options(f_in, ""SO_KEEPALIVE"");ttset_nonblocking(f_in);t}tif (exchange_protocols(f_in, f_out, line, sizeof line, 0) < 0)ttreturn -1;tline[0] = 0;tif (!read_line_old(f_in, line, sizeof line, 0))ttreturn -1;tif (!*line || strcmp(line, ""#list"") == 0) {ttrprintf(FLOG, ""module-list request from %s (%s)"",ttthost, addr);ttsend_listing(f_out);ttreturn -1;t}tif (*line == '#') {tt ttio_printf(f_out, ""@ERROR: Unknown command '%s'"", line);ttreturn -1;t}tif ((i = lp_number(line)) < 0) {ttrprintf(FLOG, ""unknown module '%s' tried from %s (%s)"",tttline, host, addr);ttio_printf(f_out, ""@ERROR: Unknown module '%s'"", line);ttreturn -1;t}#ifdef HAVE_SIGACTIONtsigact.sa_flags = SA_NOCLDSTOP;#endiftSIGACTION(SIGCHLD, remember_children);treturn rsync_module(f_in, f_out, i, addr, host);}",3,"cwe119,cwe120,cwe469"
"ne_xml_parse_response(ne_request *req, ne_xml_parser *parser){    char buf[8000];    ssize_t bytes;    int ret = 0;    while ((bytes = ne_read_response_block(req, buf, sizeof buf)) > 0) {        ret = ne_xml_parse(parser, buf, bytes);        if (ret)            return parse_error(ne_get_session(req), parser);    }    if (bytes == 0) {                 if (ne_xml_parse(parser, NULL, 0) == 0)            return NE_OK;        else            return parse_error(ne_get_session(req), parser);    } else {        return NE_ERROR;    }    }",2,"cwe119,cwe120"
"plpgsql_parse_tripword(char *word){tPLpgSQL_nsitem *ns;tchart   *cp[3];t tplpgsql_convert_ident(word, cp, 3);t tns = plpgsql_ns_lookup(cp[0], NULL);tif (ns == NULL)t{ttpfree(cp[0]);ttpfree(cp[1]);ttpfree(cp[2]);ttreturn T_ERROR;t}tif (ns->itemtype != PLPGSQL_NSTYPE_LABEL)t{ttpfree(cp[0]);ttpfree(cp[1]);ttpfree(cp[2]);ttreturn T_ERROR;t}t tns = plpgsql_ns_lookup(cp[1], cp[0]);tif (ns == NULL)t{ttpfree(cp[0]);ttpfree(cp[1]);ttpfree(cp[2]);ttreturn T_ERROR;t}tswitch (ns->itemtype)t{ttcase PLPGSQL_NSTYPE_REC:ttt{tttt ttttPLpgSQL_recfield *new;ttttnew = palloc(sizeof(PLpgSQL_recfield));ttttnew->dtype = PLPGSQL_DTYPE_RECFIELD;ttttnew->fieldname = pstrdup(cp[2]);ttttnew->recparentno = ns->itemno;ttttplpgsql_adddatum((PLpgSQL_datum *) new);ttttplpgsql_yylval.scalar = (PLpgSQL_datum *) new;ttttpfree(cp[0]);ttttpfree(cp[1]);ttttpfree(cp[2]);ttttreturn T_SCALAR;ttt}ttcase PLPGSQL_NSTYPE_ROW:ttt{tttt ttttPLpgSQL_row *row;ttttintttti;ttttrow = (PLpgSQL_row *) (plpgsql_Datums[ns->itemno]);ttttfor (i = 0; i < row->nfields; i++)tttt{tttttif (row->fieldnames[i] &&ttttttstrcmp(row->fieldnames[i], cp[2]) == 0)ttttt{ttttttplpgsql_yylval.scalar = plpgsql_Datums[row->varnos[i]];ttttttpfree(cp[0]);ttttttpfree(cp[1]);ttttttpfree(cp[2]);ttttttreturn T_SCALAR;ttttt}tttt}ttttereport(ERROR,tttttt(errcode(ERRCODE_UNDEFINED_COLUMN),tttttt errmsg(""row ""%s.%s"" has no field ""%s"""",ttttttttcp[0], cp[1], cp[2])));ttt}ttdefault:tttbreak;t}tpfree(cp[0]);tpfree(cp[1]);tpfree(cp[2]);treturn T_ERROR;}",2,"cwe119,cwe120"
"addESSIDfile(char* filename){    FILE *list;    char essid[256];tint x;    list = fopen(filename, ""r"");    if(list == NULL)    {        perror(""Unable to open ESSID list"");        return -1;    }    while( fgets(essid, 256, list) != NULL )    {                 x = strlen(essid) - 1;        while (x >= 0 && isspace((int)essid[x]))            essid[x--] = 0;        if(strlen(essid))            addESSID(essid, strlen(essid), 0);    }    fclose(list);    return 0;}",3,"cwe119,cwe120,cweother"
"__ecereMethod_MainForm_Forward(struct __ecereNameSpace__ecere__com__Instance * this){struct MainForm * __ecerePointer_MainForm = (struct MainForm *)(this ? (((char *)this) + __ecereClass_MainForm->offset) : 0);if(__ecerePointer_MainForm->historyPos < ((struct __ecereNameSpace__ecere__com__Array *)(((char *)__ecerePointer_MainForm->history + 24)))->count - 1){char location[64];__ecerePointer_MainForm->historyPos++;__ecereProp___ecereNameSpace__ecere__gui__Window_Set_disabled(((struct AddressBar *)(((char *)__ecerePointer_MainForm->addressBar + __ecereClass_AddressBar->offset)))->back, (__ecerePointer_MainForm->historyPos == 0));__ecereProp___ecereNameSpace__ecere__gui__Window_Set_disabled(((struct AddressBar *)(((char *)__ecerePointer_MainForm->addressBar + __ecereClass_AddressBar->offset)))->forward, (__ecerePointer_MainForm->historyPos >= ((struct __ecereNameSpace__ecere__com__Array *)(((char *)__ecerePointer_MainForm->history + 24)))->count - 1));sprintf(location, ""api://%p"", ((struct __ecereNameSpace__ecere__com__Instance **)((struct __ecereNameSpace__ecere__com__Array *)(((char *)__ecerePointer_MainForm->history + 24)))->array)[__ecerePointer_MainForm->historyPos]);__ecerePointer_MainForm->dontRecordHistory = 0x1;((unsigned int (*)(struct __ecereNameSpace__ecere__com__Instance *, char *  href))__extension__ ({struct __ecereNameSpace__ecere__com__Instance * __internal_ClassInst = __ecerePointer_MainForm->view;__internal_ClassInst ? __internal_ClassInst->_vTbl : __ecereClass_HelpView->_vTbl;})[__ecereVMethodID_HTMLView_OnOpen])(__ecerePointer_MainForm->view, location);__ecerePointer_MainForm->dontRecordHistory = 0x0;return 0x1;}return 0x0;}",3,"cwe119,cwe120,cwe476"
"write_pid_file(void){    int fd;    FILE *file;    if (!pid_file)        return;    fd = open(pid_file, O_WRONLY|O_NOCTTY|O_TRUNC|O_CREAT|O_EXCL, 0644);    if (fd == -1)        panic(errno, ""Could not open pid-file `%s'"", pid_file);    file = fdopen(fd, ""w"");    if (!file)        panic(errno, ""Could not open file-stream `%s'"", pid_file);    fprintf(file, ""%ld"", (long) (pidfile_owner_pid = getpid()));    fclose(file);}",2,"cwe469,cweother"
"cliGameList_deadStone(CliGameList *gl, const char *buf)  {  CliGame  *g;  char  deadStone[5];  int  args, oldMoveNum, loc;  SgfElem  *prevActive = NULL;  GoBoardGroupIter  group;  assert(MAGIC(gl));  assert(gl->playGame >= 0);  g = &gl->games[gl->playGame];  args = sscanf(buf, ""Removing @ %s"", deadStone);  assert(args == 1);  loc = goBoard_str2Loc(g->board->game->board, deadStone);  if (g->board->gameEnd != g->board->sgf->active)  {    prevActive = g->board->sgf->active;    g->board->sgf->active = g->board->gameEnd;    g->board->sgf->mode = sgfInsert_main;  }  goBoardGroupIter(group, g->board->game->board, loc)  {    sgf_addStone(g->board->sgf, goStone_empty,tt goBoard_loc2Sgf(g->board->game->board,tttt goBoardGroupIter_loc(group,tttttt      g->board->game->board)));  }  g->board->gameEnd = g->board->sgf->active;  if (prevActive != NULL)    g->board->sgf->active = prevActive;  if (g->board->onTrack)  {    if (g->board->game->moveNum < g->board->game->maxMoves)  {      oldMoveNum = g->board->game->moveNum;      goGame_moveTo(g->board->game, g->board->game->maxMoves);      if (g->board->goban->activeTimer != goStone_empty)tgoban_stopTimer(g->board->goban);      g->board->game->state = goGameState_selectDead;      goGame_markDead(g->board->game, loc);      g->board->game->state = goGameState_play;      goGame_moveTo(g->board->game, oldMoveNum);    } else  {      goGame_markDead(g->board->game, loc);    }  }  goban_update(g->board->goban);}",3,"cwe119,cwe120,cweother"
"cross_validation(const problem *prob, const parameter *param, int nr_fold, int *target){tint i;tint *fold_start = Malloc(int,nr_fold+1);tint l = prob->l;tint *perm = Malloc(int,l);tfor(i=0;i<l;i++) perm[i]=i;tfor(i=0;i<l;i++)t{ttint j = i+rand()%(l-i);ttswap(perm[i],perm[j]);t}tfor(i=0;i<=nr_fold;i++)ttfold_start[i]=i*l/nr_fold;tfor(i=0;i<nr_fold;i++)t{ttint begin = fold_start[i];ttint end = fold_start[i+1];ttint j,k;ttstruct problem subprob;ttsubprob.bias = prob->bias;ttsubprob.n = prob->n;ttsubprob.l = l-(end-begin);ttsubprob.x = Malloc(struct feature_node*,subprob.l);ttsubprob.y = Malloc(int,subprob.l);ttk=0;ttfor(j=0;j<begin;j++)tt{tttsubprob.x[k] = prob->x[perm[j]];tttsubprob.y[k] = prob->y[perm[j]];ttt++k;tt}ttfor(j=end;j<l;j++)tt{tttsubprob.x[k] = prob->x[perm[j]];tttsubprob.y[k] = prob->y[perm[j]];ttt++k;tt}ttstruct model *submodel = train(&subprob,param);ttfor(j=begin;j<end;j++)ttttarget[perm[j]] = predict(submodel,prob->x[perm[j]]);ttfree_and_destroy_model(&submodel);ttfree(subprob.x);ttfree(subprob.y);t}tfree(fold_start);tfree(perm);}",2,"cwe120,cweother"
"rli_init(char *dbname, char *db_user, char *db_pwd){  inttrc;  voidt*rlih;  charterrbuf[BUFSIZ];  if (loglevel > 1)    logit(LOG_DEBUG, ""rli_init: %s %s"", dbname, db_user);  if ((rc = rls_lock_init(&senderlistlock)) != GLOBUS_RLS_SUCCESS)    return rc;  senderlist = NULL;  if (rli_bloomfilter) {    if (rli_bloomfilter_dir)      readbf(&senderlist);  } else    if ((rc = readsender(dbname, db_user, db_pwd)) != GLOBUS_RLS_SUCCESS)      return rc;  if ((rc = rls_lock_init(&rli_rlilistlock)) != GLOBUS_RLS_SUCCESS)    return rc;  rli_rlilist = NULL;     if (db_open(dbname, db_user, db_pwd, 0, &rlih, errbuf) != GLOBUS_RLS_SUCCESS)    logit(LOG_WARNING, ""rli_init(%s): %s"", dbname, errbuf);  else {tglobus_mutex_lock(&tablemtx);tgettablecount(rlih, T_RLILFN);tgettablecount(rlih, T_RLILRC);tgettablecount(rlih, T_RLISENDER);tgettablecount(rlih, T_RLIMAP);tglobus_mutex_unlock(&tablemtx);tupdate_readrli(rlih, &rli_rlilistlock, &rli_rlilist);    db_close(rlih);  }     if (rli_expire_int > 0)    event_queue(expire, &rli_expire_int);  event_queue(rli_llupdates, &update_ll_int);  event_queue(rli_bfupdates, &update_bf_int);  if (loglevel > 1)    logit(LOG_DEBUG, ""rli_init succeeded"");  return GLOBUS_RLS_SUCCESS;}",2,"cwe119,cwe120"
"test_setting_gsm_apn_spaces (void){tNMSettingGsm *s_gsm;tconst char *tmp;ts_gsm = (NMSettingGsm *) nm_setting_gsm_new ();tASSERT (s_gsm != NULL,t        ""gsm-apn-spaces"",t        ""error creating GSM setting"");t tg_object_set (s_gsm, NM_SETTING_GSM_APN, ""foobar "", NULL);ttmp = nm_setting_gsm_get_apn (s_gsm);tASSERT (tmp != NULL,t        ""gsm-apn-spaces"", ""empty APN"");tASSERT (strcmp (tmp, ""foobar"") == 0,t        ""gsm-apn-spaces"", ""unexpected APN"");t tg_object_set (s_gsm, NM_SETTING_GSM_APN, "" foobar"", NULL);ttmp = nm_setting_gsm_get_apn (s_gsm);tASSERT (tmp != NULL,t        ""gsm-apn-spaces"", ""empty APN"");tASSERT (strcmp (tmp, ""foobar"") == 0,t        ""gsm-apn-spaces"", ""unexpected APN"");}",2,"cwe469,cweother"
"PutLineTo ( KOutputStream stream, UInt len ){  Char *          p;  UInt lt,ls;           if ( TestInput != 0 && TestOutput == stream ) {    if ( TestLine[0] == '0' ) {      if ( ! GetLine2( TestInput, TestLine, sizeof(TestLine) ) ) {        TestLine[0] = '0';      }      TestInput->number++;    }         lt = strlen(TestLine);        p = TestLine + (lt-2);         while ( TestLine <= p && ( *p == ' ' || *p == 't' ) ) {      p[1] = '0';  p[0] = '';  p--; lt--;    }         ls = strlen(stream->line);    p = stream->line + (ls-1);         if (*p == '') {      p--;          while ( stream->line <= p && ( *p == ' ' || *p == 't' ) ) {        p[1] = '0';  p[0] = '';  p--; ls--;      }    }         if ( ! strncmp( TestLine, stream->line, ls ) ) {      if (ls < lt)        memmove(TestLine,TestLine + ls,lt-ls+1);      else        TestLine[0] = '0';    }    else {      char obuf[80];             snprintf(obuf, sizeof(obuf), ""Line %i : + "", (int)TestInput->number);      PutLine2( stream, obuf, strlen(obuf) );      PutLine2( stream, Output->line, strlen(Output->line) );    }  }     else {    PutLine2( stream, stream->line, len );  }     if ( OutputLog != 0 && ! stream->isstream ) {    if ( stream->file == 1 || stream->file == 3 ) {      PutLine2( OutputLog, stream->line, len );    }  }}",2,"cwe119,cwe120"
"ext_cmp_pattern(const char *left, const char *right){tint cmp;tint left_pos;tint right_pos;tfor (;;) {ttunsigned char left_bitwise[32] = { 0, };ttunsigned char right_bitwise[32] = { 0, };ttleft_pos = ext_cmp_pattern_pos(&left, left_bitwise);ttright_pos = ext_cmp_pattern_pos(&right, right_bitwise);ttcmp = left_pos - right_pos;ttif (!cmp) {ttt tttcmp = memcmp(right_bitwise, left_bitwise, ARRAY_LEN(left_bitwise));tt}ttif (cmp) {tttbreak;tt}ttif (!left) {ttt tttbreak;tt}t}treturn cmp;}",2,"cwe119,cwe120"
return_for_user_access(access_flags *Ptr){t tint RetCode = -1;tif (Ptr == NULL)ttreturn RetCode;tRetCode = ValidFlags[Ptr->type].flag;tif (Ptr->next != NULL)ttRetCode = RetCode | return_for_user_access(Ptr->next);treturn RetCode;},2,"cwe119,cwe120"
"CVMouseUpPointer(CharView *cv ) {    static char *buts[3];    buts[0] = _(""_Yes"");    buts[1] = _(""_No"");    buts[2] = NULL;    if ( cv->widthsel ) {tif ( cv->b.sc->width<0 && cv->oldwidth>=0 ) {t    if ( gwwv_ask(_(""Negative Width""), (const char **) buts, 0, 1, _(""Negative character widths are not allowed in TrueType.Do you really want a negative width?"") )==1 )ttcv->b.sc->width = cv->oldwidth;t}tSCSynchronizeWidth(cv->b.sc,cv->b.sc->width,cv->oldwidth,NULL);tcv->expandedge = ee_none;tGDrawSetCursor(cv->v,ct_mypointer);    }    if ( cv->vwidthsel ) {tif ( cv->b.sc->vwidth<0 && cv->oldvwidth>=0 ) {t    if ( gwwv_ask(_(""Negative Width""), (const char **) buts, 0, 1, _(""Negative character widths are not allowed in TrueType.Do you really want a negative width?"") )==1 )ttcv->b.sc->vwidth = cv->oldvwidth;t}tcv->expandedge = ee_none;tGDrawSetCursor(cv->v,ct_mypointer);    }    if ( cv->nearcaret!=-1 && cv->lcarets!=NULL ) {tcv->nearcaret = -1;tcv->expandedge = ee_none;tcv->lcarets = NULL;tGDrawSetCursor(cv->v,ct_mypointer);    }    if ( cv->expandedge!=ee_none ) {tCVUndoCleanup(cv);tcv->expandedge = ee_none;tGDrawSetCursor(cv->v,ct_mypointer);    } else if ( CVAllSelected(cv) && cv->b.drawmode==dm_fore && cv->p.spline==NULL &&t    !cv->p.prevcp && !cv->p.nextcp && cv->info.y==cv->p.cy ) {tSCUndoSetLBearingChange(cv->b.sc,(int) rint(cv->info.x-cv->p.cx));tSCSynchronizeLBearing(cv->b.sc,cv->info.x-cv->p.cx,CVLayer((CharViewBase *) cv));    }    CPEndInfo(cv);}",2,"cwe119,cwe120"
"http_server_accept (struct tcp_server *ts, int sock){  printf (""http_server_accept"");  char buf[BUFSIZ];  FILE *fp = fdopen (sock, ""r"");  while (fgets (buf, BUFSIZ, fp))    {      puts (buf);      if (strcmp (buf, ""r"") == 0)        break;    }  char *msg = ""Hello world!"";  write (sock, msg, strlen (msg) + 1);  close (sock);}",2,"cwe119,cwe120"
"gf_cli3_1_gsync_out_status (dict_t *dict){        int              gsync_count = 0;        int              i = 0;        int              ret = 0;        char             mst[PATH_MAX] = {0, };        char             slv[PATH_MAX]= {0, };        char             sts[PATH_MAX] = {0, };        char             hyphens[81] = {0, };        char             *mst_val = NULL;        char             *slv_val = NULL;        char             *sts_val = NULL;        cli_out (""%-20s %-50s %-10s"", ""MASTER"", ""SLAVE"", ""STATUS"");        for (i=0; i<sizeof(hyphens)-1; i++)                hyphens[i] = '-';        cli_out (""%s"", hyphens);        ret = dict_get_int32 (dict, ""gsync-count"", &gsync_count);        if (ret) {                gf_log (""cli"", GF_LOG_INFO, ""No active geo-replication sessions""                        ""present for the selected"");                ret = 0;                goto out;        }        for (i = 1; i <= gsync_count; i++) {                snprintf (mst, sizeof(mst), ""master%d"", i);                snprintf (slv, sizeof(slv), ""slave%d"", i);                snprintf (sts, sizeof(sts), ""status%d"", i);                ret = dict_get_str (dict, mst, &mst_val);                if (ret)                        goto out;                ret = dict_get_str (dict, slv, &slv_val);                if (ret)                        goto out;                ret = dict_get_str (dict, sts, &sts_val);                if (ret)                        goto out;                cli_out (""%-20s %-50s %-10s"", mst_val,                         slv_val, sts_val);        } out:        return ret;}",2,"cwe119,cwe120"
"read_2byte_at (FILE *fp, off_t offset){tunsigned char buff[2];tif (myfseek64(fp, offset)) {ttperror(NULL);ttexit(1);t}tif (fread(&buff, 2, 1, fp) != 1) {ttperror(NULL);ttexit(1);t}treturn (buff[1] << 8) | buff[0];}",2,"cwe119,cwe120"
"rfbDefaultClientLog(const char *format, ...){    va_list args;    char buf[256];    time_t log_clock;    if(!rfbEnableClientLogging)      return;    va_start(args, format);    time(&log_clock);    strftime(buf, 255, ""%d/%m/%Y %X "", localtime(&log_clock));    fprintf(stderr, ""%s"", buf);    vfprintf(stderr, format, args);    fflush(stderr);    va_end(args);}",3,"cwe119,cwe120,cweother"
"cmd_handle(struct userrec *u, int idx, char *par){  char oldhandle[HANDLEN + 1], newhandle[HANDLEN + 1];  int i;  strncpyz(newhandle, newsplit(&par), sizeof newhandle);  if (!newhandle[0]) {    dprintf(idx, ""Usage: handle <new-handle>"");    return;  }  for (i = 0; i < strlen(newhandle); i++)    if ((newhandle[i] <= 32) || (newhandle[i] >= 127) || (newhandle[i] == '@'))      newhandle[i] = '?';  if (strchr(BADHANDCHARS, newhandle[0]) != NULL)    dprintf(idx,            ""Bizarre quantum forces prevent handle from starting with '%c'."",            newhandle[0]);  else if (get_user_by_handle(userlist, newhandle) &&           egg_strcasecmp(dcc[idx].nick, newhandle))    dprintf(idx, ""Somebody is already using %s."", newhandle);  else if (!egg_strcasecmp(newhandle, botnetnick))    dprintf(idx, ""Hey!  That's MY name!"");  else {    strncpyz(oldhandle, dcc[idx].nick, sizeof oldhandle);    if (change_handle(u, newhandle)) {      putlog(LOG_CMDS, ""*"", ""#%s# handle %s"", oldhandle, newhandle);      dprintf(idx, ""Okay, changed."");    } else      dprintf(idx, ""Failed."");  }}",2,"cwe119,cwe120"
"""readdir_r(DIR *d,struct dirent* entry, struct dirent** result) {  struct linux_dirent* ld;  *result=0;  if (!d->num || (d->cur += ((struct dirent*)(d->buf+d->cur))->d_reclen)>=d->num) {    int res=getdents(d->fd,(struct dirent*)d->buf,sizeof (d->buf)-1);    if (res<=0)      return res<0;    d->num=res; d->cur=0;  }  ld=(struct linux_dirent*)(d->buf+d->cur);  if (ld->d_reclen < sizeof(struct linux_dirent))    return 0;t/* can't happen */  *result=entry;  entry->d_ino=ld->d_ino;  entry->d_off=ld->d_off;  entry->d_reclen=ld->d_reclen;  entry->d_type=ld->d_name[ld->d_reclen-offsetof(struct linux_dirent,d_name)-1];  memcpy(entry->d_name,ld->d_name,ld->d_reclen-offsetof(struct linux_dirent,d_name));  return 0;}""",2,"cwe120,cweother"
"ssl3_AppendSignatureAndHashAlgorithm(tsslSocket *ss, const SSL3SignatureAndHashAlgorithm* sigAndHash){    unsigned char serialized[2];    serialized[0] = ssl3_OIDToTLSHashAlgorithm(sigAndHash->hashAlg);    if (serialized[0] == 0) {tPORT_SetError(SSL_ERROR_UNSUPPORTED_HASH_ALGORITHM);treturn SECFailure;    }    serialized[1] = sigAndHash->sigAlg;    return ssl3_AppendHandshake(ss, serialized, sizeof(serialized));}",2,"cwe119,cwe120"
"image2colorps( short      * pixels,               int          w,               int          h,               fd2psCMAP *  map,               int          ncol  FL_UNUSED_ARG,               const char * cmt){    int x,        y,        k,        r,        g,        b;    int *rb,        *gb,        *bb;    char pscmd[ 128 ];    short *p;    strcpy( pscmd, ps_literal( ( cmt && *cmt ) ? cmt : ""startColorImage"" ) );    ps_output( ""/redstring %d string def"", w );    ps_output( ""/grnstring %d string def"", w );    ps_output( ""/blustring %d string def"", w );    ps_output( ""/%s"", pscmd );    ps_output( ""{%d %d 8 [ %d 0 0 -%d 0 %d]"", w, h, w, h, h );    ps_output( "" {currentfile redstring readhexstring pop}"" );    ps_output( "" {currentfile grnstring readhexstring pop}"" );    ps_output( "" {currentfile blustring readhexstring pop}"" );    ps_output( "" true 3 colorimage } bind def"");         ps_output( ""%d %d scale"", w, h );    ps_verbatim( ""%s"", pscmd );    rb = malloc( w * sizeof *rb );    gb = malloc( w * sizeof *gb );    bb = malloc( w * sizeof *bb );    for ( p = pixels, k = y = 0; y < h; y++ )    {        for ( x = 0; x < w; x++, p++ )        {            rb[ x ] = map[ *p ].red;            gb[ x ] = map[ *p ].green;            bb[ x ] = map[ *p ].blue;        }        for ( x = 0; x < w; x++ )        {            r = rb[ x ];            ps_output( ""%c%c"", hexdigits[ ( r >> 4 ) & 15 ],                       hexdigits[ r & 15 ] );            if ( ++k % LINELENGTH == 0 )                ps_output( """" );        }        for ( x = 0; x < w; x++ )        {            g = gb[ x ];            ps_output( ""%c%c"", hexdigits[ ( g >> 4 ) & 15 ],                       hexdigits[ g & 15 ] );            if ( ++k % LINELENGTH == 0 )                ps_output( """" );        }        for ( x = 0; x < w; x++ )        {            b = bb[ x ];            ps_output( ""%c%c"", hexdigits[ ( b >> 4 ) & 15 ],                       hexdigits[ b & 15 ] );            if ( ++k % LINELENGTH == 0 )                ps_output( """" );        }    }    free( rb );    free( gb );    free( bb );    return 0;}",2,"cwe119,cwe120"
"TIFFReadRGBAImageOriented(TIFF* tif,ttt  uint32 rwidth, uint32 rheight, uint32* raster,ttt  int orientation, int stop){    char emsg[1024] = """";    TIFFRGBAImage img;    int ok;tif (TIFFRGBAImageOK(tif, emsg) && TIFFRGBAImageBegin(&img, tif, stop, emsg)) {ttimg.req_orientation = orientation;tt ttok = TIFFRGBAImageGet(&img, raster+(rheight-img.height)*rwidth,tttrwidth, img.height);ttTIFFRGBAImageEnd(&img);t} else {ttTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), ""%s"", emsg);ttok = 0;    }    return (ok);}",2,"cwe119,cwe120"
"III_get_scale_factors_2(mpg123_handle *fr, int *scf,struct gr_info_s *gr_info,int i_stereo){tconst unsigned char *pnt;tint i,j,n=0,numbits=0;tunsigned int slen;tconst unsigned char stab[3][6][4] =t{tt{ttt{ 6, 5, 5,5 } , { 6, 5, 7,3 } , { 11,10,0,0},ttt{ 7, 7, 7,0 } , { 6, 6, 6,3 } , {  8, 8,5,0}tt},tt{ttt{ 9, 9, 9,9 } , { 9, 9,12,6 } , { 18,18,0,0},ttt{12,12,12,0 } , {12, 9, 9,6 } , { 15,12,9,0}tt},tt{ttt{ 6, 9, 9,9 } , { 6, 9,12,6 } , { 15,18,0,0},ttt{ 6,15,12,0 } , { 6,12, 9,6 } , {  6,18,9,0}tt}t}; tif(i_stereo)  tslen = i_slen2[gr_info->scalefac_compress>>1];telsetslen = n_slen2[gr_info->scalefac_compress];tgr_info->preflag = (slen>>15) & 0x1;tn = 0;  tif( gr_info->block_type == 2 )t{ttn++;ttif(gr_info->mixed_block_flag) n++;t}tpnt = stab[n][(slen>>12)&0x7];tfor(i=0;i<4;i++)t{ttint num = slen & 0x7;ttslen >>= 3;ttif(num)tt{tttfor(j=0;j<(int)(pnt[i]);j++) *scf++ = getbits_fast(fr, num);tttnumbits += pnt[i] * num;tt}ttelsettfor(j=0;j<(int)(pnt[i]);j++) *scf++ = 0;t}  tn = (n << 1) + 1;tfor(i=0;i<n;i++) *scf++ = 0;treturn numbits;}",2,"cwe119,cwe120"
"help(void *opt, int argc, char **argv){    if(argc == 0) {tsl_help(commands, 1, argv - 1  );    } else {tSL_cmd *c = sl_match (commands, argv[0], 0); tif(c == NULL) {t    fprintf (stderr, ""No such command: %s. ""tt     ""Try ""help"" for a list of commands"",tt     argv[0]);t} else {t    if(c->func) {ttstatic char shelp[] = ""--help"";ttchar *fake[3];ttfake[0] = argv[0];ttfake[1] = shelp;ttfake[2] = NULL;tt(*c->func)(2, fake);ttfprintf(stderr, """");t    }t    if(c->help && *c->help)ttfprintf (stderr, ""%s"", c->help);t    if((++c)->name && c->func == NULL) {ttint f = 0;ttfprintf (stderr, ""Synonyms:"");ttwhile (c->name && c->func == NULL) {tt    fprintf (stderr, ""%s%s"", f ? "", "" : "" "", (c++)->name);tt    f = 1;tt}ttfprintf (stderr, """");t    }t}    }    return 0;}",2,"cwe119,cwe120"
"""_mesa_alloc_dispatch_table(){   /* Find the larger of Mesa's dispatch table and libGL's dispatch table.    * In practice, this'll be the same for stand-alone Mesa.  But for DRI    * Mesa we do this to accomodate different versions of libGL and various    * DRI drivers.    */   GLint numEntries = MAX2(_glapi_get_dispatch_table_size(), _gloffset_COUNT);   struct _glapi_table *table;   table = malloc(numEntries * sizeof(_glapi_proc));   if (table) {      _glapi_proc *entry = (_glapi_proc *) table;      GLint i;      for (i = 0; i < numEntries; i++) {         entry[i] = (_glapi_proc) _mesa_generic_nop;      }   }   return table;}""",2,"cwe120,cweother"
"child_write(struct archive_write *a, const char *buf, size_t buf_len){    struct private_data *state = a->compressor.data;    ssize_t ret;    if (state->child_stdin == -1)        return (-1);    if (buf_len == 0)        return (-1);restart_write:    do {        ret = write(state->child_stdin, buf, buf_len);    } while (ret == -1 && errno == EINTR);    if (ret > 0)        return (ret);    if (ret == 0) {        close(state->child_stdin);        state->child_stdin = -1;        fcntl(state->child_stdout, F_SETFL, 0);        return (0);    }    if (ret == -1 && errno != EAGAIN)        return (-1);    if (state->child_stdout == -1) {        fcntl(state->child_stdin, F_SETFL, 0);        __archive_check_child(state->child_stdin, state->child_stdout);        goto restart_write;    }    do {        ret = read(state->child_stdout,            state->child_buf + state->child_buf_avail,            state->child_buf_len - state->child_buf_avail);    } while (ret == -1 && errno == EINTR);    if (ret == 0 || (ret == -1 && errno == EPIPE)) {        close(state->child_stdout);        state->child_stdout = -1;        fcntl(state->child_stdin, F_SETFL, 0);        goto restart_write;    }    if (ret == -1 && errno == EAGAIN) {        __archive_check_child(state->child_stdin, state->child_stdout);        goto restart_write;    }    if (ret == -1)        return (-1);    state->child_buf_avail += ret;    ret = (a->client_writer)(&a->archive, a->client_data,        state->child_buf, state->child_buf_avail);    if (ret <= 0)        return (-1);    if ((size_t)ret < state->child_buf_avail) {        memmove(state->child_buf, state->child_buf + ret,            state->child_buf_avail - ret);    }    state->child_buf_avail -= ret;    a->archive.raw_position += ret;    goto restart_write;}",2,"cwe120,cweother"
"tiff_from_filep(gx_device_printer *dev,  const char *name, FILE *filep, int big_endian, bool usebigtiff){    char mode[5] = ""w"";    int modelen = 1;    TIFF *t;    tifs_io_private *tiffio;    if (big_endian)        mode[modelen++] = 'b';    else        mode[modelen++] = 'l';    if (usebigtiff)             mode[modelen++] = '8';    mode[modelen] = (char)0;        tiffio = (tifs_io_private *)gs_malloc(dev->memory, sizeof(tifs_io_private), 1, ""tiff_from_filep"");    if (!tiffio) {        return NULL;    }    tiffio->f = filep;    tiffio->pdev = dev;    t = TIFFClientOpen(name, mode,        (thandle_t) tiffio, (TIFFReadWriteProc)gs_tifsReadProc,        (TIFFReadWriteProc)gs_tifsWriteProc, (TIFFSeekProc)gs_tifsSeekProc,        gs_tifsCloseProc, (TIFFSizeProc)gs_tifsSizeProc, gs_tifsDummyMapProc,        gs_tifsDummyUnmapProc);    return t;}",2,"cwe119,cwe120"
"""compute_curr_prefix (const char *orig_installprefix,                     const char *orig_installdir,                     const char *curr_pathname){  char *curr_installdir;  const char *rel_installdir;  if (curr_pathname == NULL)    return NULL;  /* Determine the relative installation directory, relative to the prefix.     This is simply the difference between orig_installprefix and     orig_installdir.  */  if (strncmp (orig_installprefix, orig_installdir, strlen (orig_installprefix))      != 0)    /* Shouldn't happen - nothing should be installed outside $(prefix).  */    return NULL;  rel_installdir = orig_installdir + strlen (orig_installprefix);  /* Determine the current installation directory.  */  {    const char *p_base = curr_pathname + FILE_SYSTEM_PREFIX_LEN (curr_pathname);    const char *p = curr_pathname + strlen (curr_pathname);    char *q;    while (p > p_base)      {        p--;        if (ISSLASH (*p))          break;      }    q = (char *) xmalloc (p - curr_pathname + 1);#ifdef NO_XMALLOC    if (q == NULL)      return NULL;#endif    memcpy (q, curr_pathname, p - curr_pathname);    q[p - curr_pathname] = '0';    curr_installdir = q;  }  /* Compute the current installation prefix by removing the trailing     rel_installdir from it.  */  {    const char *rp = rel_installdir + strlen (rel_installdir);    const char *cp = curr_installdir + strlen (curr_installdir);    const char *cp_base =      curr_installdir + FILE_SYSTEM_PREFIX_LEN (curr_installdir);    while (rp > rel_installdir && cp > cp_base)      {        bool same = false;        const char *rpi = rp;        const char *cpi = cp;        while (rpi > rel_installdir && cpi > cp_base)          {            rpi--;            cpi--;            if (ISSLASH (*rpi) || ISSLASH (*cpi))              {                if (ISSLASH (*rpi) && ISSLASH (*cpi))                  same = true;                break;              }            /* Do case-insensitive comparison if the file system is always or               often case-insensitive.  It's better to accept the comparison               if the difference is only in case, rather than to fail.  */#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__            /* Native Windows, Cygwin, OS/2, DOS - case insignificant file system */            if ((*rpi >= 'a' && *rpi <= 'z' ? *rpi - 'a' + 'A' : *rpi)                != (*cpi >= 'a' && *cpi <= 'z' ? *cpi - 'a' + 'A' : *cpi))              break;#else            if (*rpi != *cpi)              break;#endif          }        if (!same)          break;        /* The last pathname component was the same.  opi and cpi now point           to the slash before it.  */        rp = rpi;        cp = cpi;      }    if (rp > rel_installdir)      {        /* Unexpected: The curr_installdir does not end with rel_installdir.  */        free (curr_installdir);        return NULL;      }    {      size_t curr_prefix_len = cp - curr_installdir;      char *curr_prefix;      curr_prefix = (char *) xmalloc (curr_prefix_len + 1);#ifdef NO_XMALLOC      if (curr_prefix == NULL)        {          free (curr_installdir);          return NULL;        }#endif      memcpy (curr_prefix, curr_installdir, curr_prefix_len);      curr_prefix[curr_prefix_len] = '0';      free (curr_installdir);      return curr_prefix;    }  }}""",2,"cwe120,cweother"
"repo_init_find_dir(repo_init *results, const char* path){tchar temp_path[GIT_PATH_MAX];tint error = GIT_SUCCESS;terror = gitfo_prettify_dir_path(temp_path, sizeof(temp_path), path, NULL);tif (error < GIT_SUCCESS)ttreturn git__rethrow(error, ""Failed to find directory to initialize repository"");tif (!results->is_bare) {ttgit__joinpath(temp_path, temp_path, GIT_DIR);t}tresults->path_repository = git__strdup(temp_path);tif (results->path_repository == NULL)ttreturn GIT_ENOMEM;treturn GIT_SUCCESS;}",2,"cwe119,cwe120"
"stk500_paged_load(PROGRAMMER * pgm, AVRPART * p, AVRMEM * m,                             unsigned int page_size,                             unsigned int addr, unsigned int n_bytes){  unsigned char buf[16];  int memtype;  int a_div;  int tries;  unsigned int n;  int block_size;  if (strcmp(m->desc, ""flash"") == 0) {    memtype = 'F';  }  else if (strcmp(m->desc, ""eeprom"") == 0) {    memtype = 'E';  }  else {    return -2;  }  if ((m->op[AVR_OP_LOADPAGE_LO]) || (m->op[AVR_OP_READ_LO]))    a_div = 2;  else    a_div = 1;  n = addr + n_bytes;  for (; addr < n; addr += block_size) {         if (strcmp(ldata(lfirst(pgm->id)), ""mib510"") == 0) {      block_size = 256;    } else {      if (n - addr < page_size)        block_size = n - addr;      else        block_size = page_size;    }    tries = 0;  retry:    tries++;    stk500_loadaddr(pgm, addr/a_div);    buf[0] = Cmnd_STK_READ_PAGE;    buf[1] = (block_size >> 8) & 0xff;    buf[2] = block_size & 0xff;    buf[3] = memtype;    buf[4] = Sync_CRC_EOP;    stk500_send(pgm, buf, 5);    if (stk500_recv(pgm, buf, 1) < 0)      exit(1);    if (buf[0] == Resp_STK_NOSYNC) {      if (tries > 33) {        fprintf(stderr, ""%s: stk500_paged_load(): can't get into sync"",                progname);        return -3;      }      if (stk500_getsync(pgm) < 0)treturn -1;      goto retry;    }    else if (buf[0] != Resp_STK_INSYNC) {      fprintf(stderr,              ""%s: stk500_paged_load(): (a) protocol error, ""              ""expect=0x%02x, resp=0x%02x"",               progname, Resp_STK_INSYNC, buf[0]);      return -4;    }    if (stk500_recv(pgm, &m->buf[addr], block_size) < 0)      exit(1);    if (stk500_recv(pgm, buf, 1) < 0)      exit(1);    if(strcmp(ldata(lfirst(pgm->id)), ""mib510"") == 0) {      if (buf[0] != Resp_STK_INSYNC) {      fprintf(stderr,              ""%s: stk500_paged_load(): (a) protocol error, ""              ""expect=0x%02x, resp=0x%02x"",               progname, Resp_STK_INSYNC, buf[0]);      return -5;    }  }    else {      if (buf[0] != Resp_STK_OK) {        fprintf(stderr,                ""%s: stk500_paged_load(): (a) protocol error, ""                ""expect=0x%02x, resp=0x%02x"",                progname, Resp_STK_OK, buf[0]);        return -5;      }    }  }  return n_bytes;}",2,"cwe119,cwe120"
"open_tun(const char *tun_device) {tint i;tint tun_fd;tstruct ifreq ifreq;tchar *tunnel = ""/dev/net/tun"";tif ((tun_fd = open(tunnel, O_RDWR)) < 0) {ttwarn(""open_tun: %s: %s"", tunnel, strerror(errno));ttreturn -1;t}tmemset(&ifreq, 0, sizeof(ifreq));tifreq.ifr_flags = IFF_TUN; tif (tun_device != NULL) {ttstrncpy(ifreq.ifr_name, tun_device, IFNAMSIZ);ttifreq.ifr_name[IFNAMSIZ-1] = '0';ttstrncpy(if_name, tun_device, sizeof(if_name));ttif_name[sizeof(if_name)-1] = '0';ttif (ioctl(tun_fd, TUNSETIFF, (void *) &ifreq) != -1) {tttfprintf(stderr, ""Opened %s"", ifreq.ifr_name);tttreturn tun_fd;tt}ttif (errno != EBUSY) {tttwarn(""open_tun: ioctl[TUNSETIFF]: %s"", strerror(errno));tttreturn -1;tt}t} else {ttfor (i = 0; i < TUN_MAX_TRY; i++) {tttsnprintf(ifreq.ifr_name, IFNAMSIZ, ""dns%d"", i);tttif (ioctl(tun_fd, TUNSETIFF, (void *) &ifreq) != -1) {ttttfprintf(stderr, ""Opened %s"", ifreq.ifr_name);ttttsnprintf(if_name, sizeof(if_name), ""dns%d"", i);ttttreturn tun_fd;ttt}tttif (errno != EBUSY) {ttttwarn(""open_tun: ioctl[TUNSETIFF]: %s"", strerror(errno));ttttreturn -1;ttt}tt}ttwarn(""open_tun: Couldn't set interface name"");t}twarn(""error when opening tun"");treturn -1;}",3,"cwe119,cwe120,cweother"
"adt7316_event_handler(int irq, void *private){tstruct iio_dev *indio_dev = private;tstruct adt7316_chip_info *chip = iio_priv(indio_dev);tu8 stat1, stat2;tint ret;ts64 time;tret = chip->bus.read(chip->bus.client, ADT7316_INT_STAT1, &stat1);tif (!ret) {ttif ((chip->id & ID_FAMILY_MASK) != ID_ADT75XX)tttstat1 &= 0x1F;tttime = iio_get_time_ns();ttif (stat1 & BIT(0))tttiio_push_event(indio_dev,tttt       IIO_UNMOD_EVENT_CODE(IIO_TEMP, 0,ttttttt    IIO_EV_TYPE_THRESH,ttttttt    IIO_EV_DIR_RISING),tttt       time);ttif (stat1 & BIT(1))tttiio_push_event(indio_dev,tttt       IIO_UNMOD_EVENT_CODE(IIO_TEMP, 0,ttttttt    IIO_EV_TYPE_THRESH,ttttttt    IIO_EV_DIR_FALLING),tttt       time);ttif (stat1 & BIT(2))tttiio_push_event(indio_dev,tttt       IIO_UNMOD_EVENT_CODE(IIO_TEMP, 1,ttttttt    IIO_EV_TYPE_THRESH,ttttttt    IIO_EV_DIR_RISING),tttt       time);ttif (stat1 & BIT(3))tttiio_push_event(indio_dev,tttt       IIO_UNMOD_EVENT_CODE(IIO_TEMP, 1,ttttttt    IIO_EV_TYPE_THRESH,ttttttt    IIO_EV_DIR_FALLING),tttt       time);ttif (stat1 & BIT(5))tttiio_push_event(indio_dev,tttt       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 1,ttttttt    IIO_EV_TYPE_THRESH,ttttttt    IIO_EV_DIR_EITHER),tttt       time);ttif (stat1 & BIT(6))tttiio_push_event(indio_dev,tttt       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 2,ttttttt    IIO_EV_TYPE_THRESH,ttttttt    IIO_EV_DIR_EITHER),tttt       time);ttif (stat1 & BIT(7))tttiio_push_event(indio_dev,tttt       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE, 3,ttttttt    IIO_EV_TYPE_THRESH,ttttttt    IIO_EV_DIR_EITHER),tttt       time);tt}tret = chip->bus.read(chip->bus.client, ADT7316_INT_STAT2, &stat2);tif (!ret) {ttif (stat2 & ADT7316_INT_MASK2_VDD)tttiio_push_event(indio_dev,tttt       IIO_UNMOD_EVENT_CODE(IIO_VOLTAGE,ttttttt    0,ttttttt    IIO_EV_TYPE_THRESH,ttttttt    IIO_EV_DIR_RISING),tttt       iio_get_time_ns());t}treturn IRQ_HANDLED;}",2,"cwe120,cweother"
"leave_group(int catchup){    set_busy(False);    popdown_save();    popdown_search();    partial_clear_cache();    clear_tagged_articles();    clear_history();    free_read_arts_list(global.curr_group);    if (!catchup)tglobal.curr_group->read_arts = create_read_arts_list();    else {tARTICLE *art;tlist_all_arts_read(global.curr_group);tif (res_process_xrefs())t    for (art = get_articles(main_thr) ; art ; art = art->next)ttif (!art->read)tt    process_xref(art);    }    cache_leave_group();    thread_ahead_leave_group(global.curr_group);    kill_exit_group(global.curr_group);    global.curr_art = NULL;    global.curr_subj = NULL;    res_enter_group(""none"");    if (catchup || global.curr_group->subscribed)tsetNewsModeConnected();    elsetsetNewsModeAllgroups(NULL);    unset_busy();    if (global.mode == NewsModeConnected)tcheck_if_rescan_due();}",2,"cwe120,cweother"
"file_load_fasta(t_TEXT *Text) { tchar c_aux[FILE_READ];ttfgets(c_aux, FILE_READ, Text->f_in); tText->length = 0;ttsize_t j = 0;t twhile(fgets(c_aux, FILE_READ, Text->f_in)){tttt tttt#if INPUT_CATttttt#if PROTEINttttif(c_aux[0] == '>'){ttttttttttText->c_buffer[j++] = 0;tttttcontinue;tttt}ttt#elif READttttif(c_aux[0] == '+'){ttttttttttText->c_buffer[j++] = 0;ttttttttttfgets(c_aux, FILE_READ, Text->f_in);tttttfgets(c_aux, FILE_READ, Text->f_in);tttttcontinue;tttt}ttt#endifttttt#endiftttttt ttsize_t i = 0;tttfor(; i < strlen(c_aux) - 1; i++){ttttttint8 tmp = map(c_aux[i]);ttt tttif(tmp)ttttText->c_buffer[j++] = tmp;tttttt}tttt#if INPUT_CATtttText->n_strings++;tt#endift}tttText->length = j-1;tfclose(Text->f_in);t tt treturn 0;}",2,"cwe119,cwe120"
"escapequotes (char *s){    char *es;    int i, k, n, len, elen;        if (s == NULL)        return NULL;        len = strlen(s);    es = (char *) malloc ((len + 1)*sizeof(char));    strcpy(es, s);    n = 0;    while ((es = strchr(es, '""'))) {    tes++;    tn++;    }        elen = len + n + 1;    es = (char *) realloc (es, elen*sizeof(char));        i = k = 0;    while (i < len) {        if (s[i] == '""') {            es[k] = '';            k++;        }        es[k] = s[i];        i++; k++;    }    es[elen-1] = '0';    return es;}",2,"cwe120,cweother"
"AutoVacMain(int argc, char *argv[]){tListCell   *cell;tListt   *dblist;tautovac_dbase *db;tTransactionId xidForceLimit;tboolttfor_xid_wrap;tsigjmp_buftlocal_sigjmp_buf;t tIsUnderPostmaster = true;tam_autovacuum = true;t tMyProcPid = getpid();t tinit_ps_display(""autovacuum process"", """", """", """");tSetProcessingMode(InitProcessing);t #ifdef HAVE_SETSIDtif (setsid() < 0)ttelog(FATAL, ""setsid() failed: %m"");#endift tpqsignal(SIGHUP, SIG_IGN);t tpqsignal(SIGINT, StatementCancelHandler);tpqsignal(SIGTERM, die);tpqsignal(SIGQUIT, quickdie);tpqsignal(SIGALRM, handle_sig_alarm);tpqsignal(SIGPIPE, SIG_IGN);tpqsignal(SIGUSR1, CatchupInterruptHandler);t tpqsignal(SIGUSR2, SIG_IGN);tpqsignal(SIGFPE, FloatExceptionHandler);tpqsignal(SIGCHLD, SIG_DFL);t tBaseInit();t #ifndef EXEC_BACKENDtInitProcess();#endift tif (sigsetjmp(local_sigjmp_buf, 1) != 0)t{tt ttHOLD_INTERRUPTS();tt ttEmitErrorReport();tt ttproc_exit(0);t}t tPG_exception_stack = &local_sigjmp_buf;tPG_SETMASK(&UnBlockSig);t tSetConfigOption(""zero_damaged_pages"", ""false"", PGC_SUSET, PGC_S_OVERRIDE);t tdblist = autovac_get_database_list();t trecentXid = ReadNewTransactionId();txidForceLimit = recentXid - autovacuum_freeze_max_age;t tif (xidForceLimit < FirstNormalTransactionId)ttxidForceLimit -= FirstNormalTransactionId;t tdb = NULL;tfor_xid_wrap = false;tforeach(cell, dblist)t{ttautovac_dbase *tmp = lfirst(cell);tt tttmp->entry = pgstat_fetch_stat_dbentry(tmp->oid);tt ttif (TransactionIdPrecedes(tmp->frozenxid, xidForceLimit))tt{tttif (db == NULL ||ttttTransactionIdPrecedes(tmp->frozenxid, db->frozenxid))ttttdb = tmp;tttfor_xid_wrap = true;tttcontinue;tt}ttelse if (for_xid_wrap)tttcontinue;ttt tt ttif (!tmp->entry)tttcontinue;tt ttif (db == NULL ||ttttmp->entry->last_autovac_time < db->entry->last_autovac_time)tttdb = tmp;t}tif (db)t{tt ttpgstat_report_autovac(db->oid);tt ttInitPostgres(db->name, NULL);ttSetProcessingMode(NormalProcessing);ttset_ps_display(db->name, false);ttereport(DEBUG1,tttt(errmsg(""autovacuum: processing database ""%s"""", db->name)));tt ttAutovacMemCxt = AllocSetContextCreate(TopMemoryContext,ttttttttttt  ""Autovacuum context"",ttttttttttt  ALLOCSET_DEFAULT_MINSIZE,ttttttttttt  ALLOCSET_DEFAULT_INITSIZE,ttttttttttt  ALLOCSET_DEFAULT_MAXSIZE);tt ttdo_autovacuum(db->entry);t}t tproc_exit(0);}",2,"cwe119,cwe120"
"static_style (GtkWidget *widget, void *data){gamgi_window *window = GAMGI_CAST_WINDOW data;GtkWidget *dialog = window->dialog0;GtkWidget *combo;GtkWidget *entry;GtkWidget *label;char token[GAMGI_ENGINE_TOKEN];int row; combo = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""combo_style"");row = gtk_combo_box_get_active (GTK_COMBO_BOX (combo));label = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""label_size"");combo = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""combo_size"");if (row == GAMGI_MESA_WIRED - 1)  {  entry = gtk_bin_get_child (GTK_BIN (combo));  gtk_entry_set_text (GTK_ENTRY (entry), """");  gtk_widget_set_sensitive (combo, FALSE);  gtk_widget_set_sensitive (label, FALSE);  }else  {  gtk_widget_set_sensitive (combo, TRUE);  gtk_widget_set_sensitive (label, TRUE);  }if (row == GAMGI_MESA_SOLID - 1)  {  sprintf (token, ""%.*f"", GAMGI_MATH_DECIMAL_SIZE, gamgi->bond->size);  entry = gtk_bin_get_child (GTK_BIN (combo));  gtk_entry_set_text (GTK_ENTRY (entry), token);  }else  {  entry = gtk_bin_get_child (GTK_BIN (combo));  gtk_entry_set_text (GTK_ENTRY (entry), """");  }}",2,"cwe119,cwe120"
"process_message (message_ty *mp){  const char *msgstr = mp->msgstr;  size_t msgstr_len = mp->msgstr_len;  char *location;  size_t nsubstrings;  char **substrings;  size_t total_len;  char *total_str;  const char *p;  char *q;  size_t k;     if (is_header (mp) && keep_header)    return;     if (mp->msgctxt != NULL)    xsetenv (""MSGFILTER_MSGCTXT"", mp->msgctxt, 1);  else    unsetenv (""MSGFILTER_MSGCTXT"");  xsetenv (""MSGFILTER_MSGID"", mp->msgid, 1);  location = xasprintf (""%s:%ld"", mp->pos.file_name,                        (long) mp->pos.line_number);  xsetenv (""MSGFILTER_LOCATION"", location, 1);  free (location);     for (p = msgstr, nsubstrings = 0;       p < msgstr + msgstr_len;       p += strlen (p) + 1, nsubstrings++);     substrings = XNMALLOC (nsubstrings, char *);  for (p = msgstr, k = 0, total_len = 0; k < nsubstrings; k++)    {      char *result;      size_t length;      process_string (p, strlen (p), &result, &length);      result = (char *) xrealloc (result, length + 1);      result[length] = '0';      substrings[k] = result;      total_len += length + 1;      p += strlen (p) + 1;    }     total_str = XNMALLOC (total_len, char);  for (k = 0, q = total_str; k < nsubstrings; k++)    {      size_t length = strlen (substrings[k]);      memcpy (q, substrings[k], length + 1);      free (substrings[k]);      q += length + 1;    }  free (substrings);  mp->msgstr = total_str;  mp->msgstr_len = total_len;}",2,"cwe120,cwe469"
"InitDict( ChewingData *pgdata, const char *prefix ){#ifdef USE_BINARY_DATAtchar filename[ PATH_MAX ];tsize_t len;tsize_t offset;tsize_t file_size;tsize_t csize;tlen = snprintf( filename, sizeof( filename ), ""%s"" PLAT_SEPARATOR ""%s"", prefix, DICT_FILE );tif ( len + 1 > sizeof( filename ) )ttreturn -1;tplat_mmap_set_invalid( &pgdata->static_data.dict_mmap );tfile_size = plat_mmap_create( &pgdata->static_data.dict_mmap, filename, FLAG_ATTRIBUTE_READ );tif ( file_size <= 0 )ttreturn -1;toffset = 0;tcsize = file_size;tpgdata->static_data.dict = plat_mmap_set_view( &pgdata->static_data.dict_mmap, &offset, &csize );tif ( !pgdata->static_data.dict )ttreturn -1;tlen = snprintf( filename, sizeof( filename ), ""%s"" PLAT_SEPARATOR ""%s"", prefix, PH_INDEX_FILE );tif ( len + 1 > sizeof( filename ) )ttreturn -1;tplat_mmap_set_invalid( &pgdata->static_data.index_mmap );tfile_size = plat_mmap_create( &pgdata->static_data.index_mmap, filename, FLAG_ATTRIBUTE_READ );tif ( file_size <= 0 )ttreturn -1;toffset = 0;tcsize = file_size;tpgdata->static_data.dict_begin = plat_mmap_set_view( &pgdata->static_data.index_mmap, &offset, &csize );tif ( !pgdata->static_data.dict_begin )ttreturn -1;treturn 0;#elsetchar filename[ PATH_MAX ];tFILE *indexfile;tint len;tint i;tpgdata->static_data.dict_begin = ALC( int, PHONE_PHRASE_NUM + 1 );tif ( !pgdata->static_data.dict_begin )ttreturn -1;tlen = snprintf( filename, sizeof( filename ), ""%s"" PLAT_SEPARATOR ""%s"", prefix, DICT_FILE );tif ( len + 1 > sizeof( filename ) )ttreturn -1;tpgdata->static_data.dictfile = fopen( filename, ""r"" );tif ( !pgdata->static_data.dictfile )ttreturn -1;tlen = snprintf( filename, sizeof( filename ), ""%s"" PLAT_SEPARATOR ""%s"", prefix, PH_INDEX_FILE );tif ( len + 1 > sizeof( filename ) )ttreturn -1;tindexfile = fopen( filename, ""r"" );tif ( !indexfile )ttreturn -1;ti = 0;t twhile ( !feof( indexfile ) )ttfscanf( indexfile, ""%d"", &pgdata->static_data.dict_begin[ i++ ] );tfclose( indexfile );treturn 0;#endif}",3,"cwe119,cwe120,cweother"
"needs_enc(const char *string) {    if (strspn(string, noenc) < strlen(string))treturn 1;    if (strncmp(string, ""=?"", 2) == 0t    && strcmp(string + strlen(string) - 2, ""?="") == 0)treturn 1;    return 0;}",2,"cwe120,cwe469"
"get_user_seq (void){ char * seq; UINT32 prom[2] = { 0L, 0L }; UINT32 sdres = 0L; printf (""Please enter some random data (only first %d are significant)"", sizeof(prom)); seq = (char *)getpass(""(eg. your old password):>""); if (strlen(seq) < sizeof(prom))  (void)memcpy((void *)&prom[0], (void *)seq, (int)strlen(seq)); else  (void)memcpy((void *)&prom[0], (void *)seq, sizeof(prom)); sdres = prom[0]^prom[1]; return (sdres);}",2,"cwe120,cweother"
"fd_server(void) {    int infd;    char inbuf[1024];    int inbuf_pos = 0, sndbuf_pos = 0;    fd_set inset, outset;#ifdef SOUND_DEBUG    fprintf(stderr, ""fd_server: starting."");    fflush(stderr);#endif    infd = fileno(stdin);    FD_ZERO(&inset);    FD_ZERO(&outset);    FD_SET(soundfd, &outset);    FD_SET(infd, &inset);    while (1) {#if defined(SGI_SOUND)                 ALsetfillpoint(soundport, 100000);#endif        select(FD_SETSIZE, &inset, &outset, NULL, NULL);        if (FD_ISSET(soundfd, &outset)) {                         if (current_buffer == first_free_buffer) FD_CLR(soundfd, &outset);            else {                int wrote;                wrote = audio_play(current_buffer, sndbuf_pos);                if (wrote < settings.buflen - sndbuf_pos) sndbuf_pos += wrote;                else {                                       memset(buffers + settings.buflen * current_buffer,                       zerolevel, settings.buflen);                   sounds_in_buffer[current_buffer] = 0;                   sndbuf_pos = 0;                   current_buffer++;                   if (current_buffer >= settings.buffers)                       current_buffer = 0;                }            }        } else {                         FD_SET(soundfd, &outset);        }        if (FD_ISSET(infd, &inset)) {            int err = read(infd, inbuf + inbuf_pos, 1);            if (err < 1 && errno != EINTR) {                if (err < 0)                    perror(""read"");                break;            }            if (inbuf[inbuf_pos] == '') {                inbuf[inbuf_pos++] = 0;                if (!StdinCmd(inbuf, inbuf_pos))                    FD_SET(soundfd, &outset);                inbuf_pos = 0;            } else {                inbuf_pos++;                if (inbuf_pos >= 1024) {                    fprintf(stderr, ""Input buffer overflow!"");                    inbuf_pos = 0;                }            }        }        FD_SET(infd, &inset);    }}",3,"cwe119,cwe120,cweother"
"free_imatrix(int **m,int nrl,int nrh,int ncl,int nch) {tif (m == NULL)ttreturn;tif (nrh < nrl)t ttnrh = nrl;tif (nch < ncl)ttnch = ncl;tfree((char *)(m[nrl-1]));tfree((char *)(m+nrl-1));}",2,"cwe119,cwe120"
"HISclose(){    if (HISwritefp != NULL) {t tHISsync();tif (dbmclose() < 0)t    syslog(L_ERROR, ""%s cant dbmclose %m"", LogName);tif (fclose(HISwritefp) == EOF)t    syslog(L_ERROR, ""%s cant fclose history %m"", LogName);tHISwritefp = NULL;tif (close(HISreadfd) < 0)t    syslog(L_ERROR, ""%s cant close history %m"", LogName);tHISreadfd = -1;    }    if (HIScachelookups > 0)        syslog(L_NOTICE, ""SERVER history cache final: %lu lookups, %lu hits"",       t       HIScachelookups, HIScachehits);}",2,"cwe120,cweother"
"verify_server_uname(char *newuname) {  AdmldapInfo admInfo = NULL;  char *grpname;  struct group  *grp;  struct passwd *pwd;  int errorcode = 0;  int i = 0;  int grmem_found = 0;  char buf[BUFSIZ];  char *configdir = util_get_conf_dir();  admInfo = admldapBuildInfoOnly(configdir, &errorcode);  if (!admInfo || errorcode) {    rpt_err(SYSTEM_ERROR, ""Can not open adm.conf for reading"", NULL, NULL);    return -1;  }  grpname = admldapGetSysGroup(admInfo);    destroyAdmldap(admInfo);  if (!grpname) {    rpt_err(SYSTEM_ERROR, ""sysgroup not found in adm.conf"", NULL, NULL);    return -1;  }  grp = getgrnam(grpname);  if (grp == NULL) {    PR_snprintf(buf, sizeof(buf), ""sysgroup '%s' does not exist"", grpname);    rpt_err(SYSTEM_ERROR, buf, NULL, NULL);tPL_strfree(grpname);    return -1;  }     pwd = getpwnam(newuname);  if (pwd == NULL) {    PR_snprintf(buf, sizeof(buf), ""Can not change Server UID, ""t    ""User '%s' does not exist"", newuname);    rpt_err(INCORRECT_USAGE, buf, NULL, NULL);tPL_strfree(grpname);    return -1;  }     while (grp->gr_mem[i] && !grmem_found) {    if (strcmp(grp->gr_mem[i], newuname) == 0) {      grmem_found = 1;    }    else i++;t  }  if (!grmem_found && pwd->pw_gid != grp->gr_gid) {    PR_snprintf(buf, sizeof(buf), ""Can not change Server UID, ""t    ""User '%s' does not belong to the group '%s'"", newuname, grpname);    rpt_err(INCORRECT_USAGE, buf, NULL, NULL);tPL_strfree(grpname);    return -1;  }  PL_strfree(grpname);  return pwd->pw_uid;}",2,"cwe119,cwe120"
"""parse_forward(const char *in, struct survey_record *out){    char dummy1;    int status;    if (out->haslabel == YES) {tstatus =t    sscanf(in, FORMAT_1, out->label, out->n_s, &out->deg, &dummy1,tt   &out->min, &dummy1, &out->sec, out->e_w, &out->dist);    }    else {tstatus = sscanf(in, FORMAT_2, out->n_s, &out->deg, &dummy1,ttt&out->min, &dummy1, &out->sec, out->e_w, &out->dist);    }    if ((status != 9 && out->haslabel == YES) ||t(status != 8 && out->haslabel == NO))treturn 0;    out->dd = DMS2DD(out->deg, out->min, out->sec);    if (out->n_s[0] == 'N') {tif (out->e_w[0] == 'E') {t    out->dd = 90.0 - out->dd;t}telse if (out->e_w[0] == 'W') {t    out->dd = 90.0 + out->dd;t}telse {t    return 0;t}    }    else if (out->n_s[0] == 'S') {tif (out->e_w[0] == 'E') {t    out->dd = 270 + out->dd;t}telse if (out->e_w[0] == 'W') {t    out->dd = 270 - out->dd;t}telse {t    return 0;t}    }    else {treturn 0;    }    out->rads = DEG2RAD(out->dd);    out->x += out->dist * cos(out->rads);    out->y += out->dist * sin(out->rads);    return status;}""",2,"cwe120,cweother"
"ebnet_bind_booklist(EB_BookList *booklist, const char *url){    EB_Error_Code error_code;    char host[NI_MAXHOST];    in_port_t port;    char book_name[EBNET_MAX_BOOK_NAME_LENGTH + 1];    char book_title[EBNET_MAX_BOOK_TITLE_LENGTH + 1];    char url_path[EB_MAX_RELATIVE_PATH_LENGTH + 1];    Line_Buffer line_buffer;    char line[EBNET_MAX_LINE_LENGTH + 1];    int ebnet_file = -1;    ssize_t read_result;    int lost_sync;    int retry_count = 0;    LOG((""in: ebnet_bind_booklist(url=%s)"", url));  retry:    lost_sync = 0;    initialize_line_buffer(&line_buffer);    set_line_buffer_timeout(&line_buffer, EBNET_TIMEOUT_SECONDS);         if (ebnet_parse_url(url, host, &port, book_name, url_path) < 0t|| *book_name != '0') {terror_code = EB_ERR_BAD_FILE_NAME;tgoto failed;    }         ebnet_file = ebnet_connect_socket(host, port, PF_UNSPEC);    if (ebnet_file < 0) {terror_code = EB_ERR_EBNET_FAIL_CONNECT;tgoto failed;    }         bind_file_to_line_buffer(&line_buffer, ebnet_file);    sprintf(line, ""BOOKLIST %sr"", book_name);    if (write_string_all(ebnet_file, EBNET_TIMEOUT_SECONDS, line) <= 0) {terror_code = EB_ERR_EBNET_FAIL_CONNECT;tlost_sync = 1;tgoto failed;    }    read_result = read_line_buffer(&line_buffer, line, sizeof(line));    if (read_result < 0 || read_result == sizeof(line) || *line != '!') {tlost_sync = 1;terror_code = EB_ERR_EBNET_FAIL_CONNECT;tgoto failed;    }    if (strncasecmp(line, ""!OK;"", 4) != 0) {terror_code = EB_ERR_EBNET_FAIL_CONNECT;tgoto failed;    }         for (;;) {tread_result = read_line_buffer(&line_buffer, line, sizeof(line));tif (read_result < 0 || read_result == sizeof(line)) {t    lost_sync = 1;t    error_code = EB_ERR_EBNET_FAIL_CONNECT;t    goto failed;t}tif (*line == '0')t    break;tif (ebnet_parse_booklist_entry(line, book_name, book_title) < 0) {t    lost_sync = 1;t    error_code = EB_ERR_EBNET_FAIL_CONNECT;t    goto failed;t}terror_code = eb_booklist_add_book(booklist, book_name, book_title);tif (error_code != EB_SUCCESS)t    goto failed;    }    ebnet_disconnect_socket(ebnet_file);    finalize_line_buffer(&line_buffer);    LOG((""out: ebnet_bind_booklist() = %s"", eb_error_string(EB_SUCCESS)));    return EB_SUCCESS;       failed:    finalize_line_buffer(&line_buffer);    if (0 <= ebnet_file) {tif (lost_sync) {t    shutdown(ebnet_file, SHUT_RDWR);t    ebnet_set_lost_sync(ebnet_file);t}tebnet_disconnect_socket(ebnet_file);tebnet_file = -1;tif (lost_sync && retry_count < EBNET_MAX_RETRY_COUNT) {t    retry_count++;t    goto retry;t}    }    LOG((""out: ebnet_bind_booklist() = %s"", eb_error_string(error_code)));    return error_code;}",2,"cwe119,cwe120"
"""drv_PICGraphic_contrast(int contrast){    char __attribute__ ((unused)) cmd[2];    /* adjust limits according to the display */    if (contrast < 0)tcontrast = 0;    if (contrast > 15)tcontrast = 15;    /* call a 'contrast' function */    cmd[0] = 'c';    cmd[1] = contrast;    // todo: fixme    // drv_PICGraphic_send(cmd, 2);    return contrast;}""",2,"cwe119,cwe120"
"retry_writev(int fd, struct iovec *iov, int iovcnt) {tint n;                tint i;                tint written;          tstatic int iov_max;   #ifdef MAXIOVtiov_max = MAXIOV;#else # ifdef IOV_MAXtiov_max = IOV_MAX;# else tiov_max = 8192;# endif #endiftwritten = 0;tfor (;;) {ttwhile (iovcnt && iov[0].iov_len == 0) {tttiov++;tttiovcnt--;tt}ttif (!iovcnt) {tttreturn written;tt}ttn = writev(fd, iov, iovcnt > iov_max ? iov_max : iovcnt);ttif (n == -1) {tttif (errno == EINVAL && iov_max > 10) {ttttiov_max /= 2;ttttcontinue;ttt}tttif (errno == EINTR) {ttttcontinue;ttt}tttreturn -1;tt} else {tttwritten += n;tt}ttfor (i = 0; i < iovcnt; i++) {tttif ((int) iov[i].iov_len > n) {ttttiov[i].iov_base = (char *)iov[i].iov_base + n;ttttiov[i].iov_len -= n;ttttbreak;ttt}tttn -= iov[i].iov_len;tttiov[i].iov_len = 0;tt}ttif (i == iovcnt) {tttreturn written;tt}t}}",2,"cwe119,cwe120"
"pdfapp_save(pdfapp_t *app){tchar buf[PATH_MAX];tif (wingetsavepath(app, buf, PATH_MAX))t{ttfz_write_options opts;ttopts.do_ascii = 1;ttopts.do_expand = 0;ttopts.do_garbage = 1;ttopts.do_linear = 0;ttfz_write_document(app->doc, buf, &opts);ttreturn 1;t}telset{ttreturn 0;t}}",2,"cwe119,cwe120"
"do_cmd_pref_file_hack(long row){tchar ftmp[80];t tprt(""Command: Load a user pref file"", row, 0);t tprt(""File: "", row + 2, 0);t tstrnfmt(ftmp, sizeof ftmp, ""%s.prf"", op_ptr->base_name);t tif (!askfor_aux(ftmp, sizeof ftmp, NULL)) return;t tif (process_pref_file(ftmp))t{tt ttprt("""", 0, 0);ttmsg_format(""Failed to load '%s'!"", ftmp);t}telset{tt ttprt("""", 0, 0);ttmsg_format(""Loaded '%s'."", ftmp);t}}",2,"cwe119,cwe120"
"gnutls_x509_crq_get_extension_by_oid (gnutls_x509_crq_t crq,                                      const char *oid, int indx,                                      void *buf, size_t * sizeof_buf,                                      unsigned int *critical){  int result;  unsigned int i;  char _oid[MAX_OID_SIZE];  size_t oid_size;  for (i = 0;; i++)    {      oid_size = sizeof (_oid);      result =        gnutls_x509_crq_get_extension_info (crq, i, _oid, &oid_size,                                            critical);      if (result < 0)        {          gnutls_assert ();          return result;        }      if (strcmp (oid, _oid) == 0)        {                                  if (indx == 0)            return gnutls_x509_crq_get_extension_data (crq, i, buf,                                                       sizeof_buf);          else            indx--;        }    }  return GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE;}",2,"cwe119,cwe120"
"check_host(krb5_context context, const char *path, char *data){    int ret;    char hostname[128];    const char *p = data;    struct addrinfo hints;    char service[32];    int defport;    struct addrinfo *ai;    hints.ai_flags = 0;    hints.ai_family = PF_UNSPEC;    hints.ai_socktype = 0;    hints.ai_protocol = 0;    hints.ai_addrlen = 0;    hints.ai_canonname = NULL;    hints.ai_addr = NULL;    hints.ai_next = NULL;              if(strncmp(p, ""http://"", 7) == 0){        p += 7;thints.ai_socktype = SOCK_STREAM;tstrlcpy(service, ""http"", sizeof(service));tdefport = 80;    } else if(strncmp(p, ""http/"", 5) == 0) {        p += 5;thints.ai_socktype = SOCK_STREAM;tstrlcpy(service, ""http"", sizeof(service));tdefport = 80;    }else if(strncmp(p, ""tcp/"", 4) == 0){        p += 4;thints.ai_socktype = SOCK_STREAM;tstrlcpy(service, ""kerberos"", sizeof(service));tdefport = 88;    } else if(strncmp(p, ""udp/"", 4) == 0) {        p += 4;thints.ai_socktype = SOCK_DGRAM;tstrlcpy(service, ""kerberos"", sizeof(service));tdefport = 88;    } else {thints.ai_socktype = SOCK_DGRAM;tstrlcpy(service, ""kerberos"", sizeof(service));tdefport = 88;    }    if(strsep_copy(&p, "":"", hostname, sizeof(hostname)) < 0) {treturn 1;    }    hostname[strcspn(hostname, ""/"")] = '0';    if(p != NULL) {tchar *end;tint tmp = strtol(p, &end, 0);tif(end == p) {t    krb5_warnx(context, ""%s: failed to parse port number in %s"",tt       path, data);t    return 1;t}tdefport = tmp;tsnprintf(service, sizeof(service), ""%u"", defport);    }    ret = getaddrinfo(hostname, service, &hints, &ai);    if(ret == EAI_SERVICE && !isdigit((unsigned char)service[0])) {tsnprintf(service, sizeof(service), ""%u"", defport);tret = getaddrinfo(hostname, service, &hints, &ai);    }    if(ret != 0) {tkrb5_warnx(context, ""%s: %s (%s)"", path, gai_strerror(ret), hostname);treturn 1;    }    return 0;}",3,"cwe119,cwe120,cwe469"
"jswrap_object_removeAllListeners(JsVar *parent, JsVar *event) {  if (!jsvIsObject(parent)) {      jsWarn(""Parent must be a proper object - not a String, Integer, etc."");      return;    }  if (jsvIsString(event)) {         char eventName[16] = ""#on"";    jsvGetString(event, &eventName[3], sizeof(eventName)-4);    JsVar *eventList = jsvFindChildFromString(parent, eventName, true);    if (eventList) {      jsvRemoveChild(parent, eventList);      jsvUnLock(eventList);    }  } else if (jsvIsUndefined(event)) {         JsvObjectIterator it;    jsvObjectIteratorNew(&it, parent);    while (jsvObjectIteratorHasValue(&it)) {      JsVar *key = jsvObjectIteratorGetKey(&it);      jsvObjectIteratorNext(&it);      if (jsvIsString(key) &&          key->varData.str[0]=='#' &&          key->varData.str[1]=='o' &&          key->varData.str[2]=='n') {                 jsvRemoveChild(parent, key);      }      jsvUnLock(key);    }    jsvObjectIteratorFree(&it);  } else {    jsWarn(""First argument to EventEmitter.removeAllListeners(..) must be a string, or undefined"");    return;  }}",2,"cwe119,cwe120"
"operatorPrintAll(void){  int i, j, nbyte, nop = 0;  char *opernames[4096];  FILE *pout = stderr;  for ( i = 0; i < NumModules; i++ )    {      j = 0;      while ( Modules[i].operators[j] )t{t  opernames[nop++] = Modules[i].operators[j++];t}    }     for ( i = 0; i < nopalias; i++ )    {      opernames[nop++] = opalias[i][0];    }  qsort(opernames, nop, sizeof(char *), cmpname);  nbyte = fprintf(pout, ""   "");  for ( i = 0; i < nop; i++ )    {      if ( nbyte > 85 )t{t  fprintf(pout, """");t  nbyte = fprintf(pout, ""   "");t}      nbyte += fprintf(pout, "" %s"", opernames[i]);    }  fprintf(pout, """");}",2,"cwe119,cwe120"
"readlabel(const unsigned char *in, int insize, const unsigned char *ref, int refsize, int *_at, jdns_string_t **name){tint at;t t t t tunsigned char out[MAX_LABEL_LENGTH - 1];tint out_size;tconst unsigned char *label, *last;tint hopped_yet;tint hopsleft;tint label_size;tat = *_at;t tif(at < 0 || at >= insize)ttreturn 0;tout_size = 0;tlabel = in + at;thopped_yet = 0;tlast = in + insize;twhile(1)t{tt ttif(label + 1 > last)tttgoto error;tt tt tt tthopsleft = 8;ttwhile(*label & 0xc0)tt{tttint offset;ttt tttif(label + 2 > last)ttttgoto error;tttoffset = getoffset(label, refsize, &hopsleft);tttif(offset == -1)ttttgoto error;tttlabel = ref + offset;tttif(!hopped_yet)ttt{ttttat += 2;tttthopped_yet = 1;ttttlast = ref + refsize;ttt}ttt tttif(label + 1 > last)ttttgoto error;tt}ttlabel_size = *label & 0x3f;tt ttif(label_size == 0)tt{tttif(!hopped_yet)tttt++at;tttbreak;tt}tt ttif(label + label_size + 1 > last)tttgoto error;tt ttif(out_size + label_size + 1 > MAX_LABEL_LENGTH - 1)tttgoto error;ttmemcpy(out + out_size, label + 1, label_size);ttout_size += label_size;ttout[out_size] = '.';tt++out_size;ttif(!hopped_yet)tttat += label_size + 1;ttlabel += label_size + 1;t}t*_at = at;t*name = jdns_string_new();tjdns_string_set(*name, out, out_size);treturn 1;error:treturn 0;}",3,"cwe119,cwe120,cweother"
"child_service (int in, int out){tchar buf[ID_BUF_SIZE];tsignal (SIGALRM, exit);talarm (Client_Timeout);tif (m_reduce_rights () == -1)ttsyslog (LOG_ERR, ""error: cannot reduce self's rights ""ttt""[m_reduce_rights()]"");telsettwhile (_getl (in, buf, ID_BUF_SIZE) != 0)tttnexus (out, buf);tclose (in);tif (out != in)ttclose (out);}",2,"cwe119,cwe120"
"read_config (VeConfig *config){tFILE *fp;tVeSection *section = config->root;tchar buf[2048];tint cnt;tchar *getsret;tconfig->mtime = get_mtime (config->file);tVE_IGNORE_EINTR (fp = fopen (config->file, ""r""));tif (fp == NULL)ttreturn;tcnt = 0;tfor (;;) {ttchar *nows = buf;ttchar *eq;ttchar *p;ttVE_IGNORE_EINTR (getsret = fgets (buf, sizeof (buf), fp));ttif (getsret == NULL)tttbreak;ttp = strchr (buf, '');ttif (p != NULL)ttt*p = '0';ttwhile (*nows == ' ' || *nows == 't')tttnows++;ttif (*nows == '[') {tttp = strchr (nows, ']');tttif (p != NULL)tttt*p = '0';tttnows++;tttsection = new_section (config, nows);tttconfig->sections = g_list_append (config->sections,ttttttt  section);tt} else if (*nows == '0') {tttadd_text_line (config, section, """");tt} else if (*nows == '#') {tttadd_text_line (config, section, buf);tt} else if ((eq = strchr (nows, '=')) != NULL) {tttchar *val;ttt*eq = '0';ttteq ++;tttval = g_strcompress (eq);tttadd_key_line (config, section,tttt      nows  ,tttt      val  ,tttt      FALSE  );tttg_free (val);tt}tt tt ttcnt ++;ttif (cnt > 5000)tttbreak;t}tVE_IGNORE_EINTR (fclose (fp));}",3,"cwe119,cwe120,cweother"
"splitPowerNet(apLoFig, asPower)  lofig_list *apLoFig;        char *asPower;{  ptype_list *pType;  chain_list *pChain;  locon_list *pLoCon;  loins_list *pLoIns;  losig_list *pSigPower, *pSig;        char *tsSig[2], *sVDD, *sVSS, *sPOW;        long  powerType;  sVDD = namealloc(""vdd"");  sVSS = namealloc(""vss"");  tsSig[C_POWER_VDD] = namealloc(""vddi"");  tsSig[C_POWER_VSS] = namealloc(""vssi"");  powerType = C_POWER_UNKNOWN; sPOW = (char*)NULL;  if (!strcmp(asPower, sVDD)) { powerType = C_POWER_VDD; sPOW = sVDD; }  if (!strcmp(asPower, sVSS)) { powerType = C_POWER_VSS; sPOW = sVSS; }  if (powerType == C_POWER_UNKNOWN) {    eprinth((char*)NULL);    eprintf(""  Only ""vdd"" and ""vss"" can be splitted (%s)."", asPower);    EXIT (1);  }  pChain    = addchain((chain_list*)NULL, (void*)tsSig[powerType]);  pSigPower = addlosig(apLoFig, NEWSIGINDEX, pChain, INTERNAL);     for(pSig = apLoFig->LOSIG; pSig != (losig_list*)NULL; pSig = pSig->NEXT)    if (cmpSigName(pSig, sPOW)) break;  if (pSig == (losig_list*)NULL) {    eprinth((char*)NULL);    eprintf(""  Signal ""%s"" not found for splitting."", sPOW);    EXIT (1);  }  pType = getptype(pSig->USER, (long)LOFIGCHAIN);  if (pType == (ptype_list*)NULL) {    eprinth((char*)NULL);    eprintf(""  Signal ""%s"" have no LOFIGCHAIN."", sPOW);    EXIT (1);  }     pChain = (chain_list*)(pType->DATA);  for(; pChain != (chain_list*)NULL;        pChain  = pChain->NEXT) {    pLoCon = (locon_list*)(pChain->DATA);    if (pLoCon->TYPE == INTERNAL) {      pLoIns = (loins_list*)(pLoCon->ROOT);      if (isPad(pLoIns->FIGNAME)) pLoCon->SIG = pSigPower;      if (    (powerType == C_POWER_VDD)          && !strcmp(pLoIns->FIGNAME, ""pvddi_sp"")) {        addInsLoCon(pLoIns, sPOW, pSig, pLoCon->DIRECTION);      }      if (    (powerType == C_POWER_VSS)          && !strcmp(pLoIns->FIGNAME, ""pvssi_sp"")) {        addInsLoCon(pLoIns, sPOW, pSig, pLoCon->DIRECTION);      }    }  }  }",3,"cwe476,cwe469,cweother"
"""jsvArrayBufferIteratorSetIntegerValue(JsvArrayBufferIterator *it, JsVarInt v) {  if (it->type == ARRAYBUFFERVIEW_UNDEFINED) return;  assert(!it->hasAccessedElement); // we just haven't implemented this case yet  char data[8];  unsigned int i,dataLen = JSV_ARRAYBUFFER_GET_SIZE(it->type);  if (JSV_ARRAYBUFFER_IS_FLOAT(it->type)) {    jsvArrayBufferIteratorFloatToData(data, dataLen, it->type, (JsVarFloat)v);  } else {    jsvArrayBufferIteratorIntToData(data, dataLen, it->type, v);  }  for (i=0;i<dataLen;i++) {    jsvStringIteratorSetChar(&it->it, data[i]);    if (dataLen!=1) jsvStringIteratorNext(&it->it);  }  if (dataLen!=1) it->hasAccessedElement = true;}""",3,"cwe119,cwe120,cweother"
"setPathInterval(parsedata * pdata) {tpathattr *pattr = pdata->pattr;tg2sattr *attr = pdata->attr;tg2sprop *prop = pdata->prop;tstatic char _t[TIMELENGTH];tdouble intvl = 0;tstatic double _x, _y, _z;tdouble leng = 0;tdouble spd;tif (pattr->count == 1) {ttstrncpy(_t, attr->time, TIMELENGTH);t} else {tt ttintvl = getTimeInterval(_t, attr->time);ttpattr->interval = pattr->interval + intvl;ttstrncpy(_t, attr->time, TIMELENGTH);tt ttleng = getDistance(_x, _y, attr->lon, attr->lat);ttpattr->length = pattr->length + leng;tt ttspd = getSpeed(leng, intvl, prop->speed2meter, prop->speed2sec);tt ttif (prop->isEdge) {tttsetEdge(pdata, _x, _y, _z, leng, intvl, spd);tt}t}t_x = attr->lon;t_y = attr->lat;t_z = attr->ele;}",2,"cwe119,cwe120"
"HDRWriteRunlengthPixels(Image *image,unsigned char *pixels){#define MinimumRunlength 4  register size_t    p,    q;  size_t    runlength;  ssize_t    count,    previous_count;  unsigned char    pixel[2];  for (p=0; p < image->columns; )  {    q=p;    runlength=0;    previous_count=0;    while ((runlength < MinimumRunlength) && (q < image->columns))    {      q+=runlength;      previous_count=(ssize_t) runlength;      runlength=1;      while ((pixels[q] == pixels[q+runlength]) &&             ((q+runlength) < image->columns) && (runlength < 127))       runlength++;    }    if ((previous_count > 1) && (previous_count == (ssize_t) (q-p)))      {        pixel[0]=(unsigned char) (128+previous_count);        pixel[1]=pixels[p];        if (WriteBlob(image,2*sizeof(*pixel),pixel) < 1)          break;        p=q;      }    while (p < q)    {      count=(ssize_t) (q-p);      if (count > 128)        count=128;      pixel[0]=(unsigned char) count;      if (WriteBlob(image,sizeof(*pixel),pixel) < 1)        break;      if (WriteBlob(image,(size_t) count*sizeof(*pixel),&pixels[p]) < 1)        break;      p+=count;    }    if (runlength >= MinimumRunlength)      {        pixel[0]=(unsigned char) (128+runlength);        pixel[1]=pixels[q];        if (WriteBlob(image,2*sizeof(*pixel),pixel) < 1)          break;        p+=runlength;      }  }  return(p);}",2,"cwe119,cwe120"
"safe_read(int fd, void *buf, size_t count) {tssize_t res;tfor (;;) {ttres = read(fd, buf, count);ttif (res >= 0) return res;ttswitch (errno) {ttcase EINTR:tttcontinue;ttdefault:tttreturn -1;tt}t}}",2,"cwe120,cweother"
"fdlg_handle_button( FDlg *fdlg, int button_id, int cx, int cy, Button **button ){    char path[512];    void *item = 0;    char *fname;    if ( !fdlg->group->frame->img->bkgnd->hide ) {        if ( group_handle_button( fdlg->group, button_id, cx, cy, button ) )            return 1;        if ( lbox_handle_button( fdlg->lbox, button_id, cx, cy, button, &item ) ) {            if ( item ) {                SDL_FillRect( fdlg->group->frame->contents, 0, 0x0 );                fname = (char*)item;                if ( fname[0] == '*' ) {                                         if ( fname[1] == '.' ) {                                                 if ( strrchr( fdlg->subdir, '/' ) )                            (strrchr( fdlg->subdir, '/' ))[0] = 0;                        else                            fdlg->subdir[0] = 0;                    }                    else {                        if ( fdlg->subdir[0] != 0 )                            strcat( fdlg->subdir, ""/"" );                        strcat( fdlg->subdir, fname + 1 );                    }                    if ( fdlg->subdir[0] == 0 )                        strcpy( path, fdlg->root );                    else                        sprintf( path, ""%s/%s"", fdlg->root, fdlg->subdir );                    lbox_set_items( fdlg->lbox, dir_get_entries( path, fdlg->root, 0 ) );                    (fdlg->file_cb)( 0, fdlg->info_buffer );                }                else {                                         if ( fdlg->subdir[0] == 0 )                        strcpy( path, fname );                    else                        sprintf( path, ""%s/%s"", fdlg->subdir, fname );                    (fdlg->file_cb)( path, fdlg->info_buffer );                }                DEST( fdlg->group->frame->contents, fdlg->info_x, fdlg->info_y, fdlg->info_buffer->w, fdlg->info_buffer->h );                SOURCE( fdlg->info_buffer, 0, 0 );                blit_surf();                frame_apply( fdlg->group->frame );            }        }        return 0;    }    return 0;}",2,"cwe119,cwe120"
"""QRinput_encodeModeNum(QRinput_List *entry, BitStream *bstream, int version, int mqr){tint words, i, ret;tunsigned int val;tif(mqr) {ttif(version > 1) {tttret = BitStream_appendNum(bstream, version - 1, MQRSPEC_MODEID_NUM);tttif(ret < 0) return -1;tt}ttret = BitStream_appendNum(bstream, MQRspec_lengthIndicator(QR_MODE_NUM, version), entry->size);ttif(ret < 0) return -1;t} else {ttret = BitStream_appendNum(bstream, 4, QRSPEC_MODEID_NUM);ttif(ret < 0) return -1;tttret = BitStream_appendNum(bstream, QRspec_lengthIndicator(QR_MODE_NUM, version), entry->size);ttif(ret < 0) return -1;t}twords = entry->size / 3;tfor(i=0; i<words; i++) {ttval  = (entry->data[i*3  ] - '0') * 100;ttval += (entry->data[i*3+1] - '0') * 10;ttval += (entry->data[i*3+2] - '0');ttret = BitStream_appendNum(bstream, 10, val);ttif(ret < 0) return -1;t}tif(entry->size - words * 3 == 1) {ttval = entry->data[words*3] - '0';ttret = BitStream_appendNum(bstream, 4, val);ttif(ret < 0) return -1;t} else if(entry->size - words * 3 == 2) {ttval  = (entry->data[words*3  ] - '0') * 10;ttval += (entry->data[words*3+1] - '0');ttBitStream_appendNum(bstream, 7, val);ttif(ret < 0) return -1;t}treturn 0;}""",2,"cwe119,cwe120"
"NITFCreateXMLTre(NITFFile* psFile,                             const char* pszTREName,                             const char *pachTRE,                             int nTRESize){    int nTreLength, nTreMinLength = -1, nTreMaxLength = -1;    int bError = FALSE;    int nTreOffset = 0;    CPLXMLNode* psTreNode;    CPLXMLNode* psOutXMLNode = NULL;    int nMDSize = 0, nMDAlloc = 0;    psTreNode = NITFFindTREXMLDescFromName(psFile, pszTREName);    if (psTreNode == NULL)    {        if (!(EQUALN(pszTREName, ""RPF"", 3) || strcmp(pszTREName, ""XXXXXX"") == 0))        {            CPLDebug(""NITF"", ""Cannot find definition of TRE %s in %s"",                    pszTREName, NITF_SPEC_FILE);        }        return NULL;    }    nTreLength = atoi(CPLGetXMLValue(psTreNode, ""length"", ""-1""));    nTreMinLength = atoi(CPLGetXMLValue(psTreNode, ""minlength"", ""-1""));    nTreMaxLength = atoi(CPLGetXMLValue(psTreNode, ""maxlength"", ""-1""));    if( (nTreLength > 0 && nTRESize != nTreLength) ||        (nTreMinLength > 0 && nTRESize < nTreMinLength) )    {        CPLError( CE_Warning, CPLE_AppDefined,                  ""%s TRE wrong size, ignoring."", pszTREName );        return NULL;    }    psOutXMLNode = CPLCreateXMLNode(NULL, CXT_Element, ""tre"");    CPLCreateXMLNode(CPLCreateXMLNode(psOutXMLNode, CXT_Attribute, ""name""),                     CXT_Text, pszTREName);    CSLDestroy(NITFGenericMetadataReadTREInternal(NULL,                                                  &nMDSize,                                                  &nMDAlloc,                                                  psOutXMLNode,                                                  pszTREName,                                                  pachTRE,                                                  nTRESize,                                                  psTreNode,                                                  &nTreOffset,                                                  """",                                                  &bError));    if (bError == FALSE && nTreLength > 0 && nTreOffset != nTreLength)    {        CPLError( CE_Warning, CPLE_AppDefined,                  ""Inconsistent declaration of %s TRE"",                  pszTREName );    }    if (nTreOffset < nTRESize)        CPLDebug(""NITF"", ""%d remaining bytes at end of %s TRE"",                 nTRESize -nTreOffset, pszTREName);    return psOutXMLNode;}",2,"cwe469,cweother"
"jtagmkI_program_disable(PROGRAMMER * pgm){  unsigned char buf[1], resp[2];  if (!PDATA(pgm)->prog_enabled)    return 0;  if (pgm->fd.ifd != -1) {    buf[0] = CMD_LEAVE_PROGMODE;    if (verbose >= 2)      fprintf(stderr, ""%s: jtagmkI_program_disable(): ""              ""Sending leave progmode command: "",              progname);    jtagmkI_send(pgm, buf, 1);    jtagmkI_recv(pgm, resp, 2);    if (resp[0] != RESP_OK) {      if (verbose >= 2)        putc('', stderr);      fprintf(stderr,              ""%s: jtagmkI_program_disable(): ""              ""timeout/error communicating with programmer (resp %c)"",              progname, resp[0]);      return -1;    } else {      if (verbose == 2)        fprintf(stderr, ""OK"");    }  }  PDATA(pgm)->prog_enabled = 0;  return 0;}",2,"cwe119,cwe120"
"load_random_image_1 (Screen *screen, Window window, Drawable drawable,                     void (*callback) (Screen *, Window, Drawable,                                       const char *name, XRectangle *geom,                                       void *closure),                     void *closure,                     char **name_ret,                     XRectangle *geom_ret){  Display *dpy = DisplayOfScreen (screen);  char *grabber = get_string_resource(dpy, ""desktopGrabber"", ""DesktopGrabber"");  char *cmd;  char id[200];  if (!grabber || !*grabber)    {      fprintf (stderr,         ""%s: resources installed incorrectly: ""desktopGrabber"" is unset!"",               progname);      exit (1);    }  sprintf (id, ""0x%lx 0x%lx"",           (unsigned long) window,           (unsigned long) drawable);  cmd = (char *) malloc (strlen(grabber) + strlen(id) + 1);     sprintf (cmd, grabber, id);  free (grabber);  grabber = 0;     checkerboard (screen, drawable);  if (window == drawable)    print_loading_msg (screen, window);  XSync (dpy, True);  hack_subproc_environment (dpy);  if (callback)    {             if (name_ret) abort();      fork_exec_cb (cmd, screen, window, drawable, callback, closure);    }  else    {             fork_exec_wait (cmd);      if (name_ret)        *name_ret = get_name (dpy, window);      if (geom_ret)        get_geometry (dpy, window, geom_ret);    }  free (cmd);  XSync (dpy, True);}",3,"cwe119,cwe120,cweother"
"run_remote_archiver(const char *remote, int argc,ttt       const char **argv){tchar *url, buf[LARGE_PACKET_MAX];tint fd[2], i, len, rv;tstruct child_process *conn;tconst char *exec = ""git-upload-archive"";tint exec_at = 0, exec_value_at = 0;tfor (i = 1; i < argc; i++) {ttconst char *arg = argv[i];ttif (!prefixcmp(arg, ""--exec="")) {tttif (exec_at)ttttdie(""multiple --exec specified"");tttexec = arg + 7;tttexec_at = i;tt} else if (!strcmp(arg, ""--exec"")) {tttif (exec_at)ttttdie(""multiple --exec specified"");tttif (i + 1 >= argc)ttttdie(""option --exec requires a value"");tttexec = argv[i + 1];tttexec_at = i;tttexec_value_at = ++i;tt}t}turl = xstrdup(remote);tconn = git_connect(fd, url, exec, 0);tfor (i = 1; i < argc; i++) {ttif (i == exec_at || i == exec_value_at)tttcontinue;ttpacket_write(fd[1], ""argument %s"", argv[i]);t}tpacket_flush(fd[1]);tlen = packet_read_line(fd[0], buf, sizeof(buf));tif (!len)ttdie(""git archive: expected ACK/NAK, got EOF"");tif (buf[len-1] == '')ttbuf[--len] = 0;tif (strcmp(buf, ""ACK"")) {ttif (len > 5 && !prefixcmp(buf, ""NACK ""))tttdie(""git archive: NACK %s"", buf + 5);ttdie(""git archive: protocol error"");t}tlen = packet_read_line(fd[0], buf, sizeof(buf));tif (len)ttdie(""git archive: expected a flush"");t trv = recv_sideband(""archive"", fd[0], 1, 2);tclose(fd[0]);tclose(fd[1]);trv |= finish_connect(conn);treturn !!rv;}",3,"cwe119,cwe120,cwe469"
"""n_commas(const char *c){    inttn = 0;    for (c = strchr(c, ',') ; c ; c = strchr(c + 1, ','))tn++;    return n;}""",2,"cwe119,cwe120"
"__ecereMethod___ecereNameSpace__ecere__gui__controls__DropBox_SelectRow(struct __ecereNameSpace__ecere__com__Instance * this, struct __ecereNameSpace__ecere__com__Instance * row){struct __ecereNameSpace__ecere__gui__controls__DropBox * __ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox = (struct __ecereNameSpace__ecere__gui__controls__DropBox *)(this ? (((char *)this) + __ecereClass___ecereNameSpace__ecere__gui__controls__DropBox->offset) : 0);if(this){__ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox->currentRow = row;if(((unsigned int)((__ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox->style & 0x4) >> 2)) && ((unsigned int)((__ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox->style & 0x20) >> 5))){char tempString[4096];if(__ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox->currentRow)__ecereProp___ecereNameSpace__ecere__gui__controls__EditBox_Set_contents(__ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox->editBox, ((char * (*)(void *, void *, char *, void *, unsigned int *))(void *)__ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox->dataType->_vTbl[__ecereVMethodID_class_OnGetString])(__ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox->dataType, (void * )__ecereMethod___ecereNameSpace__ecere__gui__controls__DataRow_GetData(__ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox->currentRow, (((void *)0))), tempString, (((void *)0)), (((void *)0))));else__ecereProp___ecereNameSpace__ecere__gui__controls__EditBox_Set_contents(__ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox->editBox, """");}__ecereMethod___ecereNameSpace__ecere__gui__controls__ListBox_SelectRow(__ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox->listBox, __ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox->currentRow ? __ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox->currentRow : (((unsigned int)((__ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox->style & 0x10) >> 4)) ? __ecerePointer___ecereNameSpace__ecere__gui__controls__DropBox->noneRow : (((void *)0))));__ecereMethod___ecereNameSpace__ecere__gui__Window_Update(this, (((void *)0)));}}",2,"cwe119,cwe120"
"ahci_sb600_enable_64bit(struct pci_dev *pdev){tstatic const struct dmi_system_id sysids[] = {tt tt{ttt.ident = ""ASUS M2A-VM"",ttt.matches = {ttttDMI_MATCH(DMI_BOARD_VENDOR,ttttt  ""ASUSTeK Computer INC.""),ttttDMI_MATCH(DMI_BOARD_NAME, ""M2A-VM""),ttt},ttt.driver_data = ""20071026"",t tt},tt tt{ttt.ident = ""MSI K9A2 Platinum"",ttt.matches = {ttttDMI_MATCH(DMI_BOARD_VENDOR,ttttt  ""MICRO-STAR INTER""),ttttDMI_MATCH(DMI_BOARD_NAME, ""MS-7376""),ttt},tt},tt tt{ttt.ident = ""MSI K9AGM2"",ttt.matches = {ttttDMI_MATCH(DMI_BOARD_VENDOR,ttttt  ""MICRO-STAR INTER""),ttttDMI_MATCH(DMI_BOARD_NAME, ""MS-7327""),ttt},tt},tt tt{ttt.ident = ""ASUS M3A"",ttt.matches = {ttttDMI_MATCH(DMI_BOARD_VENDOR,ttttt  ""ASUSTeK Computer INC.""),ttttDMI_MATCH(DMI_BOARD_NAME, ""M3A""),ttt},tt},tt{ }t};tconst struct dmi_system_id *match;tint year, month, date;tchar buf[9];tmatch = dmi_first_match(sysids);tif (pdev->bus->number != 0 || pdev->devfn != PCI_DEVFN(0x12, 0) ||t    !match)ttreturn false;tif (!match->driver_data)ttgoto enable_64bit;tdmi_get_date(DMI_BIOS_DATE, &year, &month, &date);tsnprintf(buf, sizeof(buf), ""%04d%02d%02d"", year, month, date);tif (strcmp(buf, match->driver_data) >= 0)ttgoto enable_64bit;telse {ttdev_warn(&pdev->dev,ttt ""%s: BIOS too old, forcing 32bit DMA, update BIOS"",ttt match->ident);ttreturn false;t}enable_64bit:tdev_warn(&pdev->dev, ""%s: enabling 64bit DMA"", match->ident);treturn true;}",2,"cwe119,cwe120"
"MtxOrb_backlight (Driver *drvthis, int on){tPrivateData *p = drvthis->private_data;tif (p->adjustable_backlight) {ttint promille = (on == BACKLIGHT_ON)tttt     ? p->brightnesstttt     : p->offbrightness;ttif (IS_VKD_DISPLAY) {tttunsigned char out[5] = { 'xFE', 'Y', 0 };ttt tttout[2] = (unsigned char) ((long) promille * 3 / 1000);tttwrite(p->fd, out, 3);tt}ttelse {tttunsigned char out[5] = { 'xFE', 'x99', 0 };ttt tttout[2] = (unsigned char) ((long) promille * 255 / 1000);tttwrite(p->fd, out, 3);tt}ttdebug(RPT_DEBUG, ""MtxOrb: changed brightness to %d"", promille);t}telse {ttif (on == BACKLIGHT_ON) {tttunsigned char out[4] = { 'xFE', 'B', '0', 0};tttwrite(p->fd, out, 3);tt}ttelse {tttunsigned char out[4] = { 'xFE', 'F', 0};tttwrite(p->fd, out, 2);tt}t}}",2,"cwe119,cwe120"
"cdrom_read_capacity(ide_drive_t *drive, unsigned long *capacity,ttt       unsigned long *sectors_per_frame,ttt       struct request_sense *sense){tstruct {tt__be32 lba;tt__be32 blocklen;t} capbuf;tint stat;tunsigned char cmd[BLK_MAX_CDB];tunsigned len = sizeof(capbuf);tu32 blocklen;tide_debug_log(IDE_DBG_FUNC, ""enter"");tmemset(cmd, 0, BLK_MAX_CDB);tcmd[0] = GPCMD_READ_CDVD_CAPACITY;tstat = ide_cd_queue_pc(drive, cmd, 0, &capbuf, &len, sense, 0,ttt       REQ_QUIET);tif (stat)ttreturn stat;t tblocklen = be32_to_cpu(capbuf.blocklen);tblocklen = (blocklen >> SECTOR_BITS) << SECTOR_BITS;tswitch (blocklen) {tcase 512:tcase 1024:tcase 2048:tcase 4096:ttbreak;tdefault:ttprintk_once(KERN_ERR PFX ""%s: weird block size %u; ""tttt""setting default block size to 2048"",ttttdrive->name, blocklen);ttblocklen = 2048;ttbreak;t}t*capacity = 1 + be32_to_cpu(capbuf.lba);t*sectors_per_frame = blocklen >> SECTOR_BITS;tide_debug_log(IDE_DBG_PROBE, ""cap: %lu, sectors_per_frame: %lu"",tttt     *capacity, *sectors_per_frame);treturn 0;}",2,"cwe119,cwe120"
"csync_diff(const char *myname, const char *peername, const char *filename){tFILE *p;tvoid *old_sigpipe_handler;tconst struct csync_group *g = 0;tconst struct csync_group_host *h;tchar buffer[512];tsize_t rc;twhile ( (g=csync_find_next(g, filename)) ) {ttif ( !g->myname || strcmp(g->myname, myname) ) continue;ttfor (h = g->host; h; h = h->next)tttif (!strcmp(h->hostname, peername)) {ttttgoto found_host_check;ttt}t}tcsync_debug(0, ""Host pair + file not found in configuration."");tcsync_error_count++;treturn 0;found_host_check:tif ( connect_to_host(peername) ) {ttcsync_error_count++;ttcsync_debug(0, ""ERROR: Connection to remote host failed."");ttreturn 0;t}tconn_printf(""HELLO %s"", myname);tif ( read_conn_status(0, peername) ) goto finish;tconn_printf(""TYPE %s %s"", g->key, filename);tif ( read_conn_status(0, peername) ) goto finish;t t tsnprintf(buffer,512,""%s:%s"",myname,filename);tsetenv(""my_label"",buffer,1);tsnprintf(buffer,512,""%s:%s"",peername,filename);tsetenv(""peer_label"",buffer,1);tsnprintf(buffer,512,""%s"",filename);tsetenv(""diff_file"",buffer,1);t tsnprintf(buffer, 512, ""diff -Nus --label ""$peer_label"" - --label ""$my_label"" ""$diff_file"""");told_sigpipe_handler = signal(SIGPIPE, SIG_IGN);tp = popen(buffer, ""w"");twhile ( (rc=conn_read(buffer, 512)) > 0 )ttfwrite(buffer, rc, 1, p);tfclose(p);tsignal(SIGPIPE, old_sigpipe_handler);finish:tconn_close();treturn 0;}",3,"cwe119,cwe120,cweother"
"write_pidfile(int pid, char *file, u_int16 port){  int fd, len;  char str[16], *c;    if (!(c = (char*)malloc(strlen(file)+16)))    return -1;  sprintf(c, ""%s.%d"", file, (int)port);      len = sprintf(str, ""%u"", (unsigned)pid);  if ((fd = open(c, O_WRONLY|O_CREAT|O_TRUNC, 0644)) < 0 ) {    fterr_warn(""open(%s)"", c);    free (c);    return -1;   }  if (write(fd, str, len) != len) {    fterr_warn(""write(%s)"", c);    close (fd);    free (c);    return -1;  }  return close (fd);}",3,"cwe119,cwe120,cweother"
"snd_ca0106_proc_i2c_write(struct snd_info_entry *entry, tttt       struct snd_info_buffer *buffer){tstruct snd_ca0106 *emu = entry->private_data;        char line[64];        unsigned int reg, val;        while (!snd_info_get_line(buffer, line, sizeof(line))) {                if (sscanf(line, ""%x %x"", &reg, &val) != 2)                        continue;                if ((reg <= 0x7f) || (val <= 0x1ff)) {                        snd_ca0106_i2c_write(emu, reg, val);tt}        }}",2,"cwe119,cwe120"
"vmsg ( unsigned int row, const char *fmt, va_list args ) {tchar buf[COLS];tsize_t len;tlen = vsnprintf ( buf, sizeof ( buf ), fmt, args );tmvprintw ( row, ( ( COLS - len ) / 2 ), ""%s"", buf );}",3,"cwe119,cwe120,cweother"
"listener_read_cb(evutil_socket_t fd, short what, void *p){tstruct evconnlistener *lev = p;tint err;tevconnlistener_cb cb;tevconnlistener_errorcb errorcb;tvoid *user_data;tLOCK(lev);twhile (1) {ttstruct sockaddr_storage ss;#ifdef WIN32ttint socklen = sizeof(ss);#elsettsocklen_t socklen = sizeof(ss);#endifttevutil_socket_t new_fd = accept(fd, (struct sockaddr*)&ss, &socklen);ttif (new_fd < 0)tttbreak;ttif (socklen == 0) {ttt tttevutil_closesocket(new_fd);tttcontinue;tt}ttif (!(lev->flags & LEV_OPT_LEAVE_SOCKETS_BLOCKING))tttevutil_make_socket_nonblocking(new_fd);ttif (lev->cb == NULL) {tttUNLOCK(lev);tttreturn;tt}tt++lev->refcnt;ttcb = lev->cb;ttuser_data = lev->user_data;ttUNLOCK(lev);ttcb(lev, new_fd, (struct sockaddr*)&ss, (int)socklen,tt    user_data);ttLOCK(lev);ttif (lev->refcnt == 1) {tttint freed = listener_decref_and_unlock(lev);tttEVUTIL_ASSERT(freed);tttreturn;tt}tt--lev->refcnt;t}terr = evutil_socket_geterror(fd);tif (EVUTIL_ERR_ACCEPT_RETRIABLE(err)) {ttUNLOCK(lev);ttreturn;t}tif (lev->errorcb != NULL) {tt++lev->refcnt;tterrorcb = lev->errorcb;ttuser_data = lev->user_data;ttUNLOCK(lev);tterrorcb(lev, user_data);ttLOCK(lev);ttlistener_decref_and_unlock(lev);t} else {ttevent_sock_warn(fd, ""Error from accept() call"");t}}",2,"cwe119,cwe120"
"print_version(int use_log){tchar buf[200];tint i, len = 0;tmemset(buf, 0, sizeof(buf));tlen += sprintf(buf, ""%s version %s, compiled with s2api version: %04X"",tttapp_name, version, LOGDVBAPIVERSION);tif (!use_log)ttputs(buf);telsettLOGL(0, buf);tfor (i = 0; built_info[i]; i++)ttLOGL(0, ""%s"", built_info[i]);}",2,"cwe119,cwe120"
"color_map_start (GsfXMLIn *xin, G_GNUC_UNUSED xmlChar const **attrs){tstruct theme_load_statet*state = (struct theme_load_state *) xin->user_state;tGogAxisColorMap *map;tif (state->theme == NULL)ttreturn;tif (state->theme->name)  ttreturn;tmap = g_object_new (GOG_TYPE_AXIS_COLOR_MAP, ""resource-type"", GO_RESOURCE_CHILD, NULL);tfor (; attrs && *attrs; attrs += 2)ttif (!strcmp ((char const *) *attrs, ""type"")) {tttif (strcmp ((char const *) attrs[1], ""discrete"")) {ttttif (state->theme->cm != NULL) {tttttg_warning (""[GogTheme]: extra GogAxisColorMap found."");tttttg_object_unref (map);tttttreturn;tttt}ttttstate->theme->cm =  map;ttttif (strcmp ((char const *) attrs[1], ""both""))tttttreturn;ttttg_object_ref (map);ttt}tttif (state->theme->dcm != NULL) {ttttg_warning (""[GogTheme]: extra GogAxisColorMap found."");ttttg_object_unref (map);ttttreturn;ttt}tttstate->theme->dcm = map;tt}}",2,"cwe119,cwe120"
"Cmdline (struct arg_t *my_args, int argc, char *argv[]){  extern char *optarg;  extern int optind;  int c;  int errflg = 0;  my_args->directory = false;  my_args->force = false;  my_args->interactive = false;  my_args->recursive = false;  my_args->verbose = false;  my_args->help = false;  my_args->version = false;  optind = 0;  while ((c = getopt_long (argc, argv, ""dfirRvh"", long_options, &optind)) != - 1)    {      switch (c)        {        case 'd':          my_args->directory = true;          break;        case 'f':          my_args->force = true;          break;        case 'i':          my_args->interactive = true;          break;        case 'r':        case 'R':          my_args->recursive = true;          break;        case 'v':          my_args->verbose = true;          break;        case 'h':          my_args->help = true;          usage (EXIT_SUCCESS, argv[0]);          break;        case 256:          my_args->version = true;          break;        default:          usage (EXIT_FAILURE, argv[0]);        }    }    if (errflg)    usage (EXIT_FAILURE, argv[0]);  if (optind >= argc)    my_args->optind = 0;  else    my_args->optind = optind;}",2,"cwe120,cweother"
Unpickler_dealloc(Unpicklerobject *self){    PyObject_GC_UnTrack((PyObject *)self);    Py_XDECREF(self->readline);    Py_XDECREF(self->read);    Py_XDECREF(self->file);    Py_XDECREF(self->memo);    Py_XDECREF(self->stack);    Py_XDECREF(self->pers_func);    Py_XDECREF(self->arg);    Py_XDECREF(self->last_string);    Py_XDECREF(self->find_class);    if (self->marks) {        free(self->marks);    }    if (self->buf_size) {        free(self->buf);    }    Py_TYPE(self)->tp_free((PyObject *)self);},2,"cwe120,cweother"
"drv_GU311_start(const char *section){    char cmd[3] = { 0x01, 'O' };         if (drv_generic_parport_open(section, Name) < 0)treturn -1;    if ((SIGNAL_CS = drv_generic_parport_wire_ctrl(""CS"", ""AUTOFD"")) == 0xff)treturn -1;    if ((SIGNAL_WR = drv_generic_parport_wire_ctrl(""WR"", ""STROBE"")) == 0xff)treturn -1;    if ((SIGNAL_RESET = drv_generic_parport_wire_ctrl(""RESET"", ""INIT"")) == 0xff)treturn -1;    if ((SIGNAL_BLANK = drv_generic_parport_wire_ctrl(""BLANK"", ""SLCTIN"")) == 0xff)treturn -1;                     drv_generic_parport_direction(0);t     drv_generic_parport_control(SIGNAL_CS | SIGNAL_WR | SIGNAL_RESET | SIGNAL_BLANK, 0xff);         drv_generic_parport_control(SIGNAL_CS, 0);t     drv_GU311_reset();              cmd[2] = '0';    drv_GU311_send_string(cmd, sizeof(cmd));t     cmd[2] = 'Q';    drv_GU311_send_string(cmd, sizeof(cmd));t     cmd[2] = 'a';    drv_GU311_send_string(cmd, sizeof(cmd));t     cmd[2] = 'T';    drv_GU311_send_string(cmd, sizeof(cmd));t     drv_Noritake_clear();    return 0;}",2,"cwe119,cwe120"
"get_location_cb                         (GObject      *object,                                         GAsyncResult *res,                                         gpointer      user_data){  FspSession *session = FSP_SESSION (object);  GError *error = NULL;  FspDataLocation *location = NULL;  location = fsp_session_get_location_finish (session, res, &error);  if (error != NULL)    {      g_print (""Error getting location: %s"", error->message);      g_error_free (error);    }  else    {      g_print (""[get_location_cb]::Success! Location got:"");      g_print (""[get_location_cb]::tLatitude: %g"", location->latitude);      g_print (""[get_location_cb]::tLongitude: %g"", location->longitude);      g_print (""[get_location_cb]::tAccuracy: %d"", location->accuracy);             g_print (""Press ENTER to continue..."");      getchar ();             g_print (""Getting info for photo %s..."", uploaded_photo_id);      fsp_session_get_info (session, uploaded_photo_id, NULL,                            photo_get_info_cb, NULL);      fsp_data_free (FSP_DATA (location));    }}",2,"cwe120,cweother"
"ethers_keys (int number, char *key[]){  int result = 0;  int i;  if (number == 0)    {      fprintf (stderr, _(""Enumeration not supported on %s""), ""ethers"");      return 3;    }  for (i = 0; i < number; ++i)    {      struct ether_addr *ethp, eth;      char buffer [1024], *p;      ethp = ether_aton (key[i]);      if (ethp != NULL)t{t  if (ether_ntohost (buffer, ethp))t    {t      result = 2;t      continue;t    }t  p = buffer;t}      elset{t  if (ether_hostton (key[i], &eth))t    {t      result = 2;t      continue;t    }t  p = key[i];t  ethp = &eth;t}      printf (""%s %s"", ether_ntoa (ethp), p);    }  return result;}",2,"cwe119,cwe120"
"__debug_raw(int level, const char *msg) {tconst char *c = "".-*#"";ttime_t now = time(NULL);tFILE *fp;tchar buf[64];tstrftime(buf, sizeof(buf),""%d %b %I:%M:%S"", localtime(&now));tfprintf(stderr, ""[%d] %s %c %s"", (int)getpid(), buf, c[level], msg);tif (level == LEVEL_ERROR || level == LEVEL_DEBUG) {ttfp = fopen(EVENT_NAME, ""a"");ttif (fp) { tttfprintf(fp,""[%d] %s %c %s"", (int)getpid(), buf, c[level], msg);tttfflush(fp);tttfclose(fp);tt}t}}",3,"cwe119,cwe120,cweother"
"check_pnt(const char *file, const int line, const void *pnt,ttt  const char *label){  static unsigned longtaddr_c = 0;  chartttwhere_buf[64];    if (_dmalloc_address == NULL || pnt != _dmalloc_address) {    return;  }    addr_c++;  dmalloc_message(""address '%#lx' found in '%s' at pass %ld from '%s'"",tt  (unsigned long)pnt, label, addr_c,tt  _dmalloc_chunk_desc_pnt(where_buf, sizeof(where_buf), file,ttttt  line));       if (_dmalloc_address_seen_n > 0 && addr_c >= _dmalloc_address_seen_n) {    dmalloc_errno = ERROR_IS_FOUND;    dmalloc_error(""check_pnt"");  }}",2,"cwe119,cwe120"
"setArgusWfile(char *file, char *filter){   FILE *fd = NULL;   struct ArgusWfileStruct *wfile = NULL;   char realpathname[PATH_MAX], *ptr = NULL;   int euid = geteuid();   if (ArgusWfileList == NULL)      ArgusWfileList = ArgusNewList();   if (file) {      if (strcmp (file, ""-"")) {         setuid(getuid());         if ((fd = fopen (file, ""a+"")) != NULL) {            bzero (realpathname, PATH_MAX);            if ((ptr = realpath (file, realpathname)) == NULL)               ArgusLog (LOG_ERR, ""setArgusWfile, realpath %s %s"", file, strerror(errno));            else               ptr = strdup(ptr);            fclose (fd);         } else {#ifdef ARGUSDEBUG            ArgusDebug (1, ""setArgusWfile, open %s %s"", file, strerror(errno));#endif          }         setuid(euid);      } else         ptr = strdup(file);      if ((wfile = (struct ArgusWfileStruct *) ArgusCalloc (1, sizeof (*wfile))) != NULL) {         wfile->filename = ptr;         if (filter)            wfile->filter = strdup(filter);         ArgusPushFrontList(ArgusWfileList, wfile);      } else         ArgusLog (LOG_ERR, ""setArgusWfile, ArgusCalloc %s"", strerror(errno));   } else      ArgusLog (LOG_ERR, ""setArgusWfile, file is null"");}",4,"cwe119,cwe120,cwe476,cweother"
"tty_buffer_unlock_exclusive(struct tty_port *port){tstruct tty_bufhead *buf = &port->buf;tint restart;trestart = buf->head->commit != buf->head->read;tatomic_dec(&buf->priority);tmutex_unlock(&buf->lock);tif (restart)ttqueue_work(system_unbound_wq, &buf->work);}",2,"cwe120,cweother"
"direct_debug_exit( DirectDebugDomain *domain,                   const char *func,                   const char *file,                   int         line,                   const char *format, ... ){     bool enabled;     pthread_mutex_lock( &domains_lock );     enabled = check_domain( domain );     pthread_mutex_unlock( &domains_lock );     if (enabled) {          int         len;          char        dom[48];          char        fmt[128];          char        buf[512];          long long   millis = direct_clock_get_millis();          const char *name   = direct_thread_self_name();          va_list     ap;          va_start( ap, format );          vsnprintf( buf, sizeof(buf), format, ap );          va_end( ap );          len = snprintf( dom, sizeof(dom), ""%s:"", domain->name );          if (len < 18)               len = 18;          else               len = 28;          len += direct_trace_debug_indent() * 4;          snprintf( fmt, sizeof(fmt), ""(<) [%%-15s %%3lld.%%03lld] (%%5d) %%-%ds Returning from %%s%%s [%%s:%%d]"", len );          direct_log_printf( NULL, fmt, name ? name : ""  NO NAME  "",                             millis / 1000LL, millis % 1000LL, direct_gettid(), dom,ttt     func, buf, file, line );     }}",3,"cwe119,cwe120,cweother"
"ebook_output_mpeg(BOOK_INFO *binfo, gchar *srcname, gchar *destname){tchar binary_data[EB_SIZE_PAGE];tguint argv[4];tEB_Error_Code error_code;tssize_t read_length;tFILE *fp;tif((error_code = ebook_set_subbook(binfo)) != EB_SUCCESS)ttreturn(error_code);tif((error_code = eb_decompose_movie_file_name(argv, srcname)) != EB_SUCCESS)ttreturn(error_code);t terror_code = eb_set_binary_mpeg(binfo->book, argv);tif (error_code != EB_SUCCESS){ttLOG(LOG_CRITICAL, ""Failed to set binary mpeg : %s"",ttttebook_error_message(error_code));ttreturn(error_code);t}tfp = fopen(destname, ""wb"");tif(fp == NULL){ttLOG(LOG_CRITICAL, ""Failed to open file : %s"", destname);ttreturn(EB_ERR_BAD_FILE_NAME);t}tfor (;;) {tterror_code = eb_read_binary(binfo->book, ttttt    EB_SIZE_PAGE,ttttt    binary_data, &read_length);ttif (error_code != EB_SUCCESS || read_length == 0){tttfclose(fp);tttreturn(error_code);tt}ttfwrite(binary_data, read_length, 1, fp);t}t treturn(EB_SUCCESS);}",3,"cwe119,cwe120,cweother"
"crunch_list(list)tchar *list;{tint count, i;tchar *p, *q;tchar **result = NULL;tp = list;tt twhile (p[strlen(p)-1] == LIST_DELIMITER) {ttcount--;ttp[strlen(p)-1] = '0';t}t twhile (p[0] == LIST_DELIMITER) {ttcount--;ttp++; t}tt tfor (count=i=0; p[i]; i++)ttif (p[i] == LIST_DELIMITER) count++;ttif ((result = (char **)malloc(sizeof(char *) * count+2)) == NULL) {ttprintf (""Sorry, can't get enough memory, exiting."");ttexit(0);t}tt tcount = 0;twhile ((q=strchr(p, LIST_DELIMITER))) {ttresult[count] = (char *) malloc((q - p + 1) * sizeof(char));ttif (result[count] == NULL) {tttprintf (""Sorry, can't get enough memory, exiting."");tttexit(0);tt}ttstrncpy(result[count], p, q - p);ttresult[count][q - p] = '0';ttp = q; p++;ttcount++;t}tif ((result[count] = t     (char *)malloc(sizeof(char) * strlen(p) + 1)) == NULL) {ttprintf (""Sorry, can't get enough memory, exiting."");ttexit(0);t}tstrcpy(result[count],p);tresult[++count] = NULL;#if 0tcount=0;twhile (result[count])ttdprintf (""#%d: %s"", count, StripDomains[count++]);#endiftreturn result;}",2,"cwe120,cweother"
"handle_revision_arg(const char *arg, struct rev_info *revs,tttint flags,tttint cant_be_filename){tunsigned mode;tchar *dotdot;tstruct object *object;tunsigned char sha1[20];tint local_flags;tdotdot = strstr(arg, "".."");tif (dotdot) {ttunsigned char from_sha1[20];ttconst char *next = dotdot + 2;ttconst char *this = arg;ttint symmetric = *next == '.';ttunsigned int flags_exclude = flags ^ UNINTERESTING;tt*dotdot = 0;ttnext += symmetric;ttif (!*next)tttnext = ""HEAD"";ttif (dotdot == arg)tttthis = ""HEAD"";ttif (!get_sha1(this, from_sha1) &&tt    !get_sha1(next, sha1)) {tttstruct commit *a, *b;tttstruct commit_list *exclude;ttta = lookup_commit_reference(from_sha1);tttb = lookup_commit_reference(sha1);tttif (!a || !b) {ttttdie(symmetric ?tttt    ""Invalid symmetric difference expression %s...%s"" :tttt    ""Invalid revision range %s..%s"",tttt    arg, next);ttt}tttif (!cant_be_filename) {tttt*dotdot = '.';ttttverify_non_filename(revs->prefix, arg);ttt}tttif (symmetric) {ttttexclude = get_merge_bases(a, b, 1);ttttadd_pending_commit_list(revs, exclude,tttttttflags_exclude);ttttfree_commit_list(exclude);tttta->object.flags |= flags | SYMMETRIC_LEFT;ttt} elsetttta->object.flags |= flags_exclude;tttb->object.flags |= flags;tttadd_pending_object(revs, &a->object, this);tttadd_pending_object(revs, &b->object, next);tttreturn 0;tt}tt*dotdot = '.';t}tdotdot = strstr(arg, ""^@"");tif (dotdot && !dotdot[2]) {tt*dotdot = 0;ttif (add_parents_only(revs, arg, flags))tttreturn 0;tt*dotdot = '^';t}tdotdot = strstr(arg, ""^!"");tif (dotdot && !dotdot[2]) {tt*dotdot = 0;ttif (!add_parents_only(revs, arg, flags ^ UNINTERESTING))ttt*dotdot = '^';t}tlocal_flags = 0;tif (*arg == '^') {ttlocal_flags = UNINTERESTING;ttarg++;t}tif (get_sha1_with_mode(arg, sha1, &mode))ttreturn -1;tif (!cant_be_filename)ttverify_non_filename(revs->prefix, arg);tobject = get_reference(revs, arg, sha1, flags ^ local_flags);tadd_pending_object_with_mode(revs, object, arg, mode);treturn 0;}",2,"cwe119,cwe120"
"vbi_handler(struct vbi *vbi, int fd){    int n, i;    u32 seq;    n = read(vbi->fd, rawbuf, vbi->bufsize);    if (dl_empty(vbi->clients))treturn;    if (n != vbi->bufsize)treturn;    seq = *(u32 *)&rawbuf[n - 4];    if (vbi->seq+1 != seq)    {tout_of_sync(vbi);tif (seq < 3 && vbi->seq >= 3)t    vbi_reset(vbi);    }    vbi->seq = seq;    if (seq > 1)t tfor (i = 0; i+vbi->bpl <= n; i += vbi->bpl)t    vbi_line(vbi, rawbuf + i);}",2,"cwe120,cweother"
"process_tconvert_info (csvjoin *jspec, tttt  const char *tconvcols,tttt  const char *tconvfmt,tttt  const char *keyfmt){    int *list = NULL;    char **names = NULL;    char **fmts = NULL;    const char *colname;    const char *tkeyfmt = NULL;    char *tkeyname = NULL;    int nnames = 0;    int i, j, err = 0;    names = gretl_string_split(tconvcols, &nnames, "" ,"");    if (names == NULL) {terr = E_ALLOC;    }         for (i=0; i<nnames && !err; i++) {tfor (j=0; j<JOIN_MAXCOL; j++) {t    colname = jspec->colnames[j];t    if (colname != NULL && !strcmp(names[i], colname)) {ttgretl_list_append_term(&list, j);ttif (list == NULL) {tt    err = E_ALLOC;tt} else if (*keyfmt != '0' && j == JOIN_KEY) {tt     tt    tkeyfmt = keyfmt;tt    tkeyname = names[i];tt}ttbreak;t    }t}    }         if (!err && list != NULL && (tconvfmt != NULL || tkeyfmt != NULL)) {tchar const *tmp[2] = {tconvfmt, tkeyfmt};terr = make_time_formats_array(tmp, &fmts);    }#if CDEBUG    printlist(list, ""timeconv list"");#endif    if (!err && list != NULL) {ttimeconv_map_set(nnames, names, tkeyname, fmts);    }    if (err) {t tstrings_array_free(names, nnames);tfree(list);    } else {tjspec->timecols = list;    }    return err;}",2,"cwe119,cwe120"
"g3d_texture_prepare(G3DImage *texture){tguint32 nw = 1, nh = 1, y;tguint8 *np;twhile(nw < texture->width) nw *= 2;twhile(nh < texture->height) nh *= 2;tif((nw != texture->width) || (nh != texture->height))t{tt ttnp = g_malloc(nw * nh * 4);ttmemset(np, 0xFF, nw * nh * 4);tt ttfor(y = 0; y < nh; y ++)tttmemcpy(np + ((nh - y - 1) * nw * 4),tttttexture->pixeldata +ttttt(((texture->height - y - 1) % texture->height) *ttttttexture->width * 4),tttttexture->width * 4);tt tttexture->tex_scale_u = ((G3DFloat)texture->width / (G3DFloat)nw);tttexture->tex_scale_v = ((G3DFloat)texture->height / (G3DFloat)nh);#if DEBUG > 0ttg_debug(""texture scaling factor for '%s' set to %.2f,%.2f"",ttttexture->name, texture->tex_scale_u, texture->tex_scale_v);#endiftt ttg_free(texture->pixeldata);tttexture->pixeldata = np;tttexture->width = nw;tttexture->height = nh;ttreturn TRUE;t}treturn FALSE;}",2,"cwe120,cweother"
"no_response_to_ping(void *ctx){tREQUEST *request = ctx;thome_server *home;tchar buffer[128];trad_assert(request->home_server != NULL);thome = request->home_server;thome->num_received_pings = 0;tradlog(L_ERR, ""No response to status check %d for home server %s port %d"",t       request->number,t       inet_ntop(request->proxy->dst_ipaddr.af,ttt &request->proxy->dst_ipaddr.ipaddr,ttt buffer, sizeof(buffer)),t       request->proxy->dst_port);tcheck_for_zombie_home_server(request);twait_for_proxy_id_to_expire(request);}",2,"cwe119,cwe120"
"genSC_BOTTOM( char *insname, int sym ){loins_list *ptins;char *s = namealloc(insname);   if (WORK_PHFIG == NULL) {      (void)fflush(stdout);      (void)fputs(""*** genlib error ***"", stderr);      (void)fputs(""SC_BOTTOM impossible : missing DEF_PHFIG"", stderr);      EXIT(1);   }   if (WORK_LOFIG == NULL) {      (void)fflush(stdout);      (void)fputs(""*** genlib error ***"", stderr);      (void)fputs(""SC_BOTTOM impossible : missing DEF_LOFIG"", stderr);      EXIT(1);   }   for (ptins = WORK_LOFIG->LOINS; ptins != NULL; ptins = ptins->NEXT)      if (ptins->INSNAME == s)         break;   if (ptins == NULL) {      (void)fflush(stdout);      (void)fputs(""*** genlib error ***"", stderr);      (void)fputs(""SC_BOTTOM impossible : no logical instance "", stderr);      (void)fprintf(stderr, ""%s in figure %s"", insname, WORK_LOFIG->NAME);      EXIT(1);   }   genPLACE_BOTTOM(ptins->FIGNAME, s, sym);}",3,"cwe119,cwe120,cwe476"
"mpi_task_write_gen_pg_comm(fsbe_context *cx, int total_pe){    char name[64];    int i;    int comm_num;    Pe_in_pg *p;    Pe_in_pg *head;    head = mpi_task_get_pg_comm_list();    for( p = head; p != NULL; p = p->next){        comm_num = total_pe / p->pe_num;        ompfbe_iprintf(cx, ""DO I=1,%d,1"", comm_num);        for( i = 1; i <= p->pe_num; i++){            ompfbe_iprintf(cx, ""PG_RANKS(%d) = %d + (I - 1) * %d"", i, i, p->pe_num);        }        ompfbe_iprintf(cx, ""CALL MPI_GROUP_INCL(GROUP_WORLD, %d, PG_RANKS, PG_GROUP, IERR)"", p->pe_num);        ompfbe_iprintf(cx, ""CALL MPI_COMM_CREATE(MPI_COMM_WORLD, PG_GROUP, PG_COMM, IERR)"");        ompfbe_iprintf(cx, ""IF((RANK .GT. ((I - 1) * %d)) .AND. (RANK .LE. (I * %d))) THEN"", p->pe_num, p->pe_num);        ompfbe_mpi_task_make_pg_comm_var_name(name, p->pe_num);        ompfbe_iprintf(cx, ""%s = PG_COMM"", name);        ompfbe_iprintf(cx, ""END IF"");        ompfbe_iprintf(cx, ""END DO"");    }}",2,"cwe119,cwe120"
"float2rgbe(unsigned char rgbe[4], float red, float green, float blue){  float v;  int e;  v = red;  if (green > v) v = green;  if (blue > v) v = blue;  if (v < 1e-32) {    rgbe[0] = rgbe[1] = rgbe[2] = rgbe[3] = 0;  }  else {    v = (float)(frexp(v,&e) * 256.0/v);    rgbe[0] = (unsigned char) (red * v);    rgbe[1] = (unsigned char) (green * v);    rgbe[2] = (unsigned char) (blue * v);    rgbe[3] = (unsigned char) (e + 128);  }}",2,"cwe119,cwe120"
"where_is (Keymap map, InfoCommand *cmd){  char *rep;  if (!where_is_rep_size)    where_is_rep = xmalloc (where_is_rep_size = 100);  where_is_rep_index = 0;  rep = where_is_internal (map, cmd);     if (!rep)    {      char *name;      name = function_name (cmd);      if (!name)        return NULL;        rep = where_is_internal (map, InfoCmd(info_execute_command));      if (!rep)        return """";        sprintf (where_is_rep, ""%s %s"", rep, name);      rep = where_is_rep;    }  return rep;}",2,"cwe120,cwe469"
"the(const char *str){    char *buf = nextobuf();    bool insert_the = false;    if (!strncmpi(str, ""the "", 4)) {        buf[0] = lowc(*str);        strcpy(&buf[1], str+1);        return buf;    } else if (*str < 'A' || *str > 'Z') {                 insert_the = true;    } else {                 char *tmp, *named, *called;        int l;                 if(((tmp = rindex(str, ' ')) || (tmp = rindex(str, '-'))) &&           (tmp[1] < 'A' || tmp[1] > 'Z'))                insert_the = true;        else if (tmp && index(str, ' ') < tmp) {t                          tmp = strstri(str, "" of "");            named = strstri(str, "" named "");            called = strstri(str, "" called "");            if (called && (!named || called < named)) named = called;            if (tmp && (!named || tmp < named))t                     insert_the = true;                         else if (!named && (l = strlen(str)) >= 31 &&                     !strcmp(&str[l - 31], ""Platinum Yendorian Express Card""))                    insert_the = true;        }    }    if (insert_the)            strcpy(buf, ""the "");    else            buf[0] = '0';    strcat(buf, str);    return buf;}",2,"cwe120,cwe469"
"create_digest(BIO *input, char *digest, const EVP_MD *md,ttt unsigned char **md_value)t{tint md_value_len;tmd_value_len = EVP_MD_size(md);tif (md_value_len < 0)t    goto err;tif (input)tt{tt ttEVP_MD_CTX md_ctx;ttunsigned char buffer[4096];ttint length;tt*md_value = OPENSSL_malloc(md_value_len);ttif (*md_value == 0) goto err;ttEVP_DigestInit(&md_ctx, md);ttwhile ((length = BIO_read(input, buffer, sizeof(buffer))) > 0)ttt{tttEVP_DigestUpdate(&md_ctx, buffer, length);ttt}ttEVP_DigestFinal(&md_ctx, *md_value, NULL);tt}telsett{tt ttlong digest_len;tt*md_value = string_to_hex(digest, &digest_len);ttif (!*md_value || md_value_len != digest_len)ttt{tttOPENSSL_free(*md_value);ttt*md_value = NULL;tttBIO_printf(bio_err, ""bad digest, %d bytes ""tttt   ""must be specified"", md_value_len);tttgoto err;ttt}tt}treturn md_value_len; err:treturn 0;t}",2,"cwe119,cwe120"
"glusterd_store_remove_bricks (glusterd_volinfo_t *volinfo){        int32_t                 ret = 0;        glusterd_brickinfo_t    *tmp = NULL;        glusterd_conf_t         *priv = NULL;        char                    brickdir [PATH_MAX] = {0,};        DIR                     *dir = NULL;        struct dirent           *entry = NULL;        char                    path[PATH_MAX] = {0,};        GF_ASSERT (volinfo);        list_for_each_entry (tmp, &volinfo->bricks, brick_list) {                ret = glusterd_store_delete_brick (volinfo, tmp);                if (ret)                        goto out;        }        priv = THIS->private;        GF_ASSERT (priv);        GLUSTERD_GET_BRICK_DIR (brickdir, volinfo, priv);        dir = opendir (brickdir);        glusterd_for_each_entry (entry, dir);        while (entry) {                snprintf (path, sizeof (path), ""%s/%s"",                          brickdir, entry->d_name);                ret = unlink (path);                if (ret && errno != ENOENT) {                        gf_log ("""", GF_LOG_ERROR, ""Unable to unlink %s, ""                                ""reason: %s"", path, strerror(errno));                }                glusterd_for_each_entry (entry, dir);        }        closedir (dir);        ret = rmdir (brickdir);out:        gf_log ("""", GF_LOG_DEBUG, ""Returning with %d"", ret);        return ret;}",3,"cwe119,cwe120,cwe469"
"ghw_get_value (char *buf, int len, union ghw_val *val, union ghw_type *type){  switch (ghw_get_base_type (type)->kind)    {    case ghdl_rtik_type_b2:      if (val->b2 <= 1)t{t  strncpy (buf, type->en.lits[val->b2], len - 1);t  buf[len - 1] = 0;t}      elset{t  snprintf (buf, len, ""?%d"", val->b2);t}      break;    case ghdl_rtik_type_e8:      if (val->e8 <= type->en.nbr)t{t   t  if(type->en.lits)tt{t  tstrncpy (buf, type->en.lits[val->e8], len - 1);t  tbuf[len - 1] = 0;tt}ttelsett{ttsnprintf (buf, len, ""?%d"", val->e8);tt}t}      elset{t  snprintf (buf, len, ""?%d"", val->e8);t}      break;    case ghdl_rtik_type_i32:      snprintf (buf, len, GHWLD, val->i32);      break;    case ghdl_rtik_type_p64:      snprintf (buf, len, GHWLLD, val->i64);      break;    case ghdl_rtik_type_f64:      snprintf (buf, len, ""%g"", val->f64);      break;    default:      snprintf (buf, len, ""?bad type %d?"", type->kind);    }}",2,"cwe120,cweother"
"pl_trace_out (xlator_t *this, call_frame_t *frame, fd_t *fd, loc_t *loc,              int cmd, struct gf_flock *flock, int op_ret, int op_errno, const char *domain){        posix_locks_private_t  *priv = NULL;        char                    pl_locker[256];        char                    pl_lockee[256];        char                    pl_lock[256];        char                    verdict[32];        priv = this->private;        if (!priv->trace)                return;        pl_print_locker (pl_locker, 256, this, frame);        pl_print_lockee (pl_lockee, 256, fd, loc);        if (domain)                pl_print_inodelk (pl_lock, 256, cmd, flock, domain);        else                pl_print_lock (pl_lock, 256, cmd, flock, frame->root->lk_owner);        pl_print_verdict (verdict, 32, op_ret, op_errno);        gf_log (this->name, GF_LOG_INFO,                ""[%s] Locker = {%s} Lockee = {%s} Lock = {%s}"",                verdict, pl_locker, pl_lockee, pl_lock);}",2,"cwe119,cwe120"
"PEM_dek_info(char *buf, const char *type, int len, char *str)t{tstatic const unsigned char map[17]=""0123456789ABCDEF"";tlong i;tint j;tBUF_strlcat(buf,""DEK-Info: "",PEM_BUFSIZE);tBUF_strlcat(buf,type,PEM_BUFSIZE);tBUF_strlcat(buf,"","",PEM_BUFSIZE);tj=strlen(buf);tif (j + (len * 2) + 1 > PEM_BUFSIZE)        treturn;tfor (i=0; i<len; i++)tt{ttbuf[j+i*2]  =map[(str[i]>>4)&0x0f];ttbuf[j+i*2+1]=map[(str[i]   )&0x0f];tt}tbuf[j+i*2]='';tbuf[j+i*2+1]='0';t}",2,"cwe119,cwe120"
"dump_settings (void){tinttti;tcharttbuf[100];t*buf = 0;tt ti = 0;ttt #ifndef NDMOS_OPTION_NO_CONTROL_AGENTtswitch (the_mode) {tcase 'x':ttprintf (""mode = x (extract)"");ttbreak;tcase 'c':ttprintf (""mode = c (create)"");ttbreak;tcase 't':ttprintf (""mode = t (table-of-contents)"");ttbreak;tcase 'q':ttprintf (""mode = q (query-agents)"");ttbreak;tdefault:t        printf (""mode = %c (unknown)"", the_mode);ttbreak;t}#endif  tif (v_verbose)ttprintf (""verbose %d"", v_verbose);telsettprintf (""not verbose"");#ifndef NDMOS_OPTION_NO_CONTROL_AGENTtprintf (""blocksize = %d (%dkb, %db)"",tttb_bsize, b_bsize/2, b_bsize*512);#endif  tif (d_debug)ttprintf (""debug %d"", d_debug);telsettprintf (""no debug"");#ifndef NDMOS_OPTION_NO_CONTROL_AGENTtprintf (""Data agent %s"", D_data_agent.host);tif (AGENT_GIVEN(T_tape_agent))ttprintf (""Tape agent %s"", T_tape_agent.host);telsettprintf (""Tape agent same as data agent"");tprintf (""tape device %s"", f_tape_device);tprintf (""tape format %s"", B_bu_type);tif (C_chdir)ttprintf (""Chdir %s"", C_chdir);telsettprintf (""Chdir / (default)"");#endif  tif (L_log_file)ttprintf (""Log to file %s"", L_log_file);telsettprintf (""Log to stderr (default)"");#ifndef NDMOS_OPTION_NO_CONTROL_AGENTtif (I_index_file) {ttif (strcmp (I_index_file, ""-"") == 0) {tttprintf (""Index to log, enable FILEHIST"");tt} else {tttprintf (""Index to file %s, enable FILEHIST"",tttttttI_index_file);tt}t} else {ttprintf (""Index off (default), no FILEHIST"");t}tprintf (""%d media entries"", n_m_media);tfor (i = 0; i < n_m_media; i++) {ttndmmedia_to_str (&m_media[i], buf);ttprintf (""  %2d: %s"", i, buf);t}tprintf (""%d excludes"", n_e_exclude_pattern);tfor (i = 0; i < n_e_exclude_pattern; i++) {ttprintf (""  %2d: %s"", i, e_exclude_pattern[i]);t}tprintf (""%d environment values"", n_E_environment);tfor (i = 0; i < n_E_environment; i++) {ttprintf (""  %2d: %s=%s"", i,tttE_environment[i].name, E_environment[i].value);t}tprintf (""%d files"", n_file_arg);tfor (i = 0; i < n_file_arg; i++) {ttprintf (""  %2d: @%-8lld %s"", i,tttnlist[i].fh_info.valid ? nlist[i].fh_info.value : NDMP9_INVALID_U_QUAD,tttfile_arg[i]);t}#endif  treturn;}",3,"cwe119,cwe120,cwe469"
"eb_find_file_name(const char *path_name, const char *target_file_name,    char *found_file_name){    char ebz_target_file_name[EB_MAX_FILE_NAME_LENGTH + 1];    char org_target_file_name[EB_MAX_FILE_NAME_LENGTH + 1];    char candidate_file_name[EB_MAX_FILE_NAME_LENGTH + 1];    DIR *dir;    struct dirent *entry;    size_t d_namlen;    int found = FOUND_NONE;#ifdef ENABLE_EBNET    if (is_ebnet_url(path_name)) {treturn ebnet_find_file_name(path_name, target_file_name,t    found_file_name);    }#endif    strcpy(ebz_target_file_name, target_file_name);    strcat(ebz_target_file_name, "".ebz"");    strcpy(org_target_file_name, target_file_name);    strcat(org_target_file_name, "".org"");    candidate_file_name[0] = '0';         dir = opendir(path_name);    if (dir == NULL)tgoto failed;    for (;;) {t tentry = readdir(dir);tif (entry == NULL)t    break;t td_namlen = strlen(entry->d_name);tif (2 < d_namlent    && *(entry->d_name + d_namlen - 2) == ';'t    && ASCII_ISDIGIT(*(entry->d_name + d_namlen - 1))) {t    d_namlen -= 2;t}tif (1 < d_namlen && *(entry->d_name + d_namlen - 1) == '.')t    d_namlen--;tif (strcasecmp(entry->d_name, ebz_target_file_name) == 0t    && *(ebz_target_file_name + d_namlen) == '0't    && found < FOUND_EBZ) {t    strcpy(candidate_file_name, entry->d_name);t    found = FOUND_EBZ;t}tif (strncasecmp(entry->d_name, target_file_name, d_namlen) == 0t    && *(target_file_name + d_namlen) == '0't    && found < FOUND_BASENAME) {t    strcpy(candidate_file_name, entry->d_name);t    found = FOUND_BASENAME;t}tif (strcasecmp(entry->d_name, org_target_file_name) == 0t    && *(org_target_file_name + d_namlen) == '0't    && found < FOUND_ORG) {t    strcpy(candidate_file_name, entry->d_name);t    found = FOUND_ORG;t    break;t}    }    if (found == FOUND_NONE)tgoto failed;    closedir(dir);    strcpy(found_file_name, candidate_file_name);    return EB_SUCCESS;       failed:    if (dir != NULL)tclosedir(dir);    return EB_ERR_BAD_FILE_NAME;}",3,"cwe119,cwe120,cwe469"
"sms_compose2(sms_t *h, int more){tstruct ast_tm tm;tstruct timeval now = h->scts;tchar stm[9];th->omsg[0] = 0x00;                       th->omsg[1] = 0;tputdummydata_proto2(h);tif (h->smsc) {                           tth->omsg[0] = 0x11;                   tt ttast_localtime(&now, &tm, NULL);ttsprintf(stm, ""%02d%02d%02d%02d"", tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min);   ttadddata_proto2(h, 0x14, stm, 8);     ttif (*h->oa == 0) {tttstrcpy(h->oa, ""00000000"");tt}ttadddata_proto2(h, 0x15, h->oa, strlen(h->oa));  ttadddata_proto2(h, 0x17, ""1"", 1);    t} else {                                 tth->omsg[0] = 0x10;                   tt ttadddata_proto2(h, 0x17, ""1"", 1);    ttif (*h->da == 0) {tttstrcpy(h->da, ""00000000"");tt}ttadddata_proto2(h, 0x18, h->da, strlen(h->da));  ttadddata_proto2(h, 0x1B, ""1"", 1);t       ttadddata_proto2(h, 0x1C, ""000"", 3);t   t}}",2,"cwe119,cwe120"
"""need_read_write_negative(struct conn_info *ci){tstruct tcp_spec ts;tchar buf[1400];tint len;t/*t * well - after sending something we get usualy ack stormt */tif (need_read > 0 && need_write > 0)ttreturn;tif (need_read_want_n > need_read || need_write_want_n > need_write)ttreturn;tif (need_read < need_write)ttlen = -need_read;telsettlen = -need_write;tif (len > sizeof(buf))ttlen = sizeof(buf);tmemset(buf, ' ', len);tts.saddr = ci->src_addr;tts.daddr = ci->dst_addr;tts.sport = ci->src_port;tts.dport = ci->dst_port;tts.src_mac = ci->dst.dst_mac;tts.dst_mac = ci->dst.src_mac;tts.seq = ci->dst.next_d_seq;tts.ack_seq = ci->dst.next_seq;tts.window = ci->src.window ? ci->src.window : htons(242);tts.ack = 1;tts.psh = 1;tts.rst = 0;tts.data = buf;tts.data_len = len;tsend_tcp_packet(&ts);tneed_read += len;tneed_write += len;tneed_read_want_n = need_read;tneed_write_want_n = need_write;}""",2,"cwe119,cwe120"
"client_location_changed (){tstruct interface_info *ip;tstruct client_state *client;tfor (ip = interfaces; ip; ip = ip -> next) {ttfor (client = ip -> client; client; client = client -> next) {tttswitch (client -> state) {ttt      case S_SELECTING:ttttcancel_timeout (send_discover, client);ttttbreak;ttt      case S_BOUND:ttttcancel_timeout (state_bound, client);ttttbreak;ttt      case S_REBOOTING:ttt      case S_REQUESTING:ttt      case S_RENEWING:ttttcancel_timeout (send_request, client);ttttbreak;ttt      case S_INIT:ttt      case S_REBINDING:ttt      case S_STOPPED:ttttbreak;ttt}tttclient -> state = S_INIT;tttstate_reboot (client);tt}t}}",2,"cwe120,cweother"
"scm_i_mode_bits (SCM modes){  long bits;  if (!scm_is_string (modes))    scm_wrong_type_arg_msg (NULL, 0, modes, ""string"");  bits = scm_i_mode_bits_n (scm_i_string_chars (modes),ttt    scm_i_string_length (modes));  scm_remember_upto_here_1 (modes);  return bits;}",2,"cwe119,cwe120"
"""dns_view_untrust(dns_view_t *view, dns_name_t *keyname,tt dns_rdata_dnskey_t *dnskey, isc_mem_t *mctx){tisc_result_t result;tunsigned char data[4096];tdns_rdata_t rdata = DNS_RDATA_INIT;tisc_buffer_t buffer;tdst_key_t *key = NULL;tdns_keytable_t *sr = NULL;t/*t * Clear the revoke bit, if set, so that the key will match what'st * in secroots now.t */tdnskey->flags &= ~DNS_KEYFLAG_REVOKE;t/* Convert dnskey to DST key. */tisc_buffer_init(&buffer, data, sizeof(data));tdns_rdata_fromstruct(&rdata, dnskey->common.rdclass,ttt     dns_rdatatype_dnskey, dnskey, &buffer);tresult = dns_dnssec_keyfromrdata(keyname, &rdata, mctx, &key);tif (result != ISC_R_SUCCESS)ttreturn;tresult = dns_view_getsecroots(view, &sr);tif (result == ISC_R_SUCCESS) {ttdns_keytable_deletekeynode(sr, key);ttdns_keytable_detach(&sr);t}tdst_key_free(&key);}""",2,"cwe119,cwe120"
"""parse_wxh_internal(const char *val, int size, double *pw, double *ph){  char buf[256];  char *tail;  int i;  for (i = 0; i < size; i++)    if (val[i] == 'x')      break;  if (i + 1 >= size)    return IJS_ESYNTAX;  if (i >= sizeof(buf))    return IJS_EBUF;  memcpy (buf, val, i);  buf[i] = 0;  *pw = strtod (buf, &tail);  if (tail == buf)    return IJS_ESYNTAX;  if (size - i > sizeof(buf))    return IJS_EBUF;  memcpy (buf, val + i + 1, size - i - 1);  buf[size - i - 1] = 0;  *ph = strtod (buf, &tail);  if (tail == buf)    return IJS_ESYNTAX;  return 0;}""",2,"cwe119,cwe120"
"parseResolvConf(char *filename){    FILE *f;    char buf[512];    char *p, *q;    int n;    AtomPtr nameserver = NULL;    f = fopen(filename, ""r"");    if(f == NULL) {        do_log_error(L_ERROR, errno, ""DNS: couldn't open %s"", filename);        return 0;    }    while(1) {        p = fgets(buf, 512, f);        if(p == NULL)            break;        n = strlen(buf);        if(buf[n - 1] != '') {            int c;            do_log(L_WARN, ""DNS: overly long line in %s -- skipping."",                   filename);            do {                c = fgetc(f);                if(c == EOF)                    break;            } while(c != '');            if(c == EOF)                break;        }                while(*p == ' ' || *p == 't')            p++;        if(strcasecmp_n(""nameserver"", p, 10) != 0)            continue;        p += 10;        while(*p == ' ' || *p == 't')            p++;        q = p;        while(*q == '.' || *q == ':' || digit(*q) || letter(*q))            q++;        if(*q != ' ' && *q != 't' && *q != 'r' && *q != '') {            do_log(L_WARN, ""DNS: couldn't parse line in %s -- skipping."",                   filename);            continue;        }        nameserver = internAtomLowerN(p, q - p);        break;    }    fclose(f);    if(nameserver) {        dnsNameServer = nameserver;        return 1;    } else {        return 0;    }}",3,"cwe119,cwe120,cweother"
"simple_object_internal_read (int descriptor, off_t offset,ttt     unsigned char *buffer, size_t size,ttt     const char **errmsg, int *err){  ssize_t got;  if (lseek (descriptor, offset, SEEK_SET) < 0)    {      *errmsg = ""lseek"";      *err = errno;      return 0;    }  got = read (descriptor, buffer, size);  if (got < 0)    {      *errmsg = ""read"";      *err = errno;      return 0;    }  if ((size_t) got < size)    {      *errmsg = ""file too short"";      *err = 0;      return 0;    }  return 1;}",2,"cwe120,cweother"
"inet_pton4(const char *src, unsigned char *dst) {tstatic const char digits[] = ""0123456789"";tint saw_digit, octets, ch;tunsigned char tmp[NS_INADDRSZ], *tp;tsaw_digit = 0;toctets = 0;t*(tp = tmp) = 0;twhile ((ch = *src++) != '0') {ttconst char *pch;ttif ((pch = strchr(digits, ch)) != NULL) {tttunsigned int new = *tp * 10;tttnew += (unsigned int)(pch - digits);tttif (new > 255)ttttreturn (0);ttt*tp = new;tttif (! saw_digit) {ttttif (++octets > 4)tttttreturn (0);ttttsaw_digit = 1;ttt}tt} else if (ch == '.' && saw_digit) {tttif (octets == 4)ttttreturn (0);ttt ttttp++;ttt*tp = 0;tttsaw_digit = 0;tt} elsetttreturn (0);t}tif (octets < 4)ttreturn (0);tmemmove(dst, tmp, NS_INADDRSZ);treturn (1);}",2,"cwe119,cwe120"
"socket_verify_auth(struct IPC_CHANNEL* ch, struct IPC_AUTH * auth_info){tstruct SOCKET_CH_PRIVATE *tconn_info;tintttttret = IPC_FAIL;tstruct ucredtttcred;tsocklen_ttttn = sizeof(cred);tif (ch == NULL || ch->ch_private == NULL) {ttreturn IPC_FAIL;t}tif (auth_info == NULLt||t(auth_info->uid == NULL && auth_info->gid == NULL)) {ttret = IPC_OK;     t  }t tconn_info = (struct SOCKET_CH_PRIVATE *) ch->ch_private;tif (getsockopt(conn_info->s, SOL_SOCKET, SO_PEERCRED, &cred, &n) != 0t||t(size_t)n != sizeof(cred)) {ttreturn ret;t}tch->farside_uid = cred.uid;tch->farside_gid = cred.gid;tif (ret == IPC_OK) {ttreturn ret;t}#if 0tcl_log(LOG_DEBUG, ""SO_PEERCRED returned [%d, (%ld:%ld)]""t,tcred.pid, (long)cred.uid, (long)cred.uid);tcl_log(LOG_DEBUG, ""Verifying authentication: cred.uid=%d cred.gid=%d""t,tcred.uid, cred.gid);tcl_log(LOG_DEBUG, ""Verifying authentication: uidptr=0x%lx gidptr=0x%lx""t,t(unsigned long)auth_info->uidt,t(unsigned long)auth_info->gid);#endift treturn verify_creds(auth_info, cred.uid, cred.gid);}",2,"cwe119,cwe120"
"fb_init(int vt __UNUSED__, int device){   char dev[32];      tty = 0;#if 0   if (vt != 0) fb_setvt(vt);#endif   if ( getenv(""EVAS_FB_DEV"") )     {        fb = open(getenv(""EVAS_FB_DEV""), O_RDWR);     }   else     {        sprintf(dev, ""/dev/fb/%i"", device);        fb = open(dev, O_RDWR);        if ( fb == -1 )          {             sprintf(dev, ""/dev/fb%i"", device);             fb = open(dev, O_RDWR);          }     }   if (fb == -1)     {tCRIT(""open %s: %s"", dev, strerror(errno));tfb_cleanup();        return;     }      if (ioctl(fb, FBIOGET_VSCREENINFO, &fb_ovar) == -1)     {tperror(""ioctl FBIOGET_VSCREENINFO"");        return;     }   if (ioctl(fb, FBIOGET_FSCREENINFO, &fb_fix) == -1)     {tperror(""ioctl FBIOGET_FSCREENINFO"");        return;     }   if ((fb_ovar.bits_per_pixel == 8) ||       (fb_fix.visual == FB_VISUAL_DIRECTCOLOR))     {tif (ioctl(fb,FBIOGETCMAP , &ocmap) == -1)t  {t     perror(""ioctl FBIOGETCMAP"");             return;t  }     }#if 0   if (isatty(0))      tty = 0;   else if ((tty = open(""/dev/tty"",O_RDWR)) == -1)     {tCITICAL(""open %s: %s"", ""/dev/tty"", strerror(errno));        return;     }   if (tty)     {tif (ioctl(tty, KDGETMODE, &kd_mode) == -1)t  {t     perror(""ioctl KDGETMODE"");             return;t  }tif (ioctl(tty, VT_GETMODE, &vt_omode) == -1)t  {t     perror(""ioctl VT_GETMODE"");             return;t  }     }#endif}",3,"cwe119,cwe120,cweother"
"drv_Pertelian_start(const char *section){    int backlight;    int rows = -1, cols = -1;    char *s;    char cmd[12] = """";    s = cfg_get(section, ""Size"", NULL);    if (s == NULL || *s == '0') {terror(""%s: no '%s.Size' entry from %s"", Name, section, cfg_source());treturn -1;    }    if (sscanf(s, ""%dx%d"", &cols, &rows) != 2 || rows < 1 || cols < 1) {terror(""%s: bad %s.Size '%s' from %s"", Name, section, s, cfg_source());tfree(s);treturn -1;    }    DROWS = rows;    DCOLS = cols;         if (drv_Pertelian_open(section) < 0) {treturn -1;    }         cmd[0] = PERTELIAN_LCDCOMMAND;    cmd[1] = 0x38;    cmd[2] = PERTELIAN_LCDCOMMAND;    cmd[3] = 0x06;    cmd[4] = PERTELIAN_LCDCOMMAND;    cmd[5] = 0x10;tt     cmd[6] = PERTELIAN_LCDCOMMAND;    cmd[7] = 0x0c;    cmd[8] = 0x0c;    drv_Pertelian_send(cmd, 8);    if (cfg_number(section, ""Backlight"", 0, 0, 1, &backlight) > 0) {tdrv_Pertelian_backlight(backlight);    }    drv_Pertelian_clear();t     return 0;}",2,"cwe119,cwe120"
"vtc_hexdump(struct vtclog *vl, int lvl, const char *pfx,    const unsigned char *str, int len){tint nl = 1;tunsigned l;tdouble tx;tCHECK_OBJ_NOTNULL(vl, VTCLOG_MAGIC);ttx = VTIM_mono() - t0;tassert(len >= 0);tassert(lvl >= 0);tassert(lvl < NLEAD);tAZ(pthread_mutex_lock(&vl->mtx));tvl->act = 1;tVSB_clear(vl->vsb);tif (pfx == NULL)ttpfx = """";tif (str == NULL)ttVSB_printf(vl->vsb, ""%s %-4s %4.1f %s| (null)"",tt    lead[lvl], vl->id, tx, pfx);telse {ttfor (l = 0; l < len; l++, str++) {tttif (l > 512) {ttttVSB_printf(vl->vsb, ""..."");ttttbreak;ttt}tttif (nl) {ttttVSB_printf(vl->vsb, ""%s %-4s %4.1f %s| "",tttt    lead[lvl], vl->id, tx, pfx);ttttnl = 0;ttt}tttVSB_printf(vl->vsb, "" %02x"", *str);tttif ((l & 0xf) == 0xf) {ttttVSB_printf(vl->vsb, """");ttttnl = 1;ttt}tt}t}tif (!nl)ttVSB_printf(vl->vsb, """");tAZ(VSB_finish(vl->vsb));tvtc_log_emit(vl, lvl);tVSB_clear(vl->vsb);tvl->act = 0;tAZ(pthread_mutex_unlock(&vl->mtx));tif (lvl == 0) {ttvtc_error = 1;ttif (pthread_self() != vtc_thread)tttpthread_exit(NULL);t}}",2,"cwe476,cweother"
"read_key_value(char **keyptr, int *keylen, char **valptr, int *vallen) {  int c,res,inkey;  res = 0;  inkey = 1;  *keyptr = stack;  *keylen = 0;  *vallen = 0;  while( (c = getchar()) != EOF ) {    if (c == '') break;    if ((c == 't') && inkey) {      inkey = 0;      *valptr = stack + *keylen + 1;    } else {      if (inkey) {        (*keyptr)[(*keylen)++] = c;        res = 1;      } else {        (*valptr)[(*vallen)++] = c;      }    }    if (*keylen + *vallen >= STACKSIZE - 1) {      printf(""Error, stack overflow"");      fatal(""stack overflow"", EC_DATAERR);    }  }  (*keyptr)[*keylen] = '0';  if (inkey) {    *valptr = *keyptr + *keylen;  } else {    (*valptr)[*vallen] = '0';  }  return res;}",3,"cwe120,cwe476,cweother"
"check_other_key(object l, int n, ...){tva_list ap;tobject other_key = OBJNULL;tobject k;tint i;tbool allow_other_keys = FALSE;tfor (;  !endp(l);  l = l->c.c_cdr->c.c_cdr) {ttk = l->c.c_car;ttif (!keywordp(k))tt  FEunexpected_keyword(k);ttif (endp(l->c.c_cdr))tt   tt  FEunexpected_keyword(Cnil);ttif (k == sKallow_other_keys && l->c.c_cdr->c.c_car != Cnil) {tttallow_other_keys = TRUE;tt} else {tt  char buf [100];tt  bzero(buf,n);tt  va_start(ap,n);tt  for (i = 0;  i < n;  i++)tt    { if (va_arg(ap,object) == k &&ttt  buf[i] ==0) {buf[i]=1; break;}}tt  va_end(ap);tt  if (i >= n) other_key = k;tt}t}tif (other_key != OBJNULL && !allow_other_keys)t  FEunexpected_keyword(other_key);}",2,"cwe119,cwe120"
"pg_xlogfile_name(PG_FUNCTION_ARGS){ttextt   *location = PG_GETARG_TEXT_P(0);ttextt   *result;tchart   *locationstr;tunsigned int uxlogid;tunsigned int uxrecoff;tuint32ttxlogid;tuint32ttxlogseg;tXLogRecPtrtlocationpoint;tcharttxlogfilename[MAXFNAMELEN];tlocationstr = DatumGetCString(DirectFunctionCall1(textout,tttttttttttt PointerGetDatum(location)));tif (sscanf(locationstr, ""%X/%X"", &uxlogid, &uxrecoff) != 2)ttereport(ERROR,tttt(errcode(ERRCODE_INVALID_PARAMETER_VALUE),tttt errmsg(""could not parse transaction log location ""%s"""",ttttttlocationstr)));tlocationpoint.xlogid = uxlogid;tlocationpoint.xrecoff = uxrecoff;tXLByteToPrevSeg(locationpoint, xlogid, xlogseg);tXLogFileName(xlogfilename, ThisTimeLineID, xlogid, xlogseg);tresult = DatumGetTextP(DirectFunctionCall1(textin,ttttttttttt CStringGetDatum(xlogfilename)));tPG_RETURN_TEXT_P(result);}",2,"cwe119,cwe120"
"merge_submodule(unsigned char result[20], const char *path,tt    const unsigned char base[20], const unsigned char a[20],tt    const unsigned char b[20]){tstruct commit *commit_base, *commit_a, *commit_b;tint parent_count;tstruct object_array merges;tint i;t thashcpy(result, a);t tif (is_null_sha1(base))ttreturn 0;tif (is_null_sha1(a))ttreturn 0;tif (is_null_sha1(b))ttreturn 0;tif (add_submodule_odb(path)) {ttMERGE_WARNING(path, ""not checked out"");ttreturn 0;t}tif (!(commit_base = lookup_commit_reference(base)) ||t    !(commit_a = lookup_commit_reference(a)) ||t    !(commit_b = lookup_commit_reference(b))) {ttMERGE_WARNING(path, ""commits not present"");ttreturn 0;t}t tif (!in_merge_bases(commit_base, &commit_a, 1) ||t    !in_merge_bases(commit_base, &commit_b, 1)) {ttMERGE_WARNING(path, ""commits don't follow merge-base"");ttreturn 0;t}t tif (in_merge_bases(commit_a, &commit_b, 1)) {tthashcpy(result, b);ttreturn 1;t}tif (in_merge_bases(commit_b, &commit_a, 1)) {tthashcpy(result, a);ttreturn 1;t}t t tparent_count = find_first_merges(&merges, path, commit_a, commit_b);tswitch (parent_count) {tcase 0:ttMERGE_WARNING(path, ""merge following commits not found"");ttbreak;tcase 1:ttMERGE_WARNING(path, ""not fast-forward"");ttfprintf(stderr, ""Found a possible merge resolution ""tttt""for the submodule:"");ttprint_commit((struct commit *) merges.objects[0].item);ttfprintf(stderr,ttt""If this is correct simply add it to the index ""ttt""for example""ttt""by using:""ttt""  git update-index --cacheinfo 160000 %s ""%s""""ttt""which will accept this suggestion."",tttsha1_to_hex(merges.objects[0].item->sha1), path);ttbreak;tdefault:ttMERGE_WARNING(path, ""multiple merges found"");ttfor (i = 0; i < merges.nr; i++)tttprint_commit((struct commit *) merges.objects[i].item);t}tfree(merges.objects);treturn 0;}",2,"cwe119,cwe120"
"__ecereProp_Project_Set_filePath(struct Project * this, char *  value){if(value){char string[797];__ecereFunction___ecereNameSpace__ecere__sys__GetLastDirectory(value, string);(__ecereNameSpace__ecere__com__eSystem_Delete(this->topNode->name), this->topNode->name = 0);this->topNode->name = __ecereFunction___ecereNameSpace__ecere__sys__CopyString(string);__ecereFunction___ecereNameSpace__ecere__sys__StripExtension(string);(__ecereNameSpace__ecere__com__eSystem_Delete(this->name), this->name = 0);this->name = __ecereFunction___ecereNameSpace__ecere__sys__CopyString(string);__ecereFunction___ecereNameSpace__ecere__sys__StripLastDirectory(value, string);(__ecereNameSpace__ecere__com__eSystem_Delete(this->topNode->path), this->topNode->path = 0);this->topNode->path = __ecereFunction___ecereNameSpace__ecere__sys__CopyString(string);(__ecereNameSpace__ecere__com__eSystem_Delete(this->filePath), this->filePath = 0);this->filePath = __ecereFunction___ecereNameSpace__ecere__sys__CopyString(value);}}",2,"cwe119,cwe120"
"get(input_ty *this){        int             c;        c = getchar();        if (c == EOF && ferror(stdin))        {                sub_context_ty  *scp;                scp = sub_context_new();                sub_errno_set(scp);                sub_var_set_string(scp, ""File_Name"", standard_input());                fatal_intl(scp, i18n(""read ""$filename"": $errno""));                         }        return c;}",2,"cwe120,cweother"
"freq_init(void){    char line[256],value[256];    FILE *fp;    int nr,i,j;    if (NULL == (fp = fopen(DATADIR ""/Index.map"",""r""))) {tperror(""open "" DATADIR ""/Index.map"");texit(1);    }    if (debug)tfprintf(stderr,""freq: reading "" DATADIR ""/Index.map"");    nr = 0;    i  = 0;    while (NULL != fgets(line,255,fp)) {tnr++;tif (line[0] == '' || line[0] == '#' || line[0] == '%')t    continue;tif (1 == sscanf(line,""[%255[^]]]"",value)) {t     t    chanlists = realloc(chanlists, (i+2) * sizeof(struct CHANLISTS));t    memset(chanlists+i, 0, 2*sizeof(struct CHANLISTS));t    chanlists[i].name = strdup(value);t    i++;t    continue;t}tif (NULL == chanlists) {t    fprintf(stderr,""%s:%d: error: no section"",tt    DATADIR ""/Index.map"",nr);t    continue;t}tif (1 == sscanf(line,"" file = %255[^]"",value)) {t     t    chanlists[i-1].filename = strdup(value);t    continue;t}t tfprintf(stderr,""%s:%d: syntax error"",ttDATADIR ""/Index.map"",nr);    }    fclose(fp);    chanlist_names = malloc((i+1) * sizeof(struct STRTAB));    for (j = 0; j < i; j++) {tchanlist_names[j].nr  = j;tchanlist_names[j].str = chanlists[j].name;    }    chanlist_names[j].nr  = -1;    chanlist_names[j].str = NULL;}",3,"cwe119,cwe120,cweother"
"gplotMakeOutput(GPLOT  *gplot){char     buf[L_BUF_SIZE];l_int32  ignore;    PROCNAME(""gplotMakeOutput"");    if (!gplot)        return ERROR_INT(""gplot not defined"", procName, 1);    gplotGenCommandFile(gplot);    gplotGenDataFiles(gplot);#ifndef _WIN32    if (gplot->outformat != GPLOT_X11)        snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", gplot->cmdname);    else        snprintf(buf, L_BUF_SIZE,                 ""gnuplot -persist -geometry +10+10 %s &"", gplot->cmdname);#else   if (gplot->outformat != GPLOT_X11)       snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", gplot->cmdname);   else       snprintf(buf, L_BUF_SIZE,               ""wgnuplot -persist %s"", gplot->cmdname);#endif       ignore = system(buf);       return 0;}",3,"cwe119,cwe120,cweother"
"dhcpctl_get_value (dhcpctl_data_string *result,tttt  dhcpctl_handle h, const char *value_name){tisc_result_t status;tomapi_value_t *tv = (omapi_value_t *)0;tunsigned len;tint ip;tstatus = omapi_get_value_str (h, (omapi_object_t *)0, value_name, &tv);tif (status != ISC_R_SUCCESS)ttreturn status;tswitch (tv -> value -> type) {t      case omapi_datatype_int:ttlen = sizeof (int);ttbreak;t      case omapi_datatype_string:t      case omapi_datatype_data:ttlen = tv -> value -> u.buffer.len;ttbreak;t      case omapi_datatype_object:ttlen = sizeof (omapi_handle_t);ttbreak;t      default:ttomapi_typed_data_dereference (&tv -> value, MDL);ttreturn ISC_R_UNEXPECTED;t}tstatus = omapi_data_string_new (result, len, MDL);tif (status != ISC_R_SUCCESS) {ttomapi_typed_data_dereference (&tv -> value, MDL);ttreturn status;t}tswitch (tv -> value -> type) {t      case omapi_datatype_int:ttip = htonl (tv -> value -> u.integer);ttmemcpy ((*result) -> value, &ip, sizeof ip);ttbreak;t      case omapi_datatype_string:t      case omapi_datatype_data:ttmemcpy ((*result) -> value,ttttv -> value -> u.buffer.value,ttttv -> value -> u.buffer.len);ttbreak;t      case omapi_datatype_object:ttip = htonl (tv -> value -> u.object -> handle);ttmemcpy ((*result) -> value, &ip, sizeof ip);ttbreak;t}tomapi_value_dereference (&tv, MDL);treturn ISC_R_SUCCESS;}",2,"cwe120,cweother"
"ind_and_check_pwp(Repl_Connection *conn, char * binddn, char *password){tLDAPControlt**ctrls = NULL;tLDAPtt*ld = conn->ld;tinttttrc;tconst char  *mech = bind_method_to_mech(conn->bindmethod);tLDAPDebug( LDAP_DEBUG_TRACE, ""=> bind_and_check_pwp"", 0, 0, 0 );trc = slapi_ldap_bind(conn->ld, binddn, password, mech, NULL,tttttt &ctrls, NULL, NULL);tif ( rc == LDAP_SUCCESS ) t{ttif (conn->last_ldap_error != rc)tt{tttconn->last_ldap_error = rc;tttslapi_log_error(SLAPI_LOG_FATAL, windows_repl_plugin_name,ttttttt""%s: Replication bind with %s auth resumed"",tttttttagmt_get_long_name(conn->agmt),tttttttmech ? mech : ""SIMPLE"");tt}ttif ( ctrls ) tt{tttint i;tttfor( i = 0; ctrls[ i ] != NULL; ++i ) ttt{ttttif ( !(strcmp( ctrls[ i ]->ldctl_oid, LDAP_CONTROL_PWEXPIRED)) )tttt{ttttt tttttslapi_log_error(SLAPI_LOG_FATAL, windows_repl_plugin_name, tttttt""%s: Successfully bound %s to consumer, ""tttttt""but password has expired on consumer."",ttttttagmt_get_long_name(conn->agmt), binddn);tttt}tttttttttelse if ( !(strcmp( ctrls[ i ]->ldctl_oid, LDAP_CONTROL_PWEXPIRING)) )tttt{ttttt tttttif ( (ctrls[ i ]->ldctl_value.bv_val != NULL) &&tttttt (ctrls[ i ]->ldctl_value.bv_len > 0) )ttttt{ttttttint password_expiring = atoi( ctrls[ i ]->ldctl_value.bv_val );ttttttslapi_log_error(SLAPI_LOG_FATAL, windows_repl_plugin_name, ttttttt""%s: Successfully bound %s to consumer, ""ttttttt""but password is expiring on consumer in %d seconds."",tttttttagmt_get_long_name(conn->agmt), binddn, password_expiring);ttttt}tttt}ttt}ttttldap_controls_free( ctrls );tt}ttLDAPDebug( LDAP_DEBUG_TRACE, ""<= bind_and_check_pwp - CONN_OPERATION_SUCCESS"", 0, 0, 0 );ttreturn (CONN_OPERATION_SUCCESS);t}telse t{ttldap_controls_free( ctrls );tt ttif (conn->last_ldap_error != rc)tt{tttchar *errmsg = NULL;tttconn->last_ldap_error = rc;ttt tttrc = slapi_ldap_get_lderrno( ld, NULL, &errmsg );tttslapi_log_error(SLAPI_LOG_FATAL, windows_repl_plugin_name,ttttttt""%s: Replication bind with %s auth failed: LDAP error %d (%s) (%s)"",tttttttagmt_get_long_name(conn->agmt),tttttttmech ? mech : ""SIMPLE"", rc,tttttttldap_err2string(rc), errmsg);tt} else {tttchar *errmsg = NULL;ttt tttrc = slapi_ldap_get_lderrno( ld, NULL, &errmsg );tttslapi_log_error(SLAPI_LOG_REPL, windows_repl_plugin_name,ttttttt""%s: Replication bind with %s auth failed: LDAP error %d (%s) (%s)"",tttttttagmt_get_long_name(conn->agmt),tttttttmech ? mech : ""SIMPLE"", rc,tttttttldap_err2string(rc), errmsg);tt}ttLDAPDebug( LDAP_DEBUG_TRACE, ""<= bind_and_check_pwp - CONN_OPERATION_FAILED"", 0, 0, 0 );ttreturn (CONN_OPERATION_FAILED);t}}",2,"cwe469,cweother"
"synaptics_identify(struct psmouse *psmouse){tstruct synaptics_data *priv = psmouse->private;tunsigned char id[3];tif (synaptics_send_cmd(psmouse, SYN_QUE_IDENTIFY, id))ttreturn -1;tpriv->identity = (id[0]<<16) | (id[1]<<8) | id[2];tif (SYN_ID_IS_SYNAPTICS(priv->identity))ttreturn 0;treturn -1;}",2,"cwe119,cwe120"
"SWdefdimmap(int32 swathID, char *geodim, char *datadim, int32 offset,t    int32 increment){    intn            status;t     int32           fid;t     int32           sdInterfaceID;t     int32           size;t     int32           idOffset = SWIDOFFSET;t     int32           dum;t     int32           metadata[2];     char            mapname[80];     char            swathname[80];t          status = SWchkswid(swathID, ""SWdefdimmap"", &fid, &sdInterfaceID, &dum);    if (status == 0)    {t t tsize = SWdiminfo(swathID, geodim);tif (size == -1)t{t    status = -1;t    HEpush(DFE_GENAPP, ""SWdefdimmap"", __FILE__, __LINE__);t    HEreport(""Geolocation dimension name: ""%s"" not found."",tt     geodim);t}t t tif (status == 0)t{t    size = SWdiminfo(swathID, datadim);t    if (size == -1)t    {ttstatus = -1;ttHEpush(DFE_GENAPP, ""SWdefdimmap"", __FILE__, __LINE__);ttHEreport(""Data dimension name: ""%s"" not found."",ttt datadim);t    }t}t t tif (status == 0)t{t    sprintf(mapname, ""%s%s%s"", geodim, ""/"", datadim);t    metadata[0] = offset;t    metadata[1] = increment;t    Vgetname(SWXSwath[swathID % idOffset].IDTable, swathname);t    status = EHinsertmeta(sdInterfaceID, swathname, ""s"", 1L,tttt  mapname, metadata);t}    }    return (status);}",2,"cwe119,cwe120"
"curve_parse_text(GMarkupParseContext *context, const gchar *text,                             gsize len, gpointer user, GError **error){    CurveData *c = user;    const gchar *element = g_markup_parse_context_get_element(context);    char temp[max_path];    error = error;    for (; len > 0 && g_ascii_isspace(*text); len--, text++);    for (; len > 0 && g_ascii_isspace(text[len - 1]); len--);    if (len == 0) return;    if (len > max_path - 1) len = max_path - 1;    strncpy(temp, text, len);    temp[len] = '0';    if (!strcmp(""Curve"", element)) {        g_strlcpy(c->name, temp, max_name);    }         if (c->m_gamma < 0) {        if (!strcmp(""MinXY"", element)) {            sscanf(temp, ""%lf %lf"", &c->m_min_x, &c->m_min_y);            c->m_min_x = LIM(c->m_min_x, 0, 1);            c->m_min_y = LIM(c->m_min_y, 0, 1);        }        if (!strcmp(""MaxXY"", element)) {            sscanf(temp, ""%lf %lf"", &c->m_max_x, &c->m_max_y);            c->m_max_x = LIM(c->m_max_x, 0, 1);            c->m_max_y = LIM(c->m_max_y, 0, 1);        }        if (!strcmp(""AnchorXY"", element)) {                         sscanf(temp, ""%lf %lf"",                   &c->m_anchors[c->m_numAnchors].x,                   &c->m_anchors[c->m_numAnchors].y);            c->m_anchors[c->m_numAnchors].x =                LIM(c->m_anchors[c->m_numAnchors].x, 0, 1);            c->m_anchors[c->m_numAnchors].y =                LIM(c->m_anchors[c->m_numAnchors].y, 0, 1);            c->m_numAnchors++;        }    }}",2,"cwe119,cwe120"
"camlidl_linexpr1_ap_linexpr1_set_coeff(tvalue _v_a,tvalue _v_var,tvalue _v_coeff){  struct ap_linexpr1_t *a;    ap_var_t var;    struct ap_coeff_t *coeff;    struct ap_linexpr1_t _c1;  struct ap_coeff_t _c2;  struct camlidl_ctx_struct _ctxs = { CAMLIDL_TRANSIENT, NULL };  camlidl_ctx _ctx = &_ctxs;  a = &_c1;  camlidl_ml2c_linexpr1_struct_ap_linexpr1_t(_v_a, &_c1, _ctx);  camlidl_ml2c_var_ap_var_t(_v_var, &var, _ctx);  coeff = &_c2;  camlidl_ml2c_coeff_struct_ap_coeff_t(_v_coeff, &_c2, _ctx);   {bool b;b = ap_linexpr1_set_coeff(a,var,coeff);if (b){char str[160];char* name;name = ap_var_operations->to_string(var);snprintf(str,159,""Linexpr1.set_coeff: unknown variable %s in the environment"",name);free(name);caml_failwith(str);}}     camlidl_free(_ctx);  return Val_unit;}",2,"cwe119,cwe120"
"__nisbind_connect (dir_binding *dbp){  nis_server *serv;  u_short port;  if (dbp == NULL)    return NIS_FAIL;  serv = &dbp->server_val[dbp->server_used];  memset (&dbp->addr, '0', sizeof (dbp->addr));  dbp->addr.sin_family = AF_INET;  dbp->addr.sin_addr.s_addr =    inetstr2int (serv->ep.ep_val[dbp->current_ep].uaddr);  if (dbp->addr.sin_addr.s_addr == INADDR_NONE)    return NIS_FAIL;     port = __pmap_getnisport (&dbp->addr, NIS_PROG, NIS_VERSION,ttt    dbp->use_udp ? IPPROTO_UDP : IPPROTO_TCP);  if (port == 0)    return NIS_RPCERROR;  dbp->addr.sin_port = htons (port);  dbp->socket = RPC_ANYSOCK;  if (dbp->use_udp)    dbp->clnt = clntudp_create (&dbp->addr, NIS_PROG, NIS_VERSION,tttt UDPTIMEOUT, &dbp->socket);  else    dbp->clnt = clnttcp_create (&dbp->addr, NIS_PROG, NIS_VERSION,tttt &dbp->socket, 0, 0);  if (dbp->clnt == NULL)    return NIS_RPCERROR;  clnt_control (dbp->clnt, CLSET_TIMEOUT, (caddr_t) &RPCTIMEOUT);     if (fcntl (dbp->socket, F_SETFD, 1) == -1)    perror (""fcntl: F_SETFD"");  if (dbp->use_auth)    {      if (serv->key_type == NIS_PK_DH)t{t  char netname[MAXNETNAMELEN + 1];t  char *p;t  des_block ckey;t  p = stpcpy (netname, ""unix@"");t  strncpy (p, serv->name, MAXNETNAMELEN - 5);t  netname[MAXNETNAMELEN] = '0';t  dbp->clnt->cl_auth = NULL;t  if (get_ckey (&ckey, &dbp->addr,tttdbp->use_udp ? IPPROTO_UDP : IPPROTO_TCP))t    dbp->clnt->cl_auth =t      authdes_pk_create (netname, &serv->pkey, 300, NULL, &ckey);t  if (!dbp->clnt->cl_auth)t    dbp->clnt->cl_auth = authunix_create_default ();t}      elsetdbp->clnt->cl_auth = authunix_create_default ();    }  return NIS_SUCCESS;}",2,"cwe119,cwe120"
"process_configfile(char *configfile, char **username, char **password) {tchar *userpass;tstruct stat st_buf;tFILE* config;tif(stat(configfile, &st_buf)) return -1;tuserpass = malloc(sizeof(*userpass) * st_buf.st_size);tconfig = fopen(configfile, ""r"");tfread(userpass, st_buf.st_size, 1, config);tfclose(config);treturn process_userpass(userpass, username, password);}",2,"cwe120,cweother"
"dns_sortip6(char *s,unsigned int n){  unsigned int i;  char tmp[16];  n >>= 4;  while (n > 1) {    i = dns_random(n);    --n;    byte_copy(tmp,16,s + (i << 4));    byte_copy(s + (i << 4),16,s + (n << 4));    byte_copy(s + (n << 4),16,tmp);  }}",2,"cwe119,cwe120"
"dump_images(FILE *o){  image_struct *img;  subimage_struct *sub;  int i;  static char *type_names[] = {""mono"", ""grey"", ""color""};  for (img=image_list; img; img=img->next)    for (i=0; i<3; i++)      for (sub=img->sub[i]; sub; sub=sub->next)t{t  FILE *f = fopen(sub->filename, ""rb"");t  int byte;t  fprintf(o, ""/* %s */"", sub->filename);t  fprintf(o, ""static const unsigned char data_%d[] = {"", sub->index);t  print_com = 0;t  while ((byte = fgetc (f)) != EOF)t    print_int(o, byte);t  fprintf(o, ""};"");t  fclose (f);t}  for (img=image_list; img; img=img->next)    for (i=0; i<3; i++)      if (img->sub[i])t{t  fprintf(o, ""static image sub_%d_%s[] = {"", img->index, type_names[i]);t  for (sub=img->sub[i]; sub; sub=sub->next)t    fprintf(o, ""  { %d, %d, data_%d },"", sub->w, sub->h, sub->index);t  fprintf(o, ""  { 0, 0, 0 }};"");t}  fprintf(o, ""image_list %s_imagelib[] = {"", basename);  for (img=image_list; img; img=img->next)    {      char *c = """";      fprintf(o, ""  { ""%s"", %d, %d, { "", img->name, img->a, img->d);      for (i=0; i<3; i++)t{t  if (img->sub[i])t    fprintf(o, ""%ssub_%d_%s"", c, img->index, type_names[i]);t  elset    fprintf(o, ""%s0"", c);t  c = "", "";t}      fprintf(o, "" } },"");    }  fprintf(o, ""  { 0, 0, 0, { 0, 0, 0 } }};"");}",2,"cwe120,cweother"
"_offline_in_sess(mod_instance_t mi, sess_t sess, pkt_t pkt) {    st_ret_t ret;    os_t os;    os_object_t o;    nad_t nad;    pkt_t queued;    int ns, elem, attr;    char cttl[15], cstamp[18];    time_t ttl, stamp;         if(pkt->type == pkt_PRESENCE && sess->pri >= 0 && pkt->to == NULL && sess->user->top == NULL) {        ret = storage_get(pkt->sm->st, ""queue"", jid_user(sess->jid), NULL, &os);        if(ret != st_SUCCESS) {            log_debug(ZONE, ""storage_get returned %d"", ret);            return mod_PASS;        }                if(os_iter_first(os))            do {                o = os_iter_object(os);                if(os_object_get_nad(os, o, ""xml"", &nad)) {                    queued = pkt_new(pkt->sm, nad_copy(nad));                    if(queued == NULL) {                        log_debug(ZONE, ""invalid queued packet, not delivering"");                    } else {                                                 if((ns = nad_find_scoped_namespace(queued->nad, uri_EXPIRE, NULL)) >= 0 &&                           (elem = nad_find_elem(queued->nad, 1, ns, ""x"", 1)) >= 0 &&                           (attr = nad_find_attr(queued->nad, elem, -1, ""seconds"", NULL)) >= 0) {                            snprintf(cttl, 15, ""%.*s"", NAD_AVAL_L(queued->nad, attr), NAD_AVAL(queued->nad, attr));                            ttl = atoi(cttl);                                                         if((ns = nad_find_scoped_namespace(queued->nad, uri_DELAY, NULL)) >= 0 &&                               (elem = nad_find_elem(queued->nad, 1, ns, ""x"", 1)) >= 0 &&                               (attr = nad_find_attr(queued->nad, elem, -1, ""stamp"", NULL)) >= 0) {                                snprintf(cstamp, 18, ""%.*s"", NAD_AVAL_L(queued->nad, attr), NAD_AVAL(queued->nad, attr));                                stamp = datetime_in(cstamp);                                if(stamp + ttl <= time(NULL)) {                                    log_debug(ZONE, ""queued packet has expired, dropping"");                                    pkt_free(queued);                                    continue;                                }                            }                        }                        log_debug(ZONE, ""delivering queued packet to %s"", jid_full(sess->jid));                        pkt_sess(queued, sess);                    }                }            } while(os_iter_next(os));        os_free(os);                 storage_delete(pkt->sm->st, ""queue"", jid_user(sess->jid), NULL);    }         return mod_PASS;}",3,"cwe119,cwe120,cweother"
"xml_add_error(xmlNodePtr root, struct error_t *err,ttt xmlNsPtr *avail_ns){    xmlNsPtr ns[NUM_NAMESPACE];    xmlNodePtr error, node;    const struct precond_t *precond = &preconds[err->precond];    unsigned err_ns = NS_DAV;    const char *resp_desc = ""responsedescription"";    if (precond->ns == NS_ISCHED) {terr_ns = NS_ISCHED;tresp_desc = ""response-description"";    }    if (!root) {terror = root = init_xml_response(""error"", err_ns, NULL, ns);tavail_ns = ns;    }    else error = xmlNewChild(root, NULL, BAD_CAST ""error"", NULL);    ensure_ns(avail_ns, precond->ns, root, known_namespaces[precond->ns].href,t      known_namespaces[precond->ns].prefix);    node = xmlNewChild(error, avail_ns[precond->ns],tt       BAD_CAST precond->name, NULL);    switch (err->precond) {    case DAV_NEED_PRIVS:tif (err->resource && err->rights) {t    unsigned flags = 0;t    size_t rlen = strlen(err->resource);t    const char *p = err->resource + rlen;t    node = xmlNewChild(node, NULL, BAD_CAST ""resource"", NULL);t    xml_add_href(node, NULL, err->resource);t    if (rlen > 6 && !strcmp(p-6, SCHED_INBOX))ttflags = PRIV_INBOX;t    else if (rlen > 7 && !strcmp(p-7, SCHED_OUTBOX))ttflags = PRIV_OUTBOX;t    add_privs(err->rights, flags, node, root, avail_ns);t}tbreak;    default:tif (err->resource) xml_add_href(node, avail_ns[NS_DAV], err->resource);tbreak;    }    if (err->desc) {txmlNewTextChild(error, NULL, BAD_CAST resp_desc, BAD_CAST err->desc);    }    return root;}",2,"cwe469,cweother"
"ooQ931Print (const Q931Message* q931msg) {   char buf[1000];   DListNode* curNode;   unsigned int i;   printf(""Q.931 Message:"");   printf(""   protocolDiscriminator: %i"", q931msg->protocolDiscriminator);   printf(""   callReference: %i"", q931msg->callReference);   printf(""   from: %s"", (q931msg->fromDestination ?                                        ""destination"" : ""originator""));   printf(""   messageType: %s (0x%X)"",               ooQ931GetMessageTypeName(q931msg->messageType, buf),                                                q931msg->messageType);   for(i = 0, curNode = q931msg->ies.head; i < q931msg->ies.count; i++) {      Q931InformationElement *ie = (Q931InformationElement*) curNode->data;      int length = (ie->length >= 0) ? ie->length : -ie->length;      printf(""   IE[%i] (offset 0x%X):"", i, ie->offset);      printf(""      discriminator: %s (0x%X)"",                ooQ931GetIEName(ie->discriminator, buf), ie->discriminator);      printf(""      data length: %i"", length);       curNode = curNode->next;      printf("""");   }}",2,"cwe119,cwe120"
"read_file_tgt_int_stats(struct file *file, char __user *user_buf,tttt       size_t count, loff_t *ppos){tstruct ath9k_htc_priv *priv = file->private_data;tstruct ath9k_htc_target_int_stats cmd_rsp;tchar buf[512];tunsigned int len = 0;tint ret = 0;tmemset(&cmd_rsp, 0, sizeof(cmd_rsp));tath9k_htc_ps_wakeup(priv);tWMI_CMD(WMI_INT_STATS_CMDID);tif (ret) {ttath9k_htc_ps_restore(priv);ttreturn -EINVAL;t}tath9k_htc_ps_restore(priv);tlen += scnprintf(buf + len, sizeof(buf) - len,ttt ""%20s : %10u"", ""RX"",ttt be32_to_cpu(cmd_rsp.rx));tlen += scnprintf(buf + len, sizeof(buf) - len,ttt ""%20s : %10u"", ""RXORN"",ttt be32_to_cpu(cmd_rsp.rxorn));tlen += scnprintf(buf + len, sizeof(buf) - len,ttt ""%20s : %10u"", ""RXEOL"",ttt be32_to_cpu(cmd_rsp.rxeol));tlen += scnprintf(buf + len, sizeof(buf) - len,ttt ""%20s : %10u"", ""TXURN"",ttt be32_to_cpu(cmd_rsp.txurn));tlen += scnprintf(buf + len, sizeof(buf) - len,ttt ""%20s : %10u"", ""TXTO"",ttt be32_to_cpu(cmd_rsp.txto));tlen += scnprintf(buf + len, sizeof(buf) - len,ttt ""%20s : %10u"", ""CST"",ttt be32_to_cpu(cmd_rsp.cst));tif (len > sizeof(buf))ttlen = sizeof(buf);treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);}",2,"cwe119,cwe120"
"""tds_alloc_dynamic(TDSSOCKET * tds, const char *id){tTDSDYNAMIC *dyn;tchar tmp_id[30];tif (id) {tt/* check to see if id already exists (shouldn't) */ttif (tds_lookup_dynamic(tds, id))tttreturn NULL;t} else {ttunsigned int n;ttid = tmp_id;ttfor (n = 0;;) {tttif (!tds_lookup_dynamic(tds, tds_get_dynid(tds, tmp_id)))ttttbreak;tttif (++n == 256)ttttreturn NULL;tt}t}tdyn = (TDSDYNAMIC *) calloc(1, sizeof(TDSDYNAMIC));tif (!dyn)ttreturn NULL;t/* insert into list */tdyn->next = tds->dyns;ttds->dyns = dyn;ttds_strlcpy(dyn->id, id, TDS_MAX_DYNID_LEN);treturn dyn;}""",2,"cwe119,cwe120"
"""scan(struct view *view){tchar *raw, scratch[8];tposition_t at;tsize_t bytes = view_raw(view, &raw, 0, getpagesize());tsize_t chop = bytes < view->bytes ? 8 : 0;tsize_t chlen, check;tUnicode_t ch, lastch = 0;tint crnl = 0, nl = 0;tBoolean_t any_tab = FALSE;tint tabstop = default_tab_stop;t/* Reset state */tview->text->flags &= ~(TEXT_NO_UTF8 | TEXT_CRNL | TEXT_NO_TABS);tview->text->tabstop = default_tab_stop;tif (utf8_mode == UTF8_NO)ttview->text->flags |= TEXT_NO_UTF8;telse if (utf8_mode == UTF8_AUTO)ttfor (at = 0; at + chop < bytes; at += chlen) {tttchlen = utf8_length(raw + at, bytes - at);tttch = utf8_unicode(raw + at, chlen);tttcheck = unicode_utf8(scratch, ch);tttif (chlen != check) {ttttview->text->flags |= TEXT_NO_UTF8;ttttbreak;ttt}tt}tfor (at = 0; at + chop < bytes; lastch = ch)ttif ((ch = view_unicode(view, at, &at)) == '') {tttnl++;tttcrnl += lastch == 'r';tt}tif (nl && crnl == nl)ttview->text->flags |= TEXT_CRNL;tfor (at = 0; at + chop < bytes; at = find_line_end(view, at) + 1) {ttint spaces = 0;ttwhile ((ch = view_unicode(view, at, &at)) == ' ')tttspaces++;ttif (ch == 't')tttany_tab = TRUE;ttif (spaces > 1 && spaces < tabstop)ttttabstop = spaces;t}tif (default_no_tabs || !any_tab) {ttview->text->flags |= TEXT_NO_TABS;ttview->text->tabstop = tabstop;t}}""",3,"cwe119,cwe120,cweother"
"cl_git_report_failure(tint error, const char *file, int line, const char *fncall){tchar msg[4096];tconst git_error *last = giterr_last();tp_snprintf(msg, 4096, ""error %d - %s"",tterror, last ? last->message : ""<no message>"");tclar__assert(0, file, line, fncall, msg, 1);}",2,"cwe119,cwe120"
"""_ipmi_lan_dump_rs (ipmi_ctx_t ctx,                   const void *pkt,                   unsigned int pkt_len,                   uint8_t cmd,                   uint8_t net_fn,tt   uint8_t group_extension,                   fiid_obj_t obj_cmd_rs){  fiid_field_t *tmpl_cmd = NULL;  assert (ctx          && ctx->magic == IPMI_CTX_MAGIC          && (ctx->flags & IPMI_FLAGS_DEBUG_DUMP)          && pkt          && pkt_len          && fiid_obj_valid (obj_cmd_rs));  /* Don't cleanup/return an error here.  It's just debug code. */  if ((tmpl_cmd = fiid_obj_template (obj_cmd_rs)))    {      char hdrbuf[DEBUG_UTIL_HDR_BUFLEN];      debug_hdr_cmd (DEBUG_UTIL_TYPE_IPMI_1_5,                     DEBUG_UTIL_DIRECTION_RESPONSE,                     net_fn,                     cmd,tt     group_extension,                     hdrbuf,                     DEBUG_UTIL_HDR_BUFLEN);      ipmi_dump_lan_packet (STDERR_FILENO,                            ctx->io.outofband.hostname,                            hdrbuf,                            NULL,                            pkt,                            pkt_len,                            tmpl_lan_msg_hdr_rs,                            tmpl_cmd);      fiid_template_free (tmpl_cmd);    }}""",2,"cwe119,cwe120"
"on_path_p (const char *program){  int result = 0;  struct stat st;  char *cmd = strdup (program);  char *token = strchr (cmd, ' ');  char *path = 0;  int L;  if (token) *token = 0;  token = 0;  if (strchr (cmd, '/'))    {      result = (0 == stat (cmd, &st));      goto DONE;    }  path = getenv(""PATH"");  if (!path || !*path)    goto DONE;  L = strlen (cmd);  path = strdup (path);  token = strtok (path, "":"");  while (token)    {      char *p2 = (char *) malloc (strlen (token) + L + 3);      strcpy (p2, token);      strcat (p2, ""/"");      strcat (p2, cmd);      result = (0 == stat (p2, &st));      free (p2);      if (result)        goto DONE;      token = strtok (0, "":"");    } DONE:  free (cmd);  if (path) free (path);  return result;}",2,"cwe120,cweother"
"""ComputerMatch(BYTE a,BYTE b){    int i,t;    WORD gol_a=0,gol_b=0,attacco_a,attacco_b,centro_a,centro_b,difesa_a,difesa_b;    difesa_a=CalcolaPotenza(&teamlist[a],P_DIFESA);    centro_a=CalcolaPotenza(&teamlist[a],P_CENTRO);    attacco_a=CalcolaPotenza(&teamlist[a],P_ATTACCO);    difesa_b=CalcolaPotenza(&teamlist[b],P_DIFESA);    centro_b=CalcolaPotenza(&teamlist[b],P_CENTRO);    attacco_b=CalcolaPotenza(&teamlist[b],P_ATTACCO);/* In campionati e coppe con andata e ritorno chi e' in casa ha un bonus di 1/5 della   sua potenza reale */    if( (competition==MENU_LEAGUE || competition==MENU_MATCHES) &&i_scontri>1)    {        difesa_a*=6;        difesa_a/=5;        centro_a*=6;        centro_a/=5;        attacco_a*=6;        attacco_a/=5;    }    for(i=0;i<90;i++)    {        t=centro_a-centro_b+RangeRand(201)-100;        if(gol_a>4||gol_b>4)            t=t*2/3;        else if(gol_a>2||gol_b>2)            t=t*3/4;        if(t>50)        {            t=attacco_a-difesa_b+RangeRand(81);            if(t>40)            {                gol_a++;                attacco_a-=5;                centro_a-=5;                difesa_a-=5;            }        }        else if(t<-50)        {            t=attacco_b-difesa_a+RangeRand(81);            if(t>40)            {                gol_b++;                attacco_b-=5;                centro_b-=5;                difesa_b-=5;            }        }    }    i=max(gol_a,gol_b);    while(i>7)    {        i=i*2/3;        gol_a=gol_a*2/3;        gol_b=gol_b*2/3;    }    while(gol_a>2&&gol_b>2 && (RangeRand(10)>1) )    {        gol_a/=2;        gol_b/=2;    }    if(RangeRand(10)>3 && (gol_a>4 || gol_b>4) )    {        gol_a=gol_a/2;        gol_b=gol_b/2;            }    if(abs(gol_a-gol_b)>3 && RangeRand(10)>3)    {        gol_a/=2;        gol_b/=2;    }    if(nopari&&gol_a==gol_b)    {        if(RangeRand(2))            gol_b+=1;        else            gol_a+=1;    }    return (WORD) (gol_a | (gol_b<<8) );}""",2,"cwe119,cwe120"
"cmdline_add_elfcorehdr(char *cmdline, unsigned long addr){tint cmdlen, len, align = 1024;tchar str[30], *ptr;t tif (addr%align)ttreturn -1;taddr = addr/align;tptr = str;tstrcpy(str, "" elfcorehdr="");tptr += strlen(str);tultoa(addr, ptr);tstrcat(str, ""K"");tlen = strlen(str);tcmdlen = strlen(cmdline) + len;tif (cmdlen > (COMMAND_LINE_SIZE - 1))ttdie(""Command line overflow"");tstrcat(cmdline, str);#ifdef DEBUGttprintf(""Command line after adding elfcorehdr"");ttprintf(""%s"", cmdline);#endiftreturn 0;}",2,"cwe119,cwe120"
"test_buffer_seek(tst_case *tc, void *data){    int i;    Store *store = (Store *)data;    OutStream *ostream = store->new_output(store, ""rw_seek.test"");    char text[60] = ""This is another int test string !@#$%#$%&%$*%^&*()(_"";    InStream *istream;    for (i = 0; i < 1000; i++) {        os_write_i64(ostream, i);        os_write_string(ostream, text);    }    os_seek(ostream, 987);    Aiequal(987, os_pos(ostream));    os_write_vint(ostream, 555);    os_seek(ostream, 56);    Aiequal(56, os_pos(ostream));    os_write_vint(ostream, 12345);    os_seek(ostream, 4000);    Aiequal(4000, os_pos(ostream));    os_write_voff_t(ostream, 98763210);    os_close(ostream);    istream = store->open_input(store, ""rw_seek.test"");    is_seek(istream, 56);    Aiequal(56, is_pos(istream));    Aiequal(12345, is_read_vint(istream));    is_seek(istream, 4000);    Aiequal(4000, is_pos(istream));    Aiequal(98763210, is_read_voff_t(istream));    is_seek(istream, 987);    Aiequal(987, is_pos(istream));    Aiequal(555, is_read_vint(istream));    is_close(istream);}",2,"cwe119,cwe120"
"ConnectToTCM(char *nick, struct Botlist *bptr){tchar sendstr[MAXLINE + 1];tstruct Luser *lptr;tstruct DccUser *dccptr, *nptr, *tmp;tif (!nick)t{tt ttnptr = NULL;t}telsettif (!(nptr = IsOnDcc(nick)))tttreturn 0;tdccptr = (struct DccUser *) MyMalloc(sizeof(struct DccUser));tdccptr->socket = ConnectHost(bptr->hostname, bptr->port);tif (dccptr->socket == -1)t{ttSendUmode(OPERUMODE_B,tt          ""*** Unable to connect to tcm %s [%s:%d]: %s"",tt          bptr->name,tt          bptr->hostname,tt          bptr->port,tt          strerror(errno));ttif (nptr)tt{tttircsprintf(sendstr, ""Unable to connect to port %d of %s: %sr"",ttt           bptr->port, bptr->hostname, strerror(errno));tttwritesocket(nptr->socket, sendstr);tt}ttMyFree(dccptr);ttreturn (0);t}t tircsprintf(sendstr, ""%s %s %sr"",t           bptr->name, n_OperServ, bptr->password);twritesocket(dccptr->socket, sendstr);tdccptr->flags = (SOCK_TCMBOT | SOCK_BOTHUB);tdccptr->authfd = NOSOCKET;tdccptr->nick = MyStrdup(bptr->name);tlptr = FindClient(dccptr->nick);  tif (!lptr)t{tt ttdccptr->username = MyStrdup(""unknown"");ttircsprintf(sendstr, ""%s:%d"", bptr->hostname, bptr->port);ttdccptr->hostname = MyStrdup(sendstr);t}telse  t{ttdccptr->username = MyStrdup(lptr->username);ttdccptr->hostname = MyStrdup(lptr->hostname);t}tLinkDccClient(dccptr);t tfor (tmp = connections; tmp; tmp = tmp->next)t{ttif (!IsAuth(tmp))tttcontinue;ttif (tmp == dccptr)tttcontinue;ttif (tmp->flags & SOCK_TCMBOT)tt{tttircsprintf(sendstr, ""(%s) Linked to %s [%s@%s]r"",ttt           n_OperServ, bptr->name, dccptr->username, dccptr->hostname);tttwritesocket(tmp->socket, sendstr);tt}ttelsett{tttircsprintf(sendstr, ""*** Linked to %s [%s@%s]r"",ttt           bptr->name, dccptr->username, dccptr->hostname);tttwritesocket(tmp->socket, sendstr);tt}t}treturn (1);}",2,"cwe119,cwe120"
"client3_1_inodelk (call_frame_t *frame, xlator_t *this,                   void *data){        clnt_conf_t      *conf     = NULL;        clnt_args_t      *args    = NULL;        gfs3_inodelk_req  req     = {{0,},};        int               ret     = 0;        int32_t           gf_cmd  = 0;        int32_t           gf_type = 0;        int               op_errno = ESTALE;        if (!frame || !this || !data)                goto unwind;        args = data;        if (!(args->loc && args->loc->inode))                goto unwind;        if (!uuid_is_null (args->loc->inode->gfid))                memcpy (req.gfid,  args->loc->inode->gfid, 16);        else                memcpy (req.gfid, args->loc->gfid, 16);        GF_ASSERT_AND_GOTO_WITH_ERROR (this->name,                                       !uuid_is_null (*((uuid_t*)req.gfid)),                                       unwind, op_errno, EINVAL);        if (args->cmd == F_GETLK || args->cmd == F_GETLK64)                gf_cmd = GF_LK_GETLK;        else if (args->cmd == F_SETLK || args->cmd == F_SETLK64)                gf_cmd = GF_LK_SETLK;        else if (args->cmd == F_SETLKW || args->cmd == F_SETLKW64)                gf_cmd = GF_LK_SETLKW;        else {                gf_log (this->name, GF_LOG_WARNING,                        ""Unknown cmd (%d)!"", gf_cmd);                op_errno = EINVAL;                goto unwind;        }        switch (args->flock->l_type) {        case F_RDLCK:                gf_type = GF_LK_F_RDLCK;                break;        case F_WRLCK:                gf_type = GF_LK_F_WRLCK;                break;        case F_UNLCK:                gf_type = GF_LK_F_UNLCK;                break;        }        req.path   = (char *)args->loc->path;        req.volume = (char *)args->volume;        req.cmd    = gf_cmd;        req.type   = gf_type;        gf_proto_flock_from_flock (&req.flock, args->flock);        conf = this->private;        ret = client_submit_request (this, &req, frame, conf->fops,                                     GFS3_OP_INODELK,                                     client3_1_inodelk_cbk, NULL,                                     NULL, 0, NULL, 0,                                     NULL, (xdrproc_t)xdr_gfs3_inodelk_req);        if (ret) {                op_errno = ENOTCONN;                goto unwind;        }        return 0;unwind:        gf_log (this->name, GF_LOG_WARNING, ""failed to send the fop: %s"", strerror (op_errno));        STACK_UNWIND_STRICT (inodelk, frame, -1, op_errno);        return 0;}",2,"cwe120,cwe476"
"_gc_orient(E_Gadcon_Client *gcc, E_Gadcon_Orient orient __UNUSED__) {   Instance *inst;   int mw, mh, xw, xh;   inst = gcc->data;   edje_object_size_min_get(inst->obj, &mw, &mh);   edje_object_size_max_get(inst->obj, &xw, &xh);   if ((mw < 1) || (mh < 1))     edje_object_size_min_calc(inst->obj, &mw, &mh);   if (mw < 4) mw = 4;   if (mh < 4) mh = 4;   if ((xw > 0) && (xh > 0))     e_gadcon_client_aspect_set(gcc, xw, xh);   e_gadcon_client_min_size_set(gcc, mw, mh);}",2,"cwe119,cwe120"
"archinfo_show_mainhead(carchreader *ai, cdico *dicomainhead){    char buffer[256];        if (!ai || !dicomainhead)    {   errprintf(""a parameter is null"");        return -1;    }        msgprintf(MSG_FORCE, ""====================== archive information ======================"");    msgprintf(MSG_FORCE, ""Archive type: ttt%s"", (ai->archtype==ARCHTYPE_FILESYSTEMS)?""filesystems"":""flat files"");    if ((ai->archtype==ARCHTYPE_FILESYSTEMS))        msgprintf(0, ""Filesystems count: tt%ld"", (long)ai->fscount);    msgprintf(MSG_FORCE, ""Archive id: ttt%.8x"", (unsigned int)ai->archid);    msgprintf(MSG_FORCE, ""Archive file format: tt%s"", ai->filefmt);    msgprintf(MSG_FORCE, ""Archive created with: tt%s"", ai->creatver);    msgprintf(MSG_FORCE, ""Archive creation date: tt%s"", format_time(buffer, sizeof(buffer), ai->creattime));    msgprintf(MSG_FORCE, ""Archive label: ttt%s"", ai->label);    if (ai->minfsaver > 0)          msgprintf(MSG_FORCE, ""Minimum fsarchiver version:t%d.%d.%d.%d"", (int)FSA_VERSION_GET_A(ai->minfsaver),             (int)FSA_VERSION_GET_B(ai->minfsaver), (int)FSA_VERSION_GET_C(ai->minfsaver), (int)FSA_VERSION_GET_D(ai->minfsaver));    msgprintf(MSG_FORCE, ""Compression level: tt%d (%s level %d)"", ai->fsacomp, compalgostr(ai->compalgo), ai->complevel);    msgprintf(MSG_FORCE, ""Encryption algorithm: tt%s"", cryptalgostr(ai->cryptalgo));    msgprintf(MSG_FORCE, """");        return 0;}",2,"cwe119,cwe120"
"cliPlayerList_connected(CliPlayerList *pl, const char *buf)  {  char  name[50], rank[50];  int  args, i, playerNum;  CliPlayer  *p;  args = sscanf(buf, ""{%s [ %[^]]"", name, rank);  if (args != 2)  {    if (!pl->elfBugReported)  {      pl->elfBugReported = TRUE;      cgoban_createMsgWindow(pl->data->cg, ""Cgoban Error"",ttt     msg_gameBadElf);    }    return;  }  assert(args == 2);  for (i = strlen(rank);  i && (rank[i - 1] == ' ');  --i);  rank[i] = '0';  playerNum = cliPlayerList_lookupPlayer(pl, name);  if (playerNum == -1)  {    for (playerNum = pl->sortEnd;  playerNum < pl->maxPlayers;  ++playerNum)  {      if (pl->players[playerNum].state == cliPlayer_noPlayer)tbreak;    }    expandPlayers(pl, playerNum);    p = &pl->players[playerNum];    p->state = cliPlayer_unknown;    str_copyChars(&p->name, name);    str_copyChars(&p->rank, rank);    str_copyChars(&p->idleTime, """");    p->gameIn = -1;    p->gameOb = -1;    redrawLine(pl, playerNum);  }}",3,"cwe119,cwe120,cweother"
"pushline(lua_State *L, bool firstline, GT_UNUSED GetLine *gl) {  char buffer[BUFSIZ];  char *b = buffer;  size_t l;  const char *prmt = get_prompt(L, firstline);#ifdef CURSES  if (!(b = gl_get_line(gl, prmt, NULL, 0)))    return 0;  #else  b = buffer;    fputs(prmt, stdout); fflush(stdout);   if (!fgets(b, BUFSIZ, stdin))       return 0;  #endif  l = strlen(b);  if (l > 0 && b[l-1] == '')       b[l-1] = '0';     if (firstline && b[0] == '=')       lua_pushfstring(L, ""return %s"", b+1);     else    lua_pushstring(L, b);  return 1;}",2,"cwe119,cwe120"
"progress_unknown(long sofar, long bps){tif(PROGRESS_CAN_SHOW()){ttstatic int i = 0;ttchar buf[2][64];ttfprintf(stderr, ""r%s %s %c..."",ttttbytes_to_str(buf[0], sizeof buf[0], sofar),ttttbytes_to_str(buf[1], sizeof buf[1], bps),tttt""/-|""[i++ % 4]);t}}",2,"cwe119,cwe120"
"parse_wccp2_service(void *v){    char *t;    int service = 0;    int service_id = 0;    int security_type = WCCP2_NO_SECURITY;    char wccp_password[WCCP2_PASSWORD_LEN + 1];    if (wccp2_connected == 1) {tdebug(80, 1) (""WCCPv2: Somehow reparsing the configuration ""t    ""without having shut down WCCP! Try reloading squid again."");treturn;    }         if ((t = strtok(NULL, w_space)) == NULL) {tdebug(80, 0) (""parse_wccp2_service: missing service info type (standard|dynamic)"");tself_destruct();    }    if (strcmp(t, ""standard"") == 0) {tservice = WCCP2_SERVICE_STANDARD;    } else if (strcmp(t, ""dynamic"") == 0) {tservice = WCCP2_SERVICE_DYNAMIC;    } else {tdebug(80, 0) (""parse_wccp2_service: bad service info type (expected standard|dynamic, got %s)"", t);tself_destruct();    }         service_id = GetInteger();    if (service_id < 0 || service_id > 255) {tdebug(80, 0) (""parse_wccp2_service: service info id %d is out of range (0..255)"", service_id);tself_destruct();    }    memset(wccp_password, 0, sizeof(wccp_password));         if ((t = strtok(NULL, w_space)) != NULL) {tif (strncmp(t, ""password="", 9) == 0) {t    security_type = WCCP2_MD5_SECURITY;t    strncpy(wccp_password, t + 9, WCCP2_PASSWORD_LEN);t}    }         wccp2_add_service_list(service, service_id, 0, 0, 0, empty_portlist, security_type, wccp_password);}",4,"cwe119,cwe120,cwe476,cweother"
"ssl_debug(void){tintte;tcharterrmsg[SMALLBUF];twhile ((e = ERR_get_error()) != 0) {ttERR_error_string_n(e, errmsg, sizeof(errmsg));ttupsdebugx(1, ""ssl_debug: %s"", errmsg);t}}",2,"cwe119,cwe120"
"simple_object_xcoff_write_filehdr (simple_object_write *sobj, int descriptor,tttt  unsigned int nscns, size_t symtab_offset,tttt  unsigned int nsyms, const char **errmsg,tttt  int *err){  struct simple_object_xcoff_attributes *attrs =    (struct simple_object_xcoff_attributes *) sobj->data;  int u64 = attrs->magic == U64_TOCMAGIC;  unsigned char hdrbuf[sizeof (struct external_filehdr)];  unsigned char *hdr;  void (*set_16) (unsigned char *, unsigned short);  void (*set_32) (unsigned char *, unsigned int);  void (*set_64) (unsigned char *, ulong_type);  hdr = &hdrbuf[0];  set_16 = simple_object_set_big_16;  set_32 = simple_object_set_big_32;  set_64 = simple_object_set_big_64;  memset (hdr, 0, sizeof (struct external_filehdr));  set_16 (hdr + offsetof (struct external_filehdr, f_magic), attrs->magic);  set_16 (hdr + offsetof (struct external_filehdr, f_nscns), nscns);     if (u64)    {      set_64 (hdr + offsetof (struct external_filehdr, u.xcoff64.f_symptr),t      symtab_offset);      set_32 (hdr + offsetof (struct external_filehdr, u.xcoff64.f_nsyms),t      nsyms);             set_16 (hdr + offsetof (struct external_filehdr, u.xcoff64.f_flags),t      attrs->flags);    }  else    {      set_32 (hdr + offsetof (struct external_filehdr, u.xcoff64.f_symptr),t      symtab_offset);      set_32 (hdr + offsetof (struct external_filehdr, u.xcoff64.f_nsyms),t      nsyms);             set_16 (hdr + offsetof (struct external_filehdr, u.xcoff64.f_flags),t      attrs->flags);    }  return simple_object_internal_write (descriptor, 0, hdrbuf,tttt       sizeof (struct external_filehdr),tttt       errmsg, err);}",2,"cwe119,cwe120"
"iwl_dbgfs_echo_test_write(struct file *file,tttttconst char __user *user_buf,tttttsize_t count, loff_t *ppos){tstruct iwl_priv *priv = file->private_data;tchar buf[8];tint buf_size;tmemset(buf, 0, sizeof(buf));tbuf_size = min(count, sizeof(buf) -  1);tif (copy_from_user(buf, user_buf, buf_size))ttreturn -EFAULT;tiwl_cmd_echo_test(priv);treturn count;}",2,"cwe119,cwe120"
"start_gv(char **progtorun, char *toname,tt     bool asgeom, enum streamtype pipetype){  char *args[1024];  int i;  static const char Mprefix[] = ""/tmp/geomview/"";  char Mhow[] = ""-Mcsin6"";  signal(SIGALRM, interrupt);  for (i=0; progtorun[i] != NULL; i++)    args[i] = progtorun[i];  Mhow[2] = asgeom ? 'g' : 'c';  switch (pipetype) {  case namedpipe: Mhow[3] = 'p'; Mhow[4] = '0'; break;  case unixsocket: Mhow[3] = 's'; Mhow[4] = '0'; break;  case inetsocket: strcpy(Mhow+3, ""sin""); break;  case inet6socket: strcpy(Mhow+3, ""sin6""); break;  default: break;  }  args[i++] = Mhow;#if HAVE_INET_SOCKETS || HAVE_INET6_SOCKETS  if (pipetype == inetsocket || pipetype == inet6socket) {    if ((toname = strrchr(toname, ':')) == NULL) {      toname = DFLT_PORT_STR;    } else {      ++toname;    }    args[i++] = toname;  } else#endif    args[i++] = strncmp(toname, Mprefix, sizeof(Mprefix)-1) != 0      ? toname : toname + sizeof(Mprefix)-1;  args[i] = NULL;    if (fork() == 0) {    close(0);#if SETPGRP_VOID    setpgrp();#else    setpgrp(0,getpid());#endif    execvp(progtorun[0], &args[0]);    execvp(""gv"", &args[0]);    perror(""Couldn't exec geomview nor gv"");    kill(getppid(), SIGALRM);    _exit(1);  }}",3,"cwe119,cwe120,cweother"
"is_locked(char * directory){  FILE * fp;  char filename[STRING_BLOCK];  int locked = 0;  sprintf((char*)filename,""%s/settings.txt.bfe"",directory);  fp = fopen(filename,""r"");  if (fp!=0) {    locked = 1;    fclose(fp);  }  if (locked==0) {    sprintf((char*)filename,""%s/current.sqlite3.bfe"",directory);    fp = fopen(filename,""r"");    if (fp!=0) {      locked = 1;      fclose(fp);    }  }  return locked;}",3,"cwe119,cwe120,cweother"
"getConstraints(TableInfo tblinfo[], int numTables){tintttti,ttttj;tConstraintInfo *constrinfo;tPQExpBuffer query;tPGresult   *res;tintttti_contableoid,tttti_conoid,tttti_conname,tttti_confrelid,tttti_condef;tinttttntups;t tif (g_fout->remoteVersion < 70300)ttreturn;tquery = createPQExpBuffer();tfor (i = 0; i < numTables; i++)t{ttTableInfo  *tbinfo = &tblinfo[i];ttif (!tbinfo->hastriggers || !tbinfo->dobj.dump)tttcontinue;ttif (g_verbose)tttwrite_msg(NULL, ""reading foreign key constraints for table ""%s"""",ttttt  tbinfo->dobj.name);tt ttselectSourceSchema(tbinfo->dobj.namespace->dobj.name);ttresetPQExpBuffer(query);ttappendPQExpBuffer(query,tttttt  ""SELECT tableoid, oid, conname, confrelid, ""tttttt  ""pg_catalog.pg_get_constraintdef(oid) AS condef ""tttttt  ""FROM pg_catalog.pg_constraint ""tttttt  ""WHERE conrelid = '%u'::pg_catalog.oid ""tttttt  ""AND contype = 'f'"",tttttt  tbinfo->dobj.catId.oid);ttres = PQexec(g_conn, query->data);ttcheck_sql_result(res, g_conn, query->data, PGRES_TUPLES_OK);ttntups = PQntuples(res);tti_contableoid = PQfnumber(res, ""tableoid"");tti_conoid = PQfnumber(res, ""oid"");tti_conname = PQfnumber(res, ""conname"");tti_confrelid = PQfnumber(res, ""confrelid"");tti_condef = PQfnumber(res, ""condef"");ttconstrinfo = (ConstraintInfo *) malloc(ntups * sizeof(ConstraintInfo));ttfor (j = 0; j < ntups; j++)tt{tttconstrinfo[j].dobj.objType = DO_FK_CONSTRAINT;tttconstrinfo[j].dobj.catId.tableoid = atooid(PQgetvalue(res, j, i_contableoid));tttconstrinfo[j].dobj.catId.oid = atooid(PQgetvalue(res, j, i_conoid));tttAssignDumpId(&constrinfo[j].dobj);tttconstrinfo[j].dobj.name = strdup(PQgetvalue(res, j, i_conname));tttconstrinfo[j].dobj.namespace = tbinfo->dobj.namespace;tttconstrinfo[j].contable = tbinfo;tttconstrinfo[j].condomain = NULL;tttconstrinfo[j].contype = 'f';tttconstrinfo[j].condef = strdup(PQgetvalue(res, j, i_condef));tttconstrinfo[j].confrelid = atooid(PQgetvalue(res, j, i_confrelid));tttconstrinfo[j].conindex = 0;tttconstrinfo[j].conislocal = true;tttconstrinfo[j].separate = true;tt}ttPQclear(res);t}tdestroyPQExpBuffer(query);}",2,"cwe120,cweother"
"get_sha1_mb(const char *name, unsigned char *sha1){tstruct commit *one, *two;tstruct commit_list *mbs;tunsigned char sha1_tmp[20];tconst char *dots;tint st;tdots = strstr(name, ""..."");tif (!dots)ttreturn get_sha1(name, sha1);tif (dots == name)ttst = get_sha1(""HEAD"", sha1_tmp);telse {ttstruct strbuf sb;ttstrbuf_init(&sb, dots - name);ttstrbuf_add(&sb, name, dots - name);ttst = get_sha1(sb.buf, sha1_tmp);ttstrbuf_release(&sb);t}tif (st)ttreturn st;tone = lookup_commit_reference_gently(sha1_tmp, 0);tif (!one)ttreturn -1;tif (get_sha1(dots[3] ? (dots + 3) : ""HEAD"", sha1_tmp))ttreturn -1;ttwo = lookup_commit_reference_gently(sha1_tmp, 0);tif (!two)ttreturn -1;tmbs = get_merge_bases(one, two, 1);tif (!mbs || mbs->next)ttst = -1;telse {ttst = 0;tthashcpy(sha1, mbs->item->object.sha1);t}tfree_commit_list(mbs);treturn st;}",2,"cwe119,cwe120"
"glusterd_handle_quota (rpcsvc_request_t *req){        int32_t                         ret = -1;        gf_cli_req                      cli_req = {{0,}};        dict_t                         *dict = NULL;        glusterd_op_t                   cli_op = GD_OP_QUOTA;        char                            operation[256] = {0, };        char                           *volname = NULL;        int32_t                         type = 0;        GF_ASSERT (req);        if (!xdr_to_generic (req->msg[0], &cli_req,                             (xdrproc_t)xdr_gf_cli_req)) {                                 req->rpc_err = GARBAGE_ARGS;                goto out;        }        if (cli_req.dict.dict_len) {                                 dict  = dict_new ();                ret = dict_unserialize (cli_req.dict.dict_val,                                        cli_req.dict.dict_len,                                        &dict);                if (ret < 0) {                        gf_log (""glusterd"", GF_LOG_ERROR, ""failed to ""                                    ""unserialize req-buffer to dictionary"");                        goto out;                } else {                        dict->extra_stdfree = cli_req.dict.dict_val;                }        }        ret = dict_get_str (dict, ""volname"", &volname);        if (ret) {                gf_log ("""", GF_LOG_WARNING, ""Unable to get volume name, while""                        ""handling quota command"");                goto out;        }        ret = dict_get_int32 (dict, ""type"", &type);        if (ret) {                gf_log ("""", GF_LOG_WARNING, ""Unable to get type of cmd. , while""                        ""handling quota command"");                goto out;        }        switch (type) {        case GF_QUOTA_OPTION_TYPE_ENABLE:                strncpy (operation, ""enable"", sizeof (operation));                break;        case GF_QUOTA_OPTION_TYPE_DISABLE:                strncpy (operation, ""disable"", sizeof (operation));                break;        case GF_QUOTA_OPTION_TYPE_LIMIT_USAGE:                strncpy (operation, ""limit-usage"", sizeof (operation));                break;        case GF_QUOTA_OPTION_TYPE_REMOVE:                strncpy (operation, ""remove"", sizeof (operation));                break;        }        gf_cmd_log (""volume quota"", "" %s command on %s"", operation, volname);        ret = glusterd_op_begin (req, GD_OP_QUOTA, dict);        gf_cmd_log (""volume quota"", "" %s command on %s %s"", operation,volname,                    (ret != 0)? ""FAILED"" : ""SUCCEEDED"");out:        glusterd_friend_sm ();        glusterd_op_sm ();        if (ret) {                if (dict)                        dict_unref (dict);                ret = glusterd_op_send_cli_response (cli_op, ret, 0, req,                                                     NULL, ""operation failed"");        }        return ret;}",3,"cwe119,cwe120,cwe476"
"SetClassTemplateArgs(struct Specifier * spec, struct __ecereNameSpace__ecere__sys__OldList * templateArgs){if(spec->type == 1){struct Symbol * symbol = spec->symbol;spec->templateArgs = templateArgs;if(templateArgs && templateArgs->first){char templateString[1024];struct TemplateArgument * arg;strcpy(templateString, symbol ? symbol->string : spec->name);strcat(templateString, ""<"");for(arg = templateArgs->first; arg; arg = arg->next){char argument[256];argument[0] = '0';switch(arg->type){case 2:{char expString[1024];struct __ecereNameSpace__ecere__com__Class * backupThisClass = thisClass;thisClass = (((void *)0));expString[0] = '0';PrintExpression(arg->expression, expString);strcat(argument, expString);thisClass = backupThisClass;break;}case 1:{strcat(argument, arg->identifier->string);break;}case 0:{char * typeString = StringFromSpecDecl(arg->templateDatatype->specifiers, arg->templateDatatype->decl);strcat(argument, typeString);(__ecereNameSpace__ecere__com__eSystem_Delete(typeString), typeString = 0);break;}}if(argument[0]){if(arg->prev)strcat(templateString, "", "");if(arg->name){strcat(templateString, arg->name->string);strcat(templateString, "" = "");}strcat(templateString, argument);}}{int len = strlen(templateString);if(templateString[len - 1] == '>')templateString[len++] = ' ';templateString[len++] = '>';templateString[len++] = '0';}symbol = FindClass(templateString);if(!symbol && spec->symbol){symbol = _DeclClass((((int)0x7fffffff)), templateString);}if(spec->symbol)__ecereMethod___ecereNameSpace__ecere__sys__OldList_Add(&spec->symbol->templatedClasses, __extension__ ({struct __ecereNameSpace__ecere__sys__OldLink * __ecereInstance1 = __ecereNameSpace__ecere__com__eSystem_New0(24);__ecereInstance1->data = symbol, __ecereInstance1;}));(__ecereNameSpace__ecere__com__eSystem_Delete(spec->name), spec->name = 0);spec->symbol = symbol;spec->name = __ecereFunction___ecereNameSpace__ecere__sys__CopyString(symbol ? symbol->string : templateString);}}elseFreeList(templateArgs, FreeTemplateArgument);}",2,"cwe119,cwe120"
"print_ipv4(FILE *f, const struct tc_u32_key *key){tchar abuf[256];tswitch (key->off) {tcase 0:ttswitch (ntohl(key->mask)) {ttcase 0x0f000000:tttfprintf(f, ""  match IP ihl %u"", ntohl(key->val) >> 24);tttreturn;ttcase 0x00ff0000:tttfprintf(f, ""  match IP dsfield %#x"", ntohl(key->val) >> 16);tttreturn;tt}ttbreak;tcase 8:ttif (ntohl(key->mask) == 0x00ff0000) {tttfprintf(f, ""  match IP protocol %d"", ntohl(key->val) >> 16);tttreturn;tt}ttbreak;tcase 12:tcase 16: {tttint bits = mask2bits(key->mask);tttif (bits >= 0) {ttttfprintf(f, ""  %s %s/%d"", tttttkey->off == 12 ? ""match IP src"" : ""match IP dst"",tttttinet_ntop(AF_INET, &key->val,tttttt  abuf, sizeof(abuf)),tttttbits);ttttreturn;ttt}tt}ttbreak;tcase 20:ttswitch (ntohl(key->mask)) {ttcase 0x0000ffff:tttfprintf(f, ""  match dport %u"",ttttntohl(key->val) & 0xffff);tttreturn;ttcase 0xffff0000:tttfprintf(f, ""  match sport %u"",ttttntohl(key->val) >> 16);tttreturn;ttcase 0xffffffff:tttfprintf(f, ""  match dport %u, match sport %u"",ttttntohl(key->val) & 0xffff,ttttntohl(key->val) >> 16);tttreturn;tt}tt t}}",2,"cwe119,cwe120"
"glibr(){tregister struct obj *otmp;tint xfl = 0;tboolean leftfall, rightfall;tconst char *otherwep = 0;tleftfall = (uleft && !uleft->cursed &&tt    (!uwep || !welded(uwep) || !bimanual(uwep)));trightfall = (uright && !uright->cursed && (!welded(uwep)));tif (!uarmg && (leftfall || rightfall) && !nolimbs(youmonst.data)) {tt ttYour(""%s off your %s."",ttt(leftfall && rightfall) ? ""rings slip"" : ""ring slips"",ttt(leftfall && rightfall) ? makeplural(body_part(FINGER)) :tttbody_part(FINGER));ttxfl++;ttif (leftfall) {tttotmp = uleft;tttRing_off(uleft);tttdropx(otmp);tt}ttif (rightfall) {tttotmp = uright;tttRing_off(uright);tttdropx(otmp);tt}t}totmp = uswapwep;tif (u.twoweap && otmp) {ttotherwep = is_sword(otmp) ? c_sword :tt    makesingular(oclass_names[(int)otmp->oclass]);ttYour(""%s %sslips from your %s."",tttotherwep,tttxfl ? ""also "" : """",tttmakeplural(body_part(HAND)));ttsetuswapwep((struct obj *)0);ttxfl++;ttif (otmp->otyp != LOADSTONE || !otmp->cursed)tttdropx(otmp);t}totmp = uwep;tif (otmp && !welded(otmp)) {ttconst char *thiswep;tt ttthiswep = is_sword(otmp) ? c_sword :tt    makesingular(oclass_names[(int)otmp->oclass]);ttif (otherwep && strcmp(thiswep, otherwep)) otherwep = 0;tt ttYour(""%s%s %sslips from your %s."",tttotherwep ? ""other "" : """", thiswep,tttxfl ? ""also "" : """",tttmakeplural(body_part(HAND)));ttsetuwep((struct obj *)0);ttif (otmp->otyp != LOADSTONE || !otmp->cursed)tttdropx(otmp);t}}",2,"cwe119,cwe120"
"ast_cli_command_full(int uid, int gid, int fd, const char *s){tconst char *args[AST_MAX_ARGS + 1];tstruct ast_cli_entry *e;tint x;tchar *duplicate = parse_args(s, &x, args + 1, AST_MAX_ARGS, NULL);tchar tmp[AST_MAX_ARGS + 1];tchar *retval = NULL;tstruct ast_cli_args a = {tt.fd = fd, .argc = x, .argv = args+1 };tif (duplicate == NULL)ttreturn -1;tif (x < 1)t ttgoto done;tAST_RWLIST_RDLOCK(&helpers);te = find_cli(args + 1, 0);tif (e)ttast_atomic_fetchadd_int(&e->inuse, 1);tAST_RWLIST_UNLOCK(&helpers);tif (e == NULL) {ttast_cli(fd, ""No such command '%s' (type 'core show help %s' for other possible commands)"", s, find_best(args + 1));ttgoto done;t}tast_join(tmp, sizeof(tmp), args + 1);t tif (!cli_has_permissions(uid, gid, tmp)) {ttast_cli(fd, ""You don't have permissions to run '%s' command"", tmp);ttast_free(duplicate);ttreturn 0;t}t targs[0] = (char *)e;tretval = e->handler(e, CLI_HANDLER, &a);tif (retval == CLI_SHOWUSAGE) {ttast_cli(fd, ""%s"", S_OR(e->usage, ""Invalid usage, but no usage information available.""));t} else {ttif (retval == CLI_FAILURE)tttast_cli(fd, ""Command '%s' failed."", s);t}tast_atomic_fetchadd_int(&e->inuse, -1);done:tast_free(duplicate);treturn 0;}",2,"cwe119,cwe120"
"main(int argc, const char **argv){tunsigned int i, opt;tchar filename[50];t tif (argc >= 2)ttstrcpy(filename, argv[1]);telsettstrcpy(filename, ""datafile"");tavl  = NULL;t ttrie_title = trie_initialize('0');ttrie_name  = trie_initialize('0');tinit_db(filename);t tfor (i = 0; i < db.numberOfBooks; i++) {ttavl = avl_insert(&db.arr[i], avl);tttrie_title = trie_insert(db.arr[i].title, &db.arr[i], trie_title);tttrie_name  = trie_insert(db.arr[i].authors[0].last, &db.arr[i], trie_name);t}tprintf("" [1] Load books from file""ttt"" [2] Save books to file""ttt"" [3] Add a book""ttt"" [4] Delete a book by id""ttt"" [5] Display a book by id""ttt"" [6] Display a book by title""ttt"" [7] Display books""ttt"" [8] Display books by surname search""ttt"" [9] Exit"");t twhile ((opt = get_option()) != 9) {ttswitch (opt) {tttcase 1:ttttdb_dispose();ttttinit_db(filename);ttttbreak;tttcase 2:ttttprint_db(filename);ttttbreak;tttcase 3:ttttuser_add_book();ttttbreak;tttcase 4:ttttuser_remove_book();ttttbreak;tttcase 5:ttttsearch_by_id();ttttbreak;tttcase 6:ttttsearch_by_title();ttttbreak;tttcase 7:ttttprint_db(""stdout"");ttttbreak;tttcase 8:ttttsearch_by_surname();ttttbreak;tttdefault:ttttfatal(""get_option() returns something wrong"");ttttbreak;tt}t}t tprint_db(filename);tavl_dispose(avl);ttrie_dispose(trie_title);ttrie_dispose(trie_name);tdb_dispose();treturn 0;}",2,"cwe119,cwe120"
"generic_acl_save(acl_t * acl){    int     fd;    LIST   *list;    access_t *b;    char    path[_POSIX_PATH_MAX];    char    maskstr[sizeof(""/xxx.xxx.xxx.xxx"")];    char    outbuf[1024];    snprintf(path, sizeof(path), ""%s/%s"", global.shareDir, acl->name);    if(acl->list == 0)    {        unlink(path);        return 0;    }    if((fd = open(path, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR)) == -1)        return -1;    snprintf(outbuf, sizeof(outbuf), ""# DO NOT EDIT THIS FILE! - automatically generated by opennap%s"", LE);    fake_fputs(outbuf,fd);    snprintf(outbuf, sizeof(outbuf), ""# Hi Mom, We got %s!%s"", acl->name, LE);    fake_fputs(outbuf, fd);    for (list = acl->list; list; list = list->next)    {        struct in_addr in;        b = list->data;        maskstr[0] = 0;        if(b->mask != 0xffffffff)        {            in.s_addr = BSWAP32(b->mask);            snprintf(maskstr, sizeof(maskstr), ""/%s"", inet_ntoa(in));        }        in.s_addr = BSWAP32(b->ip);        snprintf(outbuf, sizeof(outbuf), ""%s%s %3d%s"", inet_ntoa(in), maskstr, b->count, LE);        fake_fputs(outbuf,fd);    }    if(close(fd))    {        logerr(""generic_acl_save"", ""close"");        return -1;    }    return 0;}",3,"cwe119,cwe120,cweother"
"jack_shmalloc (jack_shmsize_t size, jack_shm_info_t* si) {tint shmflags;tint shmid;tint rc = -1;tjack_shm_registry_t* registry;tjack_shm_lock_registry ();tif ((registry = jack_get_free_shm_info ())) {ttshmflags = 0666 | IPC_CREAT | IPC_EXCL;ttif ((shmid = shmget (IPC_PRIVATE, size, shmflags)) >= 0) {tttregistry->size = size;tttregistry->id = shmid;tttregistry->allocator = getpid();tttsi->index = registry->index;tttsi->attached_at = MAP_FAILED;  tttrc = 0;tt} else {tttjack_error (""cannot create shm segment (%s)"",tttt    strerror (errno));tt}t}tjack_shm_unlock_registry ();treturn rc;}",2,"cwe119,cwe120"
"sec80211_install ( struct net80211_crypto **which,tt       enum net80211_crypto_alg crypt,tt       const void *key, int len, const void *rsc ){tstruct net80211_crypto *crypto = *which;tstruct net80211_crypto *tbl_crypto;t tfree ( *which );t*which = NULL;tif ( crypt == NET80211_CRYPT_NONE ) {ttDBG ( ""802.11-Sec not installing null cryptography"" );ttreturn 0;t}t tfor_each_table_entry ( tbl_crypto, NET80211_CRYPTOS ) {ttif ( tbl_crypto->algorithm == crypt ) {tttcrypto = zalloc ( sizeof ( *crypto ) +ttttt  tbl_crypto->priv_len );tttif ( ! crypto ) {ttttDBG ( ""802.11-Sec out of memory"" );ttttreturn -ENOMEM;ttt}tttmemcpy ( crypto, tbl_crypto, sizeof ( *crypto ) );tttcrypto->priv = ( ( void * ) crypto +ttttt sizeof ( *crypto ) );tttbreak;tt}t}tif ( ! crypto ) {ttDBG ( ""802.11-Sec no support for cryptosystem %d"", crypt );ttreturn -ENOTSUP_CRYPT ( crypt );t}t*which = crypto;tDBG ( ""802.11-Sec installing cryptosystem %d as %p with key of ""t      ""length %d"", crypt, crypto, len );treturn crypto->init ( crypto, key, len, rsc );}",2,"cwe120,cweother"
"unix_show(struct filter *f){tFILE *fp;tchar buf[256];tchar name[128];tint  newformat = 0;tint  cnt;tstruct unixstat *list = NULL;tif (!getenv(""PROC_NET_UNIX"") && !getenv(""PROC_ROOT"")t    && unix_show_netlink(f, NULL) == 0)ttreturn 0;tif ((fp = net_unix_open()) == NULL)ttreturn -1;tfgets(buf, sizeof(buf)-1, fp);tif (memcmp(buf, ""Peer"", 4) == 0)ttnewformat = 1;tcnt = 0;twhile (fgets(buf, sizeof(buf)-1, fp)) {ttstruct unixstat *u, **insp;ttint flags;ttif (!(u = malloc(sizeof(*u))))tttbreak;ttu->name = NULL;ttif (sscanf(buf, ""%x: %x %x %x %x %x %d %s"",ttt   &u->peer, &u->rq, &u->wq, &flags, &u->type,ttt   &u->state, &u->ino, name) < 8)tttname[0] = 0;ttif (flags&(1<<16)) {tttu->state = SS_LISTEN;tt} else {tttu->state = unix_state_map[u->state-1];tttif (u->type == SOCK_DGRAM &&ttt    u->state == SS_CLOSE &&ttt    u->peer)ttttu->state = SS_ESTABLISHED;tt}ttif (!newformat) {tttu->peer = 0;tttu->rq = 0;tttu->wq = 0;tt}ttinsp = &list;ttwhile (*insp) {tttif (u->type < (*insp)->type ||ttt    (u->type == (*insp)->type &&ttt     u->ino < (*insp)->ino))ttttbreak;tttinsp = &(*insp)->next;tt}ttu->next = *insp;tt*insp = u;ttif (name[0]) {tttif ((u->name = malloc(strlen(name)+1)) == NULL)ttttbreak;tttstrcpy(u->name, name);tt}ttif (++cnt > MAX_UNIX_REMEMBER) {tttunix_list_print(list, f);tttunix_list_free(list);tttlist = NULL;tttcnt = 0;tt}t}tfclose(fp);tif (list) {ttunix_list_print(list, f);ttunix_list_free(list);ttlist = NULL;ttcnt = 0;t}treturn 0;}",3,"cwe119,cwe120,cweother"
"radutmp_zap(UNUSED rlm_radutmp_t *inst,tt       const char *filename,tt       uint32_t nasaddr,tt       time_t t){tstruct radutmptu;tintttfd;tif (t == 0) time(&t);tfd = open(filename, O_RDWR);tif (fd < 0) {ttradlog(L_ERR, ""rlm_radutmp: Error accessing file %s: %s"",tt       filename, strerror(errno));ttreturn RLM_MODULE_FAIL;t}t trad_lockfd(fd, LOCK_LEN);t twhile (read(fd, &u, sizeof(u)) == sizeof(u)) {t  if ((nasaddr != 0 && nasaddr != u.nas_address) ||t      u.type != P_LOGIN)t    continue;t   t  if (lseek(fd, -(off_t)sizeof(u), SEEK_CUR) < 0) {t    radlog(L_ERR, ""rlm_radutmp: radutmp_zap: negative lseek!"");t    lseek(fd, (off_t)0, SEEK_SET);t  }t  u.type = P_IDLE;t  u.time = t;t  write(fd, &u, sizeof(u));t}tclose(fd);t treturn 0;}",2,"cwe120,cweother"
"transform(const char *inFile,              const char *outFile,              MACRO_STRUCT *m) {  FILE *f1;  FILE *f2;  int rv;  f1=fopen(inFile, ""r"");  if (!f1) {    fprintf(stderr, ""fopen(%s, ""r""): %s"", inFile, strerror(errno));    return 2;  }  if (outFile==0) {    f2=stdout;    rv=transformF(f1, f2, ""(stdout)"", m);  }  else {    f2=fopen(outFile, ""w+"");    if (!f2) {      fprintf(stderr, ""fopen(%s, ""w+""): %s"", outFile, strerror(errno));      fclose(f1);      return 2;    }    rv=transformF(f1, f2, outFile, m);  }  if (outFile!=0) {    if (fclose(f2)) {      fprintf(stderr, ""fclose(%s): %s"", outFile, strerror(errno));      fclose(f1);      return 2;    }  }  if (fclose(f1)) {    fprintf(stderr, ""fclose(%s): %s"", inFile, strerror(errno));    return 2;  }  return rv;}",2,"cwe469,cweother"
"""skipc(FILE *fp, const char k) {    /*     * Skips chars defined by `k` (generally spaces).     * Puts the current char back into the stream.     */    int c;    if (fp == NULL)        return -1;    /* read until c isn't a space */    c = getc(fp);    while (c != EOF && c == ' ')        c = getc(fp);    ungetc(c, fp);    return 0;}""",2,"cwe120,cweother"
"ajFilelistAddPathWildDir(AjPList list,                               const AjPStr path,                               const AjPStr wildname){    ajulong oldsize;    DIR *indir;#if defined(AJ_IRIXLF)    struct dirent64 *dp;#else      struct dirent *dp;#endif      AjPStr s = NULL;    AjPStr t = NULL;    AjPStr tpath = NULL;#ifdef _POSIX_C_SOURCE    char buf[sizeof(struct dirent)+MAXNAMLEN];#endif      oldsize = ajListGetLength(list);    tpath = ajStrNew();    ajStrAssignS(&tpath,path);    if(!ajDirnameFixExists(&tpath))    {        ajStrDel(&tpath);        return 0;    }    if(!(indir=opendir(ajStrGetPtr(tpath))))    {        ajStrDel(&tpath);        return 0;    }    s = ajStrNew();    while(#if defined(AJ_IRIXLF)#ifdef _POSIX_C_SOURCE        !readdir64_r(indir,(struct dirent64 *)buf,&dp)#else          (dp=readdir64(indir))#endif  #else  #ifdef _POSIX_C_SOURCE        !readdir_r(indir,(struct dirent *)buf,&dp)#else          (dp=readdir(indir))#endif  #endif            )    {#ifdef _POSIX_C_SOURCE        if(!dp)            break;#endif  #ifndef __CYGWIN__        if(!dp->d_ino ||           !strcmp(dp->d_name,""."") ||           !strcmp(dp->d_name,""..""))            continue;#else          if(!strcmp(dp->d_name,""."") ||           !strcmp(dp->d_name,""..""))            continue;#endif          ajStrAssignS(&s,tpath);        ajStrAppendC(&s,dp->d_name);        if(ajCharMatchWildS(dp->d_name,wildname))        {            t = ajStrNewS(s);            ajListPushAppend(list,(void *)t);        }    }    closedir(indir);    ajStrDel(&s);    ajStrDel(&tpath);    return (ajuint) (ajListGetLength(list) - oldsize);}",3,"cwe119,cwe120,cwe469"
"main (int argc, char **argv){  uint_t err = 0;  if (argc < 2) {    err = 2;    PRINT_ERR(""not enough arguments"");    PRINT_MSG(""read a wave file as a mono vector"");    PRINT_MSG(""usage: %s <source_path> [samplerate] [hop_size]"", argv[0]);    PRINT_MSG(""examples:"");    PRINT_MSG("" - read file.wav at original samplerate"");    PRINT_MSG(""       %s file.wav"", argv[0]);    PRINT_MSG("" - read file.wav at 32000Hz"");    PRINT_MSG(""       %s file.aif 32000"", argv[0]);    PRINT_MSG("" - read file.wav at original samplerate with 4096 blocks"");    PRINT_MSG(""       %s file.wav 0 4096 "", argv[0]);    return err;  }#if __APPLE__  uint_t samplerate = 0;  uint_t hop_size = 256;  uint_t n_frames = 0, read = 0;  if ( argc == 3 ) samplerate = atoi(argv[2]);  if ( argc == 4 ) hop_size = atoi(argv[3]);  char_t *source_path = argv[1];  aubio_source_apple_audio_t * s =    new_aubio_source_apple_audio(source_path, samplerate, hop_size);  if (!s) { err = 1; goto beach; }  fvec_t *vec = new_fvec(hop_size);  if (samplerate == 0 ) samplerate = aubio_source_apple_audio_get_samplerate(s);  do {    aubio_source_apple_audio_do(s, vec, &read);    fvec_print (vec);    n_frames += read;  } while ( read == hop_size );  PRINT_MSG(""read %d frames at %dHz (%d blocks) from %s"", n_frames, samplerate,    n_frames / hop_size, source_path);  del_fvec (vec);  del_aubio_source_apple_audio (s);beach:#else  err = 3;  PRINT_ERR(""aubio was not compiled with aubio_source_apple_audio"");#endif    return 0;}",2,"cwe120,cweother"
"G3d_readWindow(G3D_Region * window, const char *windowName){    struct Cell_head win;    struct Key_Value *windowKeys;    char path[GPATH_MAX];    int status;    if (windowName == NULL) {tG_get_window(&win);twindow->proj = win.proj;twindow->zone = win.zone;twindow->north = win.north;twindow->south = win.south;twindow->east = win.east;twindow->west = win.west;twindow->top = win.top;twindow->bottom = win.bottom;twindow->rows = win.rows3;twindow->cols = win.cols3;twindow->depths = win.depths;twindow->ns_res = win.ns_res3;twindow->ew_res = win.ew_res3;twindow->tb_res = win.tb_res;    }    else {tG3d_getFullWindowPath(path, windowName);tif (access(path, R_OK) != 0) {t    G_warning(""G3d_readWindow: unable to find [%s]."", path);t    return 0;t}twindowKeys = G_read_key_value_file(path, &status);tif (status != 0) {t    G3d_error(""G3d_readWindow: Unable to open %s"", path);t    return 0;t}tif (!G3d_readWriteWindow(windowKeys, 1,tttt &(window->proj), &(window->zone),tttt &(window->north), &(window->south),tttt &(window->east), &(window->west),tttt &(window->top), &(window->bottom),tttt &(window->rows), &(window->cols),tttt &(window->depths), &(window->ew_res),tttt &(window->ns_res), &(window->tb_res))) {t    G3d_errortt(""G3d_readWindow: error extracting window key(s) of file %s"",tt path);t    return 0;t}tG_free_key_value(windowKeys);    }    return 1;}",3,"cwe119,cwe120,cweother"
"call_request_handler_if_data_is_buffered(struct connection *conn) {  struct iobuf *loc = &conn->ns_conn->recv_iobuf;  struct mg_connection *c = &conn->mg_conn;#ifndef MONGOOSE_NO_WEBSOCKET  if (conn->mg_conn.is_websocket) {    do { } while (deliver_websocket_frame(conn));  } else#endif  if ((size_t) loc->len >= c->content_len &&      call_request_handler(conn) == MG_FALSE) {    open_local_endpoint(conn, 1);  }}",2,"cwe119,cwe120"
"db_lrc_add(void *hv, char *lfn, char *pfn, char *errmsg){  db_handle_tt*h = (db_handle_t *) hv;  charttbuf[BIGBUF];  SQLINTEGERtlfn_id;  SQLINTEGERtpfn_id;  intttrc;  SQLRETURNtr;  intttadjcount[T_NUM];  if (loglevel > 1)    logit(LOG_DEBUG, ""db_lrc_add: %s %s"", lfn, pfn);  if (strlen(pfn) + 1 > MAXDBSTR) {    strncpy(errmsg, pfn, MAXERRMSG);    return GLOBUS_RLS_BADARG;  }  begintran(h, adjcount);     if ((rc = updateref(h, T_LRCLFN, lfn, 1, 0, &lfn_id, NULL,tt      errmsg, adjcount)) != GLOBUS_RLS_SUCCESS)    goto error;  if ((rc = updateref(h, T_LRCPFN, pfn, 1, 1, &pfn_id, NULL,tt      errmsg, adjcount)) != GLOBUS_RLS_SUCCESS)    goto error;     snprintf(buf, BIGBUF, ""insert into t_map (lfn_id,pfn_id) values (%d,%d)"",t   (int) lfn_id, (int) pfn_id);  r = SQLExecDirect(h->stmt, (SQLCHAR *) buf, SQL_NTS);  if (!SQLOK(r)) {    rc = seterr_insertmap(h, r, ""lfn_id"", (int) lfn_id, ""pfn_id"", (int) pfn_id,ttt  NULL, 0, errmsg);    goto error;  }  adjcount[T_LRCMAP]++;  return endtran(h, SQL_COMMIT, errmsg, adjcount);error:  endtran(h, SQL_ROLLBACK, NULL, NULL);  return rc;}",2,"cwe119,cwe120"
"NK6510_SendSMS(gn_data *data, struct gn_statemachine *state){tunsigned char req[256] = {FBUS_FRAME_HEADER, 0x02,tttt  0x00, 0x00, 0x00, 0x55, 0x55};  tgn_error error;tunsigned int pos;tmemset(req + 9, 0, 244);tpos = sms_encode(data, state, req + 9);tdprintf(""Sending SMS...(%d)"", pos + 9);tif (sm_message_send(pos + 9, NK6510_MSG_SMS, req, state)) return GN_ERR_NOTREADY;tdo {tterror = sm_block_no_retry_timeout(NK6510_MSG_SMS, state->config.smsc_timeout, data, state);t} while (!state->config.smsc_timeout && error == GN_ERR_TIMEOUT);treturn error;}",2,"cwe119,cwe120"
"main(int argc, const char* argv[]){ Proto** P,*tf; int i=doargs(argc,argv); argc-=i; argv+=i; if (argc<=0) usage(""no input files given"",NULL); L=lua_open(0); P=luaM_newvector(L,argc,Proto*); for (i=0; i<argc; i++)  P[i]=load(IS(""-"")? NULL : argv[i]); tf=combine(P,argc); if (dumping) luaU_optchunk(tf); if (listing) luaU_printchunk(tf); if (testing) luaU_testchunk(tf); if (dumping) {  if (stripping) strip(tf);  luaU_dumpchunk(tf,efopen(output,""wb"")); } return 0;}",2,"cwe469,cweother"
"get_config_entry(char * in_data, const char *section, const char *key){    char *ptr = NULL, *p, *tmp;    char *line;    int in_section = 0;    char * data = strdup(in_data);    for (line = strtok_r(data, """", &ptr); line != NULL;         line = strtok_r(NULL, """", &ptr)) {                 while (isspace((unsigned char)*line) && (*line != '0'))            line++;                 if (*line == '#') {            continue;        }                 if (*line == '[') {            line++;            p = strchr(line, ']');            if (p) {                tmp = strndup(line, p - line);                if (in_section) {                                         free(data);                    return NULL;                }                if (strcmp(section, tmp) == 0) {                    free(tmp);                    in_section = 1;                    continue;                }            }        }          p = strchr(line, '=');        if (p != NULL && in_section) {                         while (p != line && isspace((unsigned char)p[-1]))                p--;                         tmp = strndup(line, p - line);            if (strcmp(key, tmp) != 0) {                free(tmp);            } else {                free(tmp);                                 line = strchr(line, '=');                line++;                while (isspace((unsigned char)*line) && (*line != '0'))                    line++;                                 p = strchr(line, '0');                while (p != line && isspace((unsigned char)p[-1]))                    p--;                                 tmp = strndup(line, p - line);                free(data);                return tmp;            }        }    }    free(data);    return NULL;}",2,"cwe469,cweother"
"fluid_server_socket_run (void *data){    fluid_server_socket_t *server_socket = (fluid_server_socket_t *)data;    fluid_socket_t client_socket;#ifdef IPV6    struct sockaddr_in6 addr;    char straddr[INET6_ADDRSTRLEN];#else    struct sockaddr_in addr;    char straddr[INET_ADDRSTRLEN];#endif    socklen_t addrlen = sizeof (addr);    int retval;    FLUID_MEMSET((char *)&addr, 0, sizeof(addr));    FLUID_LOG (FLUID_DBG, ""Server listening for connections"");    while (server_socket->cont) {        client_socket = accept (server_socket->socket, (struct sockaddr *)&addr, &addrlen);        FLUID_LOG (FLUID_DBG, ""New client connection"");        if (client_socket == INVALID_SOCKET) {            if (server_socket->cont)                FLUID_LOG(FLUID_ERR, ""Failed to accept connection"");            server_socket->cont = 0;            return;        } else {#ifdef IPV6            inet_ntop(AF_INET6, &addr.sin6_addr, straddr, sizeof(straddr));#else            inet_ntop(AF_INET, &addr.sin_addr, straddr, sizeof(straddr));#endif            retval = server_socket->func (server_socket->data, client_socket,                                          straddr);            if (retval != 0)                fluid_socket_close(client_socket);        }    }    FLUID_LOG(FLUID_DBG, ""Server closing"");}",2,"cwe119,cwe120"
"cb_key_pressed_right_side(GtkWidget   *widget,                                           GdkEventKey *event,                                          gpointer     next_widget){       if ((event->keyval == GDK_Return) && (event->state & GDK_SHIFT_MASK)) {      gtk_signal_emit_stop_by_name(GTK_OBJECT(widget), ""key_press_event"");             cb_clist_selection(clist, clist_row_selected, 0, GINT_TO_POINTER(1), NULL);      gtk_widget_grab_focus(GTK_WIDGET(next_widget));      return TRUE;   }       if ((event->keyval == GDK_e) && (event->state & GDK_CONTROL_MASK)) {      gtk_signal_emit_stop_by_name(GTK_OBJECT(widget), ""key_press_event"");             GtkTextIter start_iter;      GtkTextIter end_iter;      char *text_out;      gtk_text_buffer_get_bounds(GTK_TEXT_BUFFER(memo_text_buffer),                                 &start_iter, &end_iter);      text_out = gtk_text_buffer_get_text(GTK_TEXT_BUFFER(memo_text_buffer),                                          &start_iter, &end_iter, TRUE);            char tmp_fname[] = ""jpilot.XXXXXX"";      int tmpfd = mkstemp(tmp_fname);      if (tmpfd < 0)      {         jp_logf(JP_LOG_WARN, _(""Could not get temporary file name""));         if (text_out)            free(text_out);         return TRUE;      }      FILE *fptr = fdopen(tmpfd, ""w"");      if (!fptr) {         jp_logf(JP_LOG_WARN, _(""Could not open temporary file for external editor""));         if (text_out)            free(text_out);         return TRUE;      }      fwrite(text_out, strlen(text_out), 1, fptr);      fwrite("""", 1, 1, fptr);      fclose(fptr);             char command[1024];      const char *ext_editor;      get_pref(PREF_EXTERNAL_EDITOR, NULL, &ext_editor);      if (!ext_editor) {         jp_logf(JP_LOG_INFO, ""External Editor command empty"");         if (text_out)            free(text_out);         return TRUE;      }      if ((strlen(ext_editor) + strlen(tmp_fname) + 1) > sizeof(command))      {         jp_logf(JP_LOG_WARN, _(""External editor command too long to execute""));         if (text_out)            free(text_out);         return TRUE;      }      g_snprintf(command, sizeof(command), ""%s %s"", ext_editor, tmp_fname);             int r = system(command);            if (!r)      {                   char text_in[0xFFFF];         size_t bytes_read;         fptr = fopen(tmp_fname, ""rb"");         if (!fptr) {            jp_logf(JP_LOG_WARN, _(""Could not open temporary file from external editor""));            return TRUE;         }         bytes_read = fread(text_in, 1, 0xFFFF, fptr);         fclose(fptr);         unlink(tmp_fname);         text_in[--bytes_read] = '0';                      if (strcmp(text_out, text_in)) {            gtk_text_buffer_set_text(GTK_TEXT_BUFFER(memo_text_buffer),                                     text_in, -1);         }      }      if (text_out)         free(text_out);      return TRUE;   }       return FALSE;}",3,"cwe119,cwe120,cweother"
"do_btrfs_fsck (const char *device, int64_t superblock, int repair){  CLEANUP_FREE char *err = NULL;  int r;  size_t i = 0;  const size_t MAX_ARGS = 64;  const char *argv[MAX_ARGS];  char super_s[64];  ADD_ARG (argv, i, str_btrfsck);     if (optargs_bitmask & GUESTFS_BTRFS_FSCK_SUPERBLOCK_BITMASK) {    if (superblock < 0) {      reply_with_error (""super block offset must be >= 0"");      return -1;    }    snprintf (super_s, sizeof super_s, ""%"" PRIi64, superblock);    ADD_ARG (argv, i, ""--super"");    ADD_ARG (argv, i, super_s);  }  if (!(optargs_bitmask & GUESTFS_BTRFS_FSCK_REPAIR_BITMASK))    repair = 0;  if (repair)    ADD_ARG (argv, i, ""--repair"");  ADD_ARG (argv, i, device);  ADD_ARG (argv, i, NULL);  r = commandv (NULL, &err, argv);  if (r == -1) {    reply_with_error (""%s: %s"", device, err);    return -1;  }  return 0;}",3,"cwe119,cwe120,cweother"
"PutJpegFile(char *s, double height0, double width0, double scale, double baseline){    FILE *fp;    char *jpg;    uint16_t buffer[2];    int m=0;    uint16_t width, height;    uint32_t w, h;    uint16_t sx, sy;    jpg = strdup_together(g_home_dir, s);    diagnostics(2, ""PutJpegFile '%s'"", jpg);    fp = fopen(jpg, ""rb"");    free(jpg);    if (fp == NULL)        return;    if (fgetc(fp) != 0xFF && fgetc(fp) != 0xD8) {        fclose(fp);        diagnostics(WARNING, ""'%s' is not really a JPEG file --- skipping"");        return;    }    do {                                 while (!feof(fp) && fgetc(fp) != 0xFF) {        }                                while (!feof(fp) && (m = fgetc(fp)) == 0xFF) {        }                            } while (!feof(fp) && m != 0xC0 && m != 0xC1 && m != 0xC2 && m != 0xC3 && m != 0xC5 && m != 0xC6 && m != 0xC7 &&      m != 0xC9 && m != 0xCA && m != 0xCB && m != 0xCD && m != 0xCE && m != 0xCF);    if (fseek(fp, 3, SEEK_CUR) || fread(buffer, 2, 2, fp) != 2) {        diagnostics(WARNING, ""Cannot read graphics file '%s'"", s);        fclose(fp);        return;    }    width = buffer[1];    height = buffer[0];    if (g_little_endian) {        width = (uint16_t) LETONS(width);        height = (uint16_t) LETONS(height);    }    diagnostics(4, ""width = %d, height = %d"", width, height);    w = (uint32_t) (100000.0 * width / (20 * POINTS_PER_METER));    h = (uint32_t) (100000.0 * height / (20 * POINTS_PER_METER));    fprintRTF(""{pictjpegblippicw%ldpich%ld"", w, h);    fprintRTF(""picwgoal%ldpichgoal%ld"", width * 20, height * 20);    AdjustScaling(height*20,width*20,height0,width0,scale,&sx,&sy);    if (sx != 100 && sy != 100)        fprintRTF(""picscalex%dpicscaley%d"", sx,sy);    rewind(fp);    PutHexFile(fp);    fprintRTF(""}"");    fclose(fp);}",2,"cwe120,cweother"
"SQLWriteFileDSN (LPCSTR lpszFileName, LPCSTR lpszAppName, LPCSTR lpszKeyName,    LPSTR lpszString){  BOOL retcode = FALSE;  char filename[1024];     CLEAR_ERROR ();     if (lpszFileName)    {      _iodbcdm_getdsnfile (lpszFileName, filename, sizeof (filename));      retcode =t  WritePrivateProfileString (lpszAppName, lpszKeyName, lpszString,t  filename);      goto quit;    }  PUSH_ERROR (ODBC_ERROR_INVALID_PATH);  goto quit;quit:  return retcode;}",2,"cwe119,cwe120"
"JimAppendStreamToString(Jim_Interp *interp, fdtype fd, Jim_Obj *strObj){    char buf[256];    FILE *fh = JimFdOpenForRead(fd);    if (fh == NULL) {        return JIM_ERR;    }    while (1) {        int retval = fread(buf, 1, sizeof(buf), fh);        if (retval > 0) {            Jim_AppendString(interp, strObj, buf, retval);        }        if (retval != sizeof(buf)) {            break;        }    }    Jim_RemoveTrailingNewline(strObj);    fclose(fh);    return JIM_OK;}",2,"cwe119,cwe120"
"define_dimension(int exoid, const char *DIMENSION, int count, const char *label, int *dimid){  char errmsg[MAX_ERR_LENGTH];  int status;  if ((status = nc_def_dim(exoid, DIMENSION, count, dimid)) != NC_NOERR) {    exerrval = status;    if (status == NC_ENAMEINUSE) {      sprintf(errmsg,              ""Error: %s variable name parameters are already defined in file id %d"",              label, exoid);      ex_err(""ex_put_all_var_param_ext"",errmsg,exerrval);    } else {      sprintf(errmsg,              ""Error: failed to define number of %s variables in file id %d"",              label, exoid);      ex_err(""ex_put_all_var_param_ext"",errmsg,exerrval);    }  }  return status;}",2,"cwe119,cwe120"
"print_attachment(int qline, long int msgno, ATTACH_S *a){    char prompt[250];    if(ps_global->restricted){        q_status_message(SM_ORDER | SM_DING, 0, 4,ttt ""Alpine demo can't Print attachments"");        return;    }    snprintf(prompt, sizeof(prompt), ""attach%s %s"",t    (a->body->type == TYPETEXT) ? ""ment"" : ""ed message"",t    MIME_DGST_A(a) ? ""digest"" : a->number);    prompt[sizeof(prompt)-1] = '0';    if(open_printer(prompt) >= 0){tif(MIME_MSG_A(a))t  (void) print_msg_att(msgno, a, 1);telse if(MIME_DGST_A(a))t  print_digest_att(msgno, a);telset  (void) decode_text(a, msgno, print_char, NULL, QStatus, FM_NOINDENT);tclose_printer();    }}",2,"cwe119,cwe120"
"""NSC_Login(CK_SESSION_HANDLE hSession, CK_USER_TYPE userType,tttt    CK_CHAR_PTR pPin, CK_ULONG ulPinLen){    SFTKSlot *slot;    SFTKSession *session;    SFTKDBHandle *handle;    CK_FLAGS sessionFlags;    SECStatus rv;    CK_RV crv;    char pinStr[SFTK_MAX_PIN+1];    PRBool tokenRemoved = PR_FALSE;    CHECK_FORK();    /* get the slot */    slot = sftk_SlotFromSessionHandle(hSession);    if (slot == NULL) {treturn CKR_SESSION_HANDLE_INVALID;    }    /* make sure the session is valid */    session = sftk_SessionFromHandle(hSession);    if (session == NULL) {treturn CKR_SESSION_HANDLE_INVALID;    }    sessionFlags = session->info.flags;    sftk_FreeSession(session);    session = NULL;    /* can't log into the Netscape Slot */    if (slot->slotID == NETSCAPE_SLOT_ID) {t return CKR_USER_TYPE_INVALID;    }    if (slot->isLoggedIn) return CKR_USER_ALREADY_LOGGED_IN;    if (!slot->needLogin) {        return ulPinLen ? CKR_PIN_INCORRECT : CKR_OK;    }    slot->ssoLoggedIn = PR_FALSE;    if (ulPinLen > SFTK_MAX_PIN) return CKR_PIN_LEN_RANGE;    /* convert to null terminated string */    PORT_Memcpy(pinStr,pPin,ulPinLen);    pinStr[ulPinLen] = 0;     handle = sftk_getKeyDB(slot);    if (handle == NULL) {t return CKR_USER_TYPE_INVALID;    }    /*     * Deal with bootstrap. We allow the SSO to login in with a NULL     * password if and only if we haven't initialized the KEY DB yet.     * We only allow this on a RW session.     */    rv = sftkdb_HasPasswordSet(handle);    if (rv == SECFailure) {t/* allow SSO's to log in only if there is not password on thet * key database */tif (((userType == CKU_SO) && (sessionFlags & CKF_RW_SESSION))t    /* fips always needs to authenticate, even if there isn't a db */ttttt|| (slot->slotID == FIPS_SLOT_ID)) {t    /* should this be a fixed password? */t    if (ulPinLen == 0) {ttsftkdb_ClearPassword(handle);    ttPZ_Lock(slot->slotLock);ttslot->isLoggedIn = PR_TRUE;ttslot->ssoLoggedIn = (PRBool)(userType == CKU_SO);ttPZ_Unlock(slot->slotLock);ttsftk_update_all_states(slot);ttcrv = CKR_OK;ttgoto done;t    }t    crv = CKR_PIN_INCORRECT;t    goto done;t} tcrv = CKR_USER_TYPE_INVALID;tgoto done;    }     /* don't allow the SSO to log in if the user is already initialized */    if (userType != CKU_USER) { tcrv = CKR_USER_TYPE_INVALID; tgoto done;    }    /* build the hashed pins which we pass around */    PR_Lock(slot->pwCheckLock);    rv = sftkdb_CheckPassword(handle,pinStr, &tokenRemoved);    if (tokenRemoved) {tsftk_CloseAllSessions(slot, PR_FALSE);    }    if ((rv != SECSuccess) && (slot->slotID == FIPS_SLOT_ID)) {tPR_Sleep(loginWaitTime);    }    PR_Unlock(slot->pwCheckLock);    if (rv == SECSuccess) {tPZ_Lock(slot->slotLock);t/* make sure the login state matches the underlyingt * database state */tslot->isLoggedIn = sftkdb_PWCached(handle) == SECSuccess ?ttPR_TRUE : PR_FALSE;tPZ_Unlock(slot->slotLock); tsftk_freeDB(handle);thandle = NULL;t/* update all sessions */tsftk_update_all_states(slot);treturn CKR_OK;    }    crv = CKR_PIN_INCORRECT;done:    if (handle) {tsftk_freeDB(handle);    }    return crv;}""",2,"cwe119,cwe120"
"expandTilde(AtomPtr filename){    char *buf;    char *home;    int len;    AtomPtr ret;    if(filename == NULL || filename->length < 1 ||       filename->string[0] != '~' || filename->string[1] != '/')        return filename;        home = getenv(""HOME"");    if(home == NULL) {        return NULL;    }    len = strlen(home);    buf = malloc(len + 1 + 1 + filename->length - 2);    if(buf == NULL) {        do_log(L_ERROR, ""Could not allocate buffer."");        return NULL;    }    memcpy(buf, home, len);    if(buf[len - 1] != '/')        buf[len++] = '/';    memcpy(buf + len, filename->string + 2, filename->length - 2);    len += filename->length - 2;    ret = internAtomN(buf, len);    free(buf);    if(ret != NULL)        releaseAtom(filename);    return ret;}",2,"cwe120,cweother"
"restrict_pam_conf(int add_del){    FILE *fp;    long file_size = 0;    char *line, *new_conf;    gchar *pam_module_off;    if((fp=fopen(PROFTPD_CONF, ""r""))==NULL)    {t         return;    }    fseek(fp, 0, SEEK_END);    file_size = ftell(fp);    rewind(fp);    line     = allocate(file_size+1);    new_conf = allocate(file_size+1024);    pam_module_off = g_strconcat("""",    ""<IfModule mod_auth_pam.c>"",    ""AuthPAM off"",    ""</IfModule>"",    NULL);    if( file_size > 1 )    while(fgets(line, file_size, fp)!=NULL)    {t tif( line!=NULL && strstr(line, ""<IfModule mod_auth_pam.c>"") && add_del == 0 )        {t    while(fgets(line, file_size, fp)!=NULL)t    if( line!=NULL && strstr(line, ""</IfModule>"") )ttbreak;t}telse  tif( line!=NULL && strstr(line, ""<IfModule mod_tls.c>"") && add_del == 1 )t{t    strcat(new_conf, pam_module_off);t    strcat(new_conf, line);t}telset  strcat(new_conf, line);    }    fclose(fp);    free(line);    g_free(pam_module_off);         if((fp=fopen(PROFTPD_CONF, ""w+""))==NULL)    {tfree(new_conf);        return;     }    fputs(new_conf, fp);    fclose(fp);    free(new_conf);}",2,"cwe120,cweother"
"git_path_is_empty_dir(const char *path){tDIR *dir = NULL;tstruct dirent *e;tbool retval = true;tif (!git_path_isdir(path)) return false;tdir = opendir(path);tif (!dir) {ttgiterr_set(GITERR_OS, ""Couldn't open '%s'"", path);ttreturn false;t}twhile ((e = readdir(dir)) != NULL) {ttif (!git_path_is_dot_or_dotdot(e->d_name)) {tttgiterr_set(GITERR_INVALID,tttttt  ""'%s' exists and is not an empty directory"", path);tttretval = false;tttbreak;tt}t}tclosedir(dir);treturn retval;}",2,"cwe119,cwe120"
"handleHook(int hook){    if (hook < 0 || hook >= ID_EVT_MAX) {        return EXIT_NOK;    }    const char* _hookNames[] = {        ""hook_init"",               ""hook_exit"",               ""hook_connect"",            ""hook_disconnect""      };    DEBUG2(""handleHook() >%d<"",hook);    char hookFile[MAXLEN];    char *t = getenv(""HOME"");    if (t) {        strcpy(hookFile, t);    } else {        strcpy(hookFile, ""."");    }        strcat(hookFile, ""/.anyRemote/"");    strcat(hookFile, _hookNames[hook]);    return loadCmds(-1, hookFile, NULL, NULL);}",3,"cwe119,cwe120,cweother"
"command_dispose(char * token, Channel * c) {    char id[256];    int err = 0;    Expression * e;    json_read_string(&c->inp, id, sizeof(id));    if (read_stream(&c->inp) != 0) exception(ERR_JSON_SYNTAX);    if (read_stream(&c->inp) != MARKER_EOM) exception(ERR_JSON_SYNTAX);    e = find_expression(id);    if (e != NULL) {        list_remove(&e->link_all);        list_remove(&e->link_id);        loc_free(e->script);        loc_free(e);    }    else {        err = ERR_INV_CONTEXT;    }    write_stringz(&c->out, ""R"");    write_stringz(&c->out, token);    write_errno(&c->out, err);    write_stream(&c->out, MARKER_EOM);}",2,"cwe119,cwe120"
"command_possess(object *op, const char *params) {    object *victim;    player *pl;    int i;    char buf[MAX_BUF];    victim = NULL;    if (*params != '0') {        if (sscanf(params, ""%d"", &i))            victim = object_find_by_tag_global(i);        else if (sscanf(params, ""%s"", buf))            victim = object_find_by_name_global(buf);    }    if (victim == NULL) {        draw_ext_info(NDI_UNIQUE, 0, op, MSG_TYPE_COMMAND, MSG_TYPE_COMMAND_ERROR,                      ""Patch what object (nr)?"");        return;    }    if (victim == op) {        draw_ext_info(NDI_UNIQUE, 0, op, MSG_TYPE_COMMAND, MSG_TYPE_COMMAND_ERROR,                      ""As insane as you are, I cannot allow you to possess yourself."");        return;    }         pl = op->contr;    victim->contr = pl;    pl->ob = victim;    victim->type = PLAYER;    SET_FLAG(victim, FLAG_WIZ);              for (i = 0; i < NUM_BODY_LOCATIONS; i++)        if (i == 1 || i == 6 || i == 8 || i == 9)            victim->body_info[i] = 2;        else            victim->body_info[i] = 1;    esrv_new_player(pl, 80);      esrv_send_inventory(victim, victim);    fix_object(victim);    do_some_living(victim);}",3,"cwe119,cwe120,cweother"
"rename_file_to_embed_crc32(struct file_info *info){tsize_t len = strlen(info->full_path);tconst char* p = info->full_path + len;tconst char* c = p - 1;tchar* new_path;tchar* insertion_point;tunsigned crc32_be;tassert((info->rctx->hash_id & RHASH_CRC32) != 0);t tif(find_embedded_crc32(info->print_path, &crc32_be)) {ttunsigned char* c =ttt(unsigned char*)rhash_get_context_ptr(info->rctx, RHASH_CRC32);ttunsigned actual_crc32 = ((unsigned)c[0] << 24) |ttt((unsigned)c[1] << 16) | ((unsigned)c[2] << 8) | (unsigned)c[3];tt ttif(crc32_be != actual_crc32) {tttchar crc32_str[9];tttrhash_print(crc32_str, info->rctx, RHASH_CRC32, RHPR_UPPERCASE);ttt tttlog_warning(_(""wrong embedded CRC32, should be %s""), crc32_str);tt} else return 0;t}t tfor(; c >= info->full_path && !IS_PATH_SEPARATOR(*c); c--) {ttif(*c == '.') {tttp = c;tttbreak;tt}t}t tnew_path = (char*)rsh_malloc(len + 12);tinsertion_point = new_path + (p - info->full_path);tmemcpy(new_path, info->full_path, p - info->full_path);tif(opt.embed_crc_delimiter && *opt.embed_crc_delimiter) *(insertion_point++) = *opt.embed_crc_delimiter;trhash_print(insertion_point+1, info->rctx, RHASH_CRC32, RHPR_UPPERCASE);tinsertion_point[0] = '[';tinsertion_point[9] = ']';  tstrcpy(insertion_point + 10, p);  t tif(rename(info->full_path, new_path) < 0) {ttlog_error(_(""can't move %s to %s: %s""), info->full_path, new_path,tttstrerror(errno));ttfree(new_path);ttreturn -1;t}t tif(info->print_path >= info->full_path && info->print_path < p) {ttfile_info_set_print_path(info, new_path + len - strlen(info->print_path));t} else {ttfile_info_set_print_path(info, new_path);t}tfree(info->full_path);tinfo->full_path = new_path;treturn 0;}",2,"cwe119,cwe120"
"read_word (lua_State *L, FILE *f) {  int c;  luaL_Buffer b;  luaL_buffinit(L, &b);  do { c = fgetc(f); } while (isspace(c));     while (c != EOF && !isspace(c)) {    luaL_putchar(&b, c);    c = fgetc(f);  }  ungetc(c, f);  luaL_pushresult(&b);     return (lua_strlen(L, -1) > 0);}",2,"cwe120,cweother"
"""fil_simplifie(char *f) {  char *a, *b;  char *rollback[128];  int rollid = 0;  char lc = '/';  int query = 0;  int wasAbsolute = (*f == '/');  for(a = b = f; *a != '0';) {    if (*a == '?')      query = 1;    if (query == 0 && lc == '/' && a[0] == '.' && a[1] == '/') {        /* foo/./bar or ./foo  */      a += 2;    } else if (query == 0 && lc == '/' && a[0] == '.' && a[1] == '.' && (a[2] == '/' || a[2] == '0')) {        /* foo/../bar or ../foo or .. */      if (a[2] == '0')        a += 2;      else        a += 3;      if (rollid > 1) {        rollid--;        b = rollback[rollid - 1];      } else {                  /* too many ../ */        rollid = 0;        b = f;        if (wasAbsolute)          b++;                  /* after the / */      }    } else {      *b++ = lc = *a;      if (*a == '/') {        rollback[rollid++] = b;        if (rollid >= 127) {          *f = '0';            /* ERROR */          break;        }      }      a++;    }  }  *b = '0';  if (*f == '0') {    if (wasAbsolute) {      f[0] = '/';      f[1] = '0';    } else {      f[0] = '.';      f[1] = '/';      f[2] = '0';    }  }}""",2,"cwe119,cwe120"
"ds_doprnt(Ds *ds, unsigned int offset, Ds_mode mode, const char *fmt,tt  va_list ap){  int n;  char save_ch;  size_t flen, need, nlen;  char *msg;  va_list ap2;  ds_errmsg = NULL;  if ((msg = check_entrance(ds, offset)) != NULL)tgoto fail;  if (ds->buf != NULL && ds->len > ds->nalloc) {tmsg = ""len>nalloc"";tgoto fail;  }     va_copy(ap2, ap);  if (get_formatted_length(fmt, ap2, &flen) == -1) {tva_end(ap2);tmsg = ""get_formatted_length failed"";tgoto fail;  }  va_end(ap2);  if (mode == DS_INSERT_MODE)tneed = flen;  elsetneed = flen + 1;t   if ((int) (nlen = prepare_buf(ds, need, offset, mode)) == -1)treturn(-1);  if (mode == DS_INSERT_MODE) {t tsave_ch = *((char *) ds->buf + offset);tmemmove((char *) ds->buf + flen + offset, (char *) ds->buf + offset,tttds->len);  }  if ((n = vsprintf((char *) ds->buf + offset, fmt, ap)) < 0) {tmsg = ""vsprintf failed"";tgoto fail;  }  if ((size_t) n != flen) {t tmsg = ""character count is wrong!"";tgoto fail;  }  if (mode == DS_INSERT_MODE)t*((char *) ds->buf + flen + offset) = save_ch;     if (ds->clear_flag && nlen < ds->len)tmemzap((char *) ds->buf + offset + n, (size_t) (ds->len - nlen));  ds->len = nlen;  if ((msg = check_exit(ds)) != NULL)tgoto fail;  if (ds->exact_flag) {tif (ds_trim(ds) == NULL) {t  msg = ""ds_trim() failed"";t  goto fail;t}  }  return(n); fail:  ds_errmsg = msg;  return(-1);}",2,"cwe476,cweother"
"XLogFileRead(uint32 log, uint32 seg, int emode){tcharttpath[MAXPGPATH];tcharttxlogfname[MAXFNAMELEN];tcharttactivitymsg[MAXFNAMELEN + 16];tListCell   *cell;tinttttfd;t tforeach(cell, expectedTLIs)t{ttTimeLineIDttli = (TimeLineID) lfirst_int(cell);ttif (tli < curFileTLI)tttbreak;tttt ttXLogFileName(xlogfname, tli, log, seg);ttif (InArchiveRecovery)tt{ttt tttsnprintf(activitymsg, sizeof(activitymsg), ""waiting for %s"",ttttt xlogfname);tttset_ps_display(activitymsg, false);tttrestoredFromArchive = RestoreArchivedFile(path, xlogfname,ttttttttttttt  ""RECOVERYXLOG"",ttttttttttttt  XLogSegSize);tt}ttelsetttXLogFilePath(path, tli, log, seg);ttfd = BasicOpenFile(path, O_RDONLY | PG_BINARY, 0);ttif (fd >= 0)tt{ttt tttcurFileTLI = tli;ttt tttsnprintf(activitymsg, sizeof(activitymsg), ""recovering %s"",ttttt xlogfname);tttset_ps_display(activitymsg, false);tttreturn fd;tt}ttif (errno != ENOENT)t tttereport(PANIC,ttttt(errcode_for_file_access(),ttterrmsg(""could not open file ""%s"" (log file %u, segment %u): %m"",tttt   path, log, seg)));t}t tXLogFilePath(path, recoveryTargetTLI, log, seg);terrno = ENOENT;tereport(emode,ttt(errcode_for_file_access(),tt   errmsg(""could not open file ""%s"" (log file %u, segment %u): %m"",tttt  path, log, seg)));treturn -1;}",2,"cwe119,cwe120"
"append_message_flags(mailsession * session,    const char * message, size_t size, struct mail_flags * flags){  struct maildir * md;  int r;  char uid[PATH_MAX];  struct maildir_msg * md_msg;  chashdatum key;  chashdatum value;  uint32_t md_flags;  struct mail_cache_db * cache_db_flags;  char filename_flags[PATH_MAX];  MMAPString * mmapstr;  struct maildir_cached_session_state_data * data;    md = get_maildir_session(session);  if (md == NULL)    return MAIL_ERROR_BAD_STATE;    r = maildir_message_add_uid(md, message, size,      uid, sizeof(uid));  if (r != MAILDIR_NO_ERROR)    return maildirdriver_maildir_error_to_mail_error(r);    if (flags == NULL)    goto exit;    data = get_cached_data(session);    snprintf(filename_flags, PATH_MAX, ""%s%c%s%c%s"",      data->md_flags_directory, MAIL_DIR_SEPARATOR, data->md_quoted_mb,      MAIL_DIR_SEPARATOR, FLAGS_NAME);    r = mail_cache_db_open_lock(filename_flags, &cache_db_flags);  if (r < 0)    goto exit;    mmapstr = mmap_string_new("""");  if (mmapstr == NULL)    goto close_db_flags;    r = write_cached_flags(cache_db_flags, mmapstr,      uid, flags);    mmap_string_free(mmapstr);  mail_cache_db_close_unlock(filename_flags, cache_db_flags);    if (r != MAIL_NO_ERROR)    goto exit;    key.data = uid;  key.len = strlen(uid);  r = chash_get(md->mdir_msg_hash, &key, &value);  if (r < 0)    goto exit;    md_msg = value.data;    md_flags = maildirdriver_flags_to_maildir_flags(flags->fl_flags);    r = maildir_message_change_flags(md, uid, md_flags);  if (r != MAILDIR_NO_ERROR)    goto exit;    return MAIL_NO_ERROR;   close_db_flags:  mail_cache_db_close_unlock(filename_flags, cache_db_flags); exit:  return MAIL_NO_ERROR;}",2,"cwe119,cwe120"
"fcp_parse_uri ( struct uri *uri, struct fc_name *wwn,ttt   struct scsi_lun *lun ) {tchar wwn_buf[ FC_NAME_STRLEN + 1   ];tconst char *wwn_text;tconst char *lun_text;tint rc;t tif ( uri->opaque ) {tt ttif ( snprintf ( wwn_buf, sizeof ( wwn_buf ), ""%s"",tttturi->opaque ) < ( FC_NAME_STRLEN + 1   ) )tttreturn -EINVAL;ttif ( uri->opaque[FC_NAME_STRLEN] != ':' )tttreturn -EINVAL;ttwwn_text = wwn_buf;ttlun_text = &uri->opaque[FC_NAME_STRLEN + 1];t} else {tt ttif ( ! ( uri->host && uri->path ) )tttreturn -EINVAL;ttif ( uri->path[0] != '/' )tttreturn -EINVAL;ttwwn_text = uri->host;ttlun_text = ( uri->path + 1 );t}t tif ( ( rc = fc_aton ( wwn_text, wwn ) ) != 0 )ttreturn rc;t tif ( ( rc = scsi_parse_lun ( lun_text, lun ) ) != 0 )ttreturn rc;treturn 0;}",2,"cwe119,cwe120"
"check_an2ln(krb5_context context,t    krb5_const_principal principal,t    const char *luser,t    krb5_boolean *result){    krb5_error_code ret;    char *lname;#if 0              if (krb5_principal_get_comp_string(context, principal, 1) != NULL) {t*result =  FALSE;treturn 0;    }#endif    lname = malloc(strlen(luser) + 1);    if (lname == NULL)treturn krb5_enomem(context);    ret = krb5_aname_to_localname(context, principal, strlen(luser)+1, lname);    if (ret)tgoto out;    if (strcmp(lname, luser) == 0)t*result = TRUE;    elset*result = FALSE;out:    free(lname);    return 0;}",2,"cwe119,cwe120"
"nsupdate_parse(nsupdate_params_t *params, int argc, char *argv[]){tint opt = 0, li = 0;tint ret = KNOT_EOK;tif (params == NULL || argv == NULL) {ttreturn KNOT_EINVAL;t}tret = nsupdate_init(params);tif (ret != KNOT_EOK) {ttreturn ret;t}t tstruct option opts[] = {tt{ ""version"", no_argument, 0, 'V' },tt{ ""help"",    no_argument, 0, 'h' },tt{ 0,         0,           0, 0 }t};t twhile ((opt = getopt_long(argc, argv, ""dhDvVp:t:r:y:k:"", opts, &li))t       != -1) {ttswitch (opt) {ttcase 'd':ttcase 'D':  tttmsg_enable_debug(1);tttbreak;ttcase 'h':tttnsupdate_help();tttparams->stop = true;tttreturn KNOT_EOK;ttcase 'v':tttparams->protocol = PROTO_TCP;tttbreak;ttcase 'V':tttprintf(KNSUPDATE_VERSION);tttparams->stop = true;tttreturn KNOT_EOK;ttcase 'p':tttfree(params->server->service);tttparams->server->service = strdup(optarg);tttif (!params->server->service) {ttttERR(""failed to set default port '%s'"", optarg);ttttreturn KNOT_ENOMEM;ttt}tttbreak;ttcase 'r':tttret = params_parse_num(optarg, &params->retries);tttif (ret != KNOT_EOK) return ret;tttbreak;ttcase 't':tttret = params_parse_wait(optarg, &params->wait);tttif (ret != KNOT_EOK) return ret;tttbreak;ttcase 'y':tttret = params_parse_tsig(optarg, &params->key_params);tttif (ret != KNOT_EOK) return ret;tttbreak;ttcase 'k':tttret = params_parse_keyfile(optarg, &params->key_params);tttif (ret != KNOT_EOK) return ret;tttbreak;ttdefault:tttnsupdate_help();tttreturn KNOT_ENOTSUP;tt}t}t tif (params->protocol == PROTO_TCP) {ttparams->retries = 0;t} else {tt ttif (params->wait > 0 &&tt    (uint32_t)params->wait < ( 1 + params->retries)) {tttparams->wait = 1;tt} else {tttparams->wait /= (1 + params->retries);tt}t}t tfor (; optind < argc; ++optind) {ttstrnode_t *n = malloc(sizeof(strnode_t));ttif (!n) {  tttreturn KNOT_ENOMEM;tt}ttn->str = argv[optind];ttadd_tail(&params->qfiles, &n->n);t}treturn ret;}",3,"cwe120,cwe476,cweother"
"""edflib_latin12utf8(char *latin1_str, int len){  int i, j;  unsigned char *str, tmp_str[512];  str = (unsigned char *)latin1_str;  j = 0;  for(i=0; i<len; i++)  {    if(str[i]==0)    {      tmp_str[j] = 0;      break;    }    tmp_str[j] = str[i];    if(str[i]<32) tmp_str[j] = '.';    if((str[i]>126)&&(str[i]<160))  tmp_str[j] = '.';    if(str[i]>159)    {      if((len-j)<2)      {        tmp_str[j] = ' ';      }      else      {        tmp_str[j] = 192 + (str[i]>>6);        j++;        tmp_str[j] = 128 + (str[i]&63);      }    }    j++;    if(j>=len)  break;  }  for(i=0; i<len; i++)  {    str[i] = tmp_str[i];  }}""",3,"cwe119,cwe120,cweother"
"create_new_newsrc(char *path){    FILEt*fp;    intttc;    fp = fopen_mkdir(path, ""w"", True);    popup_title_notice(fp ? ""Created newsrc file"" :tt       ""Failed to create newsrc file"", path, fp == NULL);    if (!fp)treturn;    if (global.auto_subscribe)tif (global.auto_subscribe[0] != '/')t    fputs(global.auto_subscribe, fp);telse {t    FILEt*ng = fopen(global.auto_subscribe, ""r"");t    if (!ng)ttperror(global.auto_subscribe);t    else {ttwhile ((c = getc(ng)) != EOF)tt    putc(c, fp);ttfclose(ng);t    }t}    fclose(fp);}",2,"cwe120,cweother"
"gs_lib_ctx_set_icc_directory(const gs_memory_t *mem_gc, const char* pname,                        int dir_namelen){    char *result;    gs_lib_ctx_t *p_ctx = mem_gc->gs_lib_ctx;         if (p_ctx->profiledir != NULL && strcmp(pname,DEFAULT_DIR_ICC) == 0) {        return;    }    if (p_ctx->profiledir_len > 0) {        if (strncmp(pname, p_ctx->profiledir, p_ctx->profiledir_len) == 0) {            return;        }        gs_free_object(mem_gc->non_gc_memory, p_ctx->profiledir,                       ""gsicc_set_icc_directory"");    }         result = (char*) gs_alloc_bytes(mem_gc->non_gc_memory, dir_namelen+1,                                     ""gsicc_set_icc_directory"");    if (result != NULL) {        strcpy(result, pname);        p_ctx->profiledir = result;        p_ctx->profiledir_len = dir_namelen;    }}",2,"cwe120,cwe469"
"policy_evaluate_name(policy_state_t *state, const char *name){tint rcode;tconst policy_item_t *this;tpolicy_named_t mypolicy, *policy;tmypolicy.name = name;tpolicy = rbtree_finddata(state->inst->policies, &mypolicy);tif (!policy) return RLM_MODULE_FAIL;tDEBUG2(""rlm_policy: Evaluating policy %s"", name);trad_assert(policy->item.type != POLICY_TYPE_BAD);trad_assert(policy->item.type < POLICY_TYPE_NUM_TYPES);trcode = policy_stack_push(state, policy->policy);tif (!rcode) {ttreturn RLM_MODULE_FAIL;t}t twhile (policy_stack_pop(state, &this)) {ttrad_assert(this != NULL);ttrad_assert(this->type != POLICY_TYPE_BAD);ttrad_assert(this->type < POLICY_TYPE_NUM_TYPES);ttdebug_evaluate(""Evaluating at line %d"",ttt       this->lineno);ttrcode = (*evaluate_functions[this->type])(state,ttttttt  this);ttif (!rcode) {tttreturn RLM_MODULE_FAIL;tt}t}  treturn state->rcode;}",2,"cwe476,cweother"
"ProcessArgv(int argc, char *argv[]){tint opt;tint i=0;tint ptmxdevices = 0;ttwhile ((opt = getopt(argc, argv, ""vf:p:"")) != -1) {ttswitch (opt) {ttcase 'v':tttVerboseMode = 1;tttbreak;ttcase 'f':tttMaxFrameSize = atoi(argv[optind]);tttbreak;ttcase 'p':tttptmxdevices = atoi(optarg);tttif (ptmxdevices < 1) {ttttfprintf(stderr, ""error: too many devices"");ttttexit(1);ttt}tttfor (i=0; i < ptmxdevices; i++)ttttNewPort(""/dev/ptmx"");tttbreak;ttdefault:tttfprintf(stderr, ""Invalid option %s"", argv[optind]);tttUsage();tttexit(1);tt}t}tttwhile (optind < argc)ttNewPort(argv[optind++]);tif (NbPort < 2) {ttfprintf(stderr, ""This multiplexer needs at least two pty's"");ttexit(1);t}}",2,"cwe120,cweother"
"create_unix_socket(const char *path){tstruct sockaddr_un sunx;tint fd;tchar line[MAXLINE +1];tif (path[0] == '0')ttreturn -1;t(void) unlink(path);tmemset(&sunx, 0, sizeof(sunx));tsunx.sun_family = AF_UNIX;t(void) strncpy(sunx.sun_path, path, sizeof(sunx.sun_path));tfd = socket(AF_UNIX, SOCK_DGRAM, 0);tif (fd < 0 || bind(fd, (struct sockaddr *) &sunx,ttt   sizeof(sunx.sun_family)+strlen(sunx.sun_path)) < 0 ||t    chmod(path, 0666) < 0) {tt(void) snprintf(line, sizeof(line), ""cannot create %s"", path);ttlogerror(line);ttdprintf(""cannot create %s (%d)."", path, errno);ttclose(fd);#ifndef SYSVttdie(0);#endift}treturn fd;}",3,"cwe119,cwe120,cweother"
"pm8001_store_update_fw(struct device *cdev,tttt      struct device_attribute *attr,tttt      const char *buf, size_t count){tstruct Scsi_Host *shost = class_to_shost(cdev);tstruct sas_ha_struct *sha = SHOST_TO_SAS_HA(shost);tstruct pm8001_hba_info *pm8001_ha = sha->lldd_ha;tchar *cmd_ptr, *filename_ptr;tint res, i;tint flash_command = FLASH_CMD_NONE;tint ret;tif (!capable(CAP_SYS_ADMIN))ttreturn -EACCES;t tif (pm8001_ha->fw_status == FLASH_IN_PROGRESS)ttreturn -EINPROGRESS;tpm8001_ha->fw_status = FLASH_IN_PROGRESS;tcmd_ptr = kzalloc(count*2, GFP_KERNEL);tif (!cmd_ptr) {ttpm8001_ha->fw_status = FAIL_OUT_MEMORY;ttreturn -ENOMEM;t}tfilename_ptr = cmd_ptr + count;tres = sscanf(buf, ""%s %s"", cmd_ptr, filename_ptr);tif (res != 2) {ttpm8001_ha->fw_status = FAIL_PARAMETERS;ttret = -EINVAL;ttgoto out;t}tfor (i = 0; flash_command_table[i].code != FLASH_CMD_NONE; i++) {ttif (!memcmp(flash_command_table[i].command,tttt cmd_ptr, strlen(cmd_ptr))) {tttflash_command = flash_command_table[i].code;tttbreak;tt}t}tif (flash_command == FLASH_CMD_NONE) {ttpm8001_ha->fw_status = FAIL_PARAMETERS;ttret = -EINVAL;ttgoto out;t}tret = request_firmware(&pm8001_ha->fw_image,ttt       filename_ptr,ttt       pm8001_ha->dev);tif (ret) {ttPM8001_FAIL_DBG(pm8001_ha,tttpm8001_printk(ttt""Failed to load firmware image file %s,terror %d"",tttfilename_ptr, ret));ttpm8001_ha->fw_status = FAIL_OPEN_BIOS_FILE;ttgoto out;t}tif (FLASH_CMD_UPDATE == flash_command)ttret = pm8001_update_flash(pm8001_ha);telsettret = pm8001_set_nvmd(pm8001_ha);trelease_firmware(pm8001_ha->fw_image);out:tkfree(cmd_ptr);tif (ret)ttreturn ret;tpm8001_ha->fw_status = FLASH_OK;treturn count;}",2,"cwe120,cweother"
"client3_1_rmdir (call_frame_t *frame, xlator_t *this,                 void *data){        clnt_conf_t    *conf     = NULL;        clnt_args_t    *args     = NULL;        gfs3_rmdir_req  req      = {{0,},};        int             ret      = 0;        int             op_errno = ESTALE;        if (!frame || !this || !data)                goto unwind;        args = data;        if (!(args->loc && args->loc->parent))                goto unwind;        if (!uuid_is_null (args->loc->parent->gfid))                memcpy (req.pargfid,  args->loc->parent->gfid, 16);        else                memcpy (req.pargfid, args->loc->pargfid, 16);        GF_ASSERT_AND_GOTO_WITH_ERROR (this->name,                                       !uuid_is_null (*((uuid_t*)req.pargfid)),                                       unwind, op_errno, EINVAL);        req.bname = (char *)args->loc->name;        req.xflags = args->flags;        conf = this->private;        GF_PROTOCOL_DICT_SERIALIZE (this, args->xdata, (&req.xdata.xdata_val),                                    req.xdata.xdata_len, op_errno, unwind);        ret = client_submit_request (this, &req, frame, conf->fops,                                     GFS3_OP_RMDIR, client3_1_rmdir_cbk, NULL,                                     NULL, 0, NULL, 0,                                     NULL, (xdrproc_t)xdr_gfs3_rmdir_req);        if (ret) {                gf_log (this->name, GF_LOG_WARNING, ""failed to send the fop"");        }        if (req.xdata.xdata_val)                GF_FREE (req.xdata.xdata_val);        return 0;unwind:        CLIENT_STACK_UNWIND (rmdir, frame, -1, op_errno, NULL, NULL, NULL);        if (req.xdata.xdata_val)                GF_FREE (req.xdata.xdata_val);        return 0;}",2,"cwe120,cwe476"
"initIDs(JNIEnv *env){    if (handleID == 0) {        jclass this =            (*env)->FindClass(env, ""java/lang/ClassLoader$NativeLibrary"");        if (this == 0)            return JNI_FALSE;        handleID = (*env)->GetFieldID(env, this, ""handle"", ""J"");        if (handleID == 0)            return JNI_FALSE;        jniVersionID = (*env)->GetFieldID(env, this, ""jniVersion"", ""I"");        if (jniVersionID == 0)            return JNI_FALSE;    }    return JNI_TRUE;}",2,"cwe119,cwe120"
"StartChildProcess(int xlop){tpid_tttpid;tchart   *av[10];tinttttac = 0;tcharttxlbuf[32];t tav[ac++] = ""postgres"";#ifdef EXEC_BACKENDtav[ac++] = ""--forkboot"";tav[ac++] = NULL;ttt #endiftsnprintf(xlbuf, sizeof(xlbuf), ""-x%d"", xlop);tav[ac++] = xlbuf;tav[ac++] = ""-y"";tav[ac++] = ""template1"";tav[ac] = NULL;tAssert(ac < lengthof(av));#ifdef EXEC_BACKENDtpid = postmaster_forkexec(ac, av);#elsettttttt tpid = fork_process();tif (pid == 0)tttt t{ttIsUnderPostmaster = true;tt tt ttClosePostmasterPorts(false);tt tton_exit_reset();tt ttMemoryContextSwitchTo(TopMemoryContext);ttMemoryContextDelete(PostmasterContext);ttPostmasterContext = NULL;ttBootstrapMain(ac, av);ttExitPostmaster(0);t}#endif    tif (pid < 0)t{tt ttinttttsave_errno = errno;tterrno = save_errno;ttswitch (xlop)tt{tttcase BS_XLOG_STARTUP:ttttereport(LOG,tttttt(errmsg(""could not fork startup process: %m"")));ttttbreak;tttcase BS_XLOG_BGWRITER:ttttereport(LOG,tttt   (errmsg(""could not fork background writer process: %m"")));ttttbreak;tttdefault:ttttereport(LOG,tttttt(errmsg(""could not fork process: %m"")));ttttbreak;tt}tt ttif (xlop == BS_XLOG_STARTUP)tttExitPostmaster(1);ttreturn 0;t}t treturn pid;}",2,"cwe119,cwe120"
"asn_build_sequence(u_char * data,                   size_t * datalength, u_char type, size_t length){    static const char *errpre = ""build seq"";    char            ebuf[128];    if (*datalength < 4) {        snprintf(ebuf, sizeof(ebuf),                ""%s: length %d < 4: PUNT"", errpre,                (int) *datalength);        ebuf[ sizeof(ebuf)-1 ] = 0;        ERROR_MSG(ebuf);        return NULL;    }    *datalength -= 4;    *data++ = type;    *data++ = (u_char) (0x02 | ASN_LONG_LEN);    *data++ = (u_char) ((length >> 8) & 0xFF);    *data++ = (u_char) (length & 0xFF);    return data;}",2,"cwe119,cwe120"
"process_display(void){    int i;    char *our_host;    char *idle;    our_host = get_localhost();    if (times_on == 0) {tprintf (""Nobody logged in."");treturn;    } elsetprintf (""USERNAME Real name                      Idletime TTY Remote console location"");    for (i = 0; (i < times_on) && (i < MAX_TTYS); i++) {tchar console[30];tstruct passwd *pwent;tif (strlen((char *) tty_list[i].locale) == 0)t    snprintf(console, sizeof(console), ""(%s)"", our_host);telset    snprintf(console, sizeof(console), ""(%s)"", tty_list[i].locale);tif (strlen((char *) tty_list[i].username) > 1) {t    char *username=NULL;t    char ru[9], fn[STRLEN];t    memset(ru, 0, sizeof (ru));t    memset(fn, 0, sizeof (fn));t    strncpy(ru, tty_list[i].username, sizeof(ru)-1);t    pwent = getpwnam((char *) ru);t    if (pwent) {ttchar *cp, *x;ttcp = pwent->pw_gecos;ttif ((x = index (pwent->pw_gecos, ',')) != NULL)  tt    *x = '0';tt    if ((username = (char *)malloc (strlen(cp)+1)) != NULL) {tttmemset (username, 0, strlen(cp)+1);tttstrcpy (username, cp);tt    }ttsnprintf(fn, sizeof(fn), ""%s/.nofinger"", pwent->pw_dir);t    }t    idle = calc_idle((char *) tty_list[i].line);t    if (pwent) {ttif (!exist((char *) fn)) {tt    if (idle) {tttprintf(""%-8.8s %-30.30s %8.8s "",ttt       ru, username?username:"""", idle);tttprintf(""%3.3s %-25.25s"",ttt       (char *) tty_list[i].tty, console);tt    }tt}t    } else {ttif (idle) {tt    printf(""%-8.8s %-30.30s %8.8s "",ttt   ru, ru, idle);tt    printf(""%3.3s %-25.25s"",ttt   (char *) tty_list[i].tty, console);tt}t    }t}tfflush(stdout);    }}",2,"cwe119,cwe120"
"__ecereMethod___ecereNameSpace__ecere__net__Socket_OnReceive(struct __ecereNameSpace__ecere__com__Instance * this, const unsigned char * buffer, unsigned int count){struct __ecereNameSpace__ecere__net__Socket * __ecerePointer___ecereNameSpace__ecere__net__Socket = (struct __ecereNameSpace__ecere__net__Socket *)(this ? (((char *)this) + __ecereClass___ecereNameSpace__ecere__net__Socket->offset) : 0);if(count >= sizeof(struct __ecereNameSpace__ecere__net__Packet)){struct __ecereNameSpace__ecere__net__Packet * packet = (struct __ecereNameSpace__ecere__net__Packet *)buffer;unsigned int size = (unsigned int)((((unsigned char *)&packet->size)[3] << (unsigned char)24) | (((unsigned char *)&packet->size)[2] << (unsigned char)16) | (((unsigned char *)&packet->size)[1] << (unsigned char)8) | ((unsigned char *)&packet->size)[0]);if(count >= size){unsigned char * tempBuffer = (((void *)0));if(size){if(__ecerePointer___ecereNameSpace__ecere__net__Socket->recvBytes - size){tempBuffer = __ecereNameSpace__ecere__com__eSystem_New(sizeof(unsigned char) * (size));packet = (struct __ecereNameSpace__ecere__net__Packet *)tempBuffer;memcpy(tempBuffer, buffer, size);memmove(__ecerePointer___ecereNameSpace__ecere__net__Socket->recvBuffer, __ecerePointer___ecereNameSpace__ecere__net__Socket->recvBuffer + size, __ecerePointer___ecereNameSpace__ecere__net__Socket->recvBytes - size);}__ecerePointer___ecereNameSpace__ecere__net__Socket->recvBytes -= size;}((void (*)(struct __ecereNameSpace__ecere__com__Instance *, struct __ecereNameSpace__ecere__net__Packet * packet))__extension__ ({struct __ecereNameSpace__ecere__com__Instance * __internal_ClassInst = this;__internal_ClassInst ? __internal_ClassInst->_vTbl : __ecereClass___ecereNameSpace__ecere__net__Socket->_vTbl;})[__ecereVMethodID___ecereNameSpace__ecere__net__Socket_OnReceivePacket])(this, packet);(__ecereNameSpace__ecere__com__eSystem_Delete(tempBuffer), tempBuffer = 0);return 0;}}return 0;}",2,"cwe120,cwe476"
"""mq_notify (mqd_t mqdes, const struct sigevent *notification){  /* Make sure the type is correctly defined.  */  assert (sizeof (union notify_data) == NOTIFY_COOKIE_LEN);  /* Special treatment needed for SIGEV_THREAD.  */  if (notification == NULL || notification->sigev_notify != SIGEV_THREAD)    return INLINE_SYSCALL (mq_notify, 2, mqdes, notification);  /* The kernel cannot directly start threads.  This will have to be     done at userlevel.  Since we cannot start threads from signal     handlers we have to create a dedicated thread which waits for     notifications for arriving messages and creates threads in     response.  */  /* Initialize only once.  */  pthread_once (&once, init_mq_netlink);  /* If we cannot create the netlink socket we cannot provide     SIGEV_THREAD support.  */  if (__builtin_expect (netlink_socket == -1, 0))    {      __set_errno (ENOSYS);      return -1;    }  /* Create the cookie.  It will hold almost all the state.  */  union notify_data data;  memset (&data, '0', sizeof (data));  data.fct = notification->sigev_notify_function;  data.param = notification->sigev_value;  if (notification->sigev_notify_attributes != NULL)    {      /* The thread attribute has to be allocated separately.  */      data.attr = (pthread_attr_t *) malloc (sizeof (pthread_attr_t));      if (data.attr == NULL)treturn -1;      memcpy (data.attr, notification->sigev_notify_attributes,t      sizeof (pthread_attr_t));    }  /* Construct the new request.  */  struct sigevent se;  se.sigev_notify = SIGEV_THREAD;  se.sigev_signo = netlink_socket;  se.sigev_value.sival_ptr = &data;  /* Tell the kernel.  */  int retval = INLINE_SYSCALL (mq_notify, 2, mqdes, &se);  /* If it failed, free the allocated memory.  */  if (__builtin_expect (retval != 0, 0))    free (data.attr);  return retval;}""",2,"cwe120,cweother"
"freesenderlist(){  SENDERt*sender;  if (loglevel > 1)    logit(LOG_DEBUG, ""freesenderlist:"");  while ((sender = senderlist)) {    senderlist = sender->nxt;    freesender(sender);  }}",2,"cwe119,cwe120"
"ValidXLOGHeader(XLogPageHeader hdr, int emode){tXLogRecPtrtrecaddr;tif (hdr->xlp_magic != XLOG_PAGE_MAGIC)t{ttereport(emode,tttt(errmsg(""invalid magic number %04X in log file %u, segment %u, offset %u"",tttttthdr->xlp_magic, readId, readSeg, readOff)));ttreturn false;t}tif ((hdr->xlp_info & ~XLP_ALL_FLAGS) != 0)t{ttereport(emode,tttt(errmsg(""invalid info bits %04X in log file %u, segment %u, offset %u"",tttttthdr->xlp_info, readId, readSeg, readOff)));ttreturn false;t}tif (hdr->xlp_info & XLP_LONG_HEADER)t{ttXLogLongPageHeader longhdr = (XLogLongPageHeader) hdr;ttif (longhdr->xlp_sysid != ControlFile->system_identifier)tt{tttcharttfhdrident_str[32];tttcharttsysident_str[32];ttt tttsnprintf(fhdrident_str, sizeof(fhdrident_str), UINT64_FORMAT,ttttt longhdr->xlp_sysid);tttsnprintf(sysident_str, sizeof(sysident_str), UINT64_FORMAT,ttttt ControlFile->system_identifier);tttereport(emode,ttttt(errmsg(""WAL file is from different system""),ttttt errdetail(""WAL file SYSID is %s, pg_control SYSID is %s"",ttttttt   fhdrident_str, sysident_str)));tttreturn false;tt}ttif (longhdr->xlp_seg_size != XLogSegSize)tt{tttereport(emode,ttttt(errmsg(""WAL file is from different system""),ttttt errdetail(""Incorrect XLOG_SEG_SIZE in page header."")));tttreturn false;tt}ttif (longhdr->xlp_xlog_blcksz != XLOG_BLCKSZ)tt{tttereport(emode,ttttt(errmsg(""WAL file is from different system""),ttttt errdetail(""Incorrect XLOG_BLCKSZ in page header."")));tttreturn false;tt}t}telse if (readOff == 0)t{tt ttereport(emode,tttt(errmsg(""invalid info bits %04X in log file %u, segment %u, offset %u"",tttttthdr->xlp_info, readId, readSeg, readOff)));ttreturn false;t}trecaddr.xlogid = readId;trecaddr.xrecoff = readSeg * XLogSegSize + readOff;tif (!XLByteEQ(hdr->xlp_pageaddr, recaddr))t{ttereport(emode,tttt(errmsg(""unexpected pageaddr %X/%X in log file %u, segment %u, offset %u"",tttttthdr->xlp_pageaddr.xlogid, hdr->xlp_pageaddr.xrecoff,ttttttreadId, readSeg, readOff)));ttreturn false;t}t tif (!list_member_int(expectedTLIs, (int) hdr->xlp_tli))t{ttereport(emode,tttt(errmsg(""unexpected timeline ID %u in log file %u, segment %u, offset %u"",tttttthdr->xlp_tli,ttttttreadId, readSeg, readOff)));ttreturn false;t}t tif (hdr->xlp_tli < lastPageTLI)t{ttereport(emode,tttt(errmsg(""out-of-sequence timeline ID %u (after %u) in log file %u, segment %u, offset %u"",tttttthdr->xlp_tli, lastPageTLI,ttttttreadId, readSeg, readOff)));ttreturn false;t}tlastPageTLI = hdr->xlp_tli;treturn true;}",3,"cwe119,cwe120,cweother"
"glade_project_fix_template (GladeProject *project){  GList *l;  gboolean composite = FALSE;  for (l = project->priv->tree; l; l = l->next)    {      GObject     *obj = l->data;      GladeWidget *gwidget;      gwidget   = glade_widget_get_from_gobject (obj);      composite = glade_widget_get_is_composite (gwidget);      if (composite)        {t  glade_project_set_template (project, gwidget);t  break;        }    }}",2,"cwe120,cweother"
"Read_file(const char *filename, t      char **buf, int *size, t      const int retain_newlines){   FILE *fp;  const int maxlen = 80;  char  bufline[80];  void *ptr;  int   len;  int   bufsize = BUFSIZ;  int   newline_adj = 1;  if( !(fp = fopen(filename, ""r"")) ){    fprintf(stderr, ""STEER: Read_file: failed to open file: %s"", t    filename);    return REG_FAILURE;  }  if(!(*buf = (char *)malloc(bufsize*sizeof(char)))){    fprintf(stderr, ""STEER: Read_file: malloc failed"");    return REG_FAILURE;  }  *size = 0;  if(retain_newlines == REG_TRUE){    newline_adj = 0;  }  while(fgets(bufline, maxlen, fp)){         len = (int)strlen(bufline) - newline_adj;    memcpy(&((*buf)[*size]), bufline, len);    *size += len;    if( (bufsize - *size) < maxlen){      bufsize += BUFSIZ;      ptr = realloc(*buf, (size_t)bufsize);      if(!ptr){tfprintf(stderr, ""STEER: Read_file: realloc failed, size = %d"", ttbufsize);tfree(*buf);t*buf = NULL;tfclose(fp);treturn REG_FAILURE;      }      *buf = (char *)ptr;    }  }  (*buf)[*size] = 0;  fclose(fp);  return REG_SUCCESS;}",3,"cwe119,cwe120,cweother"
"add_controls(struct oxygen *chip,tttconst struct snd_kcontrol_new controls[],tttunsigned int count){tstatic const char *const known_ctl_names[CONTROL_COUNT] = {tt[CONTROL_SPDIF_PCM] =tttSNDRV_CTL_NAME_IEC958("""", PLAYBACK, PCM_STREAM),tt[CONTROL_SPDIF_INPUT_BITS] =tttSNDRV_CTL_NAME_IEC958("""", CAPTURE, DEFAULT),tt[CONTROL_MIC_CAPTURE_SWITCH] = ""Mic Capture Switch"",tt[CONTROL_LINE_CAPTURE_SWITCH] = ""Line Capture Switch"",tt[CONTROL_CD_CAPTURE_SWITCH] = ""CD Capture Switch"",tt[CONTROL_AUX_CAPTURE_SWITCH] = ""Aux Capture Switch"",t};tunsigned int i, j;tstruct snd_kcontrol_new template;tstruct snd_kcontrol *ctl;tint err;tfor (i = 0; i < count; ++i) {tttemplate = controls[i];ttif (chip->model.control_filter) {ttterr = chip->model.control_filter(&template);tttif (err < 0)ttttreturn err;tttif (err == 1)ttttcontinue;tt}ttif (!strcmp(template.name, ""Stereo Upmixing"") &&tt    chip->model.dac_channels_pcm == 2)tttcontinue;ttif (!strcmp(template.name, ""Mic Source Capture Enum"") &&tt    !(chip->model.device_config & AC97_FMIC_SWITCH))tttcontinue;ttif (!strncmp(template.name, ""CD Capture "", 11) &&tt    !(chip->model.device_config & AC97_CD_INPUT))tttcontinue;ttif (!strcmp(template.name, ""Master Playback Volume"") &&tt    chip->model.dac_tlv) {ttttemplate.tlv.p = chip->model.dac_tlv;ttttemplate.access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;tt}ttctl = snd_ctl_new1(&template, chip);ttif (!ctl)tttreturn -ENOMEM;tterr = snd_ctl_add(chip->card, ctl);ttif (err < 0)tttreturn err;ttfor (j = 0; j < CONTROL_COUNT; ++j)tttif (!strcmp(ctl->id.name, known_ctl_names[j])) {ttttchip->controls[j] = ctl;ttttctl->private_free = oxygen_any_ctl_free;ttt}t}treturn 0;}",3,"cwe119,cwe120,cweother"
"ccp_getunit(int linkunit,int protocol){  int i;  char proto[64];  if(protocol != PPP_CCP && protocol != PPP_LINK_CCP)    return -1;  for(i=0;i<NUM_PPP;i++) {    if(!ccp_fsm[i].inuse) {      ccp_fsm[i].inuse = 1;      ccp_fsm[i].state = INITIAL;      ccp_fsm[i].flags = 0;      ccp_fsm[i].id = 0;      ccp_fsm[i].unit = linkunit;      ccp_fsm[i].protocol = protocol;      switch (protocol) {      case 0x80FD: strcpy(proto, ""Compression Control Protocol""); break;      case 0x80FB: strcpy(proto, ""Link Compression Control Protocol""); break;      default: sprintf(proto, ""protocol: %#x"", protocol);      }      syslog(LOG_NOTICE,""CCP: got ccp-unit %d for link %d (%s)"",i,linkunit,proto);      return i;    }  }  syslog(LOG_ERR,""No more ccp_units available"");  return -1;}",2,"cwe119,cwe120"
"audio_wave_save(int wid, const char *name){tchar buf[1024];taudio_wave_t *wave = audio_wave_get(wid);tif(!wave)ttreturn -1;t tstrncpy(buf, eel_path(), sizeof(buf));#ifdef WIN32tstrncat(buf, """", sizeof(buf));#elif defined MACOStstrncat(buf, "":"", sizeof(buf));#elsetstrncat(buf, ""/"", sizeof(buf));#endiftstrncat(buf, name, sizeof(buf));tlog_printf(DLOG, ""Saving to ""%s"""", buf);t tif(strstr(name, "".raw"") || strstr(name, "".RAW""))ttreturn SaveRAW(buf, wave->data.si8, wave->size,tttt(int)wave->format, wave->rate, wave->looped);telsettreturn -2;}",3,"cwe119,cwe120,cweother"
"handle_select_language(struct unistimsession *pte){tchar tmp_language[40];tstruct unistim_languages lang;tif (pte->state != STATE_SELECTLANGUAGE) {ttpte->state = STATE_SELECTLANGUAGE;ttpte->size_buff_entry = 1;ttpte->buff_entry[0] = find_language(pte->device->language);t}tlang = options_languages[(int)pte->buff_entry[0]];tast_copy_string(tmp_language, pte->device->language, sizeof(tmp_language));tast_copy_string(pte->device->language, lang.lang_short, sizeof(pte->device->language));tsend_charset_update(pte, lang.encoding);tsend_text(TEXT_LINE0, TEXT_NORMAL, pte, ustmtext(lang.label, pte));tast_copy_string(pte->device->language, tmp_language, sizeof(pte->device->language));tlang = options_languages[find_language(pte->device->language)];tsend_charset_update(pte, lang.encoding);tsend_text_status(pte, ustmtext(""Select               Cancel"", pte));treturn;}",2,"cwe119,cwe120"
"vtc_log(struct vtclog *vl, unsigned lvl, const char *fmt, ...){tdouble tx;tCHECK_OBJ_NOTNULL(vl, VTCLOG_MAGIC);ttx = TIM_mono() - t0;tAZ(pthread_mutex_lock(&vl->mtx));tassert(lvl < NLEAD);tVSB_clear(vl->vsb);tVSB_printf(vl->vsb, ""%s %-4s %4.1f "", lead[lvl], vl->id, tx);tva_list ap;tva_start(ap, fmt);t(void)VSB_vprintf(vl->vsb, fmt, ap);tva_end(ap);tVSB_putc(vl->vsb, '');tAZ(VSB_finish(vl->vsb));tvtc_log_emit(vl, lvl);tVSB_clear(vl->vsb);tAZ(pthread_mutex_unlock(&vl->mtx));tif (lvl == 0) {ttvtc_error = 1;ttif (pthread_self() != vtc_thread)tttpthread_exit(NULL);t}}",2,"cwe476,cweother"
"ajBamIndexBuild(const char *fn){    char *fnidx;    FILE *fpidx = NULL;    AjPSeqBamBgzf fp = NULL;    AjPBamIndex idx = NULL;    if(!strcmp(fn, ""stdout""))treturn -1;    if ((fp = ajSeqBamBgzfOpenC(fn, ""r"")) == 0)    {tajErr(""ajBamIndexBuild: fail to open the BAM file '%s'."", fn);treturn -1;    }    idx = bamIndexCore(fp);    ajSeqBamBgzfClose(fp);    if(idx == 0)    {tajErr(""ajBamIndexBuild: fail to index the BAM file '%s'."", fn);treturn -1;    }    fnidx = (char*)calloc(strlen(fn) + 5, 1);    strcpy(fnidx, fn); strcat(fnidx, "".bai"");    fpidx = fopen(fnidx, ""wb"");    if (fpidx == 0)    {tajErr(""ajBamIndexBuild: fail to create the index file '%s'."", fn);tfree(fnidx);treturn -1;    }    bamIndexSave(idx, fpidx);    AJFREE(fnidx);    ajBamIndexDel(&idx);    fclose(fpidx);    return 0;}",2,"cwe120,cweother"
"paramTimezoneDefault(const USystemParams *  , char *target, int32_t targetCapacity, UErrorCode *status) {  if(U_FAILURE(*status))return 0;  UChar buf[100];  char buf2[100];  int32_t len;    len = ucal_getDefaultTimeZone(buf, 100, status);  if(U_SUCCESS(*status)&&len>0) {    u_UCharsToChars(buf, buf2, len+1);    return stringToStringBuffer(target,targetCapacity, buf2,status);  } else {    return 0;  }}",2,"cwe119,cwe120"
"rcfs_meta_load (const char *path, HDF **meta){  NEOERR *err;  char fpath[_POSIX_PATH_MAX];  HDF *m;  snprintf (fpath, sizeof(fpath), ""%s,log"", path);  err = hdf_init (&m);  if (err) return nerr_pass (err);  err = hdf_read_file (m, fpath);  if (err)  {    hdf_destroy (&m);    return nerr_pass (err);  }  *meta = m;  return STATUS_OK;}",2,"cwe119,cwe120"
"c7200_pa_create_pci_busses(c7200_t *router){      vm_instance_t *vm = router->vm;   char bus_name[128];   int i;   for(i=1;i<C7200_MAX_PA_BAYS;i++) {      snprintf(bus_name,sizeof(bus_name),""PA Slot %d"",i);      vm->pci_bus_pool[i] = pci_bus_create(bus_name,-1);      if (!vm->pci_bus_pool[i])         return(-1);   }   return(0);}",2,"cwe119,cwe120"
"FFD_CanHandleURLInService(GF_InputService *plug, const char *url){tchar szURL[2048], *sep;tFFDemux *ffd;tconst char *this_url;tif (!plug || !url)ttreturn 0;tffd = (FFDemux *)plug->priv;tthis_url = gf_term_get_service_url(ffd->service);tif (!this_url)ttreturn 0;tstrcpy(szURL, this_url);tsep = strrchr(szURL, '#');tif (sep) sep[0] = 0;tif ((url[0] != '#') && strnicmp(szURL, url, sizeof(char)*strlen(szURL))) return 0;tsep = strrchr(url, '#');tif (sep && !stricmp(sep, ""#video"") && (ffd->video_st>=0)) return 1;tif (sep && !stricmp(sep, ""#audio"") && (ffd->audio_st>=0)) return 1;treturn 0;}",2,"cwe119,cwe120"
"_libssh2_channel_process_startup(LIBSSH2_CHANNEL *channel,                                 const char *request, size_t request_len,                                 const char *message, size_t message_len){    LIBSSH2_SESSION *session = channel->session;    unsigned char *s;    static const unsigned char reply_codes[3] =        { SSH_MSG_CHANNEL_SUCCESS, SSH_MSG_CHANNEL_FAILURE, 0 };    int rc;    if (channel->process_state == libssh2_NB_state_idle) {                 channel->process_packet_len = request_len + 10;                 memset(&channel->process_packet_requirev_state, 0,               sizeof(channel->process_packet_requirev_state));        if (message)            channel->process_packet_len += + 4;        _libssh2_debug(session, LIBSSH2_TRACE_CONN,                       ""starting request(%s) on channel %lu/%lu, message=%s"",                       request, channel->local.id, channel->remote.id,                       message?message:""<null>"");        s = channel->process_packet =            LIBSSH2_ALLOC(session, channel->process_packet_len);        if (!channel->process_packet)            return _libssh2_error(session, LIBSSH2_ERROR_ALLOC,                                  ""Unable to allocate memory ""                                  ""for channel-process request"");        *(s++) = SSH_MSG_CHANNEL_REQUEST;        _libssh2_store_u32(&s, channel->remote.id);        _libssh2_store_str(&s, request, request_len);        *(s++) = 0x01;        if (message)            _libssh2_store_u32(&s, message_len);        channel->process_state = libssh2_NB_state_created;    }    if (channel->process_state == libssh2_NB_state_created) {        rc = _libssh2_transport_send(session,                                     channel->process_packet,                                     channel->process_packet_len,                                     (unsigned char *)message, message_len);        if (rc == LIBSSH2_ERROR_EAGAIN) {            _libssh2_error(session, rc,                           ""Would block sending channel request"");            return rc;        }        else if (rc) {            LIBSSH2_FREE(session, channel->process_packet);            channel->process_packet = NULL;            channel->process_state = libssh2_NB_state_idle;            return _libssh2_error(session, rc,                                  ""Unable to send channel request"");        }        LIBSSH2_FREE(session, channel->process_packet);        channel->process_packet = NULL;        _libssh2_htonu32(channel->process_local_channel, channel->local.id);        channel->process_state = libssh2_NB_state_sent;    }    if (channel->process_state == libssh2_NB_state_sent) {        unsigned char *data;        size_t data_len;        unsigned char code;        rc = _libssh2_packet_requirev(session, reply_codes, &data, &data_len,                                      1, channel->process_local_channel, 4,                                      &channel->process_packet_requirev_state);        if (rc == LIBSSH2_ERROR_EAGAIN) {            return rc;        } else if (rc) {            channel->process_state = libssh2_NB_state_idle;            return _libssh2_error(session, rc,                                  ""Failed waiting for channel success"");        }        code = data[0];        LIBSSH2_FREE(session, data);        channel->process_state = libssh2_NB_state_idle;        if (code == SSH_MSG_CHANNEL_SUCCESS)            return 0;    }    return _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_REQUEST_DENIED,                          ""Unable to complete request for ""                          ""channel-process-startup"");}",2,"cwe119,cwe120"
"gap_fmac_chk_filtermacro_file(const char *filtermacro_file){  FILE *l_fp;  char         l_buf[400];  gboolean l_rc;  l_buf[0] = '0';  l_rc = FALSE;  l_fp = g_fopen(filtermacro_file, ""r"");  if (l_fp)  {         fgets(l_buf, sizeof(l_buf)-1, l_fp);    if (strncmp(l_buf, ""# FILTERMACRO FILE"", strlen(""# FILTERMACRO FILE"")) == 0)    {      l_rc = TRUE;    }    fclose(l_fp);  }  return l_rc;}",2,"cwe119,cwe120"
"try_set_attribute (GVfsBackend *backend,tt   GVfsJobSetAttribute *job,tt   const char *filename,tt   const char *attribute,tt   GFileAttributeType type,tt   gpointer value_p,tt   GFileQueryInfoFlags flags){  GVfsBackendSftp *op_backend = G_VFS_BACKEND_SFTP (backend);  GDataOutputStream *command;  if (strcmp (attribute, G_FILE_ATTRIBUTE_UNIX_MODE) != 0)    {      g_vfs_job_failed (G_VFS_JOB (job),tttG_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,ttt_(""Operation unsupported""));      return TRUE;    }  if (type != G_FILE_ATTRIBUTE_TYPE_UINT32)     {      g_vfs_job_failed (G_VFS_JOB (job),                        G_IO_ERROR,                        G_IO_ERROR_INVALID_ARGUMENT,                        ""%s"",                        _(""Invalid attribute type (uint32 expected)""));    }  command = new_command_stream (op_backend,                                SSH_FXP_SETSTAT);  put_string (command, filename);  g_data_output_stream_put_uint32 (command, SSH_FILEXFER_ATTR_PERMISSIONS, NULL, NULL);  g_data_output_stream_put_uint32 (command, (*(guint32 *)value_p) & 0777, NULL, NULL);  queue_command_stream_and_free (op_backend, command, set_attribute_reply, G_VFS_JOB (job), NULL);    return TRUE;}",2,"cwe119,cwe120"
"ord_inline(char *arg,struct session *ses){    char left[BUFFER_SIZE];    WC ch[2];    get_arg(arg, left, 0, ses);    if (!*left)    {        tintin_eprintf(ses, ""#ord: no argument"");        return 0;    }    utf8_to_wc(ch, left, 1);    return ch[0];}",2,"cwe119,cwe120"
"hostlist_delete_host(hostlist_t hl, const char *hostname){    int n = hostlist_find(hl, hostname);    if (n >= 0)        hostlist_delete_nth(hl, n);    return n >= 0 ? 1 : 0;}",2,"cwe119,cwe120"
"""shm_mq_sendv(shm_mq_handle *mqh, shm_mq_iovec *iov, int iovcnt, bool nowait){tshm_mq_result res;tshm_mqt   *mq = mqh->mqh_queue;tSizettnbytes = 0;tSizettbytes_written;tintttti;tinttttwhich_iov = 0;tSizettoffset;tAssert(mq->mq_sender == MyProc);t/* Compute total size of write. */tfor (i = 0; i < iovcnt; ++i)ttnbytes += iov[i].len;t/* Try to write, or finish writing, the length word into the buffer. */twhile (!mqh->mqh_length_word_complete)t{ttAssert(mqh->mqh_partial_bytes < sizeof(Size));ttres = shm_mq_send_bytes(mqh, sizeof(Size) - mqh->mqh_partial_bytes,tttttttt((char *) &nbytes) +mqh->mqh_partial_bytes,ttttttttnowait, &bytes_written);ttmqh->mqh_partial_bytes += bytes_written;ttif (res != SHM_MQ_SUCCESS)tttreturn res;ttif (mqh->mqh_partial_bytes >= sizeof(Size))tt{tttAssert(mqh->mqh_partial_bytes == sizeof(Size));tttmqh->mqh_partial_bytes = 0;tttmqh->mqh_length_word_complete = true;tt}tt/* Length word can't be split unless bigger than required alignment. */ttAssert(mqh->mqh_length_word_complete || sizeof(Size) > MAXIMUM_ALIGNOF);t}t/* Write the actual data bytes into the buffer. */tAssert(mqh->mqh_partial_bytes <= nbytes);toffset = mqh->mqh_partial_bytes;tdot{ttSizettchunksize;tt/* Figure out which bytes need to be sent next. */ttif (offset >= iov[which_iov].len)tt{tttoffset -= iov[which_iov].len;ttt++which_iov;tttif (which_iov >= iovcnt)ttttbreak;tttcontinue;tt}tt/*tt * We want to avoid copying the data if at all possible, but everytt * chunk of bytes we write into the queue has to be MAXALIGN'd, excepttt * the last.  Thus, if a chunk other than the last one ends on att * non-MAXALIGN'd boundary, we have to combine the tail end of itstt * data with data from one or more following chunks until we eithertt * reach the last chunk or accumulate a number of bytes which istt * MAXALIGN'd.tt */ttif (which_iov + 1 < iovcnt &&tttoffset + MAXIMUM_ALIGNOF > iov[which_iov].len)tt{tttchartttmpbuf[MAXIMUM_ALIGNOF];tttinttttj = 0;tttfor (;;)ttt{ttttif (offset < iov[which_iov].len)tttt{ttttttmpbuf[j] = iov[which_iov].data[offset];tttttj++;tttttoffset++;tttttif (j == MAXIMUM_ALIGNOF)ttttttbreak;tttt}ttttelsetttt{tttttoffset -= iov[which_iov].len;tttttwhich_iov++;tttttif (which_iov >= iovcnt)ttttttbreak;tttt}ttt}tttres = shm_mq_send_bytes(mqh, j, tmpbuf, nowait, &bytes_written);tttmqh->mqh_partial_bytes += bytes_written;tttif (res != SHM_MQ_SUCCESS)ttttreturn res;tttcontinue;tt}tt/*tt * If this is the last chunk, we can write all the data, even if ittt * isn't a multiple of MAXIMUM_ALIGNOF.  Otherwise, we need tott * MAXALIGN_DOWN the write size.tt */ttchunksize = iov[which_iov].len - offset;ttif (which_iov + 1 < iovcnt)tttchunksize = MAXALIGN_DOWN(chunksize);ttres = shm_mq_send_bytes(mqh, chunksize, &iov[which_iov].data[offset],ttttttttnowait, &bytes_written);ttmqh->mqh_partial_bytes += bytes_written;ttoffset += bytes_written;ttif (res != SHM_MQ_SUCCESS)tttreturn res;t} while (mqh->mqh_partial_bytes < nbytes);t/* Reset for next message. */tmqh->mqh_partial_bytes = 0;tmqh->mqh_length_word_complete = false;t/* Notify receiver of the newly-written data, and return. */treturn shm_mq_notify_receiver(mq);}""",2,"cwe119,cwe120"
"GNUNET_DISK_get_blocks_available (const char *part){#ifdef SOLARIS  struct statvfs buf;  if (0 != statvfs (part, &buf))  {    LOG_STRERROR_FILE (GNUNET_ERROR_TYPE_WARNING, ""statfs"", part);    return -1;  }  return buf.f_bavail;#elif MINGW  DWORD dwDummy;  DWORD dwBlocks;  wchar_t szDrive[4];  wchar_t wpath[MAX_PATH + 1];  char *path;  path = GNUNET_STRINGS_filename_expand (part);  if (path == NULL)    return -1;     if (ERROR_SUCCESS != plibc_conv_to_win_pathwconv(path, wpath))  {    GNUNET_free (path);    return -1;  }  GNUNET_free (path);  wcsncpy (szDrive, wpath, 3);  szDrive[3] = 0;  if (!GetDiskFreeSpaceW (szDrive, &dwDummy, &dwDummy, &dwBlocks, &dwDummy))  {    LOG (GNUNET_ERROR_TYPE_WARNING, _(""`%s' failed for drive `%S': %u""),         ""GetDiskFreeSpace"", szDrive, GetLastError ());    return -1;  }  return dwBlocks;#else  struct statfs s;  if (0 != statfs (part, &s))  {    LOG_STRERROR_FILE (GNUNET_ERROR_TYPE_WARNING, ""statfs"", part);    return -1;  }  return s.f_bavail;#endif}",2,"cwe119,cwe120"
"__socket_ioq_churn_entry (rpc_transport_t *this, struct ioq *entry, int direct){        int               ret = -1;tsocket_private_t *priv = NULL;tchar              a_byte = 0;        ret = __socket_writev (this, entry->pending_vector,                               entry->pending_count,                               &entry->pending_vector,                               &entry->pending_count);        if (ret == 0) {                                 GF_ASSERT (entry->pending_count == 0);                __socket_ioq_entry_free (entry);ttpriv = this->private;ttif (priv->own_thread) {ttt tttif (!direct && read(priv->pipe[0],&a_byte,1) < 1) {ttttgf_log(this->name,GF_LOG_WARNING,tttt       ""read error on pipe"");ttt}tt}        }        return ret;}",2,"cwe120,cweother"
"update_unit_purchase_info( PurchaseDlg *pdlg ){tint total_cost = 0;tSDL_Surface *contents = pdlg->main_group->frame->contents;tUnit_Lib_Entry *unit_entry = NULL, *trsp_entry = NULL;tUnit *reinf_unit = NULL;ttSDL_FillRect( contents, 0, 0x0 );tt treinf_unit = lbox_get_selected_item( pdlg->reinf_lbox );tif (reinf_unit) {ttunit_entry = &reinf_unit->prop;ttif (reinf_unit->trsp_prop.id)ttttrsp_entry = &reinf_unit->trsp_prop;t} else {ttunit_entry = lbox_get_selected_item( pdlg->unit_lbox );tttrsp_entry = lbox_get_selected_item( pdlg->trsp_lbox );t}tt tif (unit_entry) {ttrender_unit_lib_entry_info( unit_entry, contents, 10, 10 );tttotal_cost += unit_entry->cost;tttt ttif (reinf_unit)ttt;  ttelse if(!(unit_entry->flags & GROUND_TRSP_OK)) {tttlbox_clear_items(pdlg->trsp_lbox);ttttrsp_entry = NULL;tt} else if (lbox_is_empty(pdlg->trsp_lbox) && pdlg->trsp_uclass)tttlbox_set_items(pdlg->trsp_lbox,tttttget_purchasable_unit_lib_entries(tttttpdlg->cur_nation->id,tttttpdlg->trsp_uclass->id,ttttt(const Date*)&scen_info->start_date));t}tt tif (trsp_entry) {ttrender_unit_lib_entry_info( trsp_entry, contents, 10, 155 );tttotal_cost += trsp_entry->cost;t}tt tif ( total_cost > 0 ) {ttchar str[128];ttFont *font = gui->font_std;ttint y = group_get_height( pdlg->main_group ) - 10;ttttsnprintf( str, 128, tr(""Total Cost: %d""), total_cost );ttif (!reinf_unit && !player_can_purchase_unit(cur_player, ttttttunit_entry, trsp_entry)) {tttfont = gui->font_error;ttttotal_cost = 0;  tt}ttfont->align = ALIGN_X_LEFT | ALIGN_Y_BOTTOM;ttwrite_text( font, contents, 10, y, str, 255 );ttttif (total_cost > 0) {tttfont->align = ALIGN_X_RIGHT | ALIGN_Y_BOTTOM;tttwrite_text( font, contents, ttttgroup_get_width( pdlg->main_group ) - 62, y,ttttreinf_unit?tr(""REFUND?""):tr(""REQUEST?""), 255 );tt}t}tt tif (total_cost > 0)ttgroup_set_active( pdlg->main_group, ID_PURCHASE_OK, 1 );telsettgroup_set_active( pdlg->main_group, ID_PURCHASE_OK, 0 );t tframe_apply( pdlg->main_group->frame );}",3,"cwe119,cwe120,cweother"
"timestamp(){tstatic char buf[80];t tstatic time_t saveTime = 0;ttime_t t = time(0);tif (t != saveTime) {ttstruct tm *tmp = localtime(&t);ttstrftime(buf, (size_t)sizeof(buf), ""%c"", tmp);ttsaveTime = t;t}treturn buf;}",2,"cwe119,cwe120"
"""_eglPreloadForEach(const char *search_path,                   EGLBoolean (*loader)(const char *, size_t, void *),                   void *loader_data){   const char *cur, *next;   size_t len;   cur = search_path;   while (cur) {      next = strchr(cur, ':');      len = (next) ? next - cur : strlen(cur);      if (!loader(cur, len, loader_data))         break;      cur = (next) ? next + 1 : NULL;   }}""",3,"cwe119,cwe120,cweother"
"""sis_read_i(Store *store, FindSegmentsFile *fsf){    int seg_cnt;    int i;    bool success = false;    char seg_file_name[SEGMENT_NAME_MAX_LENGTH];    InStream *is = NULL;    SegmentInfos *sis = ALLOC_AND_ZERO(SegmentInfos);    segfn_for_generation(seg_file_name, fsf->generation);    TRY        is = store->open_input(store, seg_file_name);        sis->store = store;        sis->generation = fsf->generation;        sis->format = is_read_u32(is); /* do nothing. it's the first version */        sis->version = is_read_u64(is);        sis->counter = is_read_u64(is);        seg_cnt = is_read_vint(is);        /* allocate space for segments */        for (sis->capa = 4; sis->capa < seg_cnt; sis->capa <<= 1) {        }        sis->size = 0;        sis->segs = ALLOC_N(SegmentInfo *, sis->capa);        for (i = 0; i < seg_cnt; i++) {            sis_add_si(sis, si_read(store, is));        }        sis->fis = fis_read(is);        success = true;    XFINALLY        if (is) is_close(is);        if (!success) {            sis_destroy(sis);        }    XENDTRY    fsf->p_return = sis;}""",2,"cwe119,cwe120"
"krb5_get_as_key_password(krb5_context context,                         krb5_principal client,                         krb5_enctype etype,                         krb5_prompter_fct prompter,                         void *prompter_data,                         krb5_data *salt,                         krb5_data *params,                         krb5_keyblock *as_key,                         void *gak_data,                         k5_response_items *ritems){    struct gak_password *gp = gak_data;    krb5_error_code ret;    krb5_data defsalt;    char *clientstr;    char promptstr[1024], pwbuf[1024];    krb5_data pw;    krb5_prompt prompt;    krb5_prompt_type prompt_type;    const char *rpass;         if (as_key == NULL) {        if (gp->password != NULL)            return 0;        return k5_response_items_ask_question(ritems,                                              KRB5_RESPONDER_QUESTION_PASSWORD,                                              """");    }         if (as_key->length) {        if (as_key->enctype != etype) {            krb5_free_keyblock_contents (context, as_key);            as_key->length = 0;        }    }    if (gp->password == NULL) {                 rpass = k5_response_items_get_answer(ritems,                                             KRB5_RESPONDER_QUESTION_PASSWORD);        if (rpass != NULL) {            ret = alloc_data(&gp->storage, strlen(rpass));            if (ret)                return ret;            memcpy(gp->storage.data, rpass, strlen(rpass));            gp->password = &gp->storage;        }    }    if (gp->password == NULL) {        if (prompter == NULL)            return(EIO);        if ((ret = krb5_unparse_name(context, client, &clientstr)))            return(ret);        snprintf(promptstr, sizeof(promptstr), _(""Password for %s""),                 clientstr);        free(clientstr);        pw = make_data(pwbuf, sizeof(pwbuf));        prompt.prompt = promptstr;        prompt.hidden = 1;        prompt.reply = &pw;        prompt_type = KRB5_PROMPT_TYPE_PASSWORD;                 k5_set_prompt_types(context, &prompt_type);        ret = (*prompter)(context, prompter_data, NULL, NULL, 1, &prompt);        k5_set_prompt_types(context, 0);        if (ret)            return(ret);        ret = krb5int_copy_data_contents(context, &pw, &gp->storage);        zap(pw.data, pw.length);        if (ret)            return ret;        gp->password = &gp->storage;    }    if (salt == NULL) {        if ((ret = krb5_principal2salt(context, client, &defsalt)))            return(ret);        salt = &defsalt;    } else {        defsalt.length = 0;    }    ret = krb5_c_string_to_key_with_params(context, etype, gp->password, salt,                                           params->data?params:NULL, as_key);    if (defsalt.length)        free(defsalt.data);    return(ret);}",2,"cwe119,cwe120"
"x509write_crt_set_authority_key_identifier( x509write_cert *ctx ){    int ret;    unsigned char buf[POLARSSL_MPI_MAX_SIZE * 2 + 20];      unsigned char *c = buf + sizeof(buf);    size_t len = 0;    memset( buf, 0, sizeof(buf));    ASN1_CHK_ADD( len, pk_write_pubkey( &c, buf, ctx->issuer_key ) );    sha1( buf + sizeof(buf) - len, len, buf + sizeof(buf) - 20 );    c = buf + sizeof(buf) - 20;    len = 20;    ASN1_CHK_ADD( len, asn1_write_len( &c, buf, len ) );    ASN1_CHK_ADD( len, asn1_write_tag( &c, buf, ASN1_CONTEXT_SPECIFIC | 0 ) );    ASN1_CHK_ADD( len, asn1_write_len( &c, buf, len ) );    ASN1_CHK_ADD( len, asn1_write_tag( &c, buf, ASN1_CONSTRUCTED | ASN1_SEQUENCE ) );    return x509write_crt_set_extension( ctx, OID_AUTHORITY_KEY_IDENTIFIER,                                   OID_SIZE( OID_AUTHORITY_KEY_IDENTIFIER ),                                   0, buf + sizeof(buf) - len, len );}",2,"cwe119,cwe120"
"filter_date_print(const seaudit_filter_t * filter, const char *name, FILE * f, int tabs){tint i;txmlChar *s, *escaped;tif (filter->start == NULL) {ttreturn;t}tfor (i = 0; i < tabs; i++)ttfprintf(f, ""t"");tfprintf(f, ""<criteria type=""%s"">"", name);ts = xmlCharStrdup(asctime(filter->start));tescaped = xmlURIEscapeStr(s, NULL);tfor (i = 0; i < tabs + 1; i++) {ttfprintf(f, ""t"");t}tfprintf(f, ""<item>%s</item>"", escaped);tfree(s);tfree(escaped);ts = xmlCharStrdup(asctime(filter->end));tescaped = xmlURIEscapeStr(s, NULL);tfor (i = 0; i < tabs + 1; i++)ttfprintf(f, ""t"");tfprintf(f, ""<item>%s</item>"", escaped);tfree(s);tfree(escaped);tfor (i = 0; i < tabs + 1; i++)ttfprintf(f, ""t"");tfprintf(f, ""<item>%d</item>"", filter->date_match);tfor (i = 0; i < tabs; i++)ttfprintf(f, ""t"");tfprintf(f, ""</criteria>"");}",2,"cwe120,cweother"
"gui_gtk_fi_add_event(GtkWidget *w, gpointer *_fi){tGuiGtkFI *fi = (GuiGtkFI *) _fi;tunsigned int addr;tconst char *loc0[4];tconst char *loc1[4];tfor (addr = 0; addr < fi->nloc0s; addr++) {ttloc0[addr] = gtk_entry_get_text(GTK_ENTRY(fi->loc0[addr].entry));t}tfor ( ; addr < 4; addr++) {ttloc0[addr] = NULL;t}tfor (addr = 0; addr < fi->nloc1s; addr++) {ttloc1[addr] = gtk_entry_get_text(GTK_ENTRY(fi->loc1[addr].entry));t}tfor ( ; addr < 4; addr++) {ttloc1[addr] = NULL;t}tgui_gtk_fi_add(fi, fi->type, loc0, loc1);tgtk_widget_hide(fi->dialog);}",2,"cwe119,cwe120"
"gst_udp_parse_uri (const gchar * uristr, GstUDPUri * uri){  gchar *protocol, *location_start;  gchar *location, *location_end;  gchar *colptr;     protocol = gst_uri_get_protocol (uristr);  if (!protocol)    goto no_protocol;  if (strcmp (protocol, ""udp"") != 0)    goto wrong_protocol;  g_free (protocol);  location_start = gst_uri_get_location (uristr);  if (!location_start)    return FALSE;  GST_DEBUG (""got location '%s'"", location_start);     location = g_strstr_len (location_start, -1, ""@"");  if (location == NULL)    location = location_start;  else    location += 1;  if (location[0] == '[') {    GST_DEBUG (""parse IPV6 address '%s'"", location);    location_end = strchr (location, ']');    if (location_end == NULL)      goto wrong_address;    uri->is_ipv6 = TRUE;    g_free (uri->host);    uri->host = g_strndup (location + 1, location_end - location - 1);    colptr = strrchr (location_end, ':');  } else {    GST_DEBUG (""parse IPV4 address '%s'"", location);    uri->is_ipv6 = FALSE;    colptr = strrchr (location, ':');    g_free (uri->host);    if (colptr != NULL) {      uri->host = g_strndup (location, colptr - location);    } else {      uri->host = g_strdup (location);    }  }  GST_DEBUG (""host set to '%s'"", uri->host);  if (colptr != NULL) {    uri->port = atoi (colptr + 1);  }  g_free (location_start);  return 0;   no_protocol:  {    GST_ERROR (""error parsing uri %s: no protocol"", uristr);    return -1;  }wrong_protocol:  {    GST_ERROR (""error parsing uri %s: wrong protocol (%s != udp)"", uristr,        protocol);    g_free (protocol);    return -1;  }wrong_address:  {    GST_ERROR (""error parsing uri %s"", uristr);    g_free (location);    return -1;  }}",2,"cwe469,cweother"
"ihx32_read(FILE * hexFile, unsigned char * romImage, unsigned char *eepromImage, unsigned char *fuseImage, deviceConfig_t config ) {tint lba = 0;tchar lineBuffer[256];tconst char* cp;tchar partBuffer[5];tchar *destImage;tint numBytes;tint address;tint recType;tint value;tint ii;tint done = 0;tDEBUG_p(""Preparing to read from hex file"");twhile (done == 0) {ttfgets(lineBuffer,255,hexFile);      cp = lineBuffer;tt       if( ':' != *cp++ )tcontinue;   tt       numBytes = (ascii2hexNybble( *cp++ ) << 4) + ascii2hexNybble( *cp++ );tt       for( ii = 0, address = 0; ii < 4; ii++ )      {         address <<= 4;         address += ascii2hexNybble( *cp++ );      }tt       recType = (ascii2hexNybble( *cp++ ) << 4) + ascii2hexNybble( *cp++ );ttswitch(recType) {tttcase 0:  ttttaddress += lba;            if( address >= config.configStart )            {               if( address >= config.eepromStart )                  destImage = eepromImage + address - config.eepromStart;               else                  destImage = fuseImage + 8 + address - config.configStart;               for( ii = 0; ii < numBytes; ii++ )                  *destImage++ = (ascii2hexNybble( *cp++ ) << 4) + ascii2hexNybble( *cp++ );            }            else            {               destImage = romImage + address;               for( ii = 0; ii < numBytes; ii += 2, destImage += 2 )               {                  destImage[1] = (ascii2hexNybble( *cp++ ) << 4) + ascii2hexNybble( *cp++ );                  destImage[0] = (ascii2hexNybble( *cp++ ) << 4) + ascii2hexNybble( *cp++ );               }            }ttttbreak;tttcase 1:  ttttdone = 1;ttttbreak;tttcase 2:  ttttbreak;tttcase 4:              for( ii = 0, lba = 0; ii < 4; ii++ )            {               lba <<= 4;               lba += ascii2hexNybble( *cp++ );            }            lba <<= 16;ttttbreak;tt}t}treturn 0;}",2,"cwe119,cwe120"
"snd_intel8x0_proc_read(struct snd_info_entry * entry,tttt   struct snd_info_buffer *buffer){tstruct intel8x0 *chip = entry->private_data;tunsigned int tmp;tsnd_iprintf(buffer, ""Intel8x0"");tif (chip->device_type == DEVICE_ALI)ttreturn;ttmp = igetdword(chip, ICHREG(GLOB_STA));tsnd_iprintf(buffer, ""Global control        : 0x%08x"", igetdword(chip, ICHREG(GLOB_CNT)));tsnd_iprintf(buffer, ""Global status         : 0x%08x"", tmp);tif (chip->device_type == DEVICE_INTEL_ICH4)ttsnd_iprintf(buffer, ""SDM                   : 0x%08x"", igetdword(chip, ICHREG(SDM)));tsnd_iprintf(buffer, ""AC'97 codecs ready    :"");tif (tmp & chip->codec_isr_bits) {ttint i;ttstatic const char *codecs[3] = {ttt""primary"", ""secondary"", ""tertiary""tt};ttfor (i = 0; i < chip->max_codecs; i++)tttif (tmp & chip->codec_bit[i])ttttsnd_iprintf(buffer, "" %s"", codecs[i]);t} elsettsnd_iprintf(buffer, "" none"");tsnd_iprintf(buffer, """");tif (chip->device_type == DEVICE_INTEL_ICH4 ||t    chip->device_type == DEVICE_SIS)ttsnd_iprintf(buffer, ""AC'97 codecs SDIN     : %i %i %i"",tttchip->ac97_sdin[0],tttchip->ac97_sdin[1],tttchip->ac97_sdin[2]);}",2,"cwe119,cwe120"
"""vc_replace_new_(FLAC__StreamMetadata_VorbisComment_Entry *entry, FLAC__StreamMetadata *block, const char *field, FLAC__bool all){tint indx;tchar field_name[256];tconst char *eq = strchr(field, '=');tFLAC__ASSERT(eq>field && (unsigned)(eq-field) < sizeof(field_name));tmemcpy(field_name, field, eq-field);tfield_name[eq-field]='0';tindx = vc_find_from_(block, field_name, 0);tif(indx < 0)ttvc_insert_new_(entry, block, block->data.vorbis_comment.num_comments, field);telse {ttvc_set_new_(entry, block, (unsigned)indx, field);ttif(all) {tttfor(indx = indx+1; indx >= 0 && (unsigned)indx < block->data.vorbis_comment.num_comments; )ttttif((indx = vc_find_from_(block, field_name, (unsigned)indx)) >= 0)tttttvc_delete_(block, (unsigned)indx);tt}t}tvc_calc_len_(block);}""",2,"cwe119,cwe120"
"parse_options(int argc, char *argv[]){    int c;    while ((c = getopt(argc, argv, ""+be:E:ip:ql:L:m:u:VF:f:I:A:-"")) >= 0) {        switch (c) {        case 'b': batch_mode = TRUE; break;        case 'i': interactive_mode = TRUE; break;        case 'q': load_initfile = FALSE; break;        case 'V': version(); break;        case 'f': further_options(optarg); break;        case 'p': profiler_options(optarg); break;        case 'F': feature_options(optarg); break;        case 'm':            main_module = Scm_Intern(SCM_STRING(SCM_MAKE_STR_COPYING(optarg)));            break;        case 'u':  ;        case 'l':  ;        case 'L':  ;        case 'I':  ;        case 'A':  ;        case 'e':  ;        case 'E':  ;            pre_cmds = Scm_Acons(SCM_MAKE_CHAR(c),                                 SCM_MAKE_STR_COPYING(optarg), pre_cmds);            break;tcase '-': break;        case '?': usage(); break;        }    }    return optind;}",2,"cwe120,cweother"
"search_for_application_mime_type (ActivateParametersInstall *parameters_install, const gchar *mime_type){tGdkWindow *window;tguint xid = 0;tconst char *mime_types[2];tg_assert (parameters_install->proxy != NULL);tt twindow = gtk_widget_get_window (GTK_WIDGET (parameters_install->parent_window));tif (window != NULL) {ttxid = GDK_WINDOW_XID (window);t}tmime_types[0] = mime_type;tmime_types[1] = NULL;tg_dbus_proxy_call (parameters_install->proxy,ttt   ""InstallMimeTypes"",ttt   g_variant_new (""(u^ass)"",ttttt  xid,ttttt  mime_types,ttttt  ""hide-confirm-search""),ttt   G_DBUS_CALL_FLAGS_NONE,ttt   G_MAXINT  ,ttt   NULL  ,ttt   (GAsyncReadyCallback) search_for_application_dbus_call_notify_cb,ttt   parameters_install);tDEBUG (""InstallMimeType method invoked for %s"", mime_type);}",2,"cwe119,cwe120"
"x509parse_dn_gets( char *buf, size_t size, const x509_name *dn ){    int i, ret, n;    unsigned char c;    const x509_name *name;    char s[128], *p;    memset( s, 0, sizeof( s ) );    name = dn;    p = buf;    n = size;    while( name != NULL )    {        if( name != dn ) {            ret = snprintf( p, n, "", "" );            SAFE_SNPRINTF();        }        if( memcmp( name->oid.p, OID_X520, 2 ) == 0 )        {            switch( name->oid.p[2] )            {            case X520_COMMON_NAME:                ret = snprintf( p, n, ""CN="" ); break;            case X520_COUNTRY:                ret = snprintf( p, n, ""C=""  ); break;            case X520_LOCALITY:                ret = snprintf( p, n, ""L=""  ); break;            case X520_STATE:                ret = snprintf( p, n, ""ST="" ); break;            case X520_ORGANIZATION:                ret = snprintf( p, n, ""O=""  ); break;            case X520_ORG_UNIT:                ret = snprintf( p, n, ""OU="" ); break;            default:                ret = snprintf( p, n, ""0x%02X="",                               name->oid.p[2] );                break;            }        SAFE_SNPRINTF();        }        else if( memcmp( name->oid.p, OID_PKCS9, 8 ) == 0 )        {            switch( name->oid.p[8] )            {            case PKCS9_EMAIL:                ret = snprintf( p, n, ""emailAddress="" ); break;            default:                ret = snprintf( p, n, ""0x%02X="",                               name->oid.p[8] );                break;            }        SAFE_SNPRINTF();        }        else    {            ret = snprintf( p, n, ""??="" );        SAFE_SNPRINTF();        }        for( i = 0; i < name->val.len; i++ )        {            if( i >= (int) sizeof( s ) - 1 )                break;            c = name->val.p[i];            if( c < 32 || c == 127 || ( c > 128 && c < 160 ) )                 s[i] = '?';            else s[i] = c;        }        s[i] = '0';        ret = snprintf( p, n, ""%s"", s );    SAFE_SNPRINTF();        name = name->next;    }    return( size - n );}",2,"cwe119,cwe120"
"ipmi_ek_display_carrier_connectivity( struct ipmi_ek_multi_header * record ){   int return_value = ERROR_STATUS;   struct fru_picmgext_carrier_p2p_record rsc_desc;   struct fru_picmgext_carrier_p2p_descriptor *port_desc;   if ( record == NULL ){      lprintf(LOG_ERR, ""P2P connectivity record is invalid"");      return_value = ERROR_STATUS;   }   else{      int offset = START_DATA_OFFSET;      if ( verbose > 1 ){         int k = 0;         printf(""Binary data of Carrier p2p connectivity""                  "" record starting from mfg id"");         for ( k = 0; k < ( record->header.len ); k++ ){            printf(""%02x   "", record->data[k]);         }         printf("""");      }      while ( offset <= (record->header.len - START_DATA_OFFSET) ){         rsc_desc.resource_id = record->data[offset++];         rsc_desc.p2p_count = record->data[offset++];         if ( verbose > 0 ){            printf(""resource id= %02x  port count= %d"",                        rsc_desc.resource_id,rsc_desc.p2p_count);         }                   if ( ( (rsc_desc.resource_id & AMC_MODULE) ) == AMC_MODULE ) {                         if ((rsc_desc.resource_id == AMC_MODULE)){               printf(""   %s topology:"", val2str( RTM_IPMB_L,                                 ipmi_ekanalyzer_IPMBL_addr));            }            else{                               printf(""   %s topology:"",                        val2str( (rsc_desc.resource_id & 0x0f),                        ipmi_ekanalyzer_module_type));            }         }         else{            printf(""   On Carrier Device ID %d topology: "",                        (rsc_desc.resource_id & 0x0f));         }         while ( rsc_desc.p2p_count > 0 ){ttunsigned char data[3];#ifndef WORDS_BIGENDIANttdata[0] = record->data[offset+0];ttdata[1] = record->data[offset+1];ttdata[2] = record->data[offset+2];#elsettdata[0] = record->data[offset+2];ttdata[1] = record->data[offset+1];ttdata[2] = record->data[offset+0];#endifttport_desc = (struct fru_picmgext_carrier_p2p_descriptor*)data;ttoffset += sizeof (struct fru_picmgext_carrier_p2p_descriptor);ttif ((port_desc->remote_resource_id & AMC_MODULE) == AMC_MODULE) {tttprintf(""tPort %d =====> %s, Port %d"",ttttport_desc->local_port,ttttval2str( (port_desc->remote_resource_id & 0x0f),tttttipmi_ekanalyzer_module_type),ttttport_desc->remote_port);tt}ttelse {tttprintf(""tPort %d =====> On Carrier Device ID %d, Port %d"",ttttport_desc->local_port,tttt(port_desc->remote_resource_id & 0x0f),ttttport_desc->remote_port);tt}ttrsc_desc.p2p_count--;         }      }      return_value = OK_STATUS;   }   return return_value;}",2,"cwe119,cwe120"
"iscsi_build_login_request_strings ( struct iscsi_session *iscsi,ttttt       void *data, size_t len ) {tunsigned int used = 0;tconst char *auth_method;tif ( iscsi->status & ISCSI_STATUS_STRINGS_SECURITY ) {tt ttauth_method = ""None"";tt ttif ( iscsi->initiator_username )tttauth_method = ""CHAP,None"";tt ttif ( iscsi->target_username )tttauth_method = ""CHAP"";ttused += ssnprintf ( data + used, len - used,tttt    ""InitiatorName=%s%c""tttt    ""TargetName=%s%c""tttt    ""SessionType=Normal%c""tttt    ""AuthMethod=%s%c"",tttt    iscsi->initiator_iqn, 0,tttt    iscsi->target_iqn, 0, 0,tttt    auth_method, 0 );t}tif ( iscsi->status & ISCSI_STATUS_STRINGS_CHAP_ALGORITHM ) {ttused += ssnprintf ( data + used, len - used, ""CHAP_A=5%c"", 0 );t}ttif ( ( iscsi->status & ISCSI_STATUS_STRINGS_CHAP_RESPONSE ) ) {ttchar buf[ base16_encoded_len ( iscsi->chap.response_len ) + 1 ];ttassert ( iscsi->initiator_username != NULL );ttbase16_encode ( iscsi->chap.response, iscsi->chap.response_len,ttttbuf );ttused += ssnprintf ( data + used, len - used,tttt    ""CHAP_N=%s%cCHAP_R=0x%s%c"",tttt    iscsi->initiator_username, 0, buf, 0 );t}tif ( ( iscsi->status & ISCSI_STATUS_STRINGS_CHAP_CHALLENGE ) ) {ttsize_t challenge_len = ( sizeof ( iscsi->chap_challenge ) - 1 );ttchar buf[ base16_encoded_len ( challenge_len ) + 1 ];ttbase16_encode ( ( iscsi->chap_challenge + 1 ), challenge_len,ttttbuf );ttused += ssnprintf ( data + used, len - used,tttt    ""CHAP_I=%d%cCHAP_C=0x%s%c"",tttt    iscsi->chap_challenge[0], 0, buf, 0 );t}tif ( iscsi->status & ISCSI_STATUS_STRINGS_OPERATIONAL ) {ttused += ssnprintf ( data + used, len - used,tttt    ""HeaderDigest=None%c""tttt    ""DataDigest=None%c""tttt    ""MaxConnections=1%c""tttt    ""InitialR2T=Yes%c""tttt    ""ImmediateData=No%c""tttt    ""MaxRecvDataSegmentLength=8192%c""tttt    ""MaxBurstLength=262144%c""tttt    ""DefaultTime2Wait=0%c""tttt    ""DefaultTime2Retain=0%c""tttt    ""MaxOutstandingR2T=1%c""tttt    ""DataPDUInOrder=Yes%c""tttt    ""DataSequenceInOrder=Yes%c""tttt    ""ErrorRecoveryLevel=0%c"",tttt    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );t}treturn used;}",2,"cwe119,cwe120"
GMAclose(void){    if (GMAfp) {tfclose(GMAfp);tGMAfp = NULL;    }    if (GMApathname != NULL) {tunlink(GMApathname);        free(GMApathname);tGMApathname = NULL;    }},2,"cwe119,cwe120"
"lcrt_config_load_language(){    char buf[256];    int rv;    struct lcrt_config config;    char *path[] = {""."", "".."", LCRT_INSTALL_DIR};    int i;    snprintf(buf, sizeof(buf), ""%s/""LANGUAGE_DIR, local_config_dir);    lcrt_fmkdir(buf);    snprintf(buf, sizeof(buf), ""%s/%s/""LANGUAGE_DB_NAME, local_config_dir, LANGUAGE_DIR);    lcrt_config_init(&config, buf, LANGUAGE_DB_TABLE);    if (config.open(&config) != 0) {        strncpy(buf, DEFAULT_LANGUAGE_DB, sizeof(buf));        goto out;    }    rv = config.select(&config, ""SELECT * FROM %s where name='language'"", config.db_table);    if (rv == LCRTE_NOT_FOUND || rv == LCRTE_NO_TABLE) {        strncpy(buf, DEFAULT_LANGUAGE_DB, sizeof(buf));        if (rv == LCRTE_NO_TABLE)            config.exec(&config, ""CREATE TABLE %s(name VARCHAR(64) PRIMARY KEY, value VARCHAR(255))"", config.db_table);        config.exec(&config, ""INSERT INTO %s VALUES('language', '%s')"", config.db_table, buf);        goto out1;    } else {        strncpy(buf, config.get_text_col(&config, 1), sizeof(buf));        config.get_row(&config);    }out1:    config.close(&config);out:    debug_print(""CURRENT LANGUAGE = %s"", buf);    for (i = 0; i < 3; i++) {        sprintf(config_language, ""%s/%s/%s"", path[i], LANGUAGE_DIR, buf);        if (access(config_language, F_OK | R_OK) == 0)            goto ret;    }    fprintf(stderr, ""LCRT:missing language database"");ret:    debug_print(""LANGUAGE DIR: %s"", config_language);    return LCRTE_OK;}",3,"cwe119,cwe120,cweother"
"load_diri (filename)char filename[LARGE_BUFF_LENGTH];{   FILE* fin;   int i, aa, numc, type;   char line[MAXLINE], *ptr;   struct diri *diric;   double denom;   double background_frequency[AAS];   if ((fin = fopen (filename, ""r"")) == NULL)    {      sprintf (ErrorBuffer, ""dirichlet(): Cannot open dirichlet file %s"",ttt filename);      ErrorReport(FATAL_ERR_LVL);   }   diric = (struct diri *) malloc(sizeof(struct diri));   if (diric == NULL)   {      sprintf (ErrorBuffer, ""dirichlet(): OUT OF MEMORY"");      ErrorReport(FATAL_ERR_LVL);   }   numc = 0;   while (numc < MAXDIRI && !feof(fin) && fgets(line, MAXLINE, fin) != NULL)   {      type = 0;      if (strstr(line, ""Mixture="") != NULL) type = 1;      if (strstr(line, ""Alpha="") != NULL)  type = 2;      if (type > 0)      {         ptr = strtok(line, ""=""); ptr = strtok(NULL, ""tr "");         switch (type)         {            case 1:               diric->q[numc] = atof(ptr);               break;            case 2:               diric->altot[numc] = atof(ptr);               aa = 1;               while (aa < AAS && ptr != NULL)               {                  ptr = strtok(NULL, ""tr "");                  diric->alpha[numc][aa++] = atof(ptr);               }               numc++;               break;            default:               break;         }      }   }      diric->ncomp = numc;tfor (i = 0; i < numc; i++) {ttfor (aa = 1; aa < AAS; aa++) {tttdiric->alpha_normalized[i][aa] = diric->alpha[i][aa]/diric->altot[i];tt}t}tfor (aa = 1; aa < AAS; aa++) {ttdenom = 0.0;ttfor (i = 0; i < numc; i++) {tttdenom += (diric->q[i] * diric->alpha[i][aa] / tttttttdiric->altot[i]);tt}ttbackground_frequency[aa] = denom;t}tfor (i =0; i < numc; i++) {t ttfor (aa = 1; aa < AAS; aa++) {tttdiric->frequency_to_background_ratio[i][aa] =  tdiric->alpha[i][aa]/(diric->altot[i] * background_frequency[aa]);tt}t}   fclose(fin);   return(diric);}",2,"cwe476,cweother"
"client3_1_lk (call_frame_t *frame, xlator_t *this,              void *data){        clnt_args_t     *args       = NULL;        gfs3_lk_req      req        = {{0,},};        int32_t          gf_cmd     = 0;        int32_t          gf_type    = 0;        int64_t          remote_fd  = -1;        clnt_local_t    *local      = NULL;        clnt_conf_t     *conf       = NULL;        int              op_errno   = ESTALE;        int              ret        = 0;        if (!frame || !this || !data)                goto unwind;        args = data;        conf = this->private;        local = GF_CALLOC (1, sizeof (*local), gf_client_mt_clnt_local_t);        if (!local) {                op_errno = ENOMEM;                goto unwind;        }        CLIENT_GET_REMOTE_FD(conf, args->fd, remote_fd, unwind);        ret = client_cmd_to_gf_cmd (args->cmd, &gf_cmd);        if (ret) {                op_errno = EINVAL;                gf_log (this->name, GF_LOG_WARNING,                        ""Unknown cmd (%d)!"", gf_cmd);                goto unwind;        }        switch (args->flock->l_type) {        case F_RDLCK:                gf_type = GF_LK_F_RDLCK;                break;        case F_WRLCK:                gf_type = GF_LK_F_WRLCK;                break;        case F_UNLCK:                gf_type = GF_LK_F_UNLCK;                break;        }        local->owner = frame->root->lk_owner;        local->cmd   = args->cmd;        local->fd    = fd_ref (args->fd);        frame->local = local;        req.fd    = remote_fd;        req.cmd   = gf_cmd;        req.type  = gf_type;        gf_proto_flock_from_flock (&req.flock, args->flock);        memcpy (req.gfid, args->fd->inode->gfid, 16);        ret = client_submit_request (this, &req, frame, conf->fops, GFS3_OP_LK,                                     client3_1_lk_cbk, NULL,                                     NULL, 0, NULL, 0, NULL,                                     (xdrproc_t)xdr_gfs3_lk_req);        if (ret) {                op_errno = ENOTCONN;                goto unwind;        }        return 0;unwind:        gf_log (this->name, GF_LOG_WARNING, ""failed to send the fop: %s"", strerror (op_errno));        STACK_UNWIND_STRICT (lk, frame, -1, op_errno, NULL);        return 0;}",2,"cwe120,cwe476"
"dns_server_gethostbyname_cb(int result, char type, int count, int ttl,tttttttvoid *addresses, void *arg){tif (result != DNS_ERR_NONE) {ttfprintf(stdout, ""Unexpected result %d. "", result);ttdns_ok = 0;ttgoto out;t}tif (count != 1) {ttfprintf(stdout, ""Unexpected answer count %d. "", count);ttdns_ok = 0;ttgoto out;t}tswitch (type) {tcase DNS_IPv4_A: {ttstruct in_addr *in_addrs = addresses;ttif (in_addrs[0].s_addr != htonl(0xc0a80b0bUL) || ttl != 12345) {tttfprintf(stdout, ""Bad IPv4 response ""%s"" %d. "",tttttinet_ntoa(in_addrs[0]), ttl);tttdns_ok = 0;tttgoto out;tt}ttbreak;t}tcase DNS_IPv6_AAAA: {#if defined (HAVE_STRUCT_IN6_ADDR) && defined(HAVE_INET_NTOP) && defined(INET6_ADDRSTRLEN)ttstruct in6_addr *in6_addrs = addresses;ttchar buf[INET6_ADDRSTRLEN+1];ttif (memcmp(&in6_addrs[0].s6_addr, ""abcdefghijklmnop"", 16)ttt|| ttl != 123) {tttconst char *b = inet_ntop(AF_INET6, &in6_addrs[0],buf,sizeof(buf));tttfprintf(stdout, ""Bad IPv6 response ""%s"" %d. "", b, ttl);tttdns_ok = 0;tttgoto out;tt}#endifttbreak;t}tcase DNS_PTR: {ttchar **addrs = addresses;ttif (strcmp(addrs[0], ""ZZ.EXAMPLE.COM"") || ttl != 54321) {tttfprintf(stdout, ""Bad PTR response ""%s"" %d. "",tttttaddrs[0], ttl);tttdns_ok = 0;tttgoto out;tt}ttbreak;t}tdefault:ttfprintf(stdout, ""Bad response type %d. "", type);ttdns_ok = 0;t} out:tif (++n_server_responses == 3) {ttevent_loopexit(NULL);t}}",2,"cwe119,cwe120"
"putInt(unsigned int v, char **pz){  static const char zDigits[] =     ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~"";     int i, j;  char zBuf[20];  if( v==0 ){    *(*pz)++ = '0';    return;  }  for(i=0; v>0; i++, v>>=6){    zBuf[i] = zDigits[v&0x3f];  }  for(j=i-1; j>=0; j--){    *(*pz)++ = zBuf[j];  }}",2,"cwe119,cwe120"
"il4965_rs_sta_dbgfs_scale_table_write(struct file *file,tttt      const char __user *user_buf,tttt      size_t count, loff_t *ppos){tstruct il_lq_sta *lq_sta = file->private_data;tstruct il_priv *il;tchar buf[64];tsize_t buf_size;tu32 parsed_rate;til = lq_sta->drv;tmemset(buf, 0, sizeof(buf));tbuf_size = min(count, sizeof(buf) - 1);tif (copy_from_user(buf, user_buf, buf_size))ttreturn -EFAULT;tif (sscanf(buf, ""%x"", &parsed_rate) == 1)ttlq_sta->dbg_fixed_rate = parsed_rate;telsettlq_sta->dbg_fixed_rate = 0;tlq_sta->active_legacy_rate = 0x0FFF;t tlq_sta->active_siso_rate = 0x1FD0;t tlq_sta->active_mimo2_rate = 0x1FD0;t tD_RATE(""sta_id %d rate 0x%X"", lq_sta->lq.sta_id,t       lq_sta->dbg_fixed_rate);tif (lq_sta->dbg_fixed_rate) {ttil4965_rs_fill_link_cmd(NULL, lq_sta, lq_sta->dbg_fixed_rate);ttil_send_lq_cmd(lq_sta->drv, &lq_sta->lq, CMD_ASYNC, false);t}treturn count;}",2,"cwe119,cwe120"
"sync_channel_user (CONNECTION * con, CHANNEL * chan, CHANUSER * chanUser){    ASSERT (chan->local == 0);         send_cmd (con, MSG_CLIENT_JOIN, "":%s %s"", chanUser->user->nick,t      chan->name);         if (chanUser->flags & ON_CHANNEL_OPERATOR)tsend_cmd (con, MSG_CLIENT_OP, "":%s %s %s :%u"",tt  Server_Name, chan->name, chanUser->user->nick,tt  chan->timestamp);    if (chanUser->flags & ON_CHANNEL_VOICE)tsend_cmd (con, MSG_CLIENT_CHANNEL_VOICE, "":%s %s %s :%u"",tt  Server_Name, chan->name, chanUser->user->nick,tt  chan->timestamp);    if (chanUser->flags & ON_CHANNEL_MUZZLED)tsend_cmd (con, MSG_CLIENT_CHANNEL_MUZZLE, "":%s %s %s """" %u"",tt  Server_Name, chan->name, chanUser->user->nick,tt  chan->timestamp);}",2,"cwe119,cwe120"
"partial_dialogue_callback(Widget w,tttt      XtPointer client_data,tttt      XtPointer call_data){    NoticeReplytreply = (NoticeReply)call_data;    PCEtt*c = (PCE *)client_data;    if (global.busy || (global.mode != NewsModeThread &&tttglobal.mode != NewsModeGroup))treturn;    if (reply == NoticeReplyLeft) {tSERVERt*server;tchart*buffer;tFILEt*fp;tfp = create_temp_file(&buffer);tif (!fp) {t    set_message(""Failed to create temp file!"", True);t    return;t}tunlink(buffer);tset_busy(True);tbuffer = snarf_articles(fp, c->arts + 1, c->tot);tif (!buffer) {t    fclose(fp);t    reconnect_server(True);t    unset_busy();t    return;t}tunset_busy();tif (atoi(buffer) != NNTP_OK_ARTICLE) {t    chartmessage[256];t    if (strlen(buffer) > 128)ttbuffer[128] = '0';t    sprintf(message,tt    ""Couldn't get all parts, message from server is: %s"",tt    buffer);t    set_message(message, True);t    fclose(fp);t    return;t}tif (fflush(fp) != 0 || fseek(fp, SEEK_SET, 0) != 0) {t    perror(""knews: fseek"");t    set_message(""Error: couldn't rewind temp file!"", True);t    fclose(fp);t    return;t}tset_curr_art(NULL, False);tserver = server_create(fileno(fp));tbuffer = server_read(server);tif (!res_full_header())t    buffer = do_mime(NULL, server, buffer, False, NULL, 0, NULL);telse {t    XFontStructt*font = ascii_font->header_font;t    Pixeltpixel = global.header_pixel;t    ArtTextClearLines(main_widgets.text);t    ScrollableSuspend(main_widgets.text);t    while (buffer && !IS_DOT(buffer)) {ttArtTextAddLine(main_widgets.text, buffer, font, pixel);ttif (buffer[0] == '0') {tt    font = ascii_font->body_font;tt    pixel = global.pixel;tt}ttbuffer = server_read(server);t    }t    ScrollableResume(main_widgets.text);t}tif (!buffer)t    set_message(""Error with temp file!"", True);telset    set_standard_message();tfclose(fp);tserver_set_fd(server, -1);tserver_free(server);    }    XtPopdown(c->notice);    XtDestroyWidget(c->notice);    c->notice = NULL;    remove_cache_entry(c);}",3,"cwe119,cwe120,cweother"
"visit_service(const RC_DEPTREE *deptree,t      const RC_STRINGLIST *types,t      RC_STRINGLIST *sorted,t      RC_STRINGLIST *visited,t      const RC_DEPINFO *depinfo,t      const char *runlevel, int options){tRC_STRING *type;tRC_STRING *service;tRC_DEPTYPE *dt;tRC_DEPINFO *di;tRC_STRINGLIST *provided;tRC_STRING *p;tconst char *svcname;t tTAILQ_FOREACH(type, visited, entries)ttif (strcmp(type->value, depinfo->service) == 0)tttreturn;t trc_stringlist_add(visited, depinfo->service);tTAILQ_FOREACH(type, types, entries)t{ttif (!(dt = get_deptype(depinfo, type->value)))tttcontinue;ttTAILQ_FOREACH(service, dt->services, entries) {tttif (!(options & RC_DEP_TRACE) ||ttt    strcmp(type->value, ""iprovide"") == 0)ttt{ttttrc_stringlist_add(sorted, service->value);ttttcontinue;ttt}tttif (!(di = get_depinfo(deptree, service->value)))ttttcontinue;tttprovided = get_provided(di, runlevel, options);tttif (TAILQ_FIRST(provided)) {ttttTAILQ_FOREACH(p, provided, entries) {tttttdi = get_depinfo(deptree, p->value);tttttif (di && valid_service(runlevel, di->service, type->value))ttttttvisit_service(deptree, types, sorted, visited, di,ttttttt      runlevel, options | RC_DEP_TRACE);tttt}ttt}tttelse if (di && valid_service(runlevel, service->value, type->value))ttttvisit_service(deptree, types, sorted, visited, di,ttttt      runlevel, options | RC_DEP_TRACE);tttrc_stringlist_free(provided);tt}t}t tif (options & RC_DEP_TRACE &&t    (dt = get_deptype(depinfo, ""iprovide"")))t{ttTAILQ_FOREACH(service, dt->services, entries) {tttif (!(di = get_depinfo(deptree, service->value)))ttttcontinue;tttprovided = get_provided(di, runlevel, options);tttTAILQ_FOREACH(p, provided, entries)ttttif (strcmp(p->value, depinfo->service) == 0) {tttttvisit_service(deptree, types, sorted, visited, di,tttttt       runlevel, options | RC_DEP_TRACE);tttttbreak;tttt}tttrc_stringlist_free(provided);tt}t}t tsvcname = getenv(""RC_SVCNAME"");tif (!svcname || strcmp(svcname, depinfo->service) != 0) {ttif (!get_deptype(depinfo, ""providedby""))tttrc_stringlist_add(sorted, depinfo->service);t}}",2,"cwe469,cweother"
"PQprintTuples(const PGresult *res,ttt  FILE *fout,tt ttt  int PrintAttNames,t ttt  int TerseOutput,t ttt  int colWidthtt ){tinttttnFields;tinttttnTups;tintttti,ttttj;tcharttformatString[80];tchart   *tborder = NULL;tnFields = PQnfields(res);tnTups = PQntuples(res);tif (colWidth > 0)ttsprintf(formatString, ""%%s %%-%ds"", colWidth);telsettsprintf(formatString, ""%%s %%s"");tif (nFields > 0)t{ttttttt ttif (!TerseOutput)tt{tttinttttwidth;tttwidth = nFields * 14;ttttborder = malloc(width + 1);tttif (!tborder)ttt{ttttfprintf(stderr, libpq_gettext(""out of memory""));ttttexit(1);ttt}tttfor (i = 0; i <= width; i++)tttttborder[i] = '-';ttttborder[i] = '0';tttfprintf(fout, ""%s"", tborder);tt}ttfor (i = 0; i < nFields; i++)tt{tttif (PrintAttNames)ttt{ttttfprintf(fout, formatString,ttttttTerseOutput ? """" : ""|"",ttttttPQfname(res, i));ttt}tt}ttif (PrintAttNames)tt{tttif (TerseOutput)ttttfprintf(fout, """");tttelsettttfprintf(fout, ""|%s"", tborder);tt}ttfor (i = 0; i < nTups; i++)tt{tttfor (j = 0; j < nFields; j++)ttt{ttttconst char *pval = PQgetvalue(res, i, j);ttttfprintf(fout, formatString,ttttttTerseOutput ? """" : ""|"",ttttttpval ? pval : """");ttt}tttif (TerseOutput)ttttfprintf(fout, """");tttelsettttfprintf(fout, ""|%s"", tborder);tt}t}tif (tborder)ttfree(tborder);}",3,"cwe119,cwe120,cweother"
"ast_say_datetime_zh(struct ast_channel *chan, time_t t, const char *ints, const char *lang){tstruct timeval when = { t, 0 };tstruct ast_tm tm;tchar fn[256];tint res = 0;tint hour, pm=0;tast_localtime(&when, &tm, NULL);tif (!res)ttres = ast_say_number(chan, tm.tm_year + 1900, ints, lang, (char *) NULL);tif (!res) {ttsnprintf(fn, sizeof(fn), ""digits/mon-%d"", tm.tm_mon);ttres = ast_streamfile(chan, fn, lang);ttif (!res)tttres = ast_waitstream(chan, ints);t}tif (!res)ttres = ast_say_number(chan, tm.tm_mday, ints, lang, (char *) NULL);tif (!res) {ttsnprintf(fn, sizeof(fn), ""digits/day-%d"", tm.tm_wday);ttres = ast_streamfile(chan, fn, lang);ttif (!res)tttres = ast_waitstream(chan, ints);t}thour = tm.tm_hour;tif (!hour)tthour = 12;telse if (hour == 12)ttpm = 1;telse if (hour > 12) {tthour -= 12;ttpm = 1;t}tif (pm) {ttif (!res)tttres = ast_streamfile(chan, ""digits/p-m"", lang);t} else {ttif (!res)tttres = ast_streamfile(chan, ""digits/a-m"", lang);t}tif (!res)ttres = ast_waitstream(chan, ints);tif (!res)ttres = ast_say_number(chan, hour, ints, lang, (char *) NULL);tif (!res)ttres = ast_streamfile(chan, ""digits/oclock"", lang);tif (!res)ttres = ast_waitstream(chan, ints);tif (!res)ttres = ast_say_number(chan, tm.tm_min, ints, lang, (char *) NULL);tif (!res)ttres = ast_streamfile(chan, ""digits/minute"", lang);tif (!res)ttres = ast_waitstream(chan, ints);treturn res;}",2,"cwe119,cwe120"
"insert_allows(struct universal *psource,ttt  char *buf, size_t bufsz){  buf[0] = '0';     improvement_iterate(pimprove) {    requirement_vector_iterate(&pimprove->reqs, req) {      if (are_universals_equal(psource, &req->source)) {        if (!req->negated) {                     char coreq_buf[512] = """", conoreq_buf[512] = """";          requirement_vector_iterate(&pimprove->reqs, coreq) {            if (!are_universals_equal(psource, &coreq->source)) {              char buf2[512] = """";              char *rbuf = coreq->negated ? conoreq_buf : coreq_buf;              universal_name_translation(&coreq->source,                                         buf2, sizeof(buf2));              fc_assert_action(sizeof(coreq_buf) == sizeof(conoreq_buf), break);              if (rbuf[0] == '0') {                fc_strlcpy(rbuf, buf2, sizeof(coreq_buf));              } else {                cat_snprintf(rbuf, sizeof(coreq_buf),                             Q_(""?clistmore:, %s""), buf2);              }            }          } requirement_vector_iterate_end;          if (coreq_buf[0] != '0') {            if (conoreq_buf[0] != '0') {              cat_snprintf(buf, bufsz, _(""Allows %s (with %s but no %s).""),                           improvement_name_translation(pimprove),                           coreq_buf, conoreq_buf);            } else {              cat_snprintf(buf, bufsz, _(""Allows %s (with %s).""),                           improvement_name_translation(pimprove),                           coreq_buf);            }          } else {            if (conoreq_buf[0] != '0') {              cat_snprintf(buf, bufsz, _(""Allows %s (absent %s).""),                           improvement_name_translation(pimprove),                           conoreq_buf);            } else {              cat_snprintf(buf, bufsz, _(""Allows %s.""),                           improvement_name_translation(pimprove));            }          }        } else {                     cat_snprintf(buf, bufsz, _(""Prevents %s.""),                       improvement_name_translation(pimprove));        }        cat_snprintf(buf, bufsz, """");      }    } requirement_vector_iterate_end;  } improvement_iterate_end;}",2,"cwe119,cwe120"
"genders_getmaxnodelen_corner_case(int verbose){  int i = 0;  int errcount = 0;  genders_getmaxnodelen_corner_case_t *tests = &genders_getmaxnodelen_corner_case_tests[0];     {    char buffer[MAXHOSTNAMELEN+1];    char *ptr;    memset(buffer, '0', MAXHOSTNAMELEN+1);    if (gethostname(buffer, MAXHOSTNAMELEN) < 0)      genders_err_exit(""gethostname: %s"", strerror(errno));         if ((ptr = strchr(buffer,'.')))      *ptr = '0';    if (strlen(buffer) > tests[3].expected_return_value)      tests[3].expected_return_value = strlen(buffer);  }  while (!(tests[i].num < 0))     {      errcount += _genders_getfunc_corner_case(genders_getmaxnodelen,ttttt       ""genders_getmaxnodelen"",ttttt       tests[i].num,ttttt       tests[i].param1,ttttt       tests[i].expected_return_value,ttttt       tests[i].expected_errnum,ttttt       verbose);      i++;    }  return errcount;}",2,"cwe119,cwe120"
"Scm_TmpDir(void){#if defined(GAUCHE_WINDOWS)# define TMP_PATH_MAX 1024    TCHAR buf[TMP_PATH_MAX+1], *tbuf = buf;    DWORD r, r2;         r = GetTempPath(TMP_PATH_MAX, buf);    if (r == 0) Scm_SysError(""GetTempPath failed"");    if (r > TMP_PATH_MAX) {        tbuf = SCM_NEW_ATOMIC_ARRAY(TCHAR, r+1);        r2 = GetTempPath(r, tbuf);        if (r2 != r) Scm_SysError(""GetTempPath failed"");    }    return SCM_MAKE_STR_COPYING(SCM_WCS2MBS(tbuf));#else       const char *s;    if ((s = getenv(""TMPDIR"")) != NULL) return SCM_MAKE_STR_COPYING(s);    if ((s = getenv(""TMP"")) != NULL) return SCM_MAKE_STR_COPYING(s);    else return SCM_MAKE_STR(""/tmp"");  #endif  }",3,"cwe119,cwe120,cweother"
"CanonicaliseName(char *name){ char *match,*name2; match=name; while((match=strstr(match,""/./"")) || !strncmp(match=name,""./"",2))   {    char *prev=match, *next=match+2;    while((*prev++=*next++));   } match=name; while((match=strstr(match,""//"")))   {    char *prev=match, *next=match+1;    while((*prev++=*next++));   } match=name2=name; while((match=strstr(match,""/../"")))   {    char *prev=match, *next=match+4;    if((prev-name2)==2 && !strncmp(name2,""../"",3))      {name2+=3;match++;continue;}    while(prev>name2 && *--prev!='/');    match=prev;    if(*prev=='/')prev++;    while((*prev++=*next++));   } match=&name[strlen(name)-2]; if(match>=name && !strcmp(match,""/.""))    *match=0; match=&name[strlen(name)-3]; if(match>=name && !strcmp(match,""/..""))   {    if(match==name)       *++match=0;    else       while(match>name && *--match!='/')          *match=0;   }#if 1   match=&name[strlen(name)-1]; if(match>name && !strcmp(match,""/""))    *match=0; if(!*name)    *name='.',*(name+1)=0;#else   if(!*name || !strncmp(name,""../"",3))    *name='/',*(name+1)=0;#endif return(name);}",2,"cwe469,cweother"
"libjte_write_header(struct libjte_env *o){    int ret;    if (o->jtemplate_out == NULL || o->jjigdo_out == NULL ||        o->outfile == NULL || o->jmd5_list == NULL) {        sprintf(o->message_buffer,               ""Undefined: template_path, jigdo_path, md5_paths, or outfile."");        libjte_add_msg_entry(o, o->message_buffer, 0);        return 0;    }        o->jttemplate = fopen(o->jtemplate_out, ""wb"");    if (o->jttemplate == NULL) {        sprintf(o->message_buffer,                ""Cannot open template file '%1.1024s' for writing. errno=%d"",                o->jtemplate_out, errno);        libjte_add_msg_entry(o, o->message_buffer, 0);        return 0;    }    o->jtjigdo = fopen(o->jjigdo_out, ""wb"");    if (o->jtjigdo == NULL) {        sprintf(o->message_buffer,                ""Cannot open jigdo file '%1.1024s' for writing. errno=%d"",                o->jjigdo_out, errno);        libjte_add_msg_entry(o, o->message_buffer, 0);        return 0;    }    ret = write_jt_header(o, o->jttemplate, o->jtjigdo);    if (ret <= 0)        return ret;    return 1;}",2,"cwe120,cweother"
"rem_temp_swap() {tchar file[PATH_MAX];tlong pid;tpid = getpid();tsnprintf(file, PATH_MAX, ""%s/swap/temp/swapfile-%ld"", MOUNT_DIR, pid);tif (opt_dry_run) {ttprintf(""swapoff %srm -f %s"", file, file);ttreturn;t}tif (swapoff(file))ttWARNING(""swapoff on %s failed: %s"", file, strerror(errno));tremove(file);tDEBUG(""swapoff %s"", file);}",2,"cwe119,cwe120"
"main(int argc, char** argv) {    char path[MAXPATHLEN];    int retval;    if ( (argc == 1) ||  !strcmp(argv[1], ""-h"")  || !strcmp(argv[1],""--help"") || (argc != 2) ) {        fprintf(stderr, ""%s"", usage);        exit(1);    }    retval = config.parse_file();    if (retval) {        fprintf(stderr, ""Can't parse config.xml: %s"", boincerror(retval));        exit(1);    }    retval = dir_hier_path(        argv[1], config.download_dir, config.uldl_dir_fanout, path, true    );    if (retval) {        fprintf(stderr, ""dir_hier_path(): %s"", boincerror(retval));        exit(1);    }    printf(""%s"", path);}",2,"cwe119,cwe120"
"reload_tsin_db(){  char tt[512];  if (!current_tsin_fname)    return;  strcpy(tt, current_tsin_fname);  free(current_tsin_fname); current_tsin_fname = NULL;  load_tsin_db0(tt, tsin_is_gtab);}",2,"cwe119,cwe120"
"extract_port(char *str, short *port_ptr)t{tint i;tstruct servent *s;ti=atoi(str);tif (i != 0)tt*port_ptr=(unsigned short)i;telsett{tts=getservbyname(str,""tcp"");ttif (s == NULL)ttt{tttBIO_printf(bio_err,""getservbyname failure for %s"",str);tttreturn(0);ttt}tt*port_ptr=ntohs((unsigned short)s->s_port);tt}treturn(1);t}",3,"cwe119,cwe120,cweother"
"read_connection(struct connection *cn){tsize_t bytestoread, bytestomove, offset;tssize_t nr;tbytestoread = cn->header_input.ceiling - cn->header_input.end;tif (bytestoread == 0) {ttoffset = cn->header_input.start - cn->header_input.floor;ttif (offset == 0) {tttlog_d(""input buffer full"");tttclose_connection(cn);tttreturn -1;tt}ttbytestomove = cn->header_input.end - cn->header_input.start;ttmemmove(cn->header_input.floor, cn->header_input.start, bytestomove);ttcn->header_input.start -= offset;ttcn->header_input.middle -= offset;ttcn->header_input.end -= offset;ttbytestoread = cn->header_input.ceiling - cn->header_input.end;t}tnr = read(cn->fd, cn->header_input.end, bytestoread);tif (debug)ttlog_d(""read_connection: %d %d %u %d"", cn->fd, (int) (cn->header_input.end - cn->header_input.floor), (unsigned) bytestoread, (int) nr);tif (nr == -1) {ttif (errno == EAGAIN)tttreturn 0;ttif (debug)tttlerror(""read"");ttclose_connection(cn);ttreturn -1;t}tif (nr == 0) {ttclose_connection(cn);ttreturn -1;t}tcn->nread += nr;tcn->header_input.end += nr;tcn->t = current_time;treturn 0;}",2,"cwe120,cweother"
"test_vgisinternal(){    int32   fid, vgroup_id;    intn    is_internal = FALSE;    int32   vref = -1;    intn    ii, status;    char    internal_array1[20] = {TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,                         TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE};    char    internal_array2[9] = {TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,ttt TRUE, TRUE};    intn    num_errs = 0;               fid = Hopen(VVS_FILE, DFACC_READ, 0);    CHECK(fid, FAIL, ""Hopen: tvdatasvgroups_SD.hdf"");    status = Vstart(fid);    CHECK(status, FAIL, ""Vstart"");    ii = 0;    while ((vref = Vgetid(fid, vref)) != FAIL)    {      tvgroup_id = Vattach(fid, vref, ""r"");  t tis_internal = Vgisinternal(vgroup_id);tCHECK(is_internal, FAIL, ""Vgisinternal"");tVERIFY(is_internal, internal_array1[ii], ""Vgisinternal"");tstatus = Vdetach(vgroup_id);tCHECK(status, FAIL, ""Vdetach"");tii++;    }         status = Vend(fid);    CHECK(status, FAIL, ""Vend"");    status = Hclose(fid);    CHECK(status, FAIL, ""Hclose"");              fid = Hopen(IDTYPE_FILE, DFACC_READ, 0);    CHECK(fid, FAIL, ""Hopen: idtypes.hdf"");    status = Vstart(fid);    CHECK(status, FAIL, ""Vstart"");    ii = 0;    while ((vref = Vgetid(fid, vref)) != FAIL)    {      tvgroup_id = Vattach(fid, vref, ""r"");  t tis_internal = Vgisinternal(vgroup_id);tCHECK(is_internal, FAIL, ""Vgisinternal"");  tVERIFY(is_internal, internal_array2[ii], ""Vgisinternal"");tstatus = Vdetach(vgroup_id);tCHECK(status, FAIL, ""Vdetach"");tii++;      }         status = Vend(fid);    CHECK(status, FAIL, ""Vend"");    status = Hclose(fid);    CHECK(status, FAIL, ""Hclose"");         return num_errs;}",2,"cwe119,cwe120"
"vmsg_send_oob_reply_ack(struct gnutella_node *n,tconst struct guid *muid, uint8 want, const struct array *token){tuint32 msgsize;tuint32 paysize = sizeof(uint8);tchar *payload;tg_assert(NODE_IS_UDP(n));tg_assert(token);tpayload = vmsg_fill_type(v_tmp_data, T_LIME, 11, token->data ? 3 : 2);tpayload[0] = want;tif (token->data) {ttggep_stream_t gs;ttggep_stream_init(&gs, &payload[paysize], sizeof v_tmp - paysize);ttggep_stream_pack(&gs, GGEP_NAME(SO), token->data, token->size, 0);ttpaysize += ggep_stream_close(&gs);t}tmsgsize = vmsg_fill_header(v_tmp_header, paysize, sizeof v_tmp);tvmsg_advertise_udp_compression(v_tmp_header);t tgnutella_header_set_muid(v_tmp_header, muid);t tudp_ctrl_send_msg(n, v_tmp, msgsize);tif (ttGNET_PROPERTY(vmsg_debug) > 2 ||ttGNET_PROPERTY(secure_oob_debug) ||ttGNET_PROPERTY(log_vmsg_tx)t) {ttchar buf[17];ttif (token->data)tttbin_to_hex_buf(token->data, token->size, buf, sizeof buf);ttg_debug(""VMSG sent %s to %s for %u hit%s%s%s"",tttgmsg_infostr_full(v_tmp, msgsize),tttnode_infostr(n), want, want == 1 ? """" : ""s"",ttttoken->data ? "", token=0x"" : """", token->data ? buf : """");t}}",2,"cwe119,cwe120"
"sp_readlink_cbk (call_frame_t *frame, void *cookie, xlator_t *this,                 int32_t op_ret, int32_t op_errno, const char *path,                 struct iatt *buf){        GF_ASSERT (frame);        SP_STACK_UNWIND (readlink, frame, op_ret, op_errno, path, buf);        return 0;}",2,"cwe476,cweother"
"get_VGandInfo( int32 *vg_id,               int32  file_id,               int32  vg_ref,               const  char *file_name,               int32 *n_entries,               char  **vgname,               char  **vgclass ){   intn status, ret_value = SUCCEED;   int32 status_32;   uint16 name_len = 0;         resetVG( vg_id, file_name );    *vg_id = Vattach(file_id, vg_ref, ""r"");    if( *vg_id == FAIL)  tERROR_GOTO_2( ""in %s: Vattach failed for vgroup ref=%d"", tt""get_VGandInfo"", (int) vg_ref );         status_32 = Vgetnamelen(*vg_id, &name_len);    if (FAIL == status_32)      {      ERROR_GOTO_2( ""in %s: Vgetnamelen failed for vg ref=%d"",                ""get_VGandInfo"", (int) vg_ref );    }    if (name_len > 0)    {t*vgname = (char *) HDmalloc(sizeof(char) * (name_len+1));t tCHECK_ALLOC(*vgname, ""*vgname"", ""get_VGandInfo"" );tstatus = Vinquire(*vg_id, n_entries, *vgname);tif (FAIL == status)  t{t    *n_entries = -1;t    ERROR_GOTO_2( ""in %s: Vinquire failed for vg ref=%d"",tt""get_VGandInfo"", (int) vg_ref );t}    }   else    {t*vgname = (char *) HDmalloc(sizeof(char) * (NONAME_LEN));tHDstrcpy( *vgname, ""<Undefined>"" );tstatus = Vinquire(*vg_id, n_entries, NULL);tif (FAIL == status)  t{t    *n_entries = -1;t    ERROR_GOTO_2( ""in %s: Vinquire failed for vg ref=%d"",tt""get_VGandInfo"", (int) vg_ref );t}    }         status_32 = Vgetclassnamelen(*vg_id, &name_len);    if (FAIL == status_32)      {      ERROR_GOTO_2( ""in %s: Vgetclassnamelen failed for vg ref=%d"",                ""get_VGandInfo"", (int) vg_ref );    }    if (name_len > 0)    {t*vgclass = (char *) HDmalloc(sizeof(char) * (name_len+1));t tCHECK_ALLOC(*vgclass, ""*vgclass"", ""get_VGandInfo"" );tstatus_32 = Vgetclass(*vg_id, *vgclass);tif( FAIL == status_32 )  t{t    ERROR_GOTO_2( ""in %s: Vgetclass failed for vgroup ref#=%d"",tt""get_VGandInfo"", (int) vg_ref );t}    }    else    {t*vgclass = (char *) HDmalloc(sizeof(char) * (NONAME_LEN));tHDstrcpy( *vgclass, ""<Undefined>"" );    }done:   if( ret_value == FAIL )   {tif (*vgname != NULL)t{t    HDfree((VOIDP)*vgname);  t    *vgname = NULL;t}tif (*vgclass != NULL)t{t    HDfree((VOIDP)*vgclass);  t    *vgclass = NULL;t}   }       return( ret_value );}",2,"cwe120,cweother"
"do_file(FILE *f){  char line[2048];  char src[1024];  char dest[1024];  char *p, *q, *r;  while (fgets(line, sizeof(line), f)) {    line[strlen(line)-1] = 0;    p = line;    while (*p && isspace(*p)) p++;    if (!*p) {             continue;    }    if (strchr(""#!;"", *p)) {             continue;    }    q = src;    while (*p && *p!=':') {      *q++ = *p++;    }    if (!*p) {      fprintf(stderr, ""Line [%s] does not contain a colon"", line);    } else {      *q = 0;      p++;      r = dest;      while (*p && *p!=':') {        *r++ = *p++;      }      *r = 0;      handle_mapping(src, dest);    }  }}",2,"cwe119,cwe120"
"glusterd_brickinfo_from_brick (char *brick,                               glusterd_brickinfo_t **brickinfo){        int32_t                 ret = -1;        glusterd_brickinfo_t    *new_brickinfo = NULL;        char                    *hostname = NULL;        char                    *path = NULL;        char                    *tmp_host = NULL;        char                    *tmp_path = NULL;        GF_ASSERT (brick);        GF_ASSERT (brickinfo);        tmp_host = gf_strdup (brick);        if (tmp_host && !get_host_name (tmp_host, &hostname))                goto out;        tmp_path = gf_strdup (brick);        if (tmp_path && !get_path_name (tmp_path, &path))                goto out;        GF_ASSERT (hostname);        GF_ASSERT (path);        ret = glusterd_brickinfo_new (&new_brickinfo);        if (ret)                goto out;        strncpy (new_brickinfo->hostname, hostname, 1024);        strncpy (new_brickinfo->path, path, 1024);        *brickinfo = new_brickinfo;        ret = 0;out:        if (tmp_host)                GF_FREE (tmp_host);        if (tmp_host)                GF_FREE (tmp_path);        gf_log ("""", GF_LOG_DEBUG, ""Returning %d"", ret);        return ret;}",3,"cwe120,cwe469,cweother"
"""qcount_read(const char *filepath) {    int fd = open(filepath, O_RDONLY, 0);    if (fd < 0)        return 0;    char buf[20 + 1];    ssize_t readed = read(fd, buf, (sizeof(buf) - 1));    close(fd);    int64_t num = 0;    if (readed > 0) {        buf[readed] = '0';        num = atoll(buf);    }    return num;}""",3,"cwe119,cwe120,cweother"
pbfp(long index) {  if( (fptable == NULL) || ((int)index < 0) || ((int)index >= fptableSize) )    return (FILE *) NULL;  else    return fptable[index];},3,"cwe119,cwe120,cweother"
"glusterd_unlock (uuid_t uuid){        uuid_t  owner;        char    new_owner_str[50];        char    owner_str[50];        int32_t ret = -1;        GF_ASSERT (uuid);        glusterd_get_lock_owner (&owner);        if (uuid_is_null (owner)) {                gf_log (""glusterd"", GF_LOG_ERROR, ""Cluster lock not held!"");                goto out;        }        ret = uuid_compare (uuid, owner);        if (ret) {               gf_log (""glusterd"", GF_LOG_ERROR, ""Cluster lock held by %s""                        "" ,unlock req from %s!"", uuid_utoa_r (owner ,owner_str)                        , uuid_utoa_r (uuid, new_owner_str));               goto out;        }        ret = glusterd_unset_lock_owner (uuid);        if (ret) {                gf_log (""glusterd"", GF_LOG_ERROR, ""Unable to clear cluster ""                        ""lock"");                goto out;        }        ret = 0;out:        return ret;}",2,"cwe119,cwe120"
"""repo_init_structure(repo_init *results){tconst int mode = 0755; /* or 0777 ? */tchar temp_path[GIT_PATH_MAX];tchar *git_dir = results->path_repository;tif (gitfo_mkdir_recurs(git_dir, mode))ttreturn GIT_ERROR;t/* Creates the '/objects/info/' directory */tgit__joinpath(temp_path, git_dir, GIT_OBJECTS_INFO_DIR);tif (gitfo_mkdir_recurs(temp_path, mode) < GIT_SUCCESS)ttreturn GIT_ERROR;t/* Creates the '/objects/pack/' directory */tgit__joinpath(temp_path, git_dir, GIT_OBJECTS_PACK_DIR);tif (gitfo_mkdir(temp_path, mode))ttreturn GIT_ERROR;t/* Creates the '/refs/heads/' directory */tgit__joinpath(temp_path, git_dir, GIT_REFS_HEADS_DIR);tif (gitfo_mkdir_recurs(temp_path, mode))ttreturn GIT_ERROR;t/* Creates the '/refs/tags/' directory */tgit__joinpath(temp_path, git_dir, GIT_REFS_TAGS_DIR);tif (gitfo_mkdir(temp_path, mode))ttreturn GIT_ERROR;t/* TODO: what's left? templates? */treturn GIT_SUCCESS;}""",2,"cwe119,cwe120"
"ooAcceptH225Connection()    {   OOH323CallData * call;   int ret;   char callToken[20];   char remoteIP[2+8*4+7];   OOSOCKET h225Channel=0;   memset(remoteIP, 0, sizeof(remoteIP));   ret = ooSocketAccept (*(gH323ep.listener), &h225Channel,                          remoteIP, NULL);   if(ret != ASN_OK)   {      OOTRACEERR1(""Error:Accepting h225 connection"");      return OO_FAILED;   }   ooGenerateCallToken(callToken, sizeof(callToken));   call = ooCreateCall(""incoming"", callToken);   if(!call)   {      OOTRACEERR1(""ERROR:Failed to create an incoming call"");      return OO_FAILED;   }   ast_mutex_lock(&call->Lock);   call->pH225Channel = (OOH323Channel*)       memAllocZ (call->pctxt, sizeof(OOH323Channel));   call->pH225Channel->sock = h225Channel;       if(!strcmp(call->localIP, ""0.0.0.0"") || !strcmp(call->localIP,""::""))   {      OOTRACEDBGA3(""Determining IP address for incoming call in multihomed ""                   ""mode (%s, %s)"", call->callType, call->callToken);   }   ret = ooSocketGetIpAndPort(h225Channel, call->localIP, 2+8*4+7,                                        &call->pH225Channel->port, &call->versionIP);   if(ret != ASN_OK)   {      OOTRACEERR3(""Error:Failed to retrieve local ip and port from ""                  ""socket for multihomed mode.(%s, %s)"",                    call->callType, call->callToken);      if(call->callState < OO_CALL_CLEAR)      {            call->callState = OO_CALL_CLEAR;         call->callEndReason = OO_REASON_TRANSPORTFAILURE;      }      ast_mutex_unlock(&call->Lock);      return OO_FAILED;   }   OOTRACEDBGA5(""Using Local IP address %s (IPv%d) for incoming call ""                ""(%s, %s)"", call->localIP, call->versionIP, call->callType,                  call->callToken);   if (remoteIP[0]) {tstrncpy(call->remoteIP, remoteIP, strlen(remoteIP));   }      ast_mutex_unlock(&call->Lock);   return OO_OK;}",3,"cwe119,cwe120,cwe469"
"get_units_upgrade_info(char *buf, size_t bufsz,ttt    struct unit_list *punits){  if (unit_list_size(punits) == 0) {    fc_snprintf(buf, bufsz, _(""No units to upgrade!""));    return FALSE;  } else if (unit_list_size(punits) == 1) {    return (UU_OK == unit_upgrade_info(unit_list_front(punits), buf, bufsz));  } else {    int upgrade_cost = 0;    int num_upgraded = 0;    int min_upgrade_cost = FC_INFINITY;    unit_list_iterate(punits, punit) {      if (unit_owner(punit) == client_player()          && UU_OK == unit_upgrade_test(punit, FALSE)) {tstruct unit_type *from_unittype = unit_type(punit);tstruct unit_type *to_unittype = can_upgrade_unittype(client.conn.playing,ttttttt     unit_type(punit));tint cost = unit_upgrade_price(unit_owner(punit),ttttt   from_unittype, to_unittype);tnum_upgraded++;tupgrade_cost += cost;tmin_upgrade_cost = MIN(min_upgrade_cost, cost);      }    } unit_list_iterate_end;    if (num_upgraded == 0) {      fc_snprintf(buf, bufsz, _(""None of these units may be upgraded.""));      return FALSE;    } else {                    char tbuf[MAX_LEN_MSG], ubuf[MAX_LEN_MSG];      fc_snprintf(tbuf, ARRAY_SIZE(tbuf), PL_(""Treasury contains %d gold."",                                              ""Treasury contains %d gold."",                                              client_player()->economic.gold),                  client_player()->economic.gold);             fc_snprintf(ubuf, ARRAY_SIZE(ubuf), PL_(""Upgrade %d unit"",                                              ""Upgrade %d units"",                                              num_upgraded),                  num_upgraded);             fc_snprintf(buf, bufsz, PL_(""%s for %d gold?%s"",                                  ""%s for %d gold?%s"", upgrade_cost),                  ubuf, upgrade_cost, tbuf);      return TRUE;    }  }}",2,"cwe119,cwe120"
"mdb_update_key(MDB_page *mp, indx_t indx, MDB_val *key){tMDB_nodett*node;tcharttt*base;tsize_tttt len;tintttt delta, delta0;tindx_tttt ptr, i, numkeys;tDKBUF;tnode = NODEPTR(mp, indx);tptr = mp->mp_ptrs[indx];#if MDB_DEBUGt{ttMDB_valtk2;ttchar kbuf2[(MAXKEYSIZE*2+1)];ttk2.mv_data = NODEKEY(node);ttk2.mv_size = node->mn_ksize;ttDPRINTF(""update key %u (ofs %u) [%s] to [%s] on page %zu"",tttindx, ptr,tttmdb_dkey(&k2, kbuf2),tttDKEY(key),tttmp->mp_pgno);t}#endiftdelta0 = delta = key->mv_size - node->mn_ksize;t tdelta += (delta & 1);tif (delta) {ttif (delta > 0 && SIZELEFT(mp) < delta) {tttDPRINTF(""OUCH! Not enough room, delta = %d"", delta);tttreturn ENOSPC;tt}ttnumkeys = NUMKEYS(mp);ttfor (i = 0; i < numkeys; i++) {tttif (mp->mp_ptrs[i] <= ptr)ttttmp->mp_ptrs[i] -= delta;tt}ttbase = (char *)mp + mp->mp_upper;ttlen = ptr - mp->mp_upper + NODESIZE;ttmemmove(base - delta, base, len);ttmp->mp_upper -= delta;ttnode = NODEPTR(mp, indx);t}t tif (delta0)ttnode->mn_ksize = key->mv_size;tif (key->mv_size)ttmemcpy(NODEKEY(node), key->mv_data, key->mv_size);treturn MDB_SUCCESS;}",2,"cwe119,cwe120"
"InitArchiveFmt_Tar(ArchiveHandle *AH){tlclContext *ctx;t tAH->ArchiveEntryPtr = _ArchiveEntry;tAH->StartDataPtr = _StartData;tAH->WriteDataPtr = _WriteData;tAH->EndDataPtr = _EndData;tAH->WriteBytePtr = _WriteByte;tAH->ReadBytePtr = _ReadByte;tAH->WriteBufPtr = _WriteBuf;tAH->ReadBufPtr = _ReadBuf;tAH->ClosePtr = _CloseArchive;tAH->PrintTocDataPtr = _PrintTocData;tAH->ReadExtraTocPtr = _ReadExtraToc;tAH->WriteExtraTocPtr = _WriteExtraToc;tAH->PrintExtraTocPtr = _PrintExtraToc;tAH->StartBlobsPtr = _StartBlobs;tAH->StartBlobPtr = _StartBlob;tAH->EndBlobPtr = _EndBlob;tAH->EndBlobsPtr = _EndBlobs;t tctx = (lclContext *) calloc(1, sizeof(lclContext));tAH->formatData = (void *) ctx;tctx->filePos = 0;tctx->isSpecialScript = 0;t tAH->lo_buf_size = LOBBUFSIZE;tAH->lo_buf = (void *) malloc(LOBBUFSIZE);tif (AH->lo_buf == NULL)ttdie_horribly(AH, modulename, ""out of memory"");t tif (AH->mode == archModeWrite)t{ttif (AH->fSpec && strcmp(AH->fSpec, """") != 0)tttctx->tarFH = fopen(AH->fSpec, PG_BINARY_W);ttelsetttctx->tarFH = stdout;ttif (ctx->tarFH == NULL)tttdie_horribly(NULL, modulename,tttt""could not open TOC file for output: %s"", strerror(errno));ttctx->tarFHpos = 0;tt tt ttctx->hasSeek = checkSeek(ctx->tarFH);ttif (AH->compression < 0 || AH->compression > 9)tttAH->compression = Z_DEFAULT_COMPRESSION;tt ttif (AH->compression == Z_DEFAULT_COMPRESSION)tttAH->compression = 0;tt ttif (AH->compression != 0)tttdie_horribly(NULL, modulename, ""compression not supported by tar output format"");t}telset{ttttttt ttif (AH->fSpec && strcmp(AH->fSpec, """") != 0)tttctx->tarFH = fopen(AH->fSpec, PG_BINARY_R);ttelsetttctx->tarFH = stdin;ttif (ctx->tarFH == NULL)tttdie_horribly(NULL, modulename, ""could not open TOC file for input: %s"", strerror(errno));tt tt ttctx->tarFHpos = 0;ttctx->hasSeek = checkSeek(ctx->tarFH);tt ttAH->readHeader = 0;ttctx->FH = (void *) tarOpen(AH, ""toc.dat"", 'r');ttReadHead(AH);ttReadToc(AH);tttarClose(AH, ctx->FH);t t}}",2,"cwe469,cweother"
"is_safe_error(const char *message){tchar prefix2[100];tconst char *p;tif (!strncmp(message, ""Closing Link: 127.0.0.1 ("", 25))ttreturn 1;trb_snprintf(prefix2, sizeof prefix2,ttt""Closing Link: 127.0.0.1 %s ("", me.name);tif (!strncmp(message, prefix2, strlen(prefix2)))ttreturn 1;tif (!strncmp(message, ""Restart by "", 11))ttreturn 1;tif (!strncmp(message, ""Terminated by "", 14))ttreturn 1;tif (!ircncmp(message, ""Closing Link"", 12))ttreturn 0;tif (strchr(message, '['))ttreturn 0;tp = strchr(message, '.');tif (p != NULL && p[1] != '0')ttreturn 0;tif (strchr(message, ':'))ttreturn 0;treturn 1;}",2,"cwe119,cwe120"
"segment_detach(opal_shmem_ds_t *ds_buf){    int rc = OPAL_SUCCESS;    OPAL_OUTPUT_VERBOSE(        (70, opal_shmem_base_framework.framework_output,         ""%s: %s: detaching ""         ""(id: %d, size: %lu, name: %s)"",         mca_shmem_sysv_component.super.base_version.mca_type_name,         mca_shmem_sysv_component.super.base_version.mca_component_name,         ds_buf->seg_id, (unsigned long)ds_buf->seg_size, ds_buf->seg_name)    );    if (0 != shmdt((char*)ds_buf->seg_base_addr)) {        int err = errno;        char hn[MAXHOSTNAMELEN];        gethostname(hn, MAXHOSTNAMELEN - 1);        hn[MAXHOSTNAMELEN - 1] = '0';        opal_show_help(""help-opal-shmem-sysv.txt"", ""sys call fail"", 1, hn,                       ""shmdt(2)"", """", strerror(err), err);        rc = OPAL_ERROR;    }         shmem_ds_reset(ds_buf);    return rc;}",2,"cwe119,cwe120"
"mp_555_565(int fd, struct pixel565 *fb, int width, int height, int xres, int yres){tint ret;tint i, j;tstruct pixel565 *tmp_fb;tstruct pixel555 buff[width];tfor (i = height - 1; i >= 0; i--)t{ttret = read(fd, &buff, sizeof(buff));ttif (ret < 0)tt{tttprint_error(""read"");tttreturn ret;tt}ttfor (j = 0; j < width; j++)tt{ttttmp_fb = fb + i * xres + j;ttttmp_fb->red = buff[j].red;ttttmp_fb->green = buff[j].green;ttttmp_fb->green <<= 1;ttttmp_fb->blue = buff[j].blue;tt}t}treturn 0;}",2,"cwe120,cweother"
"""KissGetValue(){  char *Scan;  int   Value;  Value = 0;  for ( Scan = KissScanBuffer; *Scan != '0'; Scan++ )  {    if ( isspace( *Scan ) ) break;  }  if ( Scan != KissScanBuffer )  {    *Scan = '0';     Value = atoi( KissScanBuffer );    *Scan = ' ';    KissScanBuffer = Scan;  }  if ( Value <= 0 )  {    fkserror( KISS_ERROR_VALUE, KissLineNumber );  }  return( Value );}""",3,"cwe119,cwe120,cweother"
"_elm_hover_smt_sub_re_eval(Evas_Object *obj){   Evas_Coord spc_l, spc_r, spc_t, spc_b;   Content_Info *prev;   Evas_Object *sub;   char buf[1024];   ELM_HOVER_DATA_GET(obj, sd);   if (!sd->smt_sub) return;   prev = sd->smt_sub;   _elm_hover_left_space_calc(sd, &spc_l, &spc_t, &spc_r, &spc_b);   elm_layout_content_unset(obj, sd->smt_sub->swallow);   sub = sd->smt_sub->obj;   sd->smt_sub->obj = NULL;   sd->smt_sub =     _elm_hover_smart_content_location_get(sd, spc_l, spc_t, spc_r, spc_b);   sd->smt_sub->obj = sub;   if (sd->smt_sub != prev)     evas_object_smart_callback_call       (obj, SIG_SMART_LOCATION_CHANGED, (void *)sd->smt_sub->swallow);   if (elm_widget_mirrored_get(obj))     {        if (sd->smt_sub == _HOV_BOTTOM_LEFT) sd->smt_sub = _HOV_BOTTOM_RIGHT;        else if (sd->smt_sub == _HOV_BOTTOM_RIGHT)          sd->smt_sub = _HOV_BOTTOM_LEFT;        else if (sd->smt_sub == _HOV_RIGHT)          sd->smt_sub = _HOV_LEFT;        else if (sd->smt_sub == _HOV_LEFT)          sd->smt_sub = _HOV_RIGHT;        else if (sd->smt_sub == _HOV_TOP_RIGHT)          sd->smt_sub = _HOV_TOP_LEFT;        else if (sd->smt_sub == _HOV_TOP_LEFT)          sd->smt_sub = _HOV_TOP_RIGHT;     }   snprintf(buf, sizeof(buf), ""elm.swallow.slot.%s"", sd->smt_sub->swallow);   elm_layout_content_set(obj, buf, sd->smt_sub->obj);}",2,"cwe119,cwe120"
"pcap_can_set_rfmon_linux(pcap_t *handle){#ifdef HAVE_LIBNLtchar phydev_path[PATH_MAX+1];tint ret;#endif#ifdef IW_MODE_MONITORtint sock_fd;tstruct iwreq ireq;#endiftif (strcmp(handle->opt.source, ""any"") == 0) {tt ttreturn 0;t}#ifdef HAVE_LIBNLt tret = get_mac80211_phydev(handle, handle->opt.source, phydev_path,t    PATH_MAX);tif (ret < 0)ttreturn ret;t tif (ret == 1)ttreturn 1;t #endif#ifdef IW_MODE_MONITORt tsock_fd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));tif (sock_fd == -1) {tt(void)snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,tt    ""socket: %s"", pcap_strerror(errno));ttreturn PCAP_ERROR;t}t tstrncpy(ireq.ifr_ifrn.ifrn_name, handle->opt.source,t    sizeof ireq.ifr_ifrn.ifrn_name);tireq.ifr_ifrn.ifrn_name[sizeof ireq.ifr_ifrn.ifrn_name - 1] = 0;tif (ioctl(sock_fd, SIOCGIWMODE, &ireq) != -1) {tt ttclose(sock_fd);ttreturn 1;t}tif (errno == ENODEV) {tt tt(void)snprintf(handle->errbuf, PCAP_ERRBUF_SIZE,tt    ""SIOCGIWMODE failed: %s"", pcap_strerror(errno));ttclose(sock_fd);ttreturn PCAP_ERROR_NO_SUCH_DEVICE;t}tclose(sock_fd);#endiftreturn 0;}",3,"cwe119,cwe120,cweother"
"jk_printf(jk_ws_service_t *s, const char *fmt, ...){    int rc = 0;    va_list args;#ifdef NETWARE          char *buf;#else        char buf[HUGE_BUFFER_SIZE];#endif    if (!s || !fmt) {        return -1;    }    va_start(args, fmt);#ifdef NETWARE        buf = (char *)malloc(HUGE_BUFFER_SIZE);        if (NULL == buf)            return -1;#endif    rc = vsnprintf(buf, HUGE_BUFFER_SIZE, fmt, args);    va_end(args);    if (rc > 0)        s->write(s, buf, rc);#ifdef NETWARE        free(buf);#endif    return rc;}",3,"cwe119,cwe120,cweother"
enable_device(struct cgpu_info *cgpu){tcgpu->deven = DEV_ENABLED;twr_lock(&devices_lock);tdevices[cgpu->cgminer_id = cgminer_id_count++] = cgpu;twr_unlock(&devices_lock);tif (hotplug_mode)ttnew_threads += cgpu->threads;telsettmining_threads += cgpu->threads;trwlock_init(&cgpu->qlock);tcgpu->queued_work = NULL;},2,"cwe119,cwe120"
"PerlIOAPR_pushed(pTHX_ PerlIO *f, const char *mode,                           SV *arg, PerlIO_funcs *tab){    IV code = PerlIOBase_pushed(aTHX_ f, mode, arg, tab);    if (*PerlIONext(f)) {             }    return code;}",2,"cwe119,cwe120"
"log_get_loglist(int logtype){tchartt**list=NULL;tintttnum, i;tLogFileInfot*logp = NULL;tcharttbuf[BUFSIZ];tchartttbuf[TBUFSIZE];tchartt*file;tswitch (logtype) {t   case SLAPD_ACCESS_LOG:ttLOG_ACCESS_LOCK_READ( );ttnum = loginfo.log_numof_access_logs;ttlogp = loginfo.log_access_logchain;ttfile = loginfo.log_access_file; ttbreak;t   case SLAPD_ERROR_LOG:ttLOG_ERROR_LOCK_READ( );ttnum = loginfo.log_numof_error_logs;ttlogp = loginfo.log_error_logchain;ttfile = loginfo.log_error_file; ttbreak;t   case SLAPD_AUDIT_LOG:ttLOG_AUDIT_LOCK_READ( );ttnum = loginfo.log_numof_audit_logs;ttlogp = loginfo.log_audit_logchain;ttfile = loginfo.log_audit_file; ttbreak;t   default:ttreturn NULL;t}tlist = (char **) slapi_ch_calloc(1, (num + 1) * sizeof(char *));ti = 0;twhile (logp) {ttlog_convert_time (logp->l_ctime, tbuf, 1  );ttPR_snprintf(buf, sizeof(buf), ""%s.%s"", file, tbuf);ttlist[i] = slapi_ch_strdup(buf);tti++;ttif (i == num) {  tttbreak;tt}ttlogp = logp->l_next;t}tlist[i] = NULL;tswitch (logtype) {t   case SLAPD_ACCESS_LOG:ttLOG_ACCESS_UNLOCK_READ();ttbreak;t   case SLAPD_ERROR_LOG:ttLOG_ERROR_UNLOCK_READ();ttbreak;t   case SLAPD_AUDIT_LOG:ttLOG_AUDIT_UNLOCK_READ();ttbreak;t}treturn list;}",2,"cwe119,cwe120"
"itbang_program_enable(PROGRAMMER * pgm, AVRPART * p){  unsigned char cmd[4];  unsigned char res[4];  int i;  if (p->flags & AVRPART_HAS_TPI) {         bitbang_tpi_tx(pgm, TPI_CMD_SKEY);    for (i = sizeof(tpi_skey) - 1; i >= 0; i--)      bitbang_tpi_tx(pgm, tpi_skey[i]);         bitbang_tpi_tx(pgm, TPI_CMD_SLDCS | TPI_REG_TPISR);    i = bitbang_tpi_rx(pgm);    return (i != -1 && (i & TPI_REG_TPISR_NVMEN)) ? 0 : -2;  }  if (p->op[AVR_OP_PGM_ENABLE] == NULL) {    fprintf(stderr, ""program enable instruction not defined for part ""%s"""",            p->desc);    return -1;  }  memset(cmd, 0, sizeof(cmd));  avr_set_bits(p->op[AVR_OP_PGM_ENABLE], cmd);  pgm->cmd(pgm, cmd, res);  if (res[2] != cmd[1])    return -2;  return 0;}",2,"cwe119,cwe120"
"include_config(char *include, int manage_globals){    STRUCT_STAT sb;    char *match = manage_globals ? ""*.conf"" : ""*.inc"";    int ret;    if (do_stat(include, &sb) < 0) {trsyserr(FLOG, errno, ""unable to stat config file ""%s"""", include);treturn 0;    }    if (S_ISREG(sb.st_mode)) {tif (manage_globals && the_sfunc)t    the_sfunc(""]push"");tret = pm_process(include, the_sfunc, the_pfunc);tif (manage_globals && the_sfunc)t    the_sfunc(""]pop"");    } else if (S_ISDIR(sb.st_mode)) {tchar buf[MAXPATHLEN], **bpp;titem_list conf_list;tstruct dirent *di;tsize_t j;tDIR *d;tif (!(d = opendir(include))) {t    rsyserr(FLOG, errno, ""unable to open config dir ""%s"""", include);t    return 0;t}tmemset(&conf_list, 0, sizeof conf_list);twhile ((di = readdir(d)) != NULL) {t    char *dname = d_name(di);t    if (!wildmatch(match, dname))ttcontinue;t    bpp = EXPAND_ITEM_LIST(&conf_list, char *, 32);t    pathjoin(buf, sizeof buf, include, dname);t    *bpp = strdup(buf);t}tclosedir(d);tif (!(bpp = conf_list.items))t    return 1;tif (conf_list.count > 1)t    qsort(bpp, conf_list.count, sizeof (char *), name_cmp);tfor (j = 0, ret = 1; j < conf_list.count; j++) {t    if (manage_globals && the_sfunc)ttthe_sfunc(j == 0 ? ""]push"" : ""]reset"");t    if ((ret = pm_process(bpp[j], the_sfunc, the_pfunc)) != 1)ttbreak;t}tif (manage_globals && the_sfunc)t    the_sfunc(""]pop"");tfor (j = 0; j < conf_list.count; j++)t    free(bpp[j]);tfree(bpp);    } elsetret = 0;    return ret;}",2,"cwe119,cwe120"
"fstab_parse(const char *path, volume_list_t *list) {    FILE *fstab;    char buf[1024];    int i, result;    char *spec, *mountPoint, *fsType, *mountOptions, *freq, *passno;    volume_t *volume;         fstab = fopen(path, ""r"");    if (fstab != NULL) {                 while (fgets(buf, sizeof(buf)-1, fstab)) {                         for (i = 0; (buf[i] != '0') && (isspace(buf[i])); i++);                         if ((buf[i] == '0') || (buf[i] == '#')) continue;                         spec         = strtok(buf+i, "" t"");            mountPoint   = strtok(NULL, "" t"");            fsType       = strtok(NULL, "" t"");            mountOptions = strtok(NULL, "" t"");            freq         = strtok(NULL, "" t"");            passno       = strtok(NULL, "" t"");                         mountOptions = mountOptions;            freq         = freq;            passno       = passno;                         volume = volume_new();            if (volume != NULL) {                volume_set_spec(volume, spec);                volume_set_mount_point(volume, mountPoint);                volume_set_fs_type(volume, fsType);                                 volume_list_add(list, volume);            }        }        fclose(fstab);        result = 0;    }    else result = ENOENT;    return result;}",3,"cwe119,cwe120,cweother"
"output_builtin_bin(struct depmod *depmod, FILE *out){tFILE *in;tstruct index_node *idx;tchar infile[PATH_MAX], line[PATH_MAX], modname[PATH_MAX];tif (out == stdout)ttreturn 0;tsnprintf(infile, sizeof(infile), ""%s/modules.builtin"",tt depmod->cfg->dirname);tin = fopen(infile, ""r"");tif (in == NULL) {ttint err = -errno;ttWRN(""could not open %s: %m"", infile);ttreturn err;t}tidx = index_create();tif (idx == NULL) {ttfclose(in);ttreturn -ENOMEM;t}twhile (fgets(line, sizeof(line), in) != NULL) {ttif (!isalpha(line[0])) {tttERR(""Invalid modules.builtin line: %s"", line);tttcontinue;tt}ttpath_to_modname(line, modname, NULL);ttindex_insert(idx, modname, """", 0);t}tindex_write(idx, out);tindex_destroy(idx);tfclose(in);treturn 0;}",3,"cwe119,cwe120,cweother"
"avrdoper_send(union filedescriptor *fdp, unsigned char *buf, size_t buflen){    if(verbose > 3)        dumpBlock(""Send"", buf, buflen);    while(buflen > 0){        unsigned char buffer[256];        int rval, lenIndex = chooseDataSize(buflen);        int thisLen = buflen > reportDataSizes[lenIndex] ?t    reportDataSizes[lenIndex] : buflen;        buffer[0] = lenIndex + 1;            buffer[1] = thisLen;        memcpy(buffer + 2, buf, thisLen);        if(verbose > 3)            fprintf(stderr, ""Sending %d bytes data chunk"", thisLen);        rval = usbSetReport(fdp, USB_HID_REPORT_TYPE_FEATURE, (char *)buffer,ttt    reportDataSizes[lenIndex] + 2);        if(rval != 0){            fprintf(stderr, ""%s: avrdoper_send(): %s"", progname, usbErrorText(rval));            exit(1);        }        buflen -= thisLen;        buf += thisLen;    }    return 0;}",2,"cwe119,cwe120"
"do_write(int fd){tchar buffer[BUFFER_SIZE];tint result, count = 0;ttimer_start(OP_WRITE);tdo {ttresult = write(fd, &buffer[count], BUFFER_SIZE - count);ttcount += result;t} while(result != -1 && count < BUFFER_SIZE);ttimer_stop(OP_WRITE);tif(result < 0) {ttprintf(""could not write: %s"", strerror(errno));ttexit(EXIT_FAILURE);t}}",4,"cwe119,cwe120,cwe476,cweother"
"x86_64_display_full_frame(struct bt_info *bt, ulong rsp, FILE *ofp){tint i, u_idx;tulong *up;tulong words, addr;tchar buf[BUFSIZE];tif (rsp < bt->frameptr)ttreturn;tif (!INSTACK(rsp, bt) || !INSTACK(bt->frameptr, bt))ttreturn;        words = (rsp - bt->frameptr) / sizeof(ulong) + 1;taddr = bt->frameptr;tu_idx = (bt->frameptr - bt->stackbase)/sizeof(ulong);tfor (i = 0; i < words; i++, u_idx++) {ttif (!(i & 1)) tttfprintf(ofp, ""%s    %lx: "", i ? """" : """", addr);ttttup = (ulong *)(&bt->stackbuf[u_idx*sizeof(ulong)]);ttfprintf(ofp, ""%s "", format_stack_entry(bt, buf, *up, 0));ttaddr += sizeof(ulong);t}tfprintf(ofp, """");}",2,"cwe119,cwe120"
"OpKill(){   cid_kill_it out ;   cid_kill_ot in ;      status=system(""clear"") ;   printf(""CID_OP_KILL"") ;   printf(""-----------"") ;tttt    printf(""Enter application id : "") ;   status=scanf(""%s"", out.appid) ;   getchar() ;   printf(""Enter component name : "") ;   status=scanf(""%s"", out.name) ;tttt    printf(""To CID :"") ;   printf(""appid : %s"", out.appid) ;   printf(""name : %s"", out.name) ;tttt    if (!writen(cidsock, (char *)&out, sizeof(out)))    {       printf(""OpKill::writen"") ;       getchar() ; getchar() ;       return ;    }tttt    if (!readn(cidsock, (char *)&in, sizeof(in)))    {       printf(""OpKill::readn"") ;       getchar() ; getchar() ;       return ;    }tttt    printf(""From CID :"") ;   printf(""status : %d"", ntohs(in.status)) ;   printf(""error : %d"", ntohs(in.error)) ;   getchar() ;  getchar() ;}",2,"cwe120,cweother"
"create_bonesfile(d_level *lev, char **bonesid, char errbuf[]){    const char *file;    int fd;    if (errbuf) *errbuf = '0';    *bonesid = set_bonesfile_name(bones, lev);    file = set_bonestemp_name();    file = fqname(file, BONESPREFIX, 0);#if defined(MICRO) || defined(WIN32)         fd = open(file, O_WRONLY |O_CREAT | O_TRUNC | O_BINARY, FCMASK);#else# ifdef MAC    fd = maccreat(file, BONE_TYPE);# else    fd = creat(file, FCMASK);# endif#endif    if (fd < 0 && errbuf)              sprintf(errbuf,                    ""Cannot create bones ""%s"", id %s (errno %d)."",                    lock, *bonesid, errno);# if defined(VMS) && !defined(SECURE)         chmod(file, FCMASK | 007);   # endif      return fd;}",2,"cwe120,cweother"
"cpio_append_stat (const char *filename, const struct stat *statbuf){  const char *orig_filename = filename;  if (*filename == '/')    filename++;  if (*filename == '0')    filename = ""."";  if (verbose >= 2)    fprintf (stderr, ""cpio_append_stat %s 0%o -> %d"",             orig_filename, statbuf->st_mode, out_fd);     int has_body = S_ISREG (statbuf->st_mode) || S_ISLNK (statbuf->st_mode);  size_t len = strlen (filename) + 1;  char header[CPIO_HEADER_LEN + 1];  snprintf (header, sizeof header,            ""070701""                         ""%08X""                           ""%08X""                           ""%08X"" ""%08X""                    ""%08X""                           ""%08X""                           ""%08X""                           ""%08X"" ""%08X""                    ""%08X"" ""%08X""                    ""%08X""                           ""%08X"",                          (unsigned) statbuf->st_ino, statbuf->st_mode,            statbuf->st_uid, statbuf->st_gid,            (unsigned) statbuf->st_nlink, (unsigned) statbuf->st_mtime,            has_body ? (unsigned) statbuf->st_size : 0,            major (statbuf->st_dev), minor (statbuf->st_dev),            major (statbuf->st_rdev), minor (statbuf->st_rdev),            (unsigned) len, 0);     write_to_fd (header, CPIO_HEADER_LEN);     write_to_fd (filename, len);  size_t padding_len = PADDING (CPIO_HEADER_LEN + len);  write_padding (padding_len);     if (has_body) {    if (S_ISREG (statbuf->st_mode))      write_file_len_to_fd (orig_filename, statbuf->st_size);    else if (S_ISLNK (statbuf->st_mode)) {      char tmp[PATH_MAX];      if (readlink (orig_filename, tmp, sizeof tmp) == -1)        error (EXIT_FAILURE, errno, ""readlink: %s"", orig_filename);      write_to_fd (tmp, statbuf->st_size);    }    padding_len = PADDING (statbuf->st_size);    write_padding (padding_len);  }}",3,"cwe119,cwe120,cweother"
"set_pglocale_pgservice(const char *argv0, const char *app){tcharttpath[MAXPGPATH];tcharttmy_exec_path[MAXPGPATH];tcharttenv_path[MAXPGPATH + sizeof(""PGSYSCONFDIR="")];t t tif (strcmp(app, PG_TEXTDOMAIN(""postgres"")) != 0)ttsetlocale(LC_ALL, """");tif (find_my_exec(argv0, my_exec_path) < 0)ttreturn;#ifdef ENABLE_NLStget_locale_path(my_exec_path, path);tbindtextdomain(app, path);ttextdomain(app);tif (getenv(""PGLOCALEDIR"") == NULL)t{tt ttsnprintf(env_path, sizeof(env_path), ""PGLOCALEDIR=%s"", path);ttcanonicalize_path(env_path + 12);ttputenv(strdup(env_path));t}#endiftif (getenv(""PGSYSCONFDIR"") == NULL)t{ttget_etc_path(my_exec_path, path);tt ttsnprintf(env_path, sizeof(env_path), ""PGSYSCONFDIR=%s"", path);ttcanonicalize_path(env_path + 13);ttputenv(strdup(env_path));t}}",3,"cwe119,cwe120,cweother"
"main(int argc, char *argv[]){tint mq;tstruct msg msg;tif (argc != 3) {ttfprintf(stderr, ""Usage: %s msg_type message"", argv[0]);ttexit(-1);t}tmq = msgget(ftok(""server.c"", 89), 0);tif (mq < 0) {ttperror(""msgget"");ttexit(-1);t}tmsg.mtype = atoi(argv[1]);tstrcpy(msg.mtext, argv[2]);tif (msgsnd(mq, &msg, strlen(msg.mtext) + 1, msg.mtype) < 0) {ttperror(""msgsnd"");ttexit(-1);t}tif (msgrcv(mq, &msg, MTEXT_SIZE, 4, 0) < 0) {ttperror(""msgrcv"");ttexit(-1);t}tprintf(""Answer: %s"", msg.mtext);treturn 0;}",2,"cwe120,cweother"
"visit(Agnode_t * n, Agraph_t * map, Stack * sp, sccstate * st){    unsigned int m, min;    Agnode_t *t;    Agraph_t *subg;    Agedge_t *e;    min = ++(st->ID);    setval(n, min);    push(sp, n);    for (e = agfstout(n->root, n); e; e = agnxtout(n->root, e)) {tt = aghead(e);tif (getval(t) == 0)t    m = visit(t, map, sp, st);telset    m = getval(t);tif (m < min)t    min = m;    }    if (getval(n) == min) {tif (!wantDegenerateComp && (top(sp) == n)) {t    setval(n, INF);t    pop(sp);t} else {t    char name[32];t    Agraph_t *G = agraphof(n);;t    sprintf(name, ""cluster_%d"", (st->Comp)++);t    subg = agsubg(G, name, TRUE);t    agbindrec(subg, ""scc_graph"", sizeof(Agraphinfo_t), TRUE);t    setrep(subg, agnode(map, name, TRUE));t    do {ttt = pop(sp);ttagsubnode(subg, t, TRUE);ttsetval(t, INF);ttsetscc(t, subg);ttst->N_nodes_in_nontriv_SCC++;t    } while (t != n);t    nodeInduce(subg, map);t    if (!StatsOnly)ttagwrite(subg, outfp);t}    }    return min;}",2,"cwe119,cwe120"
"""add_range(gchar* val){ttUrange r;ttint i=0, count=0;ttwhile(val[i]!='0' && val[i]!='-' && val[i]!=' ' && val[i]!=',') i++;ttr.start = (gchar*) malloc((i+1)*sizeof(gchar*));ttstrncpy(r.start, val, i);ttr.start[i] = '0';ttval+=i;ttcount+=i;tti=0;ttif (val[0]=='-'){tttval++;tttwhile(val[i]!='0' && val[i]!='-' && val[i]!=' ' && val[i]!=',') i++;tttr.end = (gchar*) malloc((i+1)*sizeof(gchar*));tttstrncpy(r.end, val, i);tttr.end[i] = '0';tttval+=i;tttcount+=i;tt} else {tttr.end=NULL;tt}ttthis->range.push_back(r);ttreturn count+1;}""",2,"cwe120,cweother"
"""multipart_buffer_read(multipart_buffer *self, char *buf, int bytes, int *end TSRMLS_DC){tint len, max;tchar *bound;t/* fill buffer if needed */tif (bytes > self->bytes_in_buffer) {ttfill_buffer(self TSRMLS_CC);t}t/* look for a potential boundary match, only read data up to that point */tif ((bound = php_ap_memstr(self->buf_begin, self->bytes_in_buffer, self->boundary_next, self->boundary_next_len, 1))) {ttmax = bound - self->buf_begin;ttif (end && php_ap_memstr(self->buf_begin, self->bytes_in_buffer, self->boundary_next, self->boundary_next_len, 0)) {ttt*end = 1;tt}t} else {ttmax = self->bytes_in_buffer;t}t/* maximum number of bytes we are reading */tlen = max < bytes-1 ? max : bytes-1;t/* if we read any data... */tif (len > 0) {tt/* copy the data */ttmemcpy(buf, self->buf_begin, len);ttbuf[len] = 0;ttif (bound && len > 0 && buf[len-1] == 'r') {tttbuf[--len] = 0;tt}tt/* update the buffer */ttself->bytes_in_buffer -= len;ttself->buf_begin += len;t}treturn len;}""",3,"cwe119,cwe120,cweother"
"write_syslogger_file(const char *buffer, int count, int destination){tinttttrc;tFILEt   *logfile;tif (destination == LOG_DESTINATION_CSVLOG && csvlogFile == NULL)ttopen_csvlogfile();tlogfile = destination == LOG_DESTINATION_CSVLOG ? csvlogFile : syslogFile;trc = fwrite(buffer, 1, count, logfile);t tif (rc != count)ttwrite_stderr(""could not write to log file: %s"", strerror(errno));}",2,"cwe469,cweother"
"print_attributes(VALUE_PAIR *vp){    FILE *fp;    char fname[512];    char name[2048];    char value[2048];    int cnt = 0;    slprintf(fname, sizeof(fname), ""/var/run/radattr.%s"", ifname);    fp = fopen(fname, ""w"");    if (!fp) {twarn(""radattr plugin: Could not open %s for writing: %m"", fname);treturn;    }    for (; vp; vp=vp->next) {tif (rc_avpair_tostr(vp, name, sizeof(name), value, sizeof(value)) < 0) {t    continue;t}tfprintf(fp, ""%s %s"", name, value);tcnt++;    }    fclose(fp);    dbglog(""RADATTR plugin wrote %d line(s) to file %s."", cnt, fname);}",3,"cwe119,cwe120,cweother"
"i2a_ASN1_STRING(BIO *bp, ASN1_STRING *a, int type)t{tint i,n=0;tstatic const char *h=""0123456789ABCDEF"";tchar buf[2];tif (a == NULL) return(0);tif (a->length == 0)tt{ttif (BIO_write(bp,""0"",1) != 1) goto err;ttn=1;tt}telsett{ttfor (i=0; i<a->length; i++)ttt{tttif ((i != 0) && (i%35 == 0))tttt{ttttif (BIO_write(bp,"""",2) != 2) goto err;ttttn+=2;tttt}tttbuf[0]=h[((unsigned char)a->data[i]>>4)&0x0f];tttbuf[1]=h[((unsigned char)a->data[i]   )&0x0f];tttif (BIO_write(bp,buf,2) != 2) goto err;tttn+=2;ttt}tt}treturn(n);err:treturn(-1);t}",2,"cwe119,cwe120"
"st_compare(SearchThread *st){    int rval;    int compare_true;    int correct_answer;    int e;    char *dn = NULL;    char *uid = NULL;    char uid0[100];    struct berval bvvalue = {0, NULL};         if (NULL == sdattable || sdt_getlen(sdattable) == 0) {        fprintf(stderr, ""-c option requires a DN file.  Use -B file."");        return 0;    }         do {        e = sdt_getrand(sdattable);    } while (e < 0);    dn = sdt_dn_get(sdattable, e);    uid = sdt_uid_get(sdattable, e);    compare_true = ( (rand() % 5) < 2 );    if (!compare_true) {        strcpy(uid0, uid);        uid0[0] = '@';                 uid = uid0;    }    bvvalue.bv_val = uid;    bvvalue.bv_len = uid ? strlen(uid) : 0;    rval = ldap_compare_ext_s(st->ld, dn, ""uid"", &bvvalue, NULL, NULL);    correct_answer = compare_true ? LDAP_COMPARE_TRUE : LDAP_COMPARE_FALSE;    if (rval == correct_answer) {ttrval = LDAP_SUCCESS;    } else {        fprintf(stderr, ""T%d: Failed to compare error=0x%x (%d)"",                        st->id, rval, correct_answer);        fprintf(stderr, ""dn: %s, uid: %s"", dn, uid);    }    return rval;}",2,"cwe119,cwe120"
"raw_pread(BlockDriverState *bs, int64_t offset,                     uint8_t *buf, int count){    BDRVRawState *s = bs->opaque;    int ret;    ret = fd_open(bs);    if (ret < 0)        return ret;    if (offset >= 0 && lseek(s->fd, offset, SEEK_SET) == (off_t)-1) {        ++(s->lseek_err_cnt);        if(s->lseek_err_cnt <= 10) {            DEBUG_BLOCK_PRINT(""raw_pread(%d:%s, %"" PRId64 "", %p, %d) [%"" PRId64                              ""] lseek failed : %d = %s"",                              s->fd, bs->filename, offset, buf, count,                              bs->total_sectors, errno, strerror(errno));        }        return -1;    }    s->lseek_err_cnt=0;    ret = read(s->fd, buf, count);    if (ret == count)        goto label__raw_read__success;    DEBUG_BLOCK_PRINT(""raw_pread(%d:%s, %"" PRId64 "", %p, %d) [%"" PRId64                      ""] read failed %d : %d = %s"",                      s->fd, bs->filename, offset, buf, count,                      bs->total_sectors, ret, errno, strerror(errno));         if (bs->type == BDRV_TYPE_CDROM) {        lseek(s->fd, offset, SEEK_SET);        ret = read(s->fd, buf, count);        if (ret == count)            goto label__raw_read__success;        lseek(s->fd, offset, SEEK_SET);        ret = read(s->fd, buf, count);        if (ret == count)            goto label__raw_read__success;        DEBUG_BLOCK_PRINT(""raw_pread(%d:%s, %"" PRId64 "", %p, %d) [%"" PRId64                          ""] retry read failed %d : %d = %s"",                          s->fd, bs->filename, offset, buf, count,                          bs->total_sectors, ret, errno, strerror(errno));    }label__raw_read__success:    return ret;}",2,"cwe120,cweother"
"display_numeric (cob_field *f, FILE *fp){tinttti;tintttdigits;tintttscale;tintttsize;tcob_field_attrtattr;tcob_fieldttemp;tunsigned chartdata[128];tif (f->size == 0) {ttreturn;t}tdigits = COB_FIELD_DIGITS (f);tscale = COB_FIELD_SCALE (f);tsize = digits + (COB_FIELD_HAVE_SIGN (f) ? 1 : 0);tCOB_ATTR_INIT (COB_TYPE_NUMERIC_DISPLAY, digits, scale, 0, NULL);ttemp.size = size;ttemp.data = data;ttemp.attr = &attr;tif (COB_FIELD_HAVE_SIGN (f)) {ttattr.flags = COB_FLAG_HAVE_SIGN | COB_FLAG_SIGN_SEPARATE;ttif (COB_FIELD_SIGN_LEADING (f)tt    || COB_FIELD_TYPE (f) == COB_TYPE_NUMERIC_BINARY) {tttattr.flags |= COB_FLAG_SIGN_LEADING;tt}t}tcob_move (f, &temp);tfor (i = 0; i < size; ++i) {ttputc (data[i], fp);t}}",2,"cwe119,cwe120"
"set_secret(u08bits *secret) {tif(!secret || (secret[0]==0))ttreturn 0;tdonot_print_connection_success = 1;tdel_secret(secret);tif (is_pqsql_userdb()) {#if !defined(TURN_NO_PQ)ttchar statement[LONG_STRING_SIZE];ttPGconn *pqc = get_pqdb_connection();ttif (pqc) {tt  snprintf(statement,sizeof(statement),""insert into turn_secret values('%s')"",secret);tt  PGresult *res = PQexec(pqc, statement);tt  if (!res || (PQresultStatus(res) != PGRES_COMMAND_OK)) {tt    TURN_LOG_FUNC(tttt  TURN_LOG_LEVEL_ERROR,tttt  ""Error inserting/updating secret key information: %s"",tttt  PQerrorMessage(pqc));tt  }tt  if (res) {tt    PQclear(res);tt  }tt}#endift} else if (is_mysql_userdb()) {#if !defined(TURN_NO_MYSQL)ttchar statement[LONG_STRING_SIZE];ttMYSQL * myc = get_mydb_connection();ttif (myc) {tt  snprintf(statement,sizeof(statement),""insert into turn_secret values('%s')"",secret);tt  int res = mysql_query(myc, statement);tt  if (res) {tt    TURN_LOG_FUNC(tttt  TURN_LOG_LEVEL_ERROR,tttt  ""Error inserting/updating secret key information: %s"",tttt  mysql_error(myc));tt  }tt}#endift} else if(is_redis_userdb()) {#if !defined(TURN_NO_HIREDIS)ttredisContext *rc = get_redis_connection();ttif(rc) {tttchar s[LONG_STRING_SIZE];tttdel_secret(secret);tttsnprintf(s,sizeof(s),""set turn/secret/%lu %s"", (unsigned long)turn_time(), secret);tttturnFreeRedisReply(redisCommand(rc, s));tttturnFreeRedisReply(redisCommand(rc, ""save""));tt}#endift}treturn 0;}",2,"cwe119,cwe120"
"_menu_create(const char *option_str){   struct elm_test *t = NULL;   const char *pcat = NULL;   Evas_Object *cfr = NULL, *tbx2 = NULL, *bt = NULL, *ic = NULL;   char buf[PATH_MAX];   Eina_List *l;   elm_box_clear(tbx);   EINA_LIST_FOREACH(tests, l, t)     {        if (option_str && !strcasestr(t->name, option_str)) continue;        if ((!pcat) || (strcmp(pcat, t->category)))          {             cfr = elm_frame_add(win);                           evas_object_smart_callback_add(cfr, ""clicked"", _frame_clicked, NULL);             elm_frame_autocollapse_set(cfr, EINA_TRUE);             elm_object_text_set(cfr, t->category);             evas_object_size_hint_weight_set(cfr, EVAS_HINT_EXPAND, 0.0);             evas_object_size_hint_fill_set(cfr, EVAS_HINT_FILL, 0.0);             elm_box_pack_end(tbx, cfr);             evas_object_show(cfr);             tbx2 = elm_box_add(win);             elm_box_layout_set(tbx2, evas_object_box_layout_flow_horizontal, NULL, NULL);             evas_object_size_hint_weight_set(tbx2, EVAS_HINT_EXPAND, 0.0);             evas_object_size_hint_align_set(tbx2, EVAS_HINT_FILL, 0.0);             elm_box_align_set(tbx2, 0.0, 0.5);             elm_object_content_set(cfr, tbx2);             evas_object_show(tbx2);          }        bt = elm_button_add(win);                 elm_object_text_set(bt, t->name);        if (t->icon)          {             ic = elm_icon_add(win);             snprintf(buf, sizeof(buf), ""%s/images/%s"", elm_app_data_dir_get(), t->icon);             elm_image_file_set(ic, buf, NULL);             elm_object_part_content_set(bt, ""icon"", ic);             evas_object_show(ic);          }        elm_box_pack_end(tbx2, bt);        evas_object_show(bt);        evas_object_smart_callback_add(bt, ""clicked"", t->cb, NULL);        pcat = t->category;        if (t == tt) tt = cfr;     }}",2,"cwe119,cwe120"
"generate_header_info( FL_IMAGE *im ){   SPEC *sp = im->io_spec;   char buf[ 128 ];   if ( ! im->info && ! ( im->info = fl_malloc( 1024 ) ) )       return;   sprintf( im->info, ""Size=(%d x %d)"", im->w, im->h );   sprintf( buf,""Colors=%dGlobalmap=%d"", im->map_len, sp->globalmap );   strcat( im->info,buf );   sprintf( buf,""Aspect=%dInterlace=%d"", sp->aspect, sp->interlace );   strcat( im->info, buf );   sprintf( buf,""Offset=(%d %d)"", im->wx, im->wy );   strcat( im->info, buf );}",2,"cwe119,cwe120"
"print_fields_date(print_field_t *field, time_t value, int last){tint abs_len = abs(field->len);tchar temp_char[abs_len+1];tslurm_make_time_str(&value, (char *)temp_char, sizeof(temp_char));tif (print_fields_parsable_print == PRINT_FIELDS_PARSABLE_NO_ENDINGt   && last)ttprintf(""%s"", temp_char);telse if (print_fields_parsable_print)ttprintf(""%s|"", temp_char);telse if (field->len == abs_len)ttprintf(""%*.*s "", abs_len, abs_len, temp_char);telsettprintf(""%-*.*s "", abs_len, abs_len, temp_char);}",2,"cwe119,cwe120"
"spawn_stuff( int argc, char *argv[] )t{tpid_ttkidpid;tfflush(stdout);tif( (kidpid = fork()) < 0 )tt{ttperror(""fork"");tt}telse if( kidpid == 0 )tt{ tttstruct tms tms;ttioctl(fkt,FKT_WAITREADY);t ttif (times(&tms)<0) {tttperror(""times"");tttexit(EXIT_FAILURE);tt}ttprintf(""executing %s"",argv[optind]);ttexecvp(argv[optind], &argv[optind]);ttperror(argv[optind]);ttexit(EXIT_FAILURE);tt}t tkpid = kidpid;treturn kidpid;t}",2,"cwe469,cweother"
"setup_netjet_u(struct IsdnCard *card){tint ret;tstruct IsdnCardState *cs = card->cs;tchar tmp[64];#ifdef __BIG_ENDIAN#error ""not running on big endian machines now""#endiftstrcpy(tmp, NETjet_U_revision);tprintk(KERN_INFO ""HiSax: Traverse Tech. NETspider-U driver Rev. %s"", HiSax_getrev(tmp));tif (cs->typ != ISDN_CTYPE_NETJET_U)ttreturn (0);ttest_and_clear_bit(FLG_LOCK_ATOMIC, &cs->HW_Flags);tfor (;;)t{ttif ((dev_netjet = hisax_find_pci_device(PCI_VENDOR_ID_TIGERJET,tttttttPCI_DEVICE_ID_TIGERJET_300,  dev_netjet))) {tttret = nju_pci_probe(dev_netjet, cs);tttif (!ret)ttttreturn (0);tt} else {tttprintk(KERN_WARNING ""NETspider-U: No PCI card found"");tttreturn (0);tt}ttret = nju_cs_init(card, cs);ttif (!ret)tttreturn (0);ttif (ret > 0)tttbreak;tt t}treturn nju_cs_init_rest(card, cs);}",2,"cwe119,cwe120"
"proxy_read(u_int cl){tstruct proxy_private *mydata = cldata[cl].instance->data;tu_char state = PROXY_CLOSE;t tif (cldata[cl].buflen <tt((mydata->options & OPT_CAREFUL) ? strConnLen + tt  38 :ttt  12))t{ttreturn 0;t}t tDebugLog((ALOG_DSOCKS, 0, ""webproxy%u_read(%d): Got [%-64.64s]"",ttPROXYPORT, cl, cldata[cl].inbuffer));tif (mydata->options & OPT_CAREFUL)t{tt ttif (strstr(cldata[cl].inbuffer, strConn))tt{tttstate = PROXY_OPEN;tt}t}telset{tt ttcldata[cl].inbuffer[7] = '0';tt ttif (!strstr(cldata[cl].inbuffer, ""Date:"")ttt&& !strncmp(cldata[cl].inbuffer, ""HTTP/1.0 200"", 12))tt{tttstate = PROXY_OPEN;tt}t}t tif (state == PROXY_OPEN)t{ttproxy_open_proxy(cl);t}tproxy_add_cache(cl, state);tclose(cldata[cl].rfd);tcldata[cl].rfd = 0;treturn -1;}",3,"cwe119,cwe120,cweother"
"GetShiftSlot(time_t here_and_now){ time_t now = time(NULL);  int slot = 0, chour = -1;  char cstr[64];  char str[64];  char buf[10],cbuf[10];  int hour = -1;  char timebuf[26];    snprintf(cstr,sizeof(str),""%s"",cf_strtimestamp_utc(here_and_now,timebuf));sscanf(cstr,""%s %*s %*s %d"",cbuf,&chour); for (now = CF_MONDAY_MORNING; now < CF_MONDAY_MORNING+CF_WEEK; now += CF_SHIFT_INTERVAL,slot++)   {   snprintf(str,sizeof(str),""%s"",cf_strtimestamp_utc(now,timebuf));    sscanf(str,""%s %*s %*s %d"",buf,&hour);      if ((hour/6 == chour/6) && (strcmp(cbuf,buf) == 0))      {      return slot;      }   }return -1;}",3,"cwe119,cwe120,cweother"
"list_tags(const char *pattern, int lines,tttstruct commit_list *with_commit){tstruct tag_filter filter;tif (pattern == NULL)ttpattern = ""*"";tfilter.pattern = pattern;tfilter.lines = lines;tfilter.with_commit = with_commit;tfor_each_tag_ref(show_reference, (void *) &filter);treturn 0;}",2,"cwe119,cwe120"
"efreet_icon_changes_listen(void){    Eina_List *l;    Eina_List *xdg_dirs;    char buf[PATH_MAX];    const char *dir;    if (!efreet_cache_update) return;    change_monitors = eina_hash_string_superfast_new(EINA_FREE_CB(ecore_file_monitor_del));    if (!change_monitors) return;    efreet_icon_changes_monitor_add(efreet_icon_deprecated_user_dir_get());    efreet_icon_changes_monitor_add(efreet_icon_user_dir_get());    EINA_LIST_FOREACH(efreet_extra_icon_dirs, l, dir)        efreet_icon_changes_monitor_add(dir);    xdg_dirs = efreet_data_dirs_get();    EINA_LIST_FOREACH(xdg_dirs, l, dir)    {        snprintf(buf, sizeof(buf), ""%s/icons"", dir);        efreet_icon_changes_monitor_add(buf);    }#ifndef STRICT_SPEC    EINA_LIST_FOREACH(xdg_dirs, l, dir)    {        snprintf(buf, sizeof(buf), ""%s/pixmaps"", dir);        efreet_icon_changes_monitor_add(buf);    }#endif    efreet_icon_changes_monitor_add(""/usr/share/pixmaps"");}",2,"cwe119,cwe120"
"extWrite(int fileID, void *ext){  extrec_t *extp = (extrec_t *) ext;  size_t datasize;  size_t blocklen;  size_t i;  int rprec, number;  char tempheader[32];  int *header;  void *buffer;  int byteswap = extp->byteswap;  rprec  = extp->prec;  number = extp->number;  header = extp->header;     blocklen = EXT_HEADER_LEN * rprec;  binWriteF77Block(fileID, byteswap, blocklen);  switch ( rprec )    {    case SINGLE_PRECISION:      {tfor (i = 0; i < EXT_HEADER_LEN; i++)          ((INT32 *) tempheader)[i] = (INT32) header[i];tbinWriteInt32(fileID, byteswap, EXT_HEADER_LEN, (INT32 *) tempheader);tbreak;      }    case DOUBLE_PRECISION:      {tfor (i = 0; i < EXT_HEADER_LEN; i++)          ((INT64 *) tempheader)[i] = (INT64) header[i];tbinWriteInt64(fileID, byteswap, EXT_HEADER_LEN, (INT64 *) tempheader);tbreak;      }    default:      {tError(""unexpected header precision %d"", rprec);        break;      }    }    binWriteF77Block(fileID, byteswap, blocklen);  datasize = header[3];  if ( number == EXT_COMP ) datasize *= 2;  blocklen = datasize * rprec;  binWriteF77Block(fileID, byteswap, blocklen);  extp->datasize = datasize;  buffer = extp->buffer;  switch ( rprec )    {    case SINGLE_PRECISION:      {tbinWriteFlt32(fileID, byteswap, datasize, (FLT32 *) buffer);tbreak;      }    case DOUBLE_PRECISION:      {tbinWriteFlt64(fileID, byteswap, datasize, (FLT64 *) buffer);tbreak;      }    default:      {tError(""unexpected data precision %d"", rprec);        break;      }    }  binWriteF77Block(fileID, byteswap, blocklen);  return (0);}",2,"cwe119,cwe120"
"trfs_ioctl_get_fslabel(struct file *file, void __user *arg){tstruct btrfs_root *root = BTRFS_I(file_inode(file))->root;tsize_t len;tint ret;tchar label[BTRFS_LABEL_SIZE];tspin_lock(&root->fs_info->super_lock);tmemcpy(label, root->fs_info->super_copy->label, BTRFS_LABEL_SIZE);tspin_unlock(&root->fs_info->super_lock);tlen = strnlen(label, BTRFS_LABEL_SIZE);tif (len == BTRFS_LABEL_SIZE) {ttbtrfs_warn(root->fs_info,ttt""label is too long, return the first %zu bytes"", --len);t}tret = copy_to_user(arg, label, len);treturn ret ? -EFAULT : 0;}",2,"cwe119,cwe120"
"load_playlist(basic_playlist *data){    FILE *file;    char buf[1024];    int buflen;    file = fopen(data->file, ""rb"");    if (file == NULL)     {        LOG_ERROR2(""Playlist file %s could not be opened: %s"",                 data->file, strerror(errno));        return -1;    }    if(data->pl)     {        int i;        for(i = 0; i < data->len; i++)            free(data->pl[i]);        free(data->pl);    }    data->pl = NULL;    data->len = 0;    buflen = 0;    while (1)     {        if(fgets(buf,1024, file) == NULL) break;        if(buf[0]==0) break;        if(buf[0]=='' || (buf[0]=='r' && buf[1]==''))            continue;        if(buf[0] == '#')              continue;        buf[strlen(buf)-1] = 0;                 if(strlen(buf) > 0 && buf[strlen(buf)-1] == 'r')            buf[strlen(buf)-1] = 0;        if(buflen < data->len+1)        {            buflen += 100;            data->pl = realloc(data->pl, buflen*sizeof(char *));        }        data->pl[data->len++] = strdup(buf);    }    if(data->random)        shuffle(data->pl, data->len);    return 0;}",3,"cwe119,cwe120,cweother"
"SyRandomnessInit(SyPRNGCtx *pCtx, ProcRandomSeed xSeed, void * pUserData){tchar zSeed[256];tsxu8 t;tsxi32 rc;tsxu32 i;tif( pCtx->nMagic == SXPRNG_MAGIC ){ttreturn SXRET_OK;  t}  ttif( xSeed == 0 ){ttxSeed = SyOSUtilRandomSeed;t}trc = xSeed(zSeed, sizeof(zSeed), pUserData);tif( rc != SXRET_OK ){ttreturn rc;t}tpCtx->i = pCtx->j = 0;tfor(i=0; i < SX_ARRAYSIZE(pCtx->s) ; i++){ttpCtx->s[i] = (unsigned char)i;    }    for(i=0; i < sizeof(zSeed) ; i++){      pCtx->j += pCtx->s[i] + zSeed[i];      t = pCtx->s[pCtx->j];      pCtx->s[pCtx->j] = pCtx->s[i];      pCtx->s[i] = t;    }tpCtx->nMagic = SXPRNG_MAGIC;ttreturn SXRET_OK;}",2,"cwe119,cwe120"
"IoFile_open(IoFile *self, IoObject *locals, IoMessage *m){t tchar *mode = CSTRING(DATA(self)->mode);tDATA(self)->flags = IOFILE_FLAGS_NONE;tif (IoMessage_argCount(m) > 0)t{ttDATA(self)->path = IOREF(IoMessage_locals_symbolArgAt_(m, locals, 0));t}tif (!DATA(self)->stream)t{ttif (!IoFile_justExists(self) && strcmp(mode, ""r"") != 0 )tt{tttIoFile_create(self);tttif(!IoFile_justExists(self))ttt{ttttIoState_error_(IOSTATE, m, ""unable to create file '%s'"", CSTRING(DATA(self)->path));ttt}tt}ttDATA(self)->stream = fopen(CSTRING(DATA(self)->path), mode);t}tif (DATA(self)->stream == NULL)t{ttIoState_error_(IOSTATE, m, ""unable to open file path '%s'"", CSTRING(DATA(self)->path));t}treturn self;}",2,"cwe469,cweother"
"print_udev_ambivalent(blkid_probe pr){tchar *val = NULL;tsize_t valsz = 0;tint count = 0, rc = -1;twhile (!blkid_do_probe(pr)) {ttconst char *usage = NULL, *type = NULL, *version = NULL;ttchar enc[256];ttblkid_probe_lookup_value(pr, ""USAGE"", &usage, NULL);ttblkid_probe_lookup_value(pr, ""TYPE"", &type, NULL);ttblkid_probe_lookup_value(pr, ""VERSION"", &version, NULL);ttif (!usage || !type)tttcontinue;ttblkid_encode_string(usage, enc, sizeof(enc));ttif (append_str(&val, &valsz, enc, "":""))tttgoto done;ttblkid_encode_string(type, enc, sizeof(enc));ttif (append_str(&val, &valsz, enc, version ? "":"" : "" ""))tttgoto done;ttif (version) {tttblkid_encode_string(version, enc, sizeof(enc));tttif (append_str(&val, &valsz, enc, "" ""))ttttgoto done;tt}ttcount++;t}tif (count > 1) {tt*(val + valsz - 1) = '0';tt ttprintf(""ID_FS_AMBIVALEN=%s"", val);ttrc = 0;t}done:tfree(val);treturn rc;}",2,"cwe119,cwe120"
"nxt_set_coalesce(struct net_device *dev,ttt     struct ethtool_coalesce *coal){tstruct bnxt *bp = netdev_priv(dev);tbool update_stats = false;tint rc = 0;tbp->rx_coal_ticks = coal->rx_coalesce_usecs;t tbp->rx_coal_bufs = coal->rx_max_coalesced_frames * 2;tbp->rx_coal_ticks_irq = coal->rx_coalesce_usecs_irq;tbp->rx_coal_bufs_irq = coal->rx_max_coalesced_frames_irq * 2;tbp->tx_coal_ticks = coal->tx_coalesce_usecs;tbp->tx_coal_bufs = coal->tx_max_coalesced_frames;tbp->tx_coal_ticks_irq = coal->tx_coalesce_usecs_irq;tbp->tx_coal_bufs_irq = coal->tx_max_coalesced_frames_irq;tif (bp->stats_coal_ticks != coal->stats_block_coalesce_usecs) {ttu32 stats_ticks = coal->stats_block_coalesce_usecs;tt ttif (stats_ticks)tttstats_ticks = clamp_t(u32, stats_ticks,ttttt      BNXT_MIN_STATS_COAL_TICKS,ttttt      BNXT_MAX_STATS_COAL_TICKS);ttstats_ticks = rounddown(stats_ticks, BNXT_MIN_STATS_COAL_TICKS);ttbp->stats_coal_ticks = stats_ticks;ttupdate_stats = true;t}tif (netif_running(dev)) {ttif (update_stats) {tttrc = bnxt_close_nic(bp, true, false);tttif (!rc)ttttrc = bnxt_open_nic(bp, true, false);tt} else {tttrc = bnxt_hwrm_set_coal(bp);tt}t}treturn rc;}",2,"cwe119,cwe120"
"time_to_string(__u32 cl){tstatic inttdo_gmt = -1;ttime_tttt = (time_t) cl;tconst chart*tz;tif (do_gmt == -1) {tt tttz = getenv(""TZ"");ttif (!tz)ttttz = """";ttdo_gmt = !strcmp(tz, ""GMT"");t}treturn asctime((do_gmt) ? gmtime(&t) : localtime(&t));}",2,"cwe469,cweother"
list_all_arts_read(GROUP *g){    longtfirst = g->first_art;    longtlast  = g->last_art;    free_read_arts_list(g);    if (last >= first && last > 0) {tART_LIST_NODEt*temp;ttemp = g->read_arts = (ART_LIST_NODE *)XtMalloc(sizeof(ART_LIST_NODE));ttemp->first = 1;ttemp->last  = last;ttemp->next  = NULL;    }},2,"cwe120,cweother"
"ao_plugin_set_option(ao_device *device, const char *key, const char *value){tao_oss_internal *internal = (ao_oss_internal *) device->internal;tif (!strcmp(key, ""dsp"") || !strcmp(key, ""dev"")) {                     free(internal->dev);          if(!(internal->dev = strdup(value)))            return 0;t}tif (!strcmp(key, ""id"")) {          free(internal->dev);          internal->dev=NULL;          internal->id=atoi(value);t}treturn 1;}",2,"cwe469,cweother"
"set_locale_with_workaround (int langid, const char *lcode){    char *test = setlocale(LC_ALL, lcode);# ifndef WIN32        if (test == NULL) {tchar lfix[32];tsprintf(lfix, ""%s.UTF-8"", lcode);  ttest = setlocale(LC_ALL, lfix);    }# endif    if (test != NULL) {tfprintf(stderr, ""setlocale: '%s' -> '%s'"", lcode, test);tif (strcmp(""_File"", _(""_File"")) == 0) {t    const char *langstr;t    char tmp[64];t    t    langstr = lang_string_from_id(langid);t    sscanf(langstr, ""%s"", tmp);t    gretl_lower(tmp);t    gretl_setenv(""LANGUAGE"", tmp);t}    }    return test == NULL;}",4,"cwe119,cwe120,cwe476,cweother"
"drm_dp_mst_dump_mstb(struct seq_file *m,tttt struct drm_dp_mst_branch *mstb){tstruct drm_dp_mst_port *port;tint tabs = mstb->lct;tchar prefix[10];tint i;tfor (i = 0; i < tabs; i++)ttprefix[i] = 't';tprefix[i] = '0';tseq_printf(m, ""%smst: %p, %d"", prefix, mstb, mstb->num_ports);tlist_for_each_entry(port, &mstb->ports, next) {ttseq_printf(m, ""%sport: %d: ddps: %d ldps: %d, sdp: %d/%d, %p, conn: %p"", prefix, port->port_num, port->ddps, port->ldps, port->num_sdp_streams, port->num_sdp_stream_sinks, port, port->connector);ttif (port->mstb)tttdrm_dp_mst_dump_mstb(m, port->mstb);t}}",2,"cwe119,cwe120"
"pcf8563_write_block_data(struct i2c_client *client,tttt   unsigned char reg, unsigned char length,tttt   unsigned char *buf){tint i, err;tfor (i = 0; i < length; i++) {ttunsigned char data[2] = { reg + i, buf[i] };tterr = i2c_master_send(client, data, sizeof(data));ttif (err != sizeof(data)) {tttdev_err(&client->dev,tttt""%s: err=%d addr=%02x, data=%02x"",tttt__func__, err, data[0], data[1]);tttreturn -EIO;tt}t}treturn 0;}",2,"cwe119,cwe120"
"t_isdigit(const char *ptr){tinttttclen = pg_mblen(ptr);twchar_tttcharacter[2];tif (clen == 1 || lc_ctype_is_c())ttreturn isdigit(TOUCHAR(ptr));tchar2wchar(character, 2, ptr, clen);treturn iswdigit((wint_t) character[0]);}",2,"cwe119,cwe120"
"invent_message(struct ast_channel *chan, char *domain, char *username, int busy, char *ecodes){tint res;tchar fn[PATH_MAX];tast_debug(2, ""Still preparing to play message ..."");tsnprintf(fn, sizeof(fn), ""%s%s/%s/greet"", MVM_SPOOL_DIR, domain, username);tif (ast_fileexists(fn, NULL, NULL) > 0) {ttres = ast_streamfile(chan, fn, ast_channel_language(chan));ttif (res) tttreturn -1;ttres = ast_waitstream(chan, ecodes);ttif (res) tttreturn res;t} else {ttint numericusername = 1;ttchar *i = username;ttast_debug(2, ""No personal prompts. Using default prompt set for language"");ttwhile (*i)  {tttast_debug(2, ""Numeric? Checking %c"", *i);tttif (!isdigit(*i)) {ttttnumericusername = FALSE;ttttbreak;ttt}ttti++;tt}ttif (numericusername) {tttif (ast_streamfile(chan, ""vm-theperson"", ast_channel_language(chan)))ttttreturn -1;tttif ((res = ast_waitstream(chan, ecodes)))ttttreturn res;tttres = ast_say_digit_str(chan, username, ecodes, ast_channel_language(chan));tttif (res)ttttreturn res;tt} else {tttif (ast_streamfile(chan, ""vm-theextensionis"", ast_channel_language(chan)))ttttreturn -1;tttif ((res = ast_waitstream(chan, ecodes)))ttttreturn res;tt}t}tres = ast_streamfile(chan, busy ? ""vm-isonphone"" : ""vm-isunavail"", ast_channel_language(chan));tif (res)ttreturn -1;tres = ast_waitstream(chan, ecodes);treturn res;}",2,"cwe119,cwe120"
"uf_return_running(){    int fd;    char pidtxt[128];    int pid;    int l;        if ((fd = open(G15DAEMON_PIDFILE, O_RDWR, 0644)) < 0) {            return -1;    }    if((l = read(fd,pidtxt,sizeof(pidtxt)-1)) < 0) {        unlink (G15DAEMON_PIDFILE);        close(fd);        return -1;    }    if((pid = atoi(pidtxt)) <= 0) {        g15daemon_log(LOG_ERR,""pidfile corrupt"");        unlink(G15DAEMON_PIDFILE);        close(fd);        return -1;    }    if((kill(pid,0) != 0) && errno != EPERM ) {        g15daemon_log(LOG_ERR,""Process died - removing pidfile"");        unlink(G15DAEMON_PIDFILE);        close(fd);        return -1;    }        return pid;    }",3,"cwe119,cwe120,cweother"
"writelog(FILE *fp, unsigned char *ptr, int len){ttime_tttt;tchartt*s;tchartttmp[8];tintttolen = len;tintttdosync = 0;tinttttlen;twhile (len > 0) {tttmp[0] = 0;ttif (didnl) {ttttime(&t);ttts = ctime(&t);tttfprintf(fp, ""%.24s: "", s);tttdidnl = 0;tt}ttswitch (*ptr) {tttcase 27:  ttttstrcpy(tmp, ""^["");ttttbreak;tttcase 'r':ttttline.pos = 0;ttttbreak;tttcase 8:  ttttif (line.pos > 0) line.pos--;ttttbreak;tttcase '':ttttdidnl = 1;ttttdosync = 1;ttttbreak;tttcase 't':ttttline.pos += (line.pos / 8 + 1) * 8;ttttif (line.pos >= (int)sizeof(line.buf))tttttline.pos = sizeof(line.buf) - 1;ttttbreak;tttcase  32 ... 127:tttcase 161 ... 255:tttttmp[0] = *ptr;tttttmp[1] = 0;ttttbreak;tttdefault:ttttsprintf(tmp, ""%03o"", *ptr);ttttbreak;tt}ttptr++;ttlen--;tttlen = strlen(tmp);ttif (tlen && (line.pos + tlen < (int)sizeof(line.buf))) {tttmemcpy(line.buf + line.pos, tmp, tlen);tttline.pos += tlen;tt}ttif (didnl) {tttfprintf(fp, ""%s"", line.buf);tttmemset(&line, 0, sizeof(line));tt}t}tif (dosync) {ttfflush(fp);ttif (syncalot) {tttfdatasync(fileno(fp));tt}t}toutptr += olen;tif (outptr >= endptr)ttoutptr = ringbuf;}",4,"cwe119,cwe120,cwe476,cweother"
"ref_to_key(const ref * pref, gs_param_key_t * key, iparam_list *plist){    if (r_has_type(pref, t_name)) {        ref nref;        name_string_ref(plist->memory, pref, &nref);        key->data = nref.value.const_bytes;        key->size = r_size(&nref);        key->persistent = false;      } else if (r_has_type(pref, t_integer)) {        char istr[sizeof(long) * 8 / 3 + 2];        int len;        byte *buf;        gs_sprintf(istr, ""%""PRIpsint, pref->value.intval);        len = strlen(istr);                 buf = gs_alloc_string(plist->memory, len, ""ref_to_key"");        if (!buf)            return_error(e_VMerror);        key->data = buf;        key->size = len;        key->persistent = true;    } else        return_error(e_typecheck);    return 0;}",2,"cwe119,cwe120"
"conv_r23(const int ifd){tstructtsphdrtoh;tstructtspdettod;tlseek(ifd, 0L, 0);tif  (read(ifd, (char *) &oh, sizeof(oh)) != sizeof(oh))  {ttfprintf(stderr, ""Bad header old file"");ttexit(3);t}tprintf(""#! /bin/sh# Converted from user filegspl-uchange -DA -l %d -d %d -m %d -n %d -f %s -c %s -p 0x%lx"",tt      oh.sph_minp, oh.sph_defp, oh.sph_maxp, oh.sph_cps,tt      oh.sph_form, hex_disp(oh.sph_class, 0), (unsigned long) oh.sph_flgs);twhile  (read(ifd, (char *) &od, sizeof(od)) == sizeof(od))  {ttif  (!od.spu_isvalid)tttcontinue;ttif  (!spu23fldsok(&od))tttcontinue;ttprintf(""gspl-uchange -l %d -d %d -m %d -n %d -f %s -c %s -p 0x%lx %s"",tt      od.spu_minp, od.spu_defp, od.spu_maxp, od.spu_cps,tt      od.spu_form, hex_disp(od.spu_class, 0), (unsigned long) od.spu_flgs, prin_uname((uid_t) od.spu_user));t}}",2,"cwe120,cweother"
"matrix_eigMaxSym_float (float* l,float* v,float* M,size_t n){    size_t i,k;    float r;    float* y = (float*)malloc(n*sizeof(float));    *l = 1;    for (i=0;i<n;i++)            v[i] = 1.0/sqrt(n);    for (k=0;k<500;k++)    {                 for (i=0;i<n;i++)        {            y[i] = vector_ps_float (v, &M[i*n], n);        }                 *l = vector_ps_float (v, y, n);        if (fabs(*l) < 1E-7) {            free (y);            return 0;        }                 vector_linear_float (v,y,-(*l),v,n);        r = vector_ps_float (v, v, n);        r = fabs(r/(*l));                 if (r < 1E-14){            vector_cpym_float (v, 1.0/vector_n2_float (y, n), y, n);            break;        }                 r = vector_n2p2_float (y, n);        if (r < 1E-7) {            free (y);            return 0;        }                 r = 1.0/sqrt(r);        vector_cpym_float (v, r, y, n);    }              r = -1;    for (i=0;i<n;i++)        if (v[i]<r)            r = v[i];    if (r < 0)    {        for (i=0;i<n;i++)            v[i] = -v[i];    }    free (y);    return 1;}",2,"cwe120,cweother"
"stop_daemon(void){tint fd;tint ignore_ret;tpid_t learn_pid;tfd = open(GR_LEARN_PID_PATH, O_RDONLY);tif (fd < 0)ttexit(EXIT_FAILURE);tignore_ret = read(fd, &learn_pid, sizeof(learn_pid));t tkill(learn_pid, 15);tclose(fd);tunlink(GR_LEARN_PID_PATH);treturn 0;}",2,"cwe120,cweother"
"ase32_encode(char *dst, size_t size, const void *data, size_t len){  size_t i = 0;  const uint8_t *p = data;  const char *end = &dst[size];  char *q = dst;  do {    size_t j, k;    uint8_t x[5];    char s[8];    switch (len - i) {    case 4: k = 7; break;    case 3: k = 5; break;    case 2: k = 3; break;    case 1: k = 2; break;    default:      k = 8;    }    for (j = 0; j < 5; j++)      x[j] = i < len ? p[i++] : 0;         s[0] =  (x[0] >> 3);    s[1] = ((x[0] & 0x07) << 2) | (x[1] >> 6);    s[2] =  (x[1] >> 1) & 0x1f;    s[3] = ((x[1] & 0x01) << 4) | (x[2] >> 4);    s[4] = ((x[2] & 0x0f) << 1) | (x[3] >> 7);    s[5] =  (x[3] >> 2) & 0x1f;    s[6] = ((x[3] & 0x03) << 3) | (x[4] >> 5);    s[7] =   x[4] & 0x1f;    for (j = 0; j < k && q != end; j++) {      *q++ = base32_alphabet[(uint8_t) s[j]];    }    if (end == q) {      break;    }  } while (i < len);  return q - dst;}",2,"cwe119,cwe120"
"process_intron(GtSpliceSiteInfoVisitor *ssiv, GtGenomeNode *intron,                          GtError *err){  char *sequence = NULL;  GtStrand strand;  GtRange range;  char site[5];  GtStr *seqid;  int had_err = 0;  gt_error_check(err);  gt_assert(ssiv && intron);  ssiv->intron_processed = true;  range = gt_genome_node_get_range(intron);  gt_assert(range.start);    if (gt_range_length(&range) >= 4) {    seqid = gt_genome_node_get_seqid(intron);    had_err = gt_region_mapping_get_sequence(ssiv->region_mapping, &sequence,                                             seqid, range.start, range.end,                                             err);    if (!had_err) {      strand = gt_feature_node_get_strand((GtFeatureNode*) intron);      if (strand == GT_STRAND_FORWARD || strand == GT_STRAND_REVERSE) {                 site[0] = tolower(sequence[0]);        site[1] = tolower(sequence[1]);        site[2] = tolower(sequence[gt_range_length(&range)-2]);        site[3] = tolower(sequence[gt_range_length(&range)-1]);        site[4] = '0';        if (strand == GT_STRAND_REVERSE)          had_err = gt_reverse_complement(site, 4, err);        if (!had_err) {                     gt_string_distri_add(ssiv->splicesites, site);          gt_string_distri_add(ssiv->acceptorsites, site + 2);          site[2] = '0';          gt_string_distri_add(ssiv->donorsites, site);          ssiv->show = true;        }      }      else {        gt_warning(""skipping intron with unknown orientation ""                   ""(file '%s', line %u)"", gt_genome_node_get_filename(intron),                   gt_genome_node_get_line_number(intron));      }      gt_free(sequence);    }  }  return had_err;}",2,"cwe119,cwe120"
"""consume_comment(FILE * fin) {    int c = fgetc(fin);    while(! feof(fin)) {        char cc = c;t        if(cc == '')            return;        c = fgetc(fin);    }}""",2,"cwe120,cweother"
"""Curl_FormReader(char *buffer,                       size_t size,                       size_t nitems,                       FILE *mydata){  struct Form *form;  size_t wantedsize;  size_t gotsize = 0;  form=(struct Form *)mydata;  wantedsize = size * nitems;  if(!form->data)    return 0; /* nothing, error, empty */  if(form->data->type == FORM_FILE) {    gotsize = readfromfile(form, buffer, wantedsize);    if(gotsize)      /* If positive or -1, return. If zero, continue! */      return gotsize;  }  do {    if( (form->data->length - form->sent ) > wantedsize - gotsize) {      memcpy(buffer + gotsize , form->data->line + form->sent,             wantedsize - gotsize);      form->sent += wantedsize-gotsize;      return wantedsize;    }    memcpy(buffer+gotsize,           form->data->line + form->sent,           (form->data->length - form->sent) );    gotsize += form->data->length - form->sent;    form->sent = 0;    form->data = form->data->next; /* advance */  } while(form->data && (form->data->type != FORM_FILE));  /* If we got an empty line and we have more data, we proceed to the next     line immediately to avoid returning zero before we've reached the end.     This is the bug reported November 22 1999 on curl 6.3. (Daniel) */  return gotsize;}""",2,"cwe120,cweother"
"get_temp_fname (char *out, const char *ext){  char *tmp = tempnam (NULL, ""rcomage_tmp"");  if (tmp) {    strcpy (out, tmp);    free (tmp);  } else    strcpy (out, ""rcomage_tmp"");  if (ext)    sprintf (out + strlen (out), "".%s"", ext);}",2,"cwe120,cweother"
"dvbsky_ci_ctrl(void *priv, u8 read, int addr,tttttu8 data, int *mem){tstruct dvb_usb_device *d = priv;tint ret = 0;tu8 command[4], respond[2], command_size, respond_size;tcommand[1] = (u8)((addr >> 8) & 0xff);  tcommand[2] = (u8)(addr & 0xff);  tif (read) {ttcommand[0] = 0x71;ttcommand_size = 3;ttrespond_size = 2;t} else {ttcommand[0] = 0x70;ttcommand[3] = data;ttcommand_size = 4;ttrespond_size = 1;t}tret = dvbsky_usb_generic_rw(d, command, command_size,tttrespond, respond_size);tif (ret)ttgoto err;tif (read)tt*mem = respond[1];treturn ret;err:tdev_err(&d->udev->dev, ""ci control failed=%d"", ret);treturn ret;}",2,"cwe120,cweother"
"NegateCompoundClass(char *class,struct Item **heap){ char *sp = class;  char cbuff[CF_MAXVARSIZE];Debug1(""NegateCompoundClass(%s)"",class);while(*sp != '0')   {   sscanf(sp,""%255[^.]"",cbuff);   while ((*sp != '0') && ((*sp !='.')||(*sp == '&')))      {      sp++;      }   if ((*sp == '.') || (*sp == '&'))      {      sp++;      }   if (IsHardClass(cbuff))      { char err[CF_BUFSIZE];      yyerror(""Illegal exception"");      sprintf (err,""Cannot negate the reserved class [%s]"",cbuff);      FatalError(err);      }   AppendItem(heap,cbuff,NULL);   }}",2,"cwe119,cwe120"
"getuserid(char *user){tstruct passwdt*pw;tuid_ttttuid;tif ((pw = getpwnam(user)) != NULL)tt{tttuid = pw->pw_uid;tt}telse if (*user == '#')tt{tttuid = (uid_t)atoi(&user[1]);tt}telsett{#ifdef HAVE_GETUSERIDtttid = getuserid(""nobody"");#elsetttuid = 65535;#endiftt}#if DEBUGtfprintf(stderr, ""User lookup %s -> %d"", user, uid);#endiftendpwent();treturn (uid);}",2,"cwe469,cweother"
"font_list(char ***list, int *count, int verbose){    char **fonts;    int num_fonts;    int i;    for (i = 0; ftcap[i].name; i++) ;    num_fonts = i;    fonts = G_malloc(num_fonts * sizeof(const char *));    for (i = 0; i < num_fonts; i++) {tstruct GFONT_CAP *p = &ftcap[i];tif (verbose) {t    char buf[GPATH_MAX];t    sprintf(buf, ""%s|%s|%d|%s|%d|%s|"",tt    p->name, p->longname, p->type,tt    p->path, p->index, p->encoding);t    fonts[i] = G_store(buf);t}telset    fonts[i] = G_store(p->name);    }    *list = fonts;    *count = num_fonts;}",2,"cwe119,cwe120"
"copyf(FILE *ip, FILE *op, long count, const char *ifn, const char *ofn){    char            buffer[1 << 10];    long            len;    while (count)    {        if (count < 0 || count > sizeof(buffer))            len = sizeof(buffer);        else            len = count;        len = fread(buffer, 1, len, ip);        if (len < 0)            return EOF;        if (len == 0)            break;        fwrite(buffer, 1, len, op);        if (ferror(op))            return EOF;        if (count >= 0)            count -= len;    }    return 0;}",3,"cwe119,cwe120,cweother"
"convert_au_to_pvf(FILE *in, FILE *out){tSNDSoundStruct hdr;tint i;tint c;trewind(in);tclearerr(in);tclearerr(out);         thdr.magicttt= read_one_word(in);thdr.dataLocationt= read_one_word(in);thdr.dataSizett= read_one_word(in);thdr.dataFormattt= read_one_word(in);thdr.samplingRatet= read_one_word(in);thdr.channelCountt= read_one_word(in);    tif (hdr.magic != SND_MAGIC)t{ttfprintf(stderr, ""%s: illegal magic number for an au file."", vbasename);ttttreturn(255);t}tif (hdr.channelCount != 1)t{ttfprintf(stderr, ""%s: number of channels != 1 (only mono supported)."", vbasename);ttttreturn(255);t}tfor (i = (SND_HEADER_SIZE - 4); i < hdr.dataLocation; i++)t{ttif (getc(in) == EOF)tt{tttfprintf(stderr, ""%s: unexpected EOF."", vbasename);ttttttreturn(255);tt}t}    tswitch (hdr.dataFormat)t{ttcase SND_FORMAT_MULAW_8:tttwhile(1)ttt{ttttc = getc(in);ttttif (feof(in)) break;ttttzput(byte_ulaw_to_linear(c), out);ttt}tttbreak;ttcase SND_FORMAT_LINEAR_8:tttwhile(1)ttt{ttttc = (getc(in) & 0xFF);ttttif (c >= 0x80) c -= 0x100;ttttif (feof(in)) break;ttttzput(c<<8, out);ttt}tttbreak;tttcase SND_FORMAT_LINEAR_16:ttttwhile(1)tttt{tttttc = zget(in);tttttif(feof(in)) break;tttttzput(c, out);tttt}ttttbreak;tttdefault:ttttfprintf(stderr, ""%s: unsupported or illegal sound encoding."", vbasename);ttttreturn(255);t}treturn(check_io_error(in, out));}",2,"cwe120,cweother"
"xdisp_update(int cnum, float *f){tunsigned char *bp;tshort *sp;tint i, j;tchar c;tunion comdata d;tif (cnum < 0 || cnum >= NUMCLI)ttreturn 0;ti = read(cli[cnum].cmdfd, &c, 1);tif (i < 0 && errno != EAGAIN) {ttperror(""read"");ttxdisp_terminate(cnum);ttreturn 0;t}tif (i < 1)ttreturn 0;tif (c != 'r')ttreturn 0;tfor (sp = d.s, i = 0; i < WIDTH; i++, sp++, f++) {ttif (*f >= 1)ttt*sp = 32767;ttelse if (*f <= -1)ttt*sp = -32767;ttelse ttt*sp = 32767.0 * (*f);t}tbp = d.b;tj = sizeof(d);twhile (j > 0) {tti = write(cli[cnum].datafd, bp, j);ttif (i < 0 && errno != EAGAIN) {tttperror(""write"");tttxdisp_terminate(cnum);tttreturn 0;tt}ttif (i > 0) {tttbp += i;tttj -= i;tt}t}treturn 1;}",2,"cwe120,cweother"
"readconfig(const char *name){    if (!strchr(name, '%')) {tchar filename[256];tsnprintf(filename, sizeof(filename), ""/etc/iaxmodem/%s"", name);tint fd = open(filename, O_RDONLY);tif (fd < 0) {t    printlog(LOG_ERROR, ""Cannot open %s."", filename);t    cleanup(-1);t}tint cc, pos = 0;tchar line[1024];tmemset(line, 0, 1024);twhile ((cc = read(fd, &line[pos], 1))) {t    if (line[pos] == '' || pos == 1023) {ttline[pos] = '0';ttsetconfigline(line);ttmemset(line, 0, 1024);ttpos = 0;t    } else pos++;t}tif (strlen(line)) {t    setconfigline(line);t}tif (replay && record) {t    record = 0;t    printlog(LOG_INFO, ""Disabling record"");t}tclose(fd);    }}",3,"cwe119,cwe120,cweother"
"__connman_inet_ipv6_send_rs(int index, int timeout,ttt__connman_inet_rs_cb_t callback, void *user_data){tstruct rs_cb_data *data;tstruct icmp6_filter filter;tstruct in6_addr solicit;tstruct in6_addr dst = in6addr_all_routers_mc;tint sk;tDBG("""");tif (timeout <= 0)ttreturn -EINVAL;tdata = g_try_malloc0(sizeof(struct rs_cb_data));tif (data == NULL)ttreturn -ENOMEM;tdata->callback = callback;tdata->user_data = user_data;tdata->rs_timeout = g_timeout_add_seconds(timeout, rs_timeout_cb, data);tsk = socket(AF_INET6, SOCK_RAW | SOCK_CLOEXEC, IPPROTO_ICMPV6);tif (sk < 0)ttreturn -errno;tICMP6_FILTER_SETBLOCKALL(&filter);tICMP6_FILTER_SETPASS(ND_ROUTER_ADVERT, &filter);tsetsockopt(sk, IPPROTO_ICMPV6, ICMP6_FILTER, &filter,ttttttsizeof(struct icmp6_filter));tipv6_addr_solict_mult(&dst, &solicit);tif_mc_group(sk, index, &in6addr_all_nodes_mc, IPV6_JOIN_GROUP);tif_mc_group(sk, index, &solicit, IPV6_JOIN_GROUP);tdata->channel = g_io_channel_unix_new(sk);tg_io_channel_set_close_on_unref(data->channel, TRUE);tg_io_channel_set_encoding(data->channel, NULL, NULL);tg_io_channel_set_buffered(data->channel, FALSE);tdata->watch_id = g_io_add_watch(data->channel,tttG_IO_IN | G_IO_NVAL | G_IO_HUP | G_IO_ERR,ttticmpv6_event, data);tndisc_send_unspec(ND_ROUTER_SOLICIT, index, &dst);treturn 0;}",2,"cwe119,cwe120"
"init_client_ip(int *sock, unsigned char ip[4], int port, int type)t{tunsigned long addr;tstruct sockaddr_in them;tint s,i;tif (!ssl_sock_init()) return(0);tmemset((char *)&them,0,sizeof(them));tthem.sin_family=AF_INET;tthem.sin_port=htons((unsigned short)port);taddr=(unsigned long)tt((unsigned long)ip[0]<<24L)|tt((unsigned long)ip[1]<<16L)|tt((unsigned long)ip[2]<< 8L)|tt((unsigned long)ip[3]);tthem.sin_addr.s_addr=htonl(addr);tif (type == SOCK_STREAM)tts=socket(AF_INET,SOCK_STREAM,SOCKET_PROTOCOL);telse  tts=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);ttttif (s == INVALID_SOCKET) { perror(""socket""); return(0); }#if defined(SO_KEEPALIVE) && !defined(OPENSSL_SYS_MPE)tif (type == SOCK_STREAM)tt{tti=0;tti=setsockopt(s,SOL_SOCKET,SO_KEEPALIVE,(char *)&i,sizeof(i));ttif (i < 0) { perror(""keepalive""); return(0); }tt}#endiftif (connect(s,(struct sockaddr *)&them,sizeof(them)) == -1)tt{ closesocket(s); perror(""connect""); return(0); }t*sock=s;treturn(1);t}",2,"cwe119,cwe120"
"init(int argc, char *argv[]){    unsigned int c;    opterr = 0;    while ((c = getopt(argc, argv, ""necCaDUrsv"")) != -1) {tswitch (c) {tcase 'e':t    flags |= EDGES;t    break;tcase 'n':t    flags |= NODES;t    break;tcase 'c':t    flags |= CC;t    break;tcase 'C':t    flags |= CL;t    tot_cl = 0;t    break;tcase 'a':t    flags = NODES | EDGES | CC | CL;t    break;tcase 'r':t    recurse = 1;t    break;tcase 's':t    silent = 1;t    break;tcase 'v':t    verbose = 1;t    break;tcase 'D':t    gtype = DIRECTED;t    break;tcase 'U':t    gtype = UNDIRECTED;t    break;tcase '?':t    if (optopt == '?')ttusage(0);t    elsettfprintf(stderr, ""gc: option -%c unrecognized - ignored"",tttoptopt);t    break;t}    }    argv += optind;    argc -= optind;    if (argc)tFiles = argv;    if (flags == 0)tflags = NODES | EDGES;    if (gtype == 0)tgtype = DIRECTED | UNDIRECTED;    outfile = stdout;}",2,"cwe120,cweother"
"jtag3_program_disable(PROGRAMMER * pgm){  unsigned char buf[3], *resp;  if (!PDATA(pgm)->prog_enabled)    return 0;  buf[0] = SCOPE_AVR;  buf[1] = CMD3_LEAVE_PROGMODE;  buf[2] = 0;  if (jtag3_command(pgm, buf, 3, &resp, ""leave progmode"") < 0)    return -1;  free(resp);  PDATA(pgm)->prog_enabled = 0;  return 0;}",2,"cwe119,cwe120"
"doport2(struct sockaddr_storage a, unsigned int p){    if (loggedin == 0) {        addreply_noformat(530, MSG_NOT_LOGGED_IN);        return;    }    if (epsv_all != 0) {        addreply_noformat(501, MSG_ACTIVE_DISABLED);        return;    }    if (datafd != -1) {             (void) close(datafd);        datafd = -1;    }    if (p < 1024U) {        addreply_noformat(501, MSG_BAD_PORT);        return;    }    if (doport3(STORAGE_FAMILY(a) == AF_INET6 ? PF_INET6 : PF_INET) != 0) {        return;    }    peerdataport = (in_port_t) p;    if (addrcmp(&a, &peer) != 0) {        char hbuf[NI_MAXHOST];        char peerbuf[NI_MAXHOST];                if (getnameinfo((struct sockaddr *) &a, STORAGE_LEN(a),                        hbuf, sizeof hbuf, NULL,                        (size_t) 0U, NI_NUMERICHOST) != 0 ||            getnameinfo((struct sockaddr *) &peer, STORAGE_LEN(peer),                        peerbuf, sizeof peerbuf, NULL,                        (size_t) 0U, NI_NUMERICHOST) != 0) {            goto hu;        }        if (allowfxp == 0 || (allowfxp == 1 && guest != 0)) {            hu:            (void) close(datafd);            datafd = -1;            addreply(500, MSG_NO_FXP, hbuf, peerbuf);            return;        } else {            addreply(0, MSG_FXP, peerbuf, hbuf);            memcpy(&peer, &a, sizeof a);        }    }    passive = 0;        addreply_noformat(200, MSG_PORT_SUCCESSFUL);    return;}",2,"cwe119,cwe120"
"rsh_list(struct remote *rem, struct remdirlist *dl){    int res;    struct program *pr;    const char *prog[8];    char *escaped_path;    unsigned int arg;    const char *host;    char *username;    escaped_path = rsh_code_name(dl->hostpath.path);    username = rsh_split_hostpart(dl->hostpath.host, &host);    arg = 0;    prog[arg++] = rem->name;    if(username != NULL) {        prog[arg++] = ""-l"";        prog[arg++] = username;    }    prog[arg++] = host;    prog[arg++] = ""/bin/ls"";    if((dl->flags & REM_LIST_SINGLE) != 0)        prog[arg++] = ""-ldn"";    else        prog[arg++] = ""-lan"";    prog[arg++] = escaped_path;    prog[arg++] = NULL;      res = av_start_program(prog, &pr);    if(res == 0) {        struct lscache *lc = av_new_lscache();        res = rsh_read_list(pr, lc, dl);        av_unref_obj(lc);        av_unref_obj(pr);    }    av_free(escaped_path);    av_free(username);    return res;}",2,"cwe119,cwe120"
"auth_cram_md5(struct imap_store *ctx, struct imap_cmd *cmd, const char *prompt){tint ret;tchar *response;tresponse = cram(prompt, server.user, server.pass);tret = socket_write(&ctx->imap->buf.sock, response, strlen(response));tif (ret != strlen(response))ttreturn error(""IMAP error: sending response failed"");tfree(response);treturn 0;}",2,"cwe119,cwe120"
"shell_arg (const char *args, unsigned int arg_num, char *arg){tsize_t x=0, y=0;tunsigned int count=0;tint in_arg=0, copy=0;tif (arg_num > shell_arg_count(args)-1)ttreturn (GP_ERROR);twhile (x < strlen(args)) {tttt ttif ((!isspace((int)(args[x]))) && (!in_arg)) {tttin_arg = 1;tttif (count == arg_num)ttttcopy = 1;tttcount++;tt}ttif ((isspace((int)(args[x]))) && (in_arg)) {tttcopy = 0;tttin_arg = 0;tt}ttif (copy)ttttt tttarg[y++] = args[x];ttx++;t}targ[y] = 0;tttttt treturn (GP_OK);}",2,"cwe119,cwe120"
"run_rsa_verify (const void *data, size_t datalen, int hashalgo, int pkcs1,                const char *keyfile, const char *sigfile){  gpg_error_t err;  gcry_sexp_t s_data, s_key, s_sig;  if (pkcs1)    {      unsigned char hash[64];      unsigned int hashsize;      hashsize = gcry_md_get_algo_dlen (hashalgo);      if (!hashsize || hashsize > sizeof hash)        die (""digest too long for buffer or unknown hash algorithm"");      gcry_md_hash_buffer (hashalgo, hash, data, datalen);      err = gcry_sexp_build (&s_data, NULL,                             ""(data (flags pkcs1)(hash %s %b))"",                             gcry_md_algo_name (hashalgo),                             (int)hashsize, hash);    }  else    {      gcry_mpi_t tmp;      err = gcry_mpi_scan (&tmp, GCRYMPI_FMT_USG, data, datalen,NULL);      if (!err)        {          err = gcry_sexp_build (&s_data, NULL,                                 ""(data (flags raw)(value %m))"", tmp);          gcry_mpi_release (tmp);        }    }  if (err)    die (""gcry_sexp_build failed for RSA data input: %s"",         gpg_strerror (err));  s_key = read_public_key_file (keyfile, 0);  s_sig = read_sig_file (sigfile);  err = gcry_pk_verify (s_sig, s_data, s_key);  if (!err)    puts (""GOOD signature"");  else if (gpg_err_code (err) == GPG_ERR_BAD_SIGNATURE)    puts (""BAD signature"");  else    printf (""ERROR (%s)"", gpg_strerror (err));  gcry_sexp_release (s_sig);  gcry_sexp_release (s_key);  gcry_sexp_release (s_data);}",3,"cwe119,cwe120,cweother"
"history_save (void){    if (! modified)        return;    config_clear_section (""history"");    GList * node = history.head;    for (int i = 0; i < MAX_ENTRIES; i ++)    {        if (! node)            break;        char name[32];        snprintf (name, sizeof name, ""entry%d"", i);        set_string (""history"", name, node->data);        node = node->next;    }    modified = FALSE;}",2,"cwe119,cwe120"
"gzip_decompress(ssh_session session, ssh_buffer source, size_t maxlen) {  z_stream *zin = session->current_crypto->compress_in_ctx;  void *in_ptr = buffer_get_rest(source);  unsigned long in_size = buffer_get_rest_len(source);  unsigned char out_buf[BLOCKSIZE] = {0};  ssh_buffer dest = NULL;  unsigned long len;  int status;  if (zin == NULL) {    zin = session->current_crypto->compress_in_ctx = initdecompress(session);    if (zin == NULL) {      return NULL;    }  }  dest = ssh_buffer_new();  if (dest == NULL) {    return NULL;  }  zin->next_out = out_buf;  zin->next_in = in_ptr;  zin->avail_in = in_size;  do {    zin->avail_out = BLOCKSIZE;    status = inflate(zin, Z_PARTIAL_FLUSH);    if (status != Z_OK && status != Z_BUF_ERROR) {      ssh_set_error(session, SSH_FATAL,          ""status %d inflating zlib packet"", status);      ssh_buffer_free(dest);      return NULL;    }    len = BLOCKSIZE - zin->avail_out;    if (buffer_add_data(dest,out_buf,len) < 0) {      ssh_buffer_free(dest);      return NULL;    }    if (buffer_get_rest_len(dest) > maxlen){             ssh_buffer_free(dest);      return NULL;    }    zin->next_out = out_buf;  } while (zin->avail_out == 0);  return dest;}",2,"cwe119,cwe120"
"rfc822_mkdate_buf(time_t t, char *buf){structttm *p;inttoffset;#iftUSE_TIME_ALTZONEtp=localtime(&t);toffset= -(int)timezone;tif (p->tm_isdst > 0)ttoffset= -(int)altzone;tif (offset % 60)t{ttoffset=0;ttp=gmtime(&t);t}toffset /= 60;#else#iftUSE_TIME_DAYLIGHTtp=localtime(&t);toffset= -(int)timezone;tif (p->tm_isdst > 0)ttoffset += 60*60;tif (offset % 60)t{ttoffset=0;ttp=gmtime(&t);t}toffset /= 60;#else#iftUSE_TIME_GMTOFFtp=localtime(&t);toffset= p->tm_gmtoff;tif (offset % 60)t{ttoffset=0;ttp=gmtime(&t);t}toffset /= 60;#elsetp=gmtime(&t);toffset=0;#endif#endif#endiftoffset = (offset % 60) + offset / 60 * 100;tsprintf(buf, ""%s, %02d %s %04d %02d:%02d:%02d %+05d"",ttwdays[p->tm_wday],ttp->tm_mday,ttmonths[p->tm_mon],ttp->tm_year+1900,ttp->tm_hour,ttp->tm_min,ttp->tm_sec,ttoffset);}",2,"cwe119,cwe120"
"do_register(const void *data){tstruct dundi_ie_data ied;tstruct dundi_peer *peer = (struct dundi_peer *)data;tchar eid_str[20];tchar eid_str2[20];tast_debug(1, ""Register us as '%s' to '%s'"", ast_eid_to_str(eid_str, sizeof(eid_str), &peer->us_eid), ast_eid_to_str(eid_str2, sizeof(eid_str2), &peer->eid));tpeer->registerid = ast_sched_add(sched, default_expiration * 1000, do_register, data);t tif (peer->regtrans)ttdestroy_trans(peer->regtrans, 0);tpeer->regtrans = create_transaction(peer);tif (peer->regtrans) {ttast_set_flag(peer->regtrans, FLAG_ISREG);ttmemset(&ied, 0, sizeof(ied));ttdundi_ie_append_short(&ied, DUNDI_IE_VERSION, DUNDI_DEFAULT_VERSION);ttdundi_ie_append_eid(&ied, DUNDI_IE_EID, &peer->regtrans->us_eid);ttdundi_ie_append_short(&ied, DUNDI_IE_EXPIRATION, default_expiration);ttdundi_send(peer->regtrans, DUNDI_COMMAND_REGREQ, 0, 0, &ied);t} elsettast_log(LOG_NOTICE, ""Unable to create new transaction for registering to '%s'!"", ast_eid_to_str(eid_str, sizeof(eid_str), &peer->eid));treturn 0;}",2,"cwe119,cwe120"
"tex_mp_coeff_name (char *targ, const char *src,ttt       int inmath){    char fmt[12], vname[VNAMELEN], vnesc[24];    int power;    tex_escape(vnesc, src);    sprintf(fmt, ""%%%d[^^]^%%d"", VNAMELEN - 1);    if (sscanf(vnesc, fmt, vname, &power) == 2) {t tif (!inmath) {t    sprintf(targ, ""%s$^{%d}$"", vname, power);t} else {t    sprintf(targ, ""mbox{%s}^%d"", vname, power);t}    } else {t tif (inmath) {t    sprintf(targ, ""mbox{%s}"", vnesc);t} else {t    strcpy(targ, vnesc);t}    }}",3,"cwe119,cwe120,cweother"
"main (void){  char buf[BUFSIZ];  char *p;  uint32_t *r;  int rc;  size_t errpos, i;  printf (""Input domain encoded as `%s': "", stringprep_locale_charset ());  fflush (stdout);  if (!fgets (buf, BUFSIZ, stdin))    perror (""fgets"");  buf[strlen (buf) - 1] = '0';  printf (""Read string (length %ld): "", (long int) strlen (buf));  for (i = 0; i < strlen (buf); i++)    printf (""%02x "", buf[i] & 0xFF);  printf ("""");  p = stringprep_locale_to_utf8 (buf);  if (p)    {      strcpy (buf, p);      free (p);    }  else    printf (""Could not convert string to UTF-8, continuing anyway..."");  rc = idna_to_ascii_8z (buf, &p, 0);  if (rc != IDNA_SUCCESS)    {      printf (""idna_to_ascii_8z failed (%d): %s"", rc, idna_strerror (rc));      return 2;    }  printf (""ToASCII string (length %ld): %s"", (long int) strlen (p), p);  rc = idna_to_unicode_8z4z (p, &r, 0);  free (p);  if (rc != IDNA_SUCCESS)    {      printf (""idna_to_unicode_8z4z failed (%d): %s"",t      rc, idna_strerror (rc));      return 2;    }  printf (""ToUnicode string: "");  for (i = 0; r[i]; i++)    printf (""U+%04x "", r[i]);  printf ("""");  rc = tld_check_4z (r, &errpos, NULL);  free (r);  if (rc == TLD_INVALID)    {      printf (""Domain rejected by TLD check, Unicode position %ld"", (long int) errpos);      return 1;    }  else if (rc != TLD_SUCCESS)    {      printf (""tld_check_4z() failed (%d): %s"", rc, tld_strerror (rc));      return 2;    }  printf (""Domain accepted by TLD check"");  return 0;}",2,"cwe119,cwe120"
"gn_atem_incoming_data_handle(char *buffer, int length){tint count;tunsigned char out_buf[3];tfor (count = 0; count < length ; count++) {tt ttif (buffer[count] == ModemRegisters[REG_CR] ||tt    buffer[count] == ModemRegisters[REG_LF] ||tt    buffer[count] == ModemRegisters[REG_CTRLZ] ||tt    buffer[count] == ModemRegisters[REG_ESCAPE]) {ttt tttif (buffer[count] == ModemRegisters[REG_CR] &&tttt(ModemRegisters[REG_ECHO] & BIT_ECHO)) {ttttgn_atem_string_out(""r"");ttt}ttt tttif (buffer[count] == ModemRegisters[REG_CTRLZ] ||ttt    buffer[count] == ModemRegisters[REG_ESCAPE])ttttCmdBuffer[CurrentCmdBuffer][CurrentCmdBufferIndex++] = buffer[count];tttCmdBuffer[CurrentCmdBuffer][CurrentCmdBufferIndex] = 0x00;tttParser(CmdBuffer[CurrentCmdBuffer]);tttCurrentCmdBuffer++;tttif (CurrentCmdBuffer >= MAX_CMD_BUFFERS) {ttttCurrentCmdBuffer = 0;ttt}tttCurrentCmdBufferIndex = 0;tt} else if (buffer[count] == ModemRegisters[REG_BS]) {tttif (CurrentCmdBufferIndex > 0) {tttt ttttif (ModemRegisters[REG_ECHO] & BIT_ECHO) {tttttgn_atem_string_out(""b b"");tttt}ttttCurrentCmdBufferIndex--;ttt}tt} else {ttt tttif (ModemRegisters[REG_ECHO] & BIT_ECHO) {ttttout_buf[0] = buffer[count];ttttout_buf[1] = 0;ttttgn_atem_string_out((char *)out_buf);ttt}ttt tttCmdBuffer[CurrentCmdBuffer][CurrentCmdBufferIndex++] = buffer[count];tttif (CurrentCmdBufferIndex >= CMD_BUFFER_LENGTH) {ttttCurrentCmdBufferIndex = CMD_BUFFER_LENGTH;ttt}tt}t}}",3,"cwe119,cwe120,cweother"
"_snap_target_percent(void **target_state __attribute__((unused)),ttttpercent_t *percent,ttttstruct dm_pool *mem __attribute__((unused)),ttttstruct cmd_context *cmd __attribute__((unused)),ttttstruct lv_segment *seg __attribute__((unused)),ttttchar *params, uint64_t *total_numerator,ttttuint64_t *total_denominator){tuint64_t total_sectors, sectors_allocated, metadata_sectors;tint r;t tr = sscanf(params, ""%"" PRIu64 ""/%"" PRIu64 "" %"" PRIu64,tt   &sectors_allocated, &total_sectors, &metadata_sectors);tif (r == 2 || r == 3) {tt*total_numerator += sectors_allocated;tt*total_denominator += total_sectors;ttif (r == 3 && sectors_allocated == metadata_sectors)ttt*percent = PERCENT_0;ttelse if (sectors_allocated == total_sectors)ttt*percent = PERCENT_100;ttelsettt*percent = make_percent(*total_numerator, *total_denominator);t}telse if (!strcmp(params, ""Invalid""))tt*percent = PERCENT_INVALID;telse if (!strcmp(params, ""Merge failed""))tt*percent = PERCENT_MERGE_FAILED;telsettreturn 0;treturn 1;}",2,"cwe120,cweother"
"ndmp_enum_to_str (int val, struct ndmp_enum_str_table *table){tstatic chartvbuf[8][32];tstatic inttvbix;tchar *ttvbp;tfor (; table->name; table++)ttif (table->value == val)tttreturn table->name;tvbp = vbuf[vbix&7];tvbix++;tsprintf (vbp, ""?0x%x?"", val);treturn vbp;}",2,"cwe119,cwe120"
"recalloc_sock(struct pool *pool, size_t len){tsize_t old, new;told = strlen(pool->sockbuf);tnew = old + len + 1;tif (new < pool->sockbuf_size)ttreturn;tnew = new + (RBUFSIZE - (new % RBUFSIZE));t t tpool->sockbuf = cgrealloc(pool->sockbuf, new);tmemset(pool->sockbuf + old, 0, new - old);tpool->sockbuf_size = new;}",2,"cwe119,cwe120"
"WritePhonebook(gn_data *data, struct gn_statemachine *state){tunsigned char req[FBUS_FRAME_MAX_LENGTH] = {FBUS_FRAME_HEADER, 0x04};tgn_phonebook_entry *pe;tunsigned char *pos;tint namelen, numlen;tif ((data->phonebook_entry->location < 0) || (data->phonebook_entry->location > 255))ttreturn GN_ERR_INVALIDLOCATION;tpe = data->phonebook_entry;tpos = req+4;tnamelen = strlen(pe->name);tnumlen = strlen(pe->number);tdprintf(""Writing phonebook location (%d/%d): %s"", pe->memory_type, pe->location, pe->name);tif (namelen > GN_PHONEBOOK_NAME_MAX_LENGTH) {ttdprintf(""name too long"");ttreturn GN_ERR_ENTRYTOOLONG;t}tif (numlen > GN_PHONEBOOK_NUMBER_MAX_LENGTH) {ttdprintf(""number too long"");ttreturn GN_ERR_ENTRYTOOLONG;t}tif (pe->subentries_count > 1) {ttdprintf(""61xx doesn't support subentries"");ttreturn GN_ERR_UNKNOWN;t}tif ((pe->subentries_count == 1) && ((pe->subentries[0].entry_type != GN_PHONEBOOK_ENTRY_Number)tt|| ((pe->subentries[0].number_type != GN_PHONEBOOK_NUMBER_General)tt && (pe->subentries[0].number_type != 0)) || (pe->subentries[0].id != 2)tt|| strcmp(pe->subentries[0].data.number, pe->number))) {ttdprintf(""61xx doesn't support subentries"");ttreturn GN_ERR_UNKNOWN;t}t*pos++ = get_memory_type(pe->memory_type);t*pos++ = pe->location;tif (DRVINSTANCE(state)->capabilities & NK6100_CAP_PB_UNICODE)ttnamelen = char_unicode_encode(pos + 1, pe->name, namelen);telsettnamelen = pnok_string_encode(pos + 1, namelen, pe->name);t*pos++ = namelen;tpos += namelen;t*pos++ = numlen;tpnok_string_encode(pos, numlen, pe->number);tpos += numlen;t*pos++ = (pe->caller_group == GN_PHONEBOOK_GROUP_None) ? 0xff : pe->caller_group;tif (sm_message_send(pos-req, 0x03, req, state)) return GN_ERR_NOTREADY;treturn sm_block(0x03, data, state);}",2,"cwe119,cwe120"
"istgt_get_rkey(const char *initiator_name, uint64_t lui){tISTGT_MD5CTX md5ctx;tuint8_t rkeymd5[ISTGT_MD5DIGEST_LEN];tchar buf[MAX_TMPBUF];tuint64_t rkey;tint idx;tint i;tsnprintf(buf, sizeof buf, ""%s,%16.16"" PRIx64,t    initiator_name, lui);tistgt_md5init(&md5ctx);tistgt_md5update(&md5ctx, buf, strlen(buf));tistgt_md5final(rkeymd5, &md5ctx);trkey = 0U;tidx = ISTGT_MD5DIGEST_LEN - 8;tif (idx < 0) {ttISTGT_WARNLOG(""missing MD5 length"");ttidx = 0;t}tfor (i = idx; i < ISTGT_MD5DIGEST_LEN; i++) {ttrkey |= (uint64_t) rkeymd5[i];ttrkey = rkey << 8;t}treturn rkey;}",3,"cwe119,cwe120,cweother"
"swf_svg_define_shape(SWFReader *read, SWFShape *shape, SWFFont *parent_font, Bool last_sub_shape)r{r    u32 i;r    SWFShapeRec *srec;rr    if (parent_font && (read->flags & GF_SM_SWF_NO_FONT)) r    {r        return GF_OK;r    }rr    if (!read->cur_shape) r    {r        fprintf(read->svg_output, ""<defs>"");r        if (!parent_font)r        {r            fprintf(read->svg_output, ""<g id=""S%d"" >"", shape->ID);r        }r        elser        {r            char    szGlyphId[256];r            sprintf(szGlyphId, ""Font%d_Glyph%d"", parent_font->fontID, gf_list_count(parent_font->glyphs));r            fprintf(read->svg_output, ""<g id=""%s"" >"", szGlyphId);r            gf_list_add(parent_font->glyphs, szGlyphId);r        }r    }r    read->cur_shape = (GF_Node *)""shape"";rr    i=0;r    while ((srec = (SWFShapeRec*)gf_list_enum(shape->fill_left, &i))) {r        fprintf(read->svg_output, ""<path d="""");r        swf_svg_print_shape_record_to_path_d(read, srec);r        fprintf(read->svg_output, """" "");r        swg_svg_print_shape_record_to_fill_stroke(read, srec, 1);r        fprintf(read->svg_output, ""/>"");r    }r    i=0;r    while ((srec = (SWFShapeRec*)gf_list_enum(shape->lines, &i))) {r        fprintf(read->svg_output, ""<path d="""");r        swf_svg_print_shape_record_to_path_d(read, srec);r        fprintf(read->svg_output, """" "");r        swg_svg_print_shape_record_to_fill_stroke(read, srec, 0);r        fprintf(read->svg_output, ""/>"");r    }rr    if (last_sub_shape) r    {r        read->cur_shape = NULL;r        fprintf(read->svg_output, ""</g>"");r        fprintf(read->svg_output, ""</defs>"");r    }r    return GF_OK;r}",3,"cwe119,cwe120,cweother"
"fluid_oss_audio_run(void* d){tfluid_oss_audio_driver_t* dev = (fluid_oss_audio_driver_t*) d;tfluid_synth_t* synth = dev->synth;tvoid* buffer = dev->buffer;tint len = dev->buffer_size;t twhile (dev->cont) {ttdev->read (synth, len, buffer, 0, 2, buffer, 1, 2);ttif (write (dev->dspfd, buffer, dev->buffer_byte_size) < 0) {tttFLUID_LOG(FLUID_ERR, ""Error writing to OSS sound device: %s"",ttt          strerror (errno));tttbreak;tt}t}tFLUID_LOG(FLUID_DBG, ""Audio thread finished"");}",2,"cwe120,cweother"
"er_paramutils_tilde_convert (cpl_parameterlist * param_list){cpl_parameter *p = NULL;cpl_type ptype;int f_is_present = 0;tt const char *old_str = NULL;ER_TRACE(__func__)p = cpl_parameterlist_get_first (param_list);while (p != NULL)   {   f_is_present = cpl_parameter_get_default_flag (p);   if (f_is_present)      {      ptype = cpl_parameter_get_type (p);      if (ptype == CPL_TYPE_STRING)         {         old_str = cpl_parameter_get_string (p);         if (*old_str == '~')            {            char  *cpp;            wordexp_t  result;                         if (wordexp(old_str,&result,0) != 0)               {               cpl_msg_error (er_func, ""Expansion of ~ (tilde) failed..."");               return;               }            cpp = *result.we_wordv;tt             if (cpp == NULL)               {               cpl_msg_error (er_func, ""Env. variable HOME not set"");               return;               }            cpl_parameter_set_string (p, cpp);            wordfree(&result);            }         }      }       p = cpl_parameterlist_get_next (param_list);   }ttt }",2,"cwe119,cwe120"
"text_add_str(char const *s, size_t l){    size_t rest = textsize - textpos;    if (rest < l) {tsize_t nsize = 2 * textsize;tchar *newp = realloc(textspace, nsize);tif (!newp)t    memerr(""text_add"");ttextspace = newp;ttextsize = nsize;    }    memcpy(textspace + textpos, s, l);    textpos += l;}",2,"cwe120,cwe469"
"trfs_mkfs(cdico *d, char *partition, char *fsoptions){    char command[2048];    char buffer[2048];    char options[2048];    u64 compat_flags;    u64 incompat_flags;    u64 compat_ro_flags;    int exitst;    u64 temp64;             if (dico_get_u64(d, 0, FSYSHEADKEY_BTRFSFEATURECOMPAT, &compat_flags)!=0 ||        dico_get_u64(d, 0, FSYSHEADKEY_BTRFSFEATUREINCOMPAT, &incompat_flags)!=0 ||        dico_get_u64(d, 0, FSYSHEADKEY_BTRFSFEATUREROCOMPAT, &compat_ro_flags)!=0)    {            compat_flags=0;        incompat_flags=0;        compat_ro_flags=0;    }             if (btrfs_check_compatibility(compat_flags, incompat_flags, compat_ro_flags)!=0)    {   errprintf(""this filesystem has features which are not supported by this fsarchiver version."");        return -1;    }             if (exec_command(command, sizeof(command), NULL, NULL, 0, NULL, 0, ""mkfs.btrfs"")!=0)    {   errprintf(""mkfs.btrfs not found. please install btrfs-progs on your system or check the PATH."");        return -1;    }             memset(options, 0, sizeof(options));    strlcatf(options, sizeof(options), "" %s "", fsoptions);    if (dico_get_string(d, 0, FSYSHEADKEY_FSLABEL, buffer, sizeof(buffer))==0 && strlen(buffer)>0)        strlcatf(options, sizeof(options), "" -L '%s' "", buffer);        if (dico_get_u64(d, 0, FSYSHEADKEY_FSBTRFSSECTORSIZE, &temp64)==0)        strlcatf(options, sizeof(options), "" -s %ld "", (long)temp64);        if (exec_command(command, sizeof(command), &exitst, NULL, 0, NULL, 0, ""mkfs.btrfs -f %s %s"", partition, options)!=0 || exitst!=0)    {   errprintf(""command [%s] failed"", command);        return -1;    }        return 0;}",2,"cwe119,cwe120"
"hts_findfirst(char *path) {  if (path) {    if (strnotempty(path)) {      find_handle_struct *find =        (find_handle_struct *) calloc(1, sizeof(find_handle_struct));      if (find) {        memset(find, 0, sizeof(find_handle_struct));#ifdef _WIN32        {          char BIGSTK rpath[1024 * 2];          strcpybuff(rpath, path);          if (rpath[0]) {            if (rpath[strlen(rpath) - 1] != '')              strcatbuff(rpath, """");          }          strcatbuff(rpath, ""*.*"");          find->handle = FindFirstFileA(rpath, &find->hdata);          if (find->handle != INVALID_HANDLE_VALUE)            return find;        }#else        strcpybuff(find->path, path);        {          if (find->path[0]) {            if (find->path[strlen(find->path) - 1] != '/')              strcatbuff(find->path, ""/"");          }        }        find->hdir = opendir(path);        if (find->hdir != NULL) {          if (hts_findnext(find) == 1)            return find;        }#endif        free((void *) find);      }    }  }  return NULL;}",2,"cwe119,cwe120"
"""convert_nibble(int ch){    if (isdigit(ch))        return (ch - '0');    if (ch >= 'a' && ch <= 'f')        return (ch - 'a' + 10);    if (ch >= 'A' && ch <= 'F')        return (ch - 'A' + 10);    return -1;}""",2,"cwe120,cweother"
"addtable(const netid_t netid, const char *hname, const int isalias){tstruct  hhash  *hp;tunsigned  hhval = calchhash(hname);tunsigned  nhval = calcnhash(netid);tif  (!(hp = (struct hhash *) malloc(sizeof(struct hhash) + (unsigned) strlen(hname))))ttnomem();thp->hh_next = hhashtab[hhval];thhashtab[hhval] = hp;thp->hn_next = nhashtab[nhval];tnhashtab[nhval] = hp;thp->netid = netid;thp->h_isalias = (char) isalias;tstrcpy(hp->h_name, hname);}",3,"cwe120,cwe469,cweother"
"glusterd_gsync_read_frm_status (char *path, char *buf, size_t blen){        int                 ret = 0;        int           status_fd = -1;        GF_ASSERT (path);        GF_ASSERT (buf);        status_fd = open (path, O_RDONLY);        if (status_fd == -1) {                gf_log ("""", GF_LOG_ERROR, ""Unable to read gsyncd status""                        "" file"");                return -1;        }        ret = read (status_fd, buf, blen - 1);        if (ret > 0) {                size_t len = strnlen (buf, ret);                                 if (len == 0 || len == blen - 1) {                        ret = -1;                } else {                        char *p = buf + len - 1;                        while (isspace (*p))                                *p-- = '0';                        ret = 0;                }        } else if (ret < 0)                gf_log ("""", GF_LOG_ERROR, ""Status file of gsyncd is corrupt"");        close (status_fd);        return ret;}",2,"cwe120,cweother"
"ParseCryptoPAnKey ( char *s, char *key ) {int i, j;char numstr[3];uint32_t len = strlen(s);tif ( len < 32  || len > 66 ) {ttfprintf(stderr, ""*** CryptoPAnKey error: size: %u"", len);ttfprintf(stderr, ""*** Need either a plain 32 char string, or a 32 byte hex key starting with 0x.."");ttreturn 0;t}tif ( strlen(s) == 32 ) {tt ttstrncpy(key, s, 32);ttreturn 1;t}ts[1] = tolower(s[1]);tnumstr[2] = 0;tif ( strlen(s) == 66 && s[0] == '0' && s[1] == 'x' ) {ttj = 2;ttfor ( i=0; i<32; i++ ) {tttif ( !isxdigit((int)s[j]) || !isxdigit((int)s[j+1]) )ttttreturn 0;tttnumstr[0] = s[j++];tttnumstr[1] = s[j++];tttkey[i] = strtol(numstr, NULL, 16);tt}ttreturn 1;t} t tfprintf(stderr, ""*** CryptoPAnKey error: size: %u"", len);tfprintf(stderr, ""*** Need either a plain 32 char string, or a 32 byte hex key starting with 0x.."");treturn 0;}",2,"cwe119,cwe120"
"kbseq(int (*getcfunc)(int (*recorder)(int ), void (*bail_handler)(void )),      int (*recorder)(int),      void (*bail_handler)(void),      void *data,      UCS *ch){    unsigned char c;    int      first = 1;    KBESC_T *current;    current = kbesc;    if(current == NULL)tttt       return(BADESC);    while(1){tc = (*getcfunc)(recorder, bail_handler);twhile(current->value != c){t    if(current->left == NULL){tt ttif(first){tt    unsigned long octets_so_far, remaining_octets;tt    unsigned char *inputp;tt    UCS ucs;tt    unsigned char inputbuf[20];tt     tt    memset(inputbuf, 0, sizeof(inputbuf));tt    inputbuf[0] = c;tt    octets_so_far = 1;tt    for(;;){tttremaining_octets = octets_so_far;tttinputp = inputbuf;tttucs = mbtow(data, &inputp, &remaining_octets);tttswitch(ucs){ttt  case CCONV_BADCHAR:ttt     ttt    return(BADESC);ttt  ttt  case CCONV_NEEDMORE:ttt    if(octets_so_far >= sizeof(inputbuf))ttt      return(BADESC);ttt    c = (*getcfunc)(recorder, bail_handler);ttt    inputbuf[octets_so_far++] = c;ttt    break;ttt  default:ttt     ttt    *ch = ucs;ttt    return(0);ttt}tt    }tt     tt    return(0);tt}ttelsett  return(BADESC);t    }t    current = current->left;t}tif(current->down == NULL)tt t  return(current->func);telset  current = current->down;tfirst = 0;    }}",2,"cwe119,cwe120"
"write_update() {  struct pcap_stat statistics;  int have_pcap_statistics;  if (pcap_handle) {    have_pcap_statistics = !pcap_stats(pcap_handle, &statistics);    if (!have_pcap_statistics) {      pcap_perror(pcap_handle, ""Error fetching pcap statistics"");    }  } else {    have_pcap_statistics = 0;  }  dns_table_mark_unanonymized(&dns_table, &flow_table);    printf(""Writing differential log to %s"", PENDING_UPDATE_FILENAME);  gzFile handle = gzopen (PENDING_UPDATE_FILENAME, ""wb"");  if (!handle) {    perror(""Could not open update file for writing"");    exit(1);  }  if (!gzprintf(handle,                ""%d%s"",                FILE_FORMAT_VERSION,                BUILD_ID)) {    perror(""Error writing update"");    exit(1);  }  time_t current_timestamp = time(NULL);  if (!gzprintf(handle,                ""%s %"" PRId64 "" %d %"" PRId64 """",                bismark_id,                start_timestamp_microseconds,                sequence_number,                (int64_t)current_timestamp)) {    perror(""Error writing update"");    exit(1);  }  if (have_pcap_statistics) {    if (!gzprintf(handle,                  ""%u %u %u"",                  statistics.ps_recv,                  statistics.ps_drop,                  statistics.ps_ifdrop)) {      perror(""Error writing update"");      exit(1);    }  }  if (!gzprintf(handle, """")) {    perror(""Error writing update"");    exit(1);  }  if (sequence_number == 0) {    if (domain_whitelist_write_update(&domain_whitelist, handle)) {      exit(1);    }  } else {    if (!gzprintf(handle, """")) {      perror(""Error writing update"");      exit(1);    }  }#ifndef DISABLE_ANONYMIZATION  if (anonymization_write_update(handle)) {    exit(1);  }#else  if (!gzprintf(handle, ""UNANONYMIZED"")) {    perror(""Error writing update"");    exit(1);  }#endif  if (packet_series_write_update(&packet_data, handle)      || flow_table_write_update(&flow_table, handle)      || dns_table_write_update(&dns_table, handle)      || address_table_write_update(&address_table, handle)      || drop_statistics_write_update(&drop_statistics, handle)#ifdef ENABLE_HTTP_URL              || http_table_write_update(&http_table, handle)#endif      ) {    exit(1);  }  gzclose(handle);  char update_filename[FILENAME_MAX];  snprintf(update_filename,           FILENAME_MAX,           UPDATE_FILENAME,           bismark_id,           start_timestamp_microseconds,           sequence_number);  if (rename(PENDING_UPDATE_FILENAME, update_filename)) {    perror(""Could not stage update"");    exit(1);  }  ++sequence_number;  packet_series_init(&packet_data);  flow_table_advance_base_timestamp(&flow_table, current_timestamp);  dns_table_destroy(&dns_table);  dns_table_init(&dns_table, &domain_whitelist);#ifdef ENABLE_HTTP_URL          http_table_destroy(&http_table);  http_table_init(&http_table);#endif  drop_statistics_init(&drop_statistics);}",3,"cwe119,cwe120,cweother"
"fsck_dir(int i, char *path){tDIR *dir = opendir(path);tstruct dirent *de;tchar name[100];tif (!dir)ttreturn;tif (verbose)ttfprintf(stderr, ""Checking directory %s"", path);tsprintf(name, ""%02x"", i);twhile ((de = readdir(dir)) != NULL) {ttunsigned char sha1[20];ttif (is_dot_or_dotdot(de->d_name))tttcontinue;ttif (is_loose_object_file(de, name, sha1)) {tttadd_sha1_list(sha1, DIRENT_SORT_HINT(de));tttcontinue;tt}ttif (!prefixcmp(de->d_name, ""tmp_obj_""))tttcontinue;ttfprintf(stderr, ""bad sha1 file: %s/%s"", path, de->d_name);t}tclosedir(dir);}",2,"cwe119,cwe120"
"decode_color_block(unsigned char *block, unsigned char *src,                               int format){   int i, x, y;   unsigned char *d = block;   unsigned int indexes, idx;   unsigned char colors[4][3];   unsigned short c0, c1;   c0 = GETL16(&src[0]);   c1 = GETL16(&src[2]);   unpack_rgb565(colors[0], c0);   unpack_rgb565(colors[1], c1);   if((c0 > c1) || (format == DDS_COMPRESS_BC3))   {      lerp_rgb13(colors[2], colors[0], colors[1]);      lerp_rgb13(colors[3], colors[1], colors[0]);   }   else   {      for(i = 0; i < 3; ++i)      {         colors[2][i] = (colors[0][i] + colors[1][i] + 1) >> 1;         colors[3][i] = 255;      }   }   src += 4;   for(y = 0; y < 4; ++y)   {      indexes = src[y];      for(x = 0; x < 4; ++x)      {         idx = indexes & 0x03;         d[0] = colors[idx][2];         d[1] = colors[idx][1];         d[2] = colors[idx][0];         if(format == DDS_COMPRESS_BC1)            d[3] = ((c0 <= c1) && idx == 3) ? 0 : 255;         indexes >>= 2;         d += 4;      }   }}",2,"cwe119,cwe120"
"""DGifOpen(void *userData,         InputFunc readFunc) {    unsigned char Buf[GIF_STAMP_LEN + 1];    GifFileType *GifFile;    GifFilePrivateType *Private;    GifFile = (GifFileType *)malloc(sizeof(GifFileType));    if (GifFile == NULL) {        _GifError = D_GIF_ERR_NOT_ENOUGH_MEM;        return NULL;    }    memset(GifFile, '0', sizeof(GifFileType));    Private = (GifFilePrivateType *)malloc(sizeof(GifFilePrivateType));    if (!Private) {        _GifError = D_GIF_ERR_NOT_ENOUGH_MEM;        free((char *)GifFile);        return NULL;    }    GifFile->Private = (VoidPtr)Private;    Private->FileHandle = 0;    Private->File = 0;    Private->FileState = FILE_STATE_READ;    Private->Read = readFunc;    /* TVT */    GifFile->UserData = userData;    /* TVT */    /* Lets see if this is a GIF file: */    if (READ(GifFile, Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {        _GifError = D_GIF_ERR_READ_FAILED;        free((char *)Private);        free((char *)GifFile);        return NULL;    }    /* The GIF Version number is ignored at this time. Maybe we should do     * something more useful with it. */    Buf[GIF_STAMP_LEN] = 0;    if (strncmp(GIF_STAMP, Buf, GIF_VERSION_POS) != 0) {        _GifError = D_GIF_ERR_NOT_GIF_FILE;        free((char *)Private);        free((char *)GifFile);        return NULL;    }    if (DGifGetScreenDesc(GifFile) == GIF_ERROR) {        free((char *)Private);        free((char *)GifFile);        return NULL;    }    _GifError = 0;    return GifFile;}""",3,"cwe119,cwe120,cweother"
"""mmc_get_dvd_struct_physical_private ( void *p_env,                                       mmc_run_cmd_fn_t run_mmc_cmd,                                       cdio_dvd_struct_t *s){  mmc_cdb_t cdb = {{0, }};  unsigned char buf[4 + 4 * 20], *base;  int i_status;  uint8_t layer_num = s->physical.layer_num;    cdio_dvd_layer_t *layer;    if (!p_env) return DRIVER_OP_UNINIT;  if (!run_mmc_cmd) return DRIVER_OP_UNSUPPORTED;  if (layer_num >= CDIO_DVD_MAX_LAYERS)    return -EINVAL;    CDIO_MMC_SET_COMMAND(cdb.field, CDIO_MMC_GPCMD_READ_DVD_STRUCTURE);  cdb.field[6] = layer_num;  cdb.field[7] = CDIO_DVD_STRUCT_PHYSICAL;  cdb.field[9] = sizeof(buf) & 0xff;    i_status = run_mmc_cmd(p_env, mmc_timeout_ms, ttt      mmc_get_cmd_len(cdb.field[0]), ttt      &cdb, SCSI_MMC_DATA_READ, ttt      sizeof(buf), &buf);  if (0 != i_status)    return CDIO_DISC_MODE_ERROR;    base = &buf[4];  layer = &s->physical.layer[layer_num];    /*   * place the data... really ugly, but at least we won't have to   * worry about endianess in userspace.   */  memset(layer, 0, sizeof(*layer));  layer->book_version = base[0] & 0xf;  layer->book_type = base[0] >> 4;  layer->min_rate = base[1] & 0xf;  layer->disc_size = base[1] >> 4;  layer->layer_type = base[2] & 0xf;  layer->track_path = (base[2] >> 4) & 1;  layer->nlayers = (base[2] >> 5) & 3;  layer->track_density = base[3] & 0xf;  layer->linear_density = base[3] >> 4;  layer->start_sector = base[5] << 16 | base[6] << 8 | base[7];  layer->end_sector = base[9] << 16 | base[10] << 8 | base[11];  layer->end_sector_l0 = base[13] << 16 | base[14] << 8 | base[15];  layer->bca = base[16] >> 7;  return DRIVER_OP_SUCCESS;}""",2,"cwe119,cwe120"
"_http_input_stream_content_length_read(http_input_stream_t * stream,                                       byte_t * dest, int size){  herror_t status;  int read;     if (stream->content_length - stream->received < size)    size = stream->content_length - stream->received;     status = hsocket_read(stream->sock, dest, size, 1, &read);  if (status != H_OK)  {    stream->err = status;    return -1;  }  stream->received += read;  return read;}",2,"cwe120,cweother"
"SCR_DrawField (int x, int y, int color, int width, int value, float scale){tchartnum[16], *ptr;tintttl;tintttframe;tif (width < 1)ttreturn;t tif (width > 5)ttwidth = 5;tCom_sprintf (num, sizeof(num), ""%i"", value);tl = strlen(num);tif (l > width)ttl = width;tx += 2 + CHAR_WIDTH*(width - l)*scale;tptr = num;twhile (*ptr && l)t{ttif (*ptr == '-')tttframe = STAT_MINUS;ttelsetttframe = *ptr -'0';ttDraw_ScaledPic (x,y,scale/1.8,sb_nums[color][frame]);ttx += CHAR_WIDTH*scale;ttptr++;ttl--;t}}",2,"cwe119,cwe120"
"initialize_gretldir (char *dirname, gretlopt opt){    char *ghome = getenv(""GRETL_HOME"");    int err = 0;    if (ghome != NULL) {t tstrcpy(paths.gretldir, ghome);tslash_terminate(paths.gretldir);    } else if (dirname != NULL && *dirname != '0' && t       *paths.gretldir == '0') {t tstrcpy(paths.gretldir, dirname);tslash_terminate(paths.gretldir);    }     if (*paths.gretldir == '0') {#ifdef WIN32t tchar *progfiles = program_files_path();tsprintf(paths.gretldir, ""%sgretl"", progfiles);tfree(progfiles);#elset tstrcpy(paths.gretldir, GRETL_PREFIX);tstrcat(paths.gretldir, ""/share/gretl/"");#endif    }#ifndef WIN32    check_gretldir(dirname);#endif    if (!err) {tset_helpfile_paths(opt);tset_gretl_libpath(paths.gretldir);tset_gretl_binbase(paths.gretldir);    }    strcpy(dirname, paths.gretldir);}",2,"cwe120,cweother"
"display_caret(Widget gw, XEvent *event,ttt  String *params, Cardinal *no_params){    TextFieldWidgettw = (TextFieldWidget)gw;    w->textfield.waiting_for_sel = False;    w->textfield.multiply = 1;    if (w->textfield.focus_hack &&        event->type == FocusIn &&        !event->xfocus.send_event)        return;    if (*no_params == 1 && strlen(params[0]) < 15) {        chartbuffer[16];        chart*c;        longti;        c = params[0];        i = 0;        do {            buffer[i++] =                isupper((unsigned char)*c) ? tolower((unsigned char)*c) : *c;        } while (*c++ != '0');        if (strcmp(buffer, ""on"") == 0 ||t    strcmp(buffer, ""true"") == 0) {            w->textfield.display_caret = True;            draw_caret(w);            return;        } else if (strcmp(buffer, ""off"") == 0 ||                   strcmp(buffer, ""false"") == 0) {            undraw_caret(w);            w->textfield.display_caret = False;            return;        }    }    XBell(XtDisplay(w), 0);}",3,"cwe119,cwe120,cwe469"
"include_file(struct master *master, time_t age, struct lookup_context* ctxt, struct dirent *e){tunsigned int logopt = master->logopt;tchar included_path[PATH_MAX + 1];tint included_path_len;tchar *save_name;tint status;tincluded_path_len = snprintf(included_path,tttt     PATH_MAX + 1,tttt     ""%s/%s"",tttt     ctxt->mapname,tttt     e->d_name);tif (included_path_len > PATH_MAX)ttreturn NSS_STATUS_NOTFOUND;tsave_name = master->name;tmaster->name = included_path;tmaster->depth++;tdebug(logopt, MODPREFIX ""include: %s"", master->name);tstatus = lookup_nss_read_master(master, age);tif (!status) {ttwarn(logopt,tt     MODPREFIXtt     ""failed to read included master map %s"",tt     master->name);t}tmaster->depth--;tmaster->name = save_name;treturn NSS_STATUS_SUCCESS;}",2,"cwe119,cwe120"
"postInitPlugin(void) {    char path[500];    const char *dir;    cf_log(llevInfo, ""%s post init"", PLUGIN_VERSION);    dir = cf_get_directory(4);    snprintf(path, 500, ""%s/cflogger.db"", dir);    if (sqlite3_open(path, &logger_database) != SQLITE_OK) {        cf_log(llevError, "" [%s] couldn't connect to logger database!"", PLUGIN_NAME);        sqlite3_close(logger_database);        logger_database = NULL;        return 0;    }    snprintf(path, 500, ""%s/cfnewspaper.db"", dir);    if (sqlite3_open(path, &newspaper_database) != SQLITE_OK) {        cf_log(llevError, "" [%s] unable to open newspaper database!"", PLUGIN_NAME);        sqlite3_close(logger_database);        sqlite3_close(newspaper_database);        logger_database = NULL;        newspaper_database = NULL;        return 0;    }    read_parameters();    return 0;}",2,"cwe119,cwe120"
"ocdumpfile(FILE* file, int datastart){    int i,count,rem,len;    long pos;    char dds[4096];    char hdr[1024];    struct stat stats;    unsigned int imemory;    unsigned int imemory1;    pos = ftell(file);    fseek(file,0,SEEK_SET);    fstat(fileno(file),&stats);    len = stats.st_size;    fprintf(stderr,""length=%d datastart=%d"",len,datastart);    if(datastart > 0) {        fread(dds,1,datastart,file);        dds[datastart] = '0';        fprintf(stderr,""DDS:"");        fprintf(stderr,""===================="");        fprintf(stderr,""%s"",dds);    } else {tfprintf(stderr,""DDS: none specified"");    }    fprintf(stderr,""===================="");         hdr[0] = '0';    dumpmem2(""offset"",hdr,5);    dumpmem2(""hex"",hdr,8);    dumpmem2(""uint"",hdr,12);    dumpmem2(""int"",hdr,12);    dumpmem2(""float"",hdr,12);    dumpmem2(""char[4]"",hdr,16);    dumpmem2(""double"",hdr,12);    strcat(hdr,"""");    fprintf(stderr,""%s"",hdr);    len -= datastart;    count = (len / sizeof(unsigned int));    rem = (len % sizeof(unsigned int));    for(i=0;i<count;i++) {tlong pos;tfread(&imemory,sizeof(unsigned int),1,file);tpos = ftell(file);tfread(&imemory1,sizeof(unsigned int),1,file);tfseek(file,pos,SEEK_SET);timemory = ocntoh(imemory);timemory1 = ocntoh(imemory1);tdumpmem1(i*4+datastart,imemory,imemory1);    }    if(rem > 0) {tfprintf(stderr,"">>>>remainder=%d"",rem);    }    fflush(stderr);    fseek(file,pos,SEEK_SET);  }",3,"cwe119,cwe120,cweother"
"mmaps_setup_common(void **testdata, void *start, int prot , int flags, int fd, off_t offset, int test_flags){    struct testcase *t = malloc(sizeof(*t));    size_t len = pagesize;    size_t real_offset = offset;    if (!(flags & MAP_ANONYMOUS)) {        if (lseek(fd, offset, SEEK_SET) == (off_t)-1) return -1;        write(fd, MSG1, sizeof(MSG1));          if (!(prot & PROT_WRITE)) {t    fchmod(fd, S_IREAD);t    close(fd);t    fd = open(FILENAME, O_RDONLY);t    if (fd < 0) return fd;        }    }    t->test_flags = test_flags;    t->len = len;    t->prot = prot;    t->flags = flags;    t->fd = fd;    t->offset = offset;    if ((flags & MAP_SHARED) && offset) {tlen += offset;treal_offset = 0;    }    t->addr = mmap(start, len, prot, flags, fd, real_offset);    CRUT_DEBUG(""mmap(%p, %d, 0x%x, 0x%x, %d, %d) -> %p (%d)"", start, (int)len, prot, flags, fd, (int)real_offset, t->addr, errno);    if (t->addr == MAP_FAILED) return -1;    if (flags & MAP_SHARED) {t(void)signal(SIGPIPE, &sigpipe);tif (offset) {t    munmap(t->addr, offset);t    t->addr += offset;t}tif (!crut_pipes_fork(&t->checker)) {t     t    checker_child(t);t    exit(-1);  t} else {t     t    crut_pipes_expect(&t->checker, MSG_CHILD_READY);t    CRUT_DEBUG(""Child ready"");t}    }    if (flags & MAP_ANONYMOUS) {tstrcpy(t->addr, MSG1);    }    *testdata = t;    return 0;}",2,"cwe120,cweother"
"print_attribute_header( int discrete_atts_header_p, int real_atts_header_p,                             FILE *influence_report_fp, shortstr report_mode,                             unsigned int comment_data_headers_p){  if (discrete_atts_header_p) {    fprintf( influence_report_fp,            ""%s%sDISCRETE ATTRIBUTE  (t = D)                                  ""             ""   log("", (comment_data_headers_p == TRUE) ? ""#"" : """",             (comment_data_headers_p == TRUE) ? ""#"" : """");    fprintf( influence_report_fp,            ""%s numb  t mtt  description           I-jk   Value name/Index  ""            ""   Prob-jkl/     Prob      Prob"",             (comment_data_headers_p == TRUE) ? ""#"" : """");    fprintf( influence_report_fp,             ""%s t   a                                                       ""            ""   Prob-*kl)     -jkl      -*kl"",             (comment_data_headers_p == TRUE) ? ""#"" : """");  }  if (real_atts_header_p) {              fprintf( influence_report_fp,            ""%s%sREAL ATTRIBUTE  (t = R)                                      ""             ""  |Mean-jk -"", (comment_data_headers_p == TRUE) ? ""#"" : """",             (comment_data_headers_p == TRUE) ? ""#"" : """");    fprintf( influence_report_fp,             ""%s numb  t mtt  description           I-jk      Mean     StDev ""            ""   Mean-*k|/     Mean      StDev"",             (comment_data_headers_p == TRUE) ? ""#"" : """");    fprintf( influence_report_fp,             ""%s t   a                                        -jk      -jk   ""            ""    StDev-jk     -*k       -*k%s"",             (comment_data_headers_p == TRUE) ? ""#"" : """",             (comment_data_headers_p == TRUE) ? ""#"" : """");  }  else    fprintf( influence_report_fp, ""%s"", (comment_data_headers_p == TRUE) ? ""#"" : """");}",3,"cwe119,cwe120,cweother"
"k5_try_realm_txt_rr(krb5_context context, const char *prefix, const char *name,                    char **realm){    krb5_error_code retval = KRB5_ERR_HOST_REALM_UNKNOWN;    const unsigned char *p, *base;    char host[MAXDNAME];    int ret, rdlen, len;    struct krb5int_dns_state *ds = NULL;    struct k5buf buf;         k5_buf_init_fixed(&buf, host, sizeof(host));    if (name == NULL || name[0] == '0') {        k5_buf_add(&buf, prefix);    } else {        k5_buf_add_fmt(&buf, ""%s.%s"", prefix, name);                 len = k5_buf_len(&buf);        if (len > 0 && host[len - 1] != '.')            k5_buf_add(&buf, ""."");    }    if (k5_buf_data(&buf) == NULL)        return KRB5_ERR_HOST_REALM_UNKNOWN;    ret = krb5int_dns_init(&ds, host, C_IN, T_TXT);    if (ret < 0) {        TRACE_TXT_LOOKUP_NOTFOUND(context, host);        goto errout;    }    ret = krb5int_dns_nextans(ds, &base, &rdlen);    if (ret < 0 || base == NULL)        goto errout;    p = base;    if (!INCR_OK(base, rdlen, p, 1))        goto errout;    len = *p++;    *realm = malloc((size_t)len + 1);    if (*realm == NULL) {        retval = ENOMEM;        goto errout;    }    strncpy(*realm, (const char *)p, (size_t)len);    (*realm)[len] = '0';         if ( (*realm)[len-1] == '.' )        (*realm)[len-1] = '0';    retval = 0;    TRACE_TXT_LOOKUP_SUCCESS(context, host, *realm);errout:    if (ds != NULL) {        krb5int_dns_fini(ds);        ds = NULL;    }    return retval;}",2,"cwe119,cwe120"
"ftio_write(struct ftio *ftio, void *data){  int ret, n, nbytes;  ret = -1;  nbytes = 0;   if (!(ftio->flags & FT_IO_FLAG_NO_SWAP)) {#if BYTE_ORDER == BIG_ENDIAN    if (ftio->fth.byte_order == FT_HEADER_LITTLE_ENDIAN)      ftio->swapf((void*)data);#endif  #if BYTE_ORDER == LITTLE_ENDIAN    if (ftio->fth.byte_order == FT_HEADER_BIG_ENDIAN)      ftio->swapf((void*)data);#endif    }     if (ftio->fth.flags & FT_HEADER_FLAG_COMPRESS) {    ftio->zs.next_in = (Bytef*)data;    ftio->zs.avail_in = ftio->rec_size;    while (1) {      if (deflate(&ftio->zs, Z_NO_FLUSH) != Z_OK) {        fterr_warnx(""deflate(): failed"");        goto ftio_write_out;      }             if (!ftio->zs.avail_out) {        n = writen(ftio->fd, ftio->z_buf, FT_Z_BUFSIZE);        if (n < 0) {          fterr_warn(""writen()"");          goto ftio_write_out;        }        if (n == 0) {          fterr_warnx(""writen(): EOF"");          goto ftio_write_out;        }        ftio->zs.next_out = (Bytef*)ftio->z_buf;        ftio->zs.avail_out = FT_Z_BUFSIZE;        nbytes += n;        ret = 0;        } else {        ret = 0;          break;      }    }       } else {         if ((ftio->d_start + ftio->rec_size) > ftio->d_end) {      n = writen(ftio->fd, ftio->d_buf, ftio->d_start);      if (n < 0) {        fterr_warn(""writen()"");        goto ftio_write_out;      }      if (n == 0) {        fterr_warnx(""writen(): EOF"");        goto ftio_write_out;      }      ftio->d_start = 0;      nbytes += n;    }    bcopy(data, ftio->d_buf+ftio->d_start, ftio->rec_size);    ftio->d_start += ftio->rec_size;    ret = 0;    }ftio_write_out:  if (!(ftio->flags & FT_IO_FLAG_NO_SWAP)) {#if BYTE_ORDER == BIG_ENDIAN    if (ftio->fth.byte_order == FT_HEADER_LITTLE_ENDIAN)      ftio->swapf((void*)data);#endif  #if BYTE_ORDER == LITTLE_ENDIAN    if (ftio->fth.byte_order == FT_HEADER_BIG_ENDIAN)      ftio->swapf((void*)data);#endif    }  if (ret < 0)    return ret;  else    return nbytes;}",2,"cwe120,cweother"
"ssh_scp_push_file64(ssh_scp scp, const char *filename, uint64_t size, int mode){  char buffer[1024];  int r;  uint8_t code;  char *file;  char *perms;  if(scp==NULL)      return SSH_ERROR;  if(scp->state != SSH_SCP_WRITE_INITED){    ssh_set_error(scp->session,SSH_FATAL,""ssh_scp_push_file called under invalid state"");    return SSH_ERROR;  }  file=ssh_basename(filename);  perms=ssh_scp_string_mode(mode);  SSH_LOG(SSH_LOG_PROTOCOL,""SCP pushing file %s, size %"" PRIu64 "" with permissions '%s'"",file,size,perms);  snprintf(buffer, sizeof(buffer), ""C%s %"" PRIu64 "" %s"", perms, size, file);  SAFE_FREE(file);  SAFE_FREE(perms);  r=ssh_channel_write(scp->channel,buffer,strlen(buffer));  if(r==SSH_ERROR){    scp->state=SSH_SCP_ERROR;    return SSH_ERROR;  }  r=ssh_channel_read(scp->channel,&code,1,0);  if(r<=0){    ssh_set_error(scp->session,SSH_FATAL, ""Error reading status code: %s"",ssh_get_error(scp->session));    scp->state=SSH_SCP_ERROR;    return SSH_ERROR;  }  if(code != 0){    ssh_set_error(scp->session,SSH_FATAL, ""scp status code %ud not valid"", code);    scp->state=SSH_SCP_ERROR;    return SSH_ERROR;  }  scp->filelen = size;  scp->processed = 0;  scp->state=SSH_SCP_WRITE_WRITING;  return SSH_OK;}",2,"cwe119,cwe120"
"BlurImageScanlines(Image *image,const double *kernel,                                         const unsigned long width,                                         const char *format,                                         ExceptionInfo *exception){  ThreadViewDataSet    *data_set;  MagickBool    is_grayscale;  MagickPassFail    status=MagickPass;  const MagickBool    matte=((image->matte) || (image->colorspace == CMYKColorspace));  is_grayscale=image->is_grayscale;  data_set=AllocateThreadViewDataArray(image,exception,image->columns,sizeof(PixelPacket));  if (data_set == (ThreadViewDataSet *) NULL)    status=MagickFail;  if (status != MagickFail)    {      unsigned long        row_count=0;      long        y;#if defined(HAVE_OPENMP)#  if defined(TUNE_OPENMP)#    pragma omp parallel for schedule(runtime) shared(row_count, status)#  else#    pragma omp parallel for schedule(static,4) shared(row_count, status)#  endif#endif      for (y=0; y < (long) image->rows; y++)        {          register PixelPacket            *q;          PixelPacket            *scanline;          MagickBool            thread_status;#if defined(HAVE_OPENMP)#  pragma omp critical (GM_BlurImageScanlines)#endif          thread_status=status;          if (thread_status == MagickFail)            continue;            scanline=AccessThreadViewData(data_set);          q=GetImagePixelsEx(image,0,y,image->columns,1,exception);          if (q == (PixelPacket *) NULL)            thread_status=MagickFail;          if (thread_status != MagickFail)            {              unsigned long                i=0;              scanline[i]=q[i];              i++;              for ( ; i < image->columns; i++)                {tt  if (NotPixelMatch(&scanline[i-1],&q[i],matte))                    break;                  scanline[i]=q[i];                }              if (i != image->columns)                {                  (void) memcpy(&scanline[i],&q[i],tttt(image->columns-i)*sizeof(PixelPacket));                  BlurScanline(kernel,width,scanline,q,image->columns,matte);                  if (!SyncImagePixelsEx(image,exception))                    thread_status=MagickFail;                }            }#if defined(HAVE_OPENMP)#  pragma omp critical (GM_BlurImageScanlines)#endif          {            row_count++;            if (QuantumTick(row_count,image->rows))              if (!MagickMonitorFormatted(row_count,image->rows,exception,                                          format,image->filename,width))                thread_status=MagickFail;                      if (thread_status == MagickFail)              status=MagickFail;          }        }    }  DestroyThreadViewDataSet(data_set);  image->is_grayscale=is_grayscale;  return status;}",2,"cwe120,cweother"
"morus_tag_verification(unsigned long long msglen, unsigned long long adlen, const unsigned char *c, __m128i *state)r{rtint i;rtunsigned char t[16]; rt__m128i  tmp; rtint check = 0; rrt_mm_store_si128((__m128i*)t, state[3]);rrt((uint64_t*)t)[0] ^= (adlen << 3);rt((uint64_t*)t)[1] ^= (msglen << 3);rrtstate[4] = XOR(state[4], state[0]);rrttmp = _mm_load_si128((__m128i*)t); rrtfor (i = 0; i < 8; i++) morus_stateupdate(tmp, state);  rrtfor (i = 2; i < 5; i++) state[1] = XOR(state[1], state[i]);  rrt_mm_store_si128((__m128i*)t, state[1]);rt tfor (i = 0; i  < 16; i++) check |= (c[msglen+i] ^ t[i]);rtif (0 == check) return 0; else return -1; r}",2,"cwe119,cwe120"
"mlxsw_sx_flood_init(struct mlxsw_sx *mlxsw_sx){tchar sfgc_pl[MLXSW_REG_SFGC_LEN];tchar sgcr_pl[MLXSW_REG_SGCR_LEN];tchar *sftr_pl;tint err;t tsftr_pl = kmalloc(MLXSW_REG_SFTR_LEN, GFP_KERNEL);tif (!sftr_pl)ttreturn -ENOMEM;tmlxsw_reg_sftr_pack(sftr_pl, 0, 0, MLXSW_REG_SFGC_TABLE_TYPE_SINGLE, 0,ttt    MLXSW_PORT_CPU_PORT, true);terr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sftr), sftr_pl);tkfree(sftr_pl);tif (err)ttreturn err;t tmlxsw_reg_sfgc_pack(sfgc_pl,ttt    MLXSW_REG_SFGC_TYPE_UNKNOWN_UNICAST,ttt    MLXSW_REG_SFGC_BRIDGE_TYPE_1Q_FID,ttt    MLXSW_REG_SFGC_TABLE_TYPE_SINGLE,ttt    0);terr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sfgc), sfgc_pl);tif (err)ttreturn err;tmlxsw_reg_sfgc_pack(sfgc_pl,ttt    MLXSW_REG_SFGC_TYPE_BROADCAST,ttt    MLXSW_REG_SFGC_BRIDGE_TYPE_1Q_FID,ttt    MLXSW_REG_SFGC_TABLE_TYPE_SINGLE,ttt    0);terr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sfgc), sfgc_pl);tif (err)ttreturn err;tmlxsw_reg_sfgc_pack(sfgc_pl,ttt    MLXSW_REG_SFGC_TYPE_UNREGISTERED_MULTICAST_NON_IP,ttt    MLXSW_REG_SFGC_BRIDGE_TYPE_1Q_FID,ttt    MLXSW_REG_SFGC_TABLE_TYPE_SINGLE,ttt    0);terr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sfgc), sfgc_pl);tif (err)ttreturn err;tmlxsw_reg_sfgc_pack(sfgc_pl,ttt    MLXSW_REG_SFGC_TYPE_UNREGISTERED_MULTICAST_IPV6,ttt    MLXSW_REG_SFGC_BRIDGE_TYPE_1Q_FID,ttt    MLXSW_REG_SFGC_TABLE_TYPE_SINGLE,ttt    0);terr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sfgc), sfgc_pl);tif (err)ttreturn err;tmlxsw_reg_sfgc_pack(sfgc_pl,ttt    MLXSW_REG_SFGC_TYPE_UNREGISTERED_MULTICAST_IPV4,ttt    MLXSW_REG_SFGC_BRIDGE_TYPE_1Q_FID,ttt    MLXSW_REG_SFGC_TABLE_TYPE_SINGLE,ttt    0);terr = mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sfgc), sfgc_pl);tif (err)ttreturn err;tmlxsw_reg_sgcr_pack(sgcr_pl, true);treturn mlxsw_reg_write(mlxsw_sx->core, MLXSW_REG(sgcr), sgcr_pl);}",2,"cwe119,cwe120"
"vpc_open(BlockDriverState *bs, const char *filename, int flags){    BDRVVPCState *s = bs->opaque;    int fd, i;    struct vpc_subheader header;    fd = open(filename, O_RDONLY | O_BINARY);    if (fd < 0)        return -1;    bs->read_only = 1;      s->fd = fd;    if (read(fd, &header, HEADER_SIZE) != HEADER_SIZE)        goto fail;    if (strncmp(header.magic, ""conectix"", 8))        goto fail;    lseek(s->fd, be32_to_cpu(header.type.main.subheader_offset), SEEK_SET);    if (read(fd, &header, HEADER_SIZE) != HEADER_SIZE)        goto fail;    if (strncmp(header.magic, ""cxsparse"", 8))tgoto fail;    bs->total_sectors = ((uint64_t)be32_to_cpu(header.type.sparse.pagetable_entries) *tttbe32_to_cpu(header.type.sparse.pageentry_size)) / 512;    lseek(s->fd, be32_to_cpu(header.type.sparse.pagetable_offset), SEEK_SET);    s->pagetable_entries = be32_to_cpu(header.type.sparse.pagetable_entries);    s->pagetable = qemu_malloc(s->pagetable_entries * 4);    if (!s->pagetable)tgoto fail;    if (read(s->fd, s->pagetable, s->pagetable_entries * 4) !=ts->pagetable_entries * 4)tgoto fail;    for (i = 0; i < s->pagetable_entries; i++)tbe32_to_cpus(&s->pagetable[i]);    s->pageentry_size = be32_to_cpu(header.type.sparse.pageentry_size);#ifdef CACHE    s->pageentry_u8 = qemu_malloc(512);    if (!s->pageentry_u8)tgoto fail;    s->pageentry_u32 = s->pageentry_u8;    s->pageentry_u16 = s->pageentry_u8;    s->last_pagetable = -1;#endif    return 0; fail:    close(fd);    return -1;}",2,"cwe120,cweother"
"show_transfer (gftp_transfer * tdata){  GdkPixmap * closedir_pixmap, * opendir_pixmap;  GdkBitmap * closedir_bitmap, * opendir_bitmap;  gftpui_common_curtrans_data * transdata;  gftp_file * tempfle;  GList * templist;  char *text[2];  gftp_get_pixmap (dlwdw, ""open_dir.xpm"", &opendir_pixmap, &opendir_bitmap);  gftp_get_pixmap (dlwdw, ""dir.xpm"", &closedir_pixmap, &closedir_bitmap);  text[0] = tdata->fromreq->hostname;  text[1] = _(""Waiting..."");  tdata->user_data = gtk_ctree_insert_node (GTK_CTREE (dlwdw), NULL, NULL,                                        text, 5,                                       closedir_pixmap, closedir_bitmap,                                        opendir_pixmap, opendir_bitmap,                                        FALSE,                                        tdata->numdirs + tdata->numfiles < 50);  transdata = g_malloc0 (sizeof (*transdata));  transdata->transfer = tdata;  transdata->curfle = NULL;  gtk_ctree_node_set_row_data (GTK_CTREE (dlwdw), tdata->user_data, transdata);  tdata->show = 0;  tdata->curfle = tdata->updfle = tdata->files;  tdata->total_bytes = 0;  for (templist = tdata->files; templist != NULL; templist = templist->next)    {      tempfle = templist->data;      text[0] = gftpui_gtk_get_utf8_file_pos (tempfle);      if (tempfle->transfer_action == GFTP_TRANS_ACTION_SKIP)        text[1] = _(""Skipped"");      else        {          tdata->total_bytes += tempfle->size;          text[1] = _(""Waiting..."");        }      tempfle->user_data = gtk_ctree_insert_node (GTK_CTREE (dlwdw),                                              tdata->user_data,                                              NULL, text, 5, NULL, NULL, NULL,                                              NULL, FALSE, FALSE);      transdata = g_malloc0 (sizeof (*transdata));      transdata->transfer = tdata;      transdata->curfle = templist;      gtk_ctree_node_set_row_data (GTK_CTREE (dlwdw), tempfle->user_data,                                    transdata);    }  if (!tdata->toreq->stopable && gftp_need_password (tdata->toreq))    {      tdata->toreq->stopable = 1;      MakeEditDialog (_(""Enter Password""),tt      _(""Please enter your password for this site""), NULL, 0,tt      NULL, gftp_dialog_button_connect,                       get_trans_password, tdata->toreq,tt      cancel_get_trans_password, tdata);    }  if (!tdata->fromreq->stopable && gftp_need_password (tdata->fromreq))    {      tdata->fromreq->stopable = 1;      MakeEditDialog (_(""Enter Password""),tt      _(""Please enter your password for this site""), NULL, 0,tt      NULL, gftp_dialog_button_connect,                       get_trans_password, tdata->fromreq,tt      cancel_get_trans_password, tdata);    }}",2,"cwe119,cwe120"
"play_message_callerid(struct ast_channel *chan, struct vm_state *vms, char *cid, const char *context, int callback, int saycidnumber){tint res = 0;tint i;tchar *callerid, *name;tchar prefile[PATH_MAX] = """";t tif ((cid == NULL)||(context == NULL))ttreturn res;t tast_debug(1, ""VM-CID: composite caller ID received: %s, context: %s"", cid, context);tast_callerid_parse(cid, &name, &callerid);tif ((!ast_strlen_zero(callerid)) && strcmp(callerid, ""Unknown"")) {tt tt ttfor (i = 0 ; i < MAX_NUM_CID_CONTEXTS ; i++){tttast_debug(1, ""VM-CID: comparing internalcontext: %s"", cidinternalcontexts[i]);tttif ((strcmp(cidinternalcontexts[i], context) == 0))ttttbreak;tt}ttif (i != MAX_NUM_CID_CONTEXTS){  tttif (!res) {ttttsnprintf(prefile, sizeof(prefile), ""%s%s/%s/greet"", VM_SPOOL_DIR, context, callerid);ttttif (!ast_strlen_zero(prefile)) {ttttt tttttif (ast_fileexists(prefile, NULL, NULL) > 0) {ttttttast_verb(3, ""Playing envelope info: CID number '%s' matches mailbox number, playing recorded name"", callerid);ttttttif (!callback)tttttttres = wait_file2(chan, vms, ""vm-from"");ttttttres = ast_stream_and_wait(chan, prefile, """");ttttt} else {ttttttast_verb(3, ""Playing envelope info: message from '%s'"", callerid);tttttt ttttttif (!callback)tttttttres = wait_file2(chan, vms, ""vm-from-extension"");ttttttres = ast_say_digit_str(chan, callerid, """", ast_channel_language(chan));ttttt}tttt}ttt}tt} else if (!res) {tttast_debug(1, ""VM-CID: Numeric caller id: (%s)"", callerid);ttt tttif (!callback) {tttt ttttsnprintf(prefile, sizeof(prefile), ""%s/recordings/callerids/%s"", ast_config_AST_SPOOL_DIR, callerid);ttttif (!saycidnumber && ast_fileexists(prefile, NULL, NULL) > 0) {tttttast_verb(3, ""Playing recorded name for CID number '%s' - '%s'"", callerid,prefile);tttttwait_file2(chan, vms, ""vm-from"");tttttres = ast_stream_and_wait(chan, prefile, """");tttttast_verb(3, ""Played recorded name result '%d'"", res);tttt} else {ttttt tttttwait_file2(chan, vms, ""vm-from-phonenumber"");tttttres = ast_say_digit_str(chan, callerid, AST_DIGIT_ANY, ast_channel_language(chan));tttt}ttt} else {ttttres = ast_say_digit_str(chan, callerid, AST_DIGIT_ANY, ast_channel_language(chan));ttt}tt}t} else {tt ttast_debug(1, ""VM-CID: From an unknown number"");tt ttres = wait_file2(chan, vms, ""vm-unknown-caller"");t}treturn res;}",2,"cwe119,cwe120"
"uwb_rc_mac_addr_setup(struct uwb_rc *rc){tint result;tstruct device *dev = &rc->uwb_dev.dev;tstruct uwb_dev *uwb_dev = &rc->uwb_dev;tchar devname[UWB_ADDR_STRSIZE];tstruct uwb_mac_addr addr;tresult = uwb_rc_mac_addr_get(rc, &addr);tif (result < 0) {ttdev_err(dev, ""cannot retrieve UWB EUI-48 address: %d"", result);ttreturn result;t}tif (uwb_mac_addr_unset(&addr) || uwb_mac_addr_bcast(&addr)) {ttaddr.data[0] = 0x02;  ttget_random_bytes(&addr.data[1], sizeof(addr.data)-1);ttresult = uwb_rc_mac_addr_set(rc, &addr);ttif (result < 0) {tttuwb_mac_addr_print(devname, sizeof(devname), &addr);tttdev_err(dev, ""cannot set EUI-48 address %s: %d"",ttttdevname, result);tttreturn result;tt}t}tuwb_dev->mac_addr = addr;treturn 0;}",2,"cwe119,cwe120"
"usage(void){tconst char *env;tconst char *user;#ifndef WIN32tstruct passwd *pw = NULL;#endift tuser = getenv(""PGUSER"");tif (!user)t{#if !defined(WIN32) && !defined(__OS2__)ttpw = getpwuid(geteuid());ttif (pw)tttuser = pw->pw_name;ttelsett{tttpsql_error(""could not get current user name: %s"", strerror(errno));tttexit(EXIT_FAILURE);tt}#elsettttttt ttcharttbuf[128];ttDWORDttbufsize = sizeof(buf) - 1;ttif (GetUserName(buf, &bufsize))tttuser = buf;#endif    t} tprintf(_(""This is psql %s, the PostgreSQL interactive terminal.""),tt   PG_VERSION);tputs(_(""Usage:""));tputs(_(""  psql [OPTIONS]... [DBNAME [USERNAME]]""));tputs(_(""General options:""));t tenv = getenv(""PGDATABASE"");tif (!env)ttenv = user;tprintf(_(""  -d DBNAME       specify database name to connect to (default: ""%s"")""), env);tputs(_(""  -c COMMAND      run only single command (SQL or internal) and exit""));tputs(_(""  -f FILENAME     execute commands from file, then exit""));tputs(_(""  -1 (""one"")      execute command file as a single transaction""));tputs(_(""  -l              list available databases, then exit""));tputs(_(""  -v NAME=VALUE   set psql variable NAME to VALUE""));tputs(_(""  -X              do not read startup file (~/.psqlrc)""));tputs(_(""  --help          show this help, then exit""));tputs(_(""  --version       output version information, then exit""));tputs(_(""Input and output options:""));tputs(_(""  -a              echo all input from script""));tputs(_(""  -e              echo commands sent to server""));tputs(_(""  -E              display queries that internal commands generate""));tputs(_(""  -q              run quietly (no messages, only query output)""));tputs(_(""  -o FILENAME     send query results to file (or |pipe)""));tputs(_(""  -n              disable enhanced command line editing (readline)""));tputs(_(""  -s              single-step mode (confirm each query)""));tputs(_(""  -S              single-line mode (end of line terminates SQL command)""));tputs(_(""  -L FILENAME     send session log to file""));tputs(_(""Output format options:""));tputs(_(""  -A              unaligned table output mode (-P format=unaligned)""));tputs(_(""  -H              HTML table output mode (-P format=html)""));tputs(_(""  -t              print rows only (-P tuples_only)""));tputs(_(""  -T TEXT         set HTML table tag attributes (width, border) (-P tableattr=)""));tputs(_(""  -x              turn on expanded table output (-P expanded)""));tputs(_(""  -P VAR[=ARG]    set printing option VAR to ARG (see pset command)""));tprintf(_(""  -F STRING       set field separator (default: ""%s"") (-P fieldsep=)""),tt   DEFAULT_FIELD_SEP);tputs(_(""  -R STRING       set record separator (default: newline) (-P recordsep=)""));tputs(_(""Connection options:""));t tenv = getenv(""PGHOST"");tprintf(_(""  -h HOSTNAME     database server host or socket directory (default: ""%s"")""),tt   env ? env : _(""local socket""));t tenv = getenv(""PGPORT"");tprintf(_(""  -p PORT         database server port (default: ""%s"")""),tt   env ? env : DEF_PGPORT_STR);t tenv = getenv(""PGUSER"");tif (!env)ttenv = user;tprintf(_(""  -U NAME         database user name (default: ""%s"")""), env);tputs(_(""  -W              force password prompt (should happen automatically)""));tputs(_(tt   ""For more information, type ""?"" (for internal commands) or ""help""""t  ""(for SQL commands) from within psql, or consult the psql section in""tt   ""the PostgreSQL documentation.""tt   ""Report bugs to <pgsql-bugs@postgresql.org>.""));}",3,"cwe119,cwe120,cweother"
"tiles_load_default() {  char crap[30];  char crap1[10];  int h;  log_info(""loading tilescreens..."");  for (h = 1; h <= GFX_TILES_NB_SETS; h++)    {      if (h < 10)tstrcpy(crap1,""0"");      elsetstrcpy(crap1, """");            sprintf(crap, ""tiles/Ts%s%d.BMP"", crap1, h);      tiles_load_slot(crap, h);      if (gfx_tiles[h] == NULL)texit(0);    }    log_info(""Done with tilescreens..."");}",2,"cwe119,cwe120"
"display_statfs_nodes(const char *path, const char *domain){tgfarm_error_t e;tint nhosts, i;tstruct gfarm_host_sched_info *hosts;tgfarm_uint64_t used, avail;tgfarm_uint64_t total_used = 0, total_avail = 0;tchar capbuf[GFARM_INT64STRLEN];tchar usedbuf[GFARM_INT64STRLEN];tchar availbuf[GFARM_INT64STRLEN];te = schedule_host_domain(path, domain, &nhosts, &hosts);tif (e != GFARM_ERR_NO_ERROR)ttreturn (e);tprintf(formatter->nodes_title_format,t       ""1K-blocks"", ""Used"", ""Avail"", ""Use%"", ""Host"");tfor (i = 0; i < nhosts; ++i) {ttused = hosts[i].disk_used;ttavail = hosts[i].disk_avail;tt(*formatter->blocks_to_string)(capbuf, sizeof capbuf,tt    (unsigned long long)used + avail);tt(*formatter->blocks_to_string)(usedbuf, sizeof usedbuf,tt    (unsigned long long)used);tt(*formatter->blocks_to_string)(availbuf, sizeof availbuf,tt    (unsigned long long)avail);ttprintf(formatter->nodes_data_format,tt       capbuf, usedbuf, availbuf,tt       (double)used / (used + avail) * 100,tt       hosts[i].host);tttotal_used += used;tttotal_avail += avail;t}tif (nhosts > 0) {ttputs(formatter->nodes_separator);tt(*formatter->blocks_to_string)(capbuf, sizeof capbuf,tt    (unsigned long long)total_used + total_avail);tt(*formatter->blocks_to_string)(usedbuf, sizeof usedbuf,tt    (unsigned long long)total_used);tt(*formatter->blocks_to_string)(availbuf, sizeof availbuf,tt    (unsigned long long)total_avail);ttprintf(formatter->nodes_data_format,tt       capbuf, usedbuf, availbuf,tt       (double)total_used / (total_used + total_avail) * 100,tt       """");t}telsettputs(""No file system node"");tgfarm_host_sched_info_free(nhosts, hosts); treturn (GFARM_ERR_NO_ERROR);}",3,"cwe119,cwe120,cweother"
"add_logytics( FL_OBJECT * ob ){    FLI_XYPLOT_SPEC *sp = ob->spec;    float yw;    int yr,        ticl = 6,        i;    char label[ 80 ];    if ( sp->ytic <= 0 )        return;    for ( i = 0; i < sp->num_yminor; i++ )    {        yr = sp->ytic_minor[ i ];        fl_line( sp->xi, yr, sp->xi - ticl / 2, yr, ob->col2 );    }    for ( i = 0; i < sp->num_ymajor; i++ )    {        yr = sp->ytic_major[ i ];        fl_line( sp->xi - ticl, yr, sp->xi, yr, ob->col2 );        yw = sp->ymajor_val[ i ];        if ( sp->ybase == 10.0 )        {            sprintf( label, ""%g"", pow( sp->ybase, yw ) );            fl_drw_text( FL_ALIGN_RIGHT, sp->xi - ticl + 2, yr,                         0, 0, ob->col2, sp->lstyle, sp->lsize, label );        }        else        {            int len,                ll;            ll = sprintf( label, ""%d"", ( int ) ceil( yw ) );            fl_drw_text( FL_ALIGN_RIGHT, sp->xi - ticl + 2, yr - 3,                         0, 0, ob->col2, sp->lstyle, sp->lsize, label );            len = fl_get_string_width( sp->lstyle, sp->lsize, label, ll );            sprintf( label, ""%g"", sp->ybase );            fl_drw_text( FL_ALIGN_RIGHT, sp->xi - ticl + 2 - len - 1,                         yr + 1, 0, 0, ob->col2, sp->lstyle, sp->lsize, label );        }    }}",2,"cwe119,cwe120"
"sgf_write_header_reduced(SGFNode *root, int overwrite){  time_t curtime = time(NULL);  struct tm *loctime = localtime(&curtime);  char str[128];  int dummy;  gg_snprintf(str, 128, ""%4.4i-%2.2i-%2.2i"",t      loctime->tm_year+1900, loctime->tm_mon+1, loctime->tm_mday);  if (overwrite || !sgfGetIntProperty(root, ""DT"", &dummy))    sgfOverwriteProperty(root, ""DT"", str);  if (overwrite || !sgfGetIntProperty(root, ""AP"", &dummy))    sgfOverwriteProperty(root, ""AP"", ""GNU Go:""VERSION);  sgfOverwriteProperty(root, ""FF"", ""4"");}",2,"cwe119,cwe120"
"_profiles_list_fill(Evas_Object *l_widget,                    Eina_List   *p_names){   const char *cur_profile = NULL;   const char *profile;   void *sel_it = NULL;   Eina_List *l;   if (!p_names)     return;   elm_list_clear(l_widget);   cur_profile = elm_config_profile_get();   EINA_LIST_FOREACH(p_names, l, profile)     {#ifdef ELM_EFREET        Efreet_Desktop *desk = NULL;#endif        const char *label, *ext, *pdir;        char buf[PATH_MAX];        Elm_Object_Item *list_it;        Evas_Object *ic;        pdir = elm_config_profile_dir_get(profile, EINA_TRUE);        if (!pdir) pdir = elm_config_profile_dir_get(profile, EINA_FALSE);        label = profile;#ifdef ELM_EFREET        snprintf(buf, sizeof(buf), ""%s/profile.desktop"", pdir);        desk = efreet_desktop_new(buf);        if ((desk) && (desk->name)) label = desk->name;        else          {             if (desk) efreet_desktop_free(desk);             pdir = elm_config_profile_dir_get(profile, EINA_FALSE);             snprintf(buf, sizeof(buf), ""%s/profile.desktop"", pdir);             desk = efreet_desktop_new(buf);             if ((desk) && (desk->name)) label = desk->name;             else label = profile;          }#endif        buf[0] = 0;        if (pdir) snprintf(buf, sizeof(buf), ""%s/icon.edj"", pdir);#ifdef ELM_EFREET        if ((desk) && (desk->icon) && (pdir))          snprintf(buf, sizeof(buf), ""%s/%s"", pdir, desk->icon);#endif        ic = elm_icon_add(l_widget);        ext = strrchr(buf, '.');        if (ext)          {             if (!strcmp(ext, "".edj"")) elm_image_file_set(ic, buf, ""icon"");             else elm_image_file_set(ic, buf, NULL);          }        evas_object_size_hint_aspect_set(ic, EVAS_ASPECT_CONTROL_VERTICAL,                                         1, 1);        evas_object_show(ic);        list_it = elm_list_item_append(l_widget, label, ic, NULL,                                       _profiles_list_selected_cb,                                       strdup(profile));        elm_object_item_del_cb_set(list_it, _profiles_list_item_del_cb);        if (cur_profile && !strcmp(profile, cur_profile))          sel_it = list_it;        elm_config_profile_dir_free(pdir);#ifdef ELM_EFREET        if (desk) efreet_desktop_free(desk);#endif     }   if (sel_it) elm_list_item_selected_set(sel_it, EINA_TRUE);   elm_list_go(l_widget);}",2,"cwe119,cwe120"
"create_outfile(){    struct stattostat;      int flags = O_WRONLY | O_CREAT | O_EXCL;    for (;;) {t tif (check_ofname() != OK) {t    close(ifd);t    return ERROR;t}t tremove_ofname = 1;tofd = open(ofname, flags, RW_USER);tif (ofd == -1) {t    perror(ofname);t    close(ifd);t    exit_code = ERROR;t    return ERROR;t}t tif (fstat(ofd, &ostat) != 0) {t    fprintf(stderr, ""%s: "", progname);t    perror(ofname);t    close(ifd); close(ofd);t    unlink(ofname);t    exit_code = ERROR;t    return ERROR;t}tif (!name_too_long(ofname, &ostat)) return OK;tif (decompress) {t     t    WARN((stderr, ""%s: %s: warning, name truncated"",tt  progname, ofname));t    return OK;t}tclose(ofd);tunlink(ofname);tshorten_name(ofname);    }}",3,"cwe119,cwe120,cweother"
"profile_has_subsection(profile_t prof, const char *section,tttt  const char *subsection){tvoidttt*state;tconst chartt*names[4];tcharttt*name;tinttttret = 0;tnames[0] = section;tnames[1] = subsection;tnames[2] = 0;tif (profile_iterator_create(prof, names,tttt    PROFILE_ITER_LIST_SECTION |tttt    PROFILE_ITER_RELATIONS_ONLY, &state))ttreturn 0;tif ((profile_iterator(&state, &name, 0) == 0) && name) {ttfree(name);ttret = 1;t}tprofile_iterator_free(&state);treturn ret;}",2,"cwe119,cwe120"
"getrow(int fd, void *buf, int row, int len){    if (direction > 0)tlseek(fd, (off_t) row * len, 0);    elsetlseek(fd, (off_t) (nrows - row - 1) * len, 0);    if (read(fd, (DCELL *) buf, len) != len)tG_fatal_error(_(""Error reading temporary file""));    return 1;}",2,"cwe120,cweother"
"ArgusWriteConnection (struct ARGUS_INPUT *input, unsigned char *buf, int cnt){   int retn = 0, fd = 0, len = 0;   unsigned char *output = NULL;   if (input && (!input->filename)) {      if ((fd = input->fd) > 2) {#ifdef ARGUS_SASL         unsigned char outputbuf[MAXSTRLEN];         output = outputbuf;         len = cnt;         if (input->sasl_conn) {#ifdef ARGUSDEBUG            ArgusDebug (5, ""ArgusWriteConnection: sasl_encode(0x%x, 0x%x, %d, 0x%x, 0x%x)"",                                         input->sasl_conn, buf, cnt, &output, &len);#endif            if ((retn = sasl_encode(input->sasl_conn, buf, (unsigned int) cnt, (char **) &output, &len)) != SASL_OK)               ArgusLog (LOG_ERR, ""sasl_encode: failed returned %d"", retn);         }#else         output = buf;         len = cnt;#endif  #ifdef ARGUSDEBUG         ArgusDebug (1, ""ArgusWriteConnection: write(%d, 0x%x, %d)"", fd, output, len);#endif         if ((retn = write (fd, output, len)) > 0) {         } else            ArgusLog (LOG_ERR, ""ArgusWriteConnection(0x%x) error %s"", input, strerror(errno));#ifdef ARGUS_SASL         if (output != outputbuf)            free(output);#endif        }   }#ifdef ARGUSDEBUG   ArgusDebug (3, ""ArgusWriteConnection(0x%x, 0x%x, %d) returning %d"", input, buf, cnt, len);#endif   return (retn);}",2,"cwe119,cwe120"
"""cmd_ipv4_prefix_match(const char *str){tconst char *sp;tint dots = 0;tchar buf[4];tif (str == NULL)ttreturn partly_match;tfor (;;) {ttmemset (buf, 0, sizeof (buf));ttsp = str;ttwhile (*str != '0' && *str != '/') {tttif (*str == '.') {ttttif (dots == 3)tttttreturn no_match;ttttif (*(str + 1) == '.' || *(str + 1) == '/')tttttreturn no_match;ttttif (*(str + 1) == '0')tttttreturn partly_match;ttttdots++;ttttbreak;ttt}tttif (!isdigit ((int) *str))ttttreturn no_match;tttstr++;tt}ttif (str - sp > 3)tttreturn no_match;ttstrncpy (buf, sp, str - sp);ttif (atoi (buf) > 255)tttreturn no_match;ttif (dots == 3) {tttif (*str == '/') {ttttif (*(str + 1) == '0')tttttreturn partly_match;ttttstr++;ttttbreak;ttt} else if (*str == '0') {ttttreturn partly_match;ttt}tt}ttif (*str == '0')tttreturn partly_match;ttstr++;t}tsp = str;twhile (*str != '0') {ttif (!isdigit ((int) *str))tttreturn no_match;ttstr++;t}tif (atoi (sp) > 32)ttreturn no_match;treturn exact_match;}""",3,"cwe119,cwe120,cweother"
"game_select_scan_info(gfx_driver_t *gfx_driver, gfx_bitmap_font_t* font_default, gfx_bitmap_font_t* font_small, char *name, int total){tgfx_color_t black;tgfx_color_t white;tgfx_color_t grey;tgfx_color_t blue;trect_t box;tint error;tchar text[256];tblack = create_color_t(0, 0, 0);twhite = create_color_t(255, 255, 255);tgrey = create_color_t(85, 85, 85);tblue = create_color_t(0, 0, 170);tgame_select_draw_bg(gfx_driver, font_default);t tgame_select_display_window(gfx_driver, font_default, gfx_rect(GS_SCAN_WINDOW_LEFT, GS_SCAN_WINDOW_TOP, GS_SCAN_WINDOW_WIDTH, GS_SCAN_WINDOW_HEIGHT), ""Scanning for Games"");t tgfx_box_text(gfx_driver, gfx_rect(GS_SCAN_WINDOW_LEFT + 6, GS_SCAN_WINDOW_TOP + 16, GS_SCAN_WINDOW_WIDTH - 11, 8), font_default, create_pixmap_color_t(black), create_pixmap_color_t(white), ""Please wait, scanning for games..."", 0);tif (name) {ttsnprintf(text, 256, ""Adding: %s"", name);tttgfx_box_text(gfx_driver, gfx_rect(GS_SCAN_WINDOW_LEFT + 6, GS_SCAN_WINDOW_TOP + 32, GS_SCAN_WINDOW_WIDTH - 11, 8), font_default, create_pixmap_color_t(black), create_pixmap_color_t(white), text, 0);t}ttsnprintf(text, 256, ""Games found: %i"", total);tgfx_box_text(gfx_driver, gfx_rect(GS_SCAN_WINDOW_LEFT + 6, GS_SCAN_WINDOW_TOP + 48, GS_SCAN_WINDOW_WIDTH - 11, 8), font_default, create_pixmap_color_t(black), create_pixmap_color_t(white), text, 0);tbox = gfx_rect(0, 0, 320 * gfx_driver->mode->xfact, 200 * gfx_driver->mode->yfact);tif ((error = gfx_driver->update(gfx_driver, box, gfx_point(box.x, box.y), GFX_BUFFER_FRONT)))t{ttGFXERROR(""Error occured while updating region (%d,%d,%d,%d) in buffer %d"", box.x, box.y, box.xl, box.yl, GFX_BUFFER_BACK);t}}",2,"cwe119,cwe120"
"schema_new(LDAP *ld){tLDAPMessage *result, *entry;tchar **values;tchar *subschema_dn;tint code;tconst char *errp;tchar *attrs[2] = {""subschemaSubentry"", 0};ttschema *schema;tif (ldap_search_s(ld, """", LDAP_SCOPE_BASE, 0, attrs, 0, &result)) {ttldap_perror(ld, ""ldap_search"");ttreturn 0;t}tif ( !(entry = ldap_first_entry(ld, result))) {ttldap_perror(ld, ""ldap_first_entry"");ttreturn 0;t}tvalues = ldap_get_values(ld, entry, ""subschemaSubentry"");tif (!values) {ttfputs(""subschemaSubentry attribute not found."", stderr);ttldap_msgfree(result);ttreturn 0;t}tsubschema_dn = xdup(*values);tldap_value_free(values);tldap_msgfree(result);tentry = get_entry(ld, subschema_dn, &result);tfree(subschema_dn);tvalues = ldap_get_values(ld, entry, ""objectClasses"");tschema = xalloc(sizeof(tschema));tschema->classes = g_hash_table_new(strcasehash, strcaseequal);tschema->types = g_hash_table_new(strcasehash, strcaseequal);tif (values) {ttchar **ptr = values;ttfor (ptr = values; *ptr; ptr++) {tttLDAPObjectClass *clstttt= ldap_str2objectclass(*ptr, &code, &errp, 0);tttif (cls)ttttadd_objectclass(schema->classes, cls);                        else                                fprintf(stderr,                                        ""Warning: Cannot parse class: %s"",                                        ldap_scherr2str(code));tt}ttldap_value_free(values);t}tvalues = ldap_get_values(ld, entry, ""attributeTypes"");tif (values) {ttchar **ptr = values;ttfor (ptr = values; *ptr; ptr++) {tttLDAPAttributeType *attttt= ldap_str2attributetype(ttttt*ptr, &code, &errp, 0);tttif (at)                                add_attributetype(schema->types, at);                        else                                fprintf(stderr,                                        ""Warning: Cannot parse type: %s"",                                        ldap_scherr2str(code));tt}ttldap_value_free(values);t}tldap_msgfree(result);treturn schema;}",2,"cwe119,cwe120"
"AddPrefixedClasses(char *name,char *classlist){ char *sp, currentitem[CF_MAXVARSIZE],local[CF_MAXVARSIZE],pref[CF_BUFSIZE]; if ((classlist == NULL) || strlen(classlist) == 0)   {   return;   }memset(local,0,CF_MAXVARSIZE);strncpy(local,classlist,CF_MAXVARSIZE-1);for (sp = local; *sp != '0'; sp++)   {   memset(currentitem,0,CF_MAXVARSIZE);   sscanf(sp,""%250[^.:,]"",currentitem);   sp += strlen(currentitem);   pref[0] = '0';   snprintf(pref,CF_BUFSIZE,""%s_%s"",name,currentitem);   if (IsHardClass(pref))      {      FatalError(""cfengine: You cannot use -D to define a reserved class!"");      }   NewClass(pref);   }}",2,"cwe119,cwe120"
"post(Agraph_t * g){    Agnode_t *v;    Agnode_t *prev;    char buf[256];    char dflt[256];    Agsym_t *sym;    Agsym_t *psym;    double dist, oldmax;    double maxdist = 0.0;t     sym = agattr(g, AGNODE, ""dist"", """");    if (doPath)tpsym = agattr(g, AGNODE, ""prev"", """");    if (setall)tsprintf(dflt, ""%.3lf"", HUGE);    for (v = agfstnode(g); v; v = agnxtnode(g, v)) {tdist = getdist(v);tif (dist) {t    dist--;t    sprintf(buf, ""%.3lf"", dist);t    agxset(v, sym, buf);t    if (doPath && (prev = getprev(v)))ttagxset(v, psym, agnameof(prev));t    if (maxdist < dist)ttmaxdist = dist;t} else if (setall)t    agxset(v, sym, dflt);    }    sym = agattrsym(g, ""maxdist"");    if (sym) {tif (!setall) {t     t    oldmax = atof(agxget(g, sym));t    if (oldmax > maxdist)ttmaxdist = oldmax;t}tsprintf(buf, ""%.3lf"", maxdist);tagxset(g, sym, buf);    } else {tsprintf(buf, ""%.3lf"", maxdist);tagattr(g, AGRAPH, ""maxdist"", buf);    }    agclean(g, AGNODE, ""dijkstra"");    agclean(g, AGEDGE, ""dijkstra"");}",3,"cwe119,cwe120,cweother"
"send_snapshot(int fd, int input_number){    unsigned char *frame = NULL;    int frame_size = 0;    char buffer[BUFFER_SIZE] = {0};    struct timeval timestamp;         pthread_mutex_lock(&pglobal->in[input_number].db);    pthread_cond_wait(&pglobal->in[input_number].db_update, &pglobal->in[input_number].db);         frame_size = pglobal->in[input_number].size;         if((frame = malloc(frame_size + 1)) == NULL) {        free(frame);        pthread_mutex_unlock(&pglobal->in[input_number].db);        send_error(fd, 500, ""not enough memory"");        return;    }         timestamp = pglobal->in[input_number].timestamp;    memcpy(frame, pglobal->in[input_number].buf, frame_size);    DBG(""got frame (size: %d kB)"", frame_size / 1024);    pthread_mutex_unlock(&pglobal->in[input_number].db);         sprintf(buffer, ""HTTP/1.0 200 OKr""             STD_HEADER             ""Content-type: image/jpegr""             ""X-Timestamp: %d.%06dr""             ""r"", (int) timestamp.tv_sec, (int) timestamp.tv_usec);         if(write(fd, buffer, strlen(buffer)) < 0 ||             write(fd, frame, frame_size) < 0) {        free(frame);        return;    }    free(frame);}",2,"cwe119,cwe120"
"load_glas(struct bc_read_stream *s, struct grammar *g){         g->num_glas = 0;    while(1)    {        struct record_info ri = bc_rs_next_data_record(s);        if(ri.record_type == StartBlock && ri.id == BC_GLA)        {            g->num_glas++;            bc_rs_skip_block(s);        }        else if(ri.record_type == EndBlock)            break;        else            unexpected(s, ri);    }    bc_rs_rewind_block(s);    g->glas = malloc(g->num_glas * sizeof(*g->glas));    int gla_offset = 0;    while(1)    {        struct record_info ri = bc_rs_next_data_record(s);        if(ri.record_type == StartBlock && ri.id == BC_GLA)        {            load_gla(s, &g->glas[gla_offset++], g);        }        else if(ri.record_type == EndBlock)            break;        else            unexpected(s, ri);    }}",2,"cwe120,cweother"
"snd_ac97_proc_read_functions(struct snd_ac97 *ac97, struct snd_info_buffer *buffer){tint header = 0, function;tunsigned short info, sense_info;tstatic const char *function_names[12] = {tt""Master Out"", ""AUX Out"", ""Center/LFE Out"", ""SPDIF Out"",tt""Phone In"", ""Mic 1"", ""Mic 2"", ""Line In"", ""CD In"", ""Video In"",tt""Aux In"", ""Mono Out""t};tstatic const char *locations[8] = {tt""Rear I/O Panel"", ""Front Panel"", ""Motherboard"", ""Dock/External"",tt""reserved"", ""reserved"", ""reserved"", ""NC/unused""t};tfor (function = 0; function < 12; ++function) {ttsnd_ac97_write(ac97, AC97_FUNC_SELECT, function << 1);ttinfo = snd_ac97_read(ac97, AC97_FUNC_INFO);ttif (!(info & 0x0001))tttcontinue;ttif (!header) {tttsnd_iprintf(buffer, ""                    Gain     Inverted  Buffer delay  Location"");tttheader = 1;tt}ttsense_info = snd_ac97_read(ac97, AC97_SENSE_INFO);ttsnd_iprintf(buffer, ""%-17s: %3d.%d dBV    %c      %2d/fs         %s"",ttt    function_names[function],ttt    (info & 0x8000 ? -1 : 1) * ((info & 0x7000) >> 12) * 3 / 2,ttt    ((info & 0x0800) >> 11) * 5,ttt    info & 0x0400 ? 'X' : '-',ttt    (info & 0x03e0) >> 5,ttt    locations[sense_info >> 13]);t}}",2,"cwe119,cwe120"
"destroy_most_inst_obj(struct most_inst_obj *inst){tstruct most_c_obj *c, *tmp;t tlist_for_each_entry_safe(c, tmp, &inst->channel_list, list) {ttdestroy_most_c_obj(c);t}tkobject_put(&inst->kobj);}",2,"cwe119,cwe120"
"inflate_request(const char *prog_name, int out){tz_stream stream;tunsigned char in_buf[8192];tunsigned char out_buf[8192];tunsigned long cnt = 0;tint ret;tmemset(&stream, 0, sizeof(stream));tret = inflateInit2(&stream, (15 + 16));tif (ret != Z_OK)ttdie(""cannot start zlib inflater, zlib err %d"", ret);twhile (1) {ttssize_t n = xread(0, in_buf, sizeof(in_buf));ttif (n <= 0)tttdie(""request ended in the middle of the gzip stream"");ttstream.next_in = in_buf;ttstream.avail_in = n;ttwhile (0 < stream.avail_in) {tttint ret;tttstream.next_out = out_buf;tttstream.avail_out = sizeof(out_buf);tttret = inflate(&stream, Z_NO_FLUSH);tttif (ret != Z_OK && ret != Z_STREAM_END)ttttdie(""zlib error inflating request, result %d"", ret);tttn = stream.total_out - cnt;tttif (write_in_full(out, out_buf, n) != n)ttttdie(""%s aborted reading request"", prog_name);tttcnt += n;tttif (ret == Z_STREAM_END)ttttgoto done;tt}t}done:tinflateEnd(&stream);tclose(out);}",2,"cwe119,cwe120"
"com_touch(char * arg){tchar server_fullname[AFP_MAX_PATH];tint ret;tchar filename[AFP_MAX_PATH];tchar * basename = filename;tif (escape_paths(filename,NULL,arg)) {ttprintf(""Syntax: touch <newfile>"");ttgoto error;t}tif ((server==NULL) || (vol==NULL)) {ttprintf(""You're not connected yet to a volume"");ttgoto error;t}tget_server_path(basename,server_fullname);tret=ml_creat(vol,server_fullname,0600);treturn 0;error:treturn -1;treturn 0;}",2,"cwe119,cwe120"
"hm_addhash_str(struct cli_matcher *root, const char *strhash, uint32_t size, const char *virusname) {    enum CLI_HASH_TYPE type;    char binhash[CLI_HASHLEN_MAX];    int hlen;    if(!root || !strhash) {tcli_errmsg(""hm_addhash_str: NULL root or hash"");treturn CL_ENULLARG;    }         if(size == (uint32_t)-1) {tcli_errmsg(""hm_addhash_str: null or invalid size (%u)"", size);treturn CL_EARG;    }    hlen = strlen(strhash);    switch(hlen) {    case 32:ttype = CLI_HASH_MD5;tbreak;    case 40:ttype = CLI_HASH_SHA1;tbreak;    case 64:ttype = CLI_HASH_SHA256;tbreak;    default:tcli_errmsg(""hm_addhash_str: invalid hash %s -- FIXME!"", strhash);treturn CL_EARG;    }    if(cli_hex2str_to(strhash, (char *)binhash, hlen)) {tcli_errmsg(""hm_addhash_str: invalid hash %s"", strhash);treturn CL_EARG;    }    return hm_addhash_bin(root, binhash, type, size, virusname);}",2,"cwe119,cwe120"
"main(int argc, char **argv) {  struct mem_message message;  int r;#if HAVE_GETOPT_LONG  int indx;  static struct option long_options[] = {    {""server"",   1, 0, 's'},    {""port"",     1, 0, 'p'},    {""user"",     1, 0, 'u'},    {""password"", 1, 0, 'v'},    {""from"",     1, 0, 'f'},    {""tls"",      0, 0, 'S'},    {""no-esmtp"", 0, 0, 'E'},  };#endif  while(1) {#if HAVE_GETOPT_LONGtr = getopt_long(argc, argv, ""s:p:u:v:f:SE"", long_options, &indx);#elsetr = getopt(argc, argv, ""s:p:u:v:f:SE"");#endif    if (r < 0)      break;    switch (r) {    case 's':      if (smtp_server != NULL)tfree(smtp_server);      smtp_server = strdup(optarg);      break;    case 'p':      smtp_port = (uint16_t) strtoul(optarg, NULL, 10);      break;    case 'u':      if (smtp_user != NULL)tfree(smtp_user);      smtp_user = strdup(optarg);      break;    case 'v':      if (smtp_password != NULL)tfree(smtp_password);      smtp_password = strdup(optarg);      break;    case 'f':      if (smtp_from != NULL)tfree(smtp_from);      smtp_from = strdup(optarg);      break;    case 'S':      smtp_tls = 1;      break;    case 'E':      smtp_esmtp = 0;      break;    }  }  argc -= optind;  argv += optind;  if (argc < 1) {    fprintf(stderr, ""usage: smtpsend [-f from] [-u user] [-v password] [-s server] [-p port] [-S] <rcpts>..."");    return EXIT_FAILURE;  }  if (smtp_from == NULL && (smtp_from = guessfrom()) == NULL) {    fprintf(stderr, ""can't guess a valid from, please use -f option."");    return EXIT_FAILURE;  }       if (collect(&message))    return EXIT_FAILURE;    send_message(message.data, message.len, argv);  release(&message);  return EXIT_SUCCESS;}",2,"cwe120,cweother"
"lift_object(struct obj *obj,            struct obj *container,t             long *cnt_p,            bool telekinesis){    int result, old_wt, new_wt, prev_encumbr, next_encumbr;    if (obj->otyp == BOULDER && In_sokoban(&u.uz))    {        You(""cannot get your %s around this %s."",            body_part(HAND), xname(obj));        return -1;    }    if (obj->otyp == LOADSTONE ||        (obj->otyp == BOULDER && throws_rocks(youmonst.data)))            return 1;tt     *cnt_p = carry_count(obj, container, *cnt_p, telekinesis, &old_wt, &new_wt);    if (*cnt_p < 1L)    {        result = -1;t     }    else if (obj->oclass != COIN_CLASS && inv_cnt() >= 52 &&             !merge_choice(invent, obj))    {        Your(""knapsack cannot accommodate any more items."");        result = -1;t     }    else    {        result = 1;        prev_encumbr = near_capacity();        if (prev_encumbr < flags.pickup_burden)                prev_encumbr = flags.pickup_burden;        next_encumbr = calc_capacity(new_wt - old_wt);        if (next_encumbr > prev_encumbr)        {            if (telekinesis)            {                result = 0;t             }            else            {                char qbuf[BUFSZ];                long savequan = obj->quan;                obj->quan = *cnt_p;                strcpy(qbuf,                       (next_encumbr > HVY_ENCUMBER) ? overloadmsg :                       (next_encumbr > MOD_ENCUMBER) ? nearloadmsg :                       moderateloadmsg);                sprintf(eos(qbuf), "" %s. Continue?"",                        safe_qbuf(qbuf, sizeof("" . Continue?""),                                  doname(obj), an(simple_typename(obj->otyp)), ""something""));                obj->quan = savequan;                switch (ynq(qbuf))                {                case 'q':  result = -1; break;                case 'n':  result =  0; break;                default:   break;t                 }                clear_nhwindow(WIN_MESSAGE);            }        }    }    if (obj->otyp == SCR_SCARE_MONSTER && result <= 0 && !container)            obj->spe = 0;    return result;}",2,"cwe119,cwe120"
"AssignSkin (edict_t * ent, const char *s, qboolean nickChanged){tint playernum = ent - g_edicts - 1;tchar *p;tchar t[MAX_SKINLEN], skin[64] = ""0"";tif (ctf->value && !matchmode->value)t{ttQ_strncpyz(t, s, sizeof(t));ttif ((p = strrchr (t, '/')) != NULL)tttp[1] = 0;ttelsetttstrcpy (t, ""male/"");ttswitch (ent->client->resp.team)tt{ttcase TEAM1:tttCom_sprintf(skin, sizeof(skin), ""%s%s%s"", ent->client->pers.netname, t, CTF_TEAM1_SKIN);tttbreak;ttcase TEAM2:tttCom_sprintf(skin, sizeof(skin), ""%s%s%s"", ent->client->pers.netname, t, CTF_TEAM2_SKIN);tttbreak;ttdefault:tttCom_sprintf(skin, sizeof(skin), ""%s%s"", ent->client->pers.netname, s);tttbreak;tt}t}telset{ttswitch (ent->client->resp.team)tt{ttcase TEAM1:ttcase TEAM2:ttcase TEAM3:tttCom_sprintf(skin, sizeof(skin), ""%s%s"", ent->client->pers.netname, teams[ent->client->resp.team].skin);tttbreak;ttdefault:tttCom_sprintf(skin, sizeof(skin), ""%s%s"", ent->client->pers.netname, s);tttbreak;tt}t}tgi.configstring(CS_PLAYERSKINS + playernum, skin);}",2,"cwe119,cwe120"
"telnet_raw_vprintf(telnet_t *telnet, const char *fmt, va_list va) {tchar buffer[1024];tchar *output = buffer;tint rs;t trs = vsnprintf(buffer, sizeof(buffer), fmt, va);tif ((size_t)rs >= sizeof(buffer)) {ttoutput = (char*)malloc(rs + 1);ttif (output == 0) {ttt_error(telnet, __LINE__, __func__, TELNET_ENOMEM, 0,ttttt""malloc() failed: %s"", strerror(errno));tttreturn -1;tt}ttrs = vsnprintf(output, rs + 1, fmt, va);t}t ttelnet_send(telnet, output, rs);t tif (output != buffer) {ttfree(output);t}treturn rs;}",3,"cwe119,cwe120,cweother"
"gf_odf_read_esd(GF_BitStream *bs, GF_ESD *esd, u32 DescSize){tGF_Err e = GF_OK;tu32 ocrflag, urlflag, streamdependflag, tmp_size, nbBytes, read;tif (! esd) return GF_BAD_PARAM;tnbBytes = 0;tesd->ESID = gf_bs_read_int(bs, 16);tstreamdependflag = gf_bs_read_int(bs, 1);turlflag = gf_bs_read_int(bs, 1);tocrflag = gf_bs_read_int(bs, 1);tesd->streamPriority = gf_bs_read_int(bs, 5);tnbBytes += 3;ttif (streamdependflag) {ttesd->dependsOnESID = gf_bs_read_int(bs, 16);ttnbBytes += 2;t}tif (urlflag) {tte = gf_odf_read_url_string(bs, & esd->URLString, &read);ttif (e) return e;ttnbBytes += read;t}tif (ocrflag) {ttesd->OCRESID = gf_bs_read_int(bs, 16);ttnbBytes += 2;t}t  twhile (nbBytes < DescSize) {ttGF_Descriptor *tmp = NULL;tte = gf_odf_parse_descriptor(bs, &tmp, &tmp_size);tt ttif (e==GF_ODF_INVALID_DESCRIPTOR) {tttnbBytes += tmp_size;tttif (nbBytes>DescSize) return e;tttgf_bs_read_int(bs, DescSize-nbBytes);tttreturn GF_OK;tt}ttif (e) return e;ttif (!tmp) return GF_ODF_INVALID_DESCRIPTOR;tte = AddDescriptorToESD(esd, tmp);ttif (e) return e;ttnbBytes += tmp_size + gf_odf_size_field_size(tmp_size);tttt ttif (!tmp_size) nbBytes = DescSize;t}tif (DescSize != nbBytes) return GF_ODF_INVALID_DESCRIPTOR;treturn e;}",2,"cwe120,cweother"
"get_next_reel (int tape_des){  static int reel_number = 1;  FILE *tty_in;ttt   FILE *tty_out;tt   int old_tape_des;  char *next_archive_name;  dynamic_string new_name;  char *str_res;  ds_init (&new_name, 128);     tty_in = fopen (TTY_NAME, ""r"");  if (tty_in == NULL)    error (2, errno, TTY_NAME);  tty_out = fopen (TTY_NAME, ""w"");  if (tty_out == NULL)    error (2, errno, TTY_NAME);  old_tape_des = tape_des;  tape_offline (tape_des);  rmtclose (tape_des);     ++reel_number;  if (new_media_message)    fprintf (tty_out, ""%s"", new_media_message);  else if (new_media_message_with_number)    fprintf (tty_out, ""%s%d%s"", new_media_message_with_number, reel_number,t     new_media_message_after_number);  else if (archive_name)    fprintf (tty_out, _(""Found end of tape.  Load next tape and press RETURN. ""));  else    fprintf (tty_out, _(""Found end of tape.  To continue, type device/file name when ready.""));  fflush (tty_out);  if (archive_name)    {      int c;      dotc = getc (tty_in);      while (c != EOF && c != '');      tape_des = open_archive (archive_name);      if (tape_des == -1)topen_error (archive_name);    }  else    {      dot{t  if (tape_des < 0)t    {t      fprintf (tty_out,tt       _(""To continue, type device/file name when ready.""));t      fflush (tty_out);t    }t  str_res = ds_fgets (tty_in, &new_name);t  if (str_res == NULL || str_res[0] == '0')t    exit (1);t  next_archive_name = str_res;t  tape_des = open_archive (next_archive_name);t  if (tape_des == -1)t    open_error (next_archive_name);t}      while (tape_des < 0);    }     if (tape_des != old_tape_des)    error (1, 0, _(""internal error: tape descriptor changed from %d to %d""),t   old_tape_des, tape_des);  free (new_name.ds_string);  fclose (tty_in);  fclose (tty_out);}",2,"cwe120,cweother"
"ecore_con_socks_init(void){   const char *socks;   char *h, *p, *l, *u = NULL;   char buf[512];   int port, lookup = 0;   Eina_Bool v5 = EINA_FALSE;   Ecore_Con_Socks *ecs;   unsigned char addr[sizeof(struct in_addr)];#ifdef HAVE_IPV6   unsigned char addr6[sizeof(struct in6_addr)];#endif       socks = getenv(""ECORE_CON_SOCKS_V4"");   if (!socks)     {                 socks = getenv(""ECORE_CON_SOCKS_V5"");        v5 = EINA_TRUE;     }   if ((!socks) || (!socks[0]) || (strlen(socks) > 512)) return;   strncpy(buf, socks, sizeof(buf));   h = strchr(buf, '@');       if (h && (h - buf > 0)) *h++ = 0, u = buf;   else h = buf;       p = strchr(h, '-');   if (!p) return;   *p++ = 0;   if (!inet_pton(AF_INET, h, addr))#ifdef HAVE_IPV6     {        if (!v5) return;        if (!inet_pton(AF_INET6, h, addr6))          return;     }#else     return;#endif   errno = 0;   port = strtol(p, &l, 10);   if (errno || (port < 0) || (port > 65535)) return;   if (l && (l[0] == ':'))     lookup = (l[1] == '1');   if (v5)     ecs = ecore_con_socks5_remote_add(h, port, u, NULL);   else     ecs = ecore_con_socks4_remote_add(h, port, u);   if (!ecs) return;   ecore_con_socks_lookup_set(ecs, lookup);   ecore_con_socks_apply_always(ecs);   INF(""Added global proxy server %s%s%s:%d - DNS lookup %s"",       u ?: """", u ? ""@"" : """", h, port, lookup ? ""ENABLED"" : ""DISABLED"");}",3,"cwe119,cwe120,cweother"
"info_intuit_options_node (WINDOW *window, NODE *initial_node, char *program){     static const char *invocation_nodes[] = {    ""%s invocation"",    ""Invoking %s"",    ""Preliminaries"",         ""Invocation"",    ""Command Arguments"",     ""Invoking `%s'"",    ""%s options"",    ""Options"",    ""Option "",               ""Invoking"",    ""All options"",           ""Arguments"",    ""%s cmdline"",            ""%s"",                    (const char *)0  };  NODE *node = NULL;  REFERENCE **menu;  const char **try_node;     for (node = initial_node; node; initial_node = node)    {      REFERENCE *entry = NULL;             menu = info_menu_of_node (initial_node);             if (!menu)        break;             for (try_node = invocation_nodes; *try_node; try_node++)        {          char *nodename;          nodename = xmalloc (strlen (program) + strlen (*try_node));          sprintf (nodename, *try_node, program);                     entry = entry_in_menu (nodename, menu,                                 strcmp (*try_node, ""%s"") == 0);          free (nodename);          if (entry)            break;        }      if (!entry)        break;      if (!entry->filename)        entry->filename = xstrdup (initial_node->parent ? initial_node->parent                                   : initial_node->filename);             node = info_get_node (entry->filename, entry->nodename,                             PARSE_NODE_VERBATIM);      info_free_references (menu);      if (!node)        break;    }     if (initial_node)    info_set_node_of_window (1, window, initial_node);  if (!info_error_was_printed)    window_clear_echo_area ();}",2,"cwe469,cweother"
"Client_UpdateCloakedHostname(CLIENT *Client, CLIENT *Origin,ttt     const char *Hostname){tchar Cloak_Buffer[CLIENT_HOST_LEN];tassert(Client != NULL);tif (!Origin)ttOrigin = Client_ThisServer();tif (!Client->cloaked) {ttClient->cloaked = malloc(CLIENT_HOST_LEN);ttif (!Client->cloaked)tttreturn;t}tif (!Hostname) {tt ttif (*Conf_CloakHostModeX) {tttstrlcpy(Cloak_Buffer, Client->host,ttttsizeof(Cloak_Buffer));tttstrlcat(Cloak_Buffer, Conf_CloakHostSalt,ttttsizeof(Cloak_Buffer));tttsnprintf(Client->cloaked, CLIENT_HOST_LEN,tttt Conf_CloakHostModeX, Hash(Cloak_Buffer));tt} elsetttstrlcpy(Client->cloaked, Client_ID(Client->introducer),ttttCLIENT_HOST_LEN);t} elsettstrlcpy(Client->cloaked, Hostname, CLIENT_HOST_LEN);tLogDebug(""Cloaked hostname of ""%s"" updated to ""%s"""",tt Client_ID(Client), Client->cloaked);t tIRC_WriteStrServersPrefixFlag(Client_NextHop(Origin), Origin, 'M',tttt      ""METADATA %s cloakhost :%s"",tttt      Client_ID(Client), Client->cloaked);}",3,"cwe119,cwe120,cweother"
"cache_lock_file(void){    char file[PATH_MAX];    struct flock fl;    int lockfd;    snprintf(file, sizeof(file), ""%s/efreet/desktop_data.lock"", efreet_cache_home_get());    lockfd = open(file, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);    if (lockfd < 0) return -1;    efreet_fsetowner(lockfd);    memset(&fl, 0, sizeof(struct flock));    fl.l_type = F_WRLCK;    fl.l_whence = SEEK_SET;    if (fcntl(lockfd, F_SETLK, &fl) < 0)    {        INF(""LOCKED! You may want to delete %s if this persists"", file);        close(lockfd);        return -1;    }    return lockfd;}",3,"cwe119,cwe120,cweother"
"alloc_vjd_yshadow_deck(int L, int i, int j){  int status;  char **a;  int    jp;  ESL_ALLOC(a, sizeof(char *) * (L+1));    for (jp = 0;   jp < i-1;    jp++) a[jp] = NULL;  for (jp = j+1; jp <= L;     jp++) a[jp] = NULL;  for (jp = 0;   jp <= j-i+1; jp++) ESL_ALLOC(a[jp+i-1], sizeof(char) * (jp+1));  return a; ERROR:  cm_Fail(""Memory allocation error."");  return NULL;  }",2,"cwe120,cweother"
"""exrefresh(){tchart*scan;t/* If this ex command wrote ANYTHING set exwrote so vi's  :  commandt * can tell that it must wait for a user keystroke before redrawing.t */tfor (scan=kbuf; scan<stdscr; scan++)ttif (*scan == '')tttexwrote = TRUE;#if MICROSOFTttt/* avoid compiler bug */tscan = stdscr;#definetstdscrtscan#endift/* now we do the refresh thing */tif (*o_exrefresh)t{ttrefresh();t}telset{ttwqrefresh(stdscr);t}#if MICROSOFT#undeftstdscrtstdscr = scan;#endiftif (mode != MODE_VI)t{ttmanymsgs = FALSE;t}}""",2,"cwe119,cwe120"
"print_char(int c){#ifndef _WINDOWS    int i, outchars;    unsigned char obuf[MAX(MB_LEN_MAX,32)];    if(!ps_global->print->err       && (outchars = utf8_to_locale(c, &cb, obuf, sizeof(obuf)))){tfor(i = 0; i < outchars && !ps_global->print->err; i++)t  if(putc(obuf[i], ps_global->print->fp) == EOF)t    ps_global->print->err = 1;    }#else      if(!ps_global->print->err       && (ps_global->print->err = mswin_print_char_utf8(c)))      q_status_message1(SM_ORDER, 0, 9, ""Print cancelled: %s"",tt     mswin_print_error((unsigned short)ps_global->print->err));#endif      return(!ps_global->print->err);}",2,"cwe119,cwe120"
"menu_choose_string(char *label, char *ret_buf, int buf_len, char *dfl){tchar buf[BUFSIZE];tint len, min_len;ttif (!label)ttlabel = """";tset_tty_color(COLOR_WHITE);tif (dfl) {ttif (strlen(label))tttprintf(""%s [%s]> "", label, dfl);ttelsetttprintf(""[%s]> "", dfl);t} elsettprintf(""%s> "", label);tfgets(buf, sizeof(buf), stdin);tset_tty_color(COLOR_LIGHTGRAY);tif (buf[0] == 0x0a) {ttif (dfl)tttstrcpy(buf, dfl);ttelsetttreturn -1;t}tlen = strlen(buf);tif (buf[len - 1] == '')ttbuf[len - 1] = 0;tmin_len = buf_len < len + 1 ? buf_len : len + 1;tmemcpy(ret_buf, buf, min_len);tret_buf[min_len - 1] = 0;treturn 0;}",2,"cwe119,cwe120"
"""GUCArrayReset(ArrayType *array){tArrayType  *newarray;tintttti;tinttttindex;t/* if array is currently null, nothing to do */tif (!array)ttreturn NULL;t/* if we're superuser, we can delete everything */tif (superuser())ttreturn NULL;tnewarray = NULL;tindex = 1;tfor (i = 1; i <= ARR_DIMS(array)[0]; i++)t{ttDatumttd;ttchart   *val;ttchart   *eqsgn;ttboolttisnull;ttstruct config_generic *gconf;ttd = array_ref(array, 1, &i,ttttt  -1 /* varlenarray */ ,ttttt  -1 /* TEXT's typlen */ ,ttttt  false /* TEXT's typbyval */ ,ttttt  'i' /* TEXT's typalign */ ,ttttt  &isnull);ttif (isnull)tttcontinue;ttval = DatumGetCString(DirectFunctionCall1(textout, d));tteqsgn = strchr(val, '=');tt*eqsgn = '0';ttgconf = find_option(val, false, WARNING);ttif (!gconf)tttcontinue;tt/* note: superuser-ness was already checked above */tt/* skip entry if OK to delete */ttif (gconf->context == PGC_USERSET)tttcontinue;tt/* XXX do we need to worry about database owner? */tt/* else add it to the output array */ttif (newarray)tt{tttnewarray = array_set(newarray, 1, &index,tttttttt d,tttttttt false,tttttttt -1 /* varlenarray */ ,tttttttt -1 /* TEXT's typlen */ ,tttttttt false /* TEXT's typbyval */ ,tttttttt 'i' /* TEXT's typalign */ );tt}ttelsetttnewarray = construct_array(&d, 1,ttttttttt   TEXTOID,ttttttttt   -1, false, 'i');ttindex++;ttpfree(val);t}treturn newarray;}""",2,"cwe119,cwe120"
"set_variable(const char *var, EFI_GUID *guid, uint32_t attributes,t     uint32_t size, void *buf){tif (!kernel_efi_path)ttreturn -EINVAL;tint varfs_len = strlen(var) + 48 + strlen(kernel_efi_path);tchar *varfs = malloc(varfs_len),tt*newbuf = malloc(size + sizeof(attributes));tint fd;tsnprintf(varfs, varfs_len, ""%s/%s-%s"", kernel_efi_path,tt var, guid_to_str(guid));tfd = open(varfs, O_RDWR|O_CREAT|O_TRUNC, 0644);tfree(varfs);tif (fd < 0)ttreturn errno;tmemcpy(newbuf, &attributes, sizeof(attributes));tmemcpy(newbuf + sizeof(attributes), buf, size);ttif (write(fd, newbuf, size + sizeof(attributes)) != size + sizeof(attributes))ttreturn errno;tclose(fd);treturn 0;}",2,"cwe120,cweother"
"parse_tune_options(int argc, char *argv[]){tint c;twhile ((c = getopt(argc, argv, ""J:lL:U:V"")) != EOF) {ttswitch (c) {ttcase 'J':ttt tttparse_journal_opts_j2(optarg);tttJ_flag = 1;tttOpenMode = ""r+"";tttbreak;ttcase 'l':ttt tttl_flag = 1;tttbreak;ttcase 'L':ttt tttnew_label = optarg;tttL_flag = 1;tttOpenMode = ""r+"";tttbreak;ttcase 'U':ttt tttnew_UUID = optarg;tttU_flag = 1;tttOpenMode = ""r+"";tttbreak;ttcase 'V':ttt tttexit(0);tttbreak;ttdefault:ttttune_usage();tttbreak;tt}t}tif (optind != argc - 1) {ttprintf(""Error: Device not specified or command format error."");tttune_usage();t}tif (!J_flag && !l_flag && !L_flag && !U_flag) {ttprintf(""Error: No options selected."");tttune_usage();t}tdevice = argv[optind];treturn;}",2,"cwe120,cweother"
"SendMotd(int sockfd){tchar line[MAXLINE + 1];tchar *final;tchar *ch;tFILE *fp;tif ((fp = fopen(DccMotdFile, ""r"")) == NULL)t{ttwritesocket(sockfd, ""MOTD file missingr"");ttreturn;t}twhile (fgets(line, sizeof(line), fp))t{ttif ((ch = strchr(buffer, '')) != NULL)ttt*ch = '0';ttif (*line != '0')tt{tttfinal = Substitute(NULL, line, sockfd);tttif (final && (final != (char *) -1))ttt{ttttwritesocket(sockfd, final);ttttMyFree(final);ttt}tt}ttwritesocket(sockfd, ""r"");t}tfclose(fp);}",3,"cwe119,cwe120,cweother"
"skip_extension( FILE     * fp,                FL_IMAGE * im ){    int pchar,        err = 0;    while ( ! err && ( pchar = getc( fp ) ) != EOF && pchar != IMAGESEP )    {        switch ( pchar )        {            case '0' :            case TRAILER :                break;            case EXTENSION :                err = readextension( fp, im );                break;            default :                M_warn( ""GIFextension"", ""%s: Bogus byte 0x%02x"",                        im->infile, pchar );                return EOF;        }    }    return err ? EOF : pchar;}",2,"cwe120,cweother"
"""start_gtab_pho_query(char *utf8){  phokey_t phokeys[32];  int phokeysN, i;  phokeysN = utf8_pho_keys(utf8, phokeys);  if (phokeysN <= 0)    return;  u_char rtyp_pho[4];  bzero(rtyp_pho, sizeof(rtyp_pho));  key_typ_pho(phokeys[0], rtyp_pho);  char xkeys[4];  bzero(xkeys, sizeof(xkeys));  for(i=0; i < 4; i++) {    if (!rtyp_pho[i])      continue;    xkeys[i] = typ_pho_no_to_xkey(i, rtyp_pho[i]);  }  if (!xkeys[3])    xkeys[3] = ' ';  for(i=0; i < 4; i++) {    feedkey_pho(xkeys[i], 0);  }}""",2,"cwe119,cwe120"
"show_monitor_status(struct Client *client_p){tchar onbuf[BUFSIZE], offbuf[BUFSIZE];tstruct Client *target_p;tstruct monitor *monptr;tchar *onptr, *offptr;tint cur_onlen, cur_offlen;tint mlen, arglen;trb_dlink_node *ptr;tmlen = cur_onlen = rb_sprintf(onbuf, form_str(RPL_MONONLINE), me.name, client_p->name, """");tcur_offlen = rb_sprintf(offbuf, form_str(RPL_MONOFFLINE), me.name, client_p->name, """");tonptr = onbuf + mlen;toffptr = offbuf + mlen;tSetCork(client_p);tRB_DLINK_FOREACH(ptr, client_p->localClient->monitor_list.head)t{ttmonptr = ptr->data;ttif((target_p = find_named_person(monptr->name)) != NULL)tt{tttif(cur_onlen + strlen(target_p->name) +ttt   strlen(target_p->username) + strlen(target_p->host) + 3 >= BUFSIZE - 3)ttt{ttttsendto_one_buffer(client_p, onbuf);ttttcur_onlen = mlen;ttttonptr = onbuf + mlen;ttt}tttif(cur_onlen != mlen)ttt{tttt*onptr++ = ',';ttttcur_onlen++;ttt}tttarglen = rb_sprintf(onptr, ""%s!%s@%s"",ttttt    target_p->name, target_p->username, target_p->host);tttonptr += arglen;tttcur_onlen += arglen;tt}ttelsett{tttif(cur_offlen + strlen(monptr->name) + 1 >= BUFSIZE - 3)ttt{ttttsendto_one_buffer(client_p, offbuf);ttttcur_offlen = mlen;ttttoffptr = offbuf + mlen;ttt}tttif(cur_offlen != mlen)ttt{tttt*offptr++ = ',';ttttcur_offlen++;ttt}tttarglen = rb_sprintf(offptr, ""%s"", monptr->name);tttoffptr += arglen;tttcur_offlen += arglen;tt}t}tClearCork(client_p);tif(cur_onlen != mlen)ttsendto_one_buffer(client_p, onbuf);tif(cur_offlen != mlen)ttsendto_one_buffer(client_p, offbuf);}",2,"cwe119,cwe120"
"x86_64_irq_eframe_link_init(void){tint c;tstruct syment *sp, *spn;tchar buf[BUFSIZE];tchar link_register[BUFSIZE];        char *arglist[MAXARGS];tulong max_instructions;tif (machdep->machspec->irq_eframe_link == UNINITIALIZED)ttmachdep->machspec->irq_eframe_link = 0;telsettreturn; tif (THIS_KERNEL_VERSION < LINUX(2,6,9)) ttreturn;tif (!(sp = symbol_search(""common_interrupt"")) ||t    !(spn = next_symbol(NULL, sp))) {ttreturn;t}tmax_instructions = spn->value - sp->value;topen_tmpfile();        sprintf(buf, ""x/%ldi 0x%lx"",ttmax_instructions, sp->value);        if (!gdb_pass_through(buf, pc->tmpfile, GNU_RETURN_ON_ERROR))ttreturn;tlink_register[0] = NULLCHAR;trewind(pc->tmpfile);        while (fgets(buf, BUFSIZE, pc->tmpfile)) {ttif (!strstr(buf, sp->name))tttbreak;ttif ((c = parse_line(buf, arglist)) < 4)tttcontinue;ttif (strstr(arglist[2], ""push""))tttstrcpy(link_register, arglist[3]);t}tclose_tmpfile();tif (CRASHDEBUG(1)) ttfprintf(fp, ""IRQ stack link register: %s"", tt    strlen(link_register) ? tttlink_register : ""undetermined"");tif (STREQ(link_register, ""%rbp""))ttmachdep->machspec->irq_eframe_link = 40;telse if (THIS_KERNEL_VERSION >= LINUX(2,6,29)) ttmachdep->machspec->irq_eframe_link = 40;}",3,"cwe119,cwe120,cweother"
"read_string(const char *prompt, char *buf, size_t len, int echo){    struct sigaction sigs[NSIG];    int oksigs[NSIG];    struct sigaction sa;    FILE *tty;    int ret = 0;    int of = 0;    int i;    int c;    char *p;    struct termios t_new, t_old;    memset(&oksigs, 0, sizeof(oksigs));    memset(&sa, 0, sizeof(sa));    sa.sa_handler = intr;    sigemptyset(&sa.sa_mask);    sa.sa_flags = 0;    for(i = 1; i < sizeof(sigs) / sizeof(sigs[0]); i++)tif (i != SIGALRM)t    if (sigaction(i, &sa, &sigs[i]) == 0)ttoksigs[i] = 1;    if((tty = fopen(""/dev/tty"", ""r"")) == NULL)ttty = stdin;    fprintf(stderr, ""%s"", prompt);    fflush(stderr);    if(echo == 0){ttcgetattr(fileno(tty), &t_old);tmemcpy(&t_new, &t_old, sizeof(t_new));tt_new.c_lflag &= ~ECHO;ttcsetattr(fileno(tty), TCSANOW, &t_new);    }    intr_flag = 0;    p = buf;    while(intr_flag == 0){tc = getc(tty);tif(c == EOF){t    if(!ferror(tty))ttret = 1;t    break;t}tif(c == '')t    break;tif(of == 0)t    *p++ = c;tof = (p == buf + len);    }    if(of)tp--;    *p = 0;    if(echo == 0){tprintf("""");ttcsetattr(fileno(tty), TCSANOW, &t_old);    }    if(tty != stdin)tfclose(tty);    for(i = 1; i < sizeof(sigs) / sizeof(sigs[0]); i++)tif (oksigs[i])t    sigaction(i, &sigs[i], NULL);    if(ret)treturn -3;    if(intr_flag)treturn -2;    if(of)treturn -1;    return 0;}",2,"cwe120,cweother"
"write_appledouble(GFile *f, LPCTSTR pictname){    unsigned char data[256];    unsigned long resource_length;         resource_length = write_resource_pict(NULL, pictname);    memset(data, 0, sizeof(data));    memcpy(data, apple_double_magic, 4);t     put_bigendian_dword(data+4, 0x00020000);t          put_bigendian_word(data+24, 2);t          put_bigendian_dword(data+26, 9);t     put_bigendian_dword(data+30, 50);t     put_bigendian_dword(data+34, 32);t          put_bigendian_dword(data+38, 2);t     put_bigendian_dword(data+42, 82);t     put_bigendian_dword(data+46, resource_length);t          memcpy(data+50, ""EPSF"", 4);tt     memcpy(data+54, ""MSWD"", 4);tt     data[58] = 1;ttt     gfile_write(f, data, 82);         if (write_resource_pict(f, pictname) <= 0)treturn -1;    return 0;}",2,"cwe119,cwe120"
p_object_to_hdf (PyObject *ho){  if (HDFObjectCheck(ho))  {    return ((HDFObject *)ho)->data;  }  return NULL;},2,"cwe119,cwe120"
"initLmSensors( struct SensorModul* sm ){  const sensors_chip_name* scn;  int nr = 0;  if ( sensors_init( NULL ) ) {    LmSensorsOk = -1;    return;  }  LmSensors = new_ctnr();  while ( ( scn = sensors_get_detected_chips( NULL, &nr ) ) != NULL ) {    int nr1 = 0;    const sensors_feature* sf;    while ( ( sf = sensors_get_features( scn, &nr1 ) ) != 0 ) {      const sensors_subfeature *ssubf;      LMSENSOR *p;      char *s, *label;      char scnbuf[BUFFER_SIZE_LMSEN];      switch( sf->type )      {        case SENSORS_FEATURE_IN:          ssubf = sensors_get_subfeature( scn, sf,                                          SENSORS_SUBFEATURE_IN_INPUT );          break;        case SENSORS_FEATURE_FAN:          ssubf = sensors_get_subfeature( scn, sf,                                          SENSORS_SUBFEATURE_FAN_INPUT );          break;        case SENSORS_FEATURE_TEMP:          ssubf = sensors_get_subfeature( scn, sf,                                          SENSORS_SUBFEATURE_TEMP_INPUT );          break;        default:            ssubf = NULL;      }      if ( !ssubf )        continue;      label = sensors_get_label( scn, sf );      sensors_snprintf_chip_name(scnbuf, BUFFER_SIZE_LMSEN, scn);      p = (LMSENSOR*)malloc( sizeof( LMSENSOR ) );      p->fullName = (char*)malloc( strlen( ""lmsensors/"" ) +                                   strlen( scnbuf ) + 1 +                                   strlen( label ) + 1 );      snprintf( p->fullName, BUFFER_SIZE_LMSEN, ""lmsensors/%s/%s"", scnbuf, label );             for ( s = p->fullName; *s; s++ )        if ( *s == ' ' )          *s = '_';      p->scn = scn;      p->sf = sf;      p->sfd = ssubf;             if ( search_ctnr( LmSensors, sensorCmp, p ) < 0 ) {        push_ctnr( LmSensors, p );        registerMonitor( p->fullName, ""float"", printLmSensor, printLmSensorInfo, sm );      } else {        free( p->fullName );        free( p );      }      free( label );    }  }  bsort_ctnr( LmSensors, sensorCmp );}",3,"cwe119,cwe120,cweother"
"mq_fetch_child_size_and_contri (call_frame_t *frame, void *cookie,                                xlator_t *this, int32_t op_ret,                                int32_t op_errno, dict_t *xdata){        int32_t            ret              = -1;        char               contri_key [512] = {0, };        dict_t            *newdict          = NULL;        quota_local_t     *local            = NULL;        quota_inode_ctx_t *ctx              = NULL;        local = frame->local;        if (op_ret == -1) {                gf_log (this->name, (op_errno == ENOENT) ? GF_LOG_DEBUG                        : GF_LOG_WARNING,                        ""couldnt mark inode corresponding to path (%s) dirty ""                        ""(%s)"", local->parent_loc.path, strerror (op_errno));                goto err;        }        VALIDATE_OR_GOTO (local->ctx, err);        VALIDATE_OR_GOTO (local->contri, err);        gf_log (this->name, GF_LOG_DEBUG, ""%s marked dirty"", local->parent_loc.path);                 ret = mq_inode_ctx_get (local->parent_loc.inode, this, &ctx);        if (ret == -1) {                op_errno = EINVAL;                goto err;        }        LOCK (&ctx->lock);        {                ctx->dirty = 1;        }        UNLOCK (&ctx->lock);        newdict = dict_new ();        if (newdict == NULL) {                op_errno = ENOMEM;                goto err;        }        if (local->loc.inode->ia_type == IA_IFDIR) {                ret = dict_set_int64 (newdict, QUOTA_SIZE_KEY, 0);                if (ret < 0) {                        gf_log (this->name, GF_LOG_WARNING,                                ""dict_set failed."");                        goto err;                }        }        GET_CONTRI_KEY (contri_key, local->contri->gfid, ret);        if (ret < 0) {                op_errno = ENOMEM;                goto err;        }        ret = dict_set_int64 (newdict, contri_key, 0);        if (ret < 0) {                gf_log (this->name, GF_LOG_WARNING,                        ""dict_set failed."");                goto err;        }        mq_set_ctx_updation_status (local->ctx, _gf_false);        if (uuid_is_null (local->loc.gfid))                uuid_copy (local->loc.gfid, local->loc.inode->gfid);        GF_UUID_ASSERT (local->loc.gfid);        STACK_WIND (frame, mq_update_inode_contribution, FIRST_CHILD(this),                    FIRST_CHILD(this)->fops->lookup, &local->loc, newdict);        ret = 0;err:        if ((op_ret == -1) || (ret < 0)) {                local->err = op_errno;                mq_set_ctx_updation_status (local->ctx, _gf_false);                mq_release_parent_lock (frame, NULL, this, 0, 0, NULL);        }        if (newdict)                dict_unref (newdict);        return 0;}",2,"cwe119,cwe120"
"probe_hfs(struct blkid_probe *probe __BLKID_ATTR((unused)),ttt struct blkid_magic *id __BLKID_ATTR((unused)),ttt unsigned char *buf){tstruct hfs_mdb *hfs = (struct hfs_mdb *) buf;tchartuuid_str[17];t__u64tuuid;tif ((memcmp(hfs->embed_sig, ""H+"", 2) == 0) ||t    (memcmp(hfs->embed_sig, ""HX"", 2) == 0))ttreturn 1;t tuuid = blkid_le64(*((unsigned long long *) hfs->finder_info.id));tif (uuid) {ttsprintf(uuid_str, ""%016llX"", uuid);ttblkid_set_tag(probe->dev, ""UUID"", uuid_str, 0);t}tblkid_set_tag(probe->dev, ""LABEL"", hfs->label, hfs->label_len);treturn 0;}",2,"cwe119,cwe120"
"hash_table_to_dict_cb (gpointer key, gpointer value, gpointer user_data){    PyObject *d = user_data;    PyObject *string_value;    string_value = PyString_FromString (value);    PyDict_SetItemString (d, key, string_value);    Py_DECREF (string_value);}",2,"cwe119,cwe120"
"""rl_gather_tyi (){  int tty;  register int tem, result;  int chars_avail, k;  char input;#if defined(HAVE_SELECT)  fd_set readfds, exceptfds;  struct timeval timeout;#endif  tty = fileno (rl_instream);#if defined (HAVE_SELECT)  FD_ZERO (&readfds);  FD_ZERO (&exceptfds);  FD_SET (tty, &readfds);  FD_SET (tty, &exceptfds);  timeout.tv_sec = 0;  timeout.tv_usec = _keyboard_input_timeout;  result = select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout);  if (result <= 0)    return 0;t/* Nothing to read. */#endif  result = -1;#if defined (FIONREAD)  errno = 0;  result = ioctl (tty, FIONREAD, &chars_avail);  if (result == -1 && errno == EIO)    return -1;#endif#if defined (O_NDELAY)  if (result == -1)    {      tem = fcntl (tty, F_GETFL, 0);      fcntl (tty, F_SETFL, (tem | O_NDELAY));      chars_avail = read (tty, &input, 1);      fcntl (tty, F_SETFL, tem);      if (chars_avail == -1 && errno == EAGAIN)treturn 0;      if (chars_avail == 0)t/* EOF */t{t  rl_stuff_char (EOF);t  return (0);t}    }#endif /* O_NDELAY */#if defined (__MINGW32__)  /* We use getch to read console input, so use the same     mechanism to check for more.  Otherwise, we don't know.  */  if (isatty (fileno (rl_instream)))    chars_avail = _kbhit ();  else    chars_avail = 0;  result = 0;#endif  /* If there's nothing available, don't waste time trying to read     something. */  if (chars_avail <= 0)    return 0;  tem = ibuffer_space ();  if (chars_avail > tem)    chars_avail = tem;  /* One cannot read all of the available input.  I can only read a single     character at a time, or else programs which require input can be     thwarted.  If the buffer is larger than one character, I lose.     Damn! */  if (tem < ibuffer_len)    chars_avail = 0;  if (result != -1)    {      while (chars_avail--)t{t  k = (*rl_getc_function) (rl_instream);t  rl_stuff_char (k);t  if (k == NEWLINE || k == RETURN)t    break;t}    }  else    {      if (chars_avail)trl_stuff_char (input);    }  return 1;}""",2,"cwe120,cweother"
"dowidths(Dir *db){tchar buf[256];tint n;tif(sflag) {ttn = sprint(buf, ""%llud"", (db->length+1023)/1024);ttif(n > swidth)tttswidth = n;t}tif(qflag) {ttn = sprint(buf, ""%lud"", db->qid.vers);ttif(n > qwidth)tttqwidth = n;t}tif(mflag) {ttn = snprint(buf, sizeof buf, ""[%s]"", db->muid);ttif(n > mwidth)tttmwidth = n;t}tif(lflag) {ttn = sprint(buf, ""%ud"", db->dev);ttif(n > vwidth)tttvwidth = n;ttn = strlen(db->uid);ttif(n > uwidth)tttuwidth = n;ttn = sprint(buf, ""%llud"", db->length);ttn += strlen(db->gid);ttif(n > glwidth)tttglwidth = n;t}}",2,"cwe119,cwe120"
"ring_write_file(ringbuffy *rbuf, int fd, int count){tint diff, free, pos, rest, rr;tif (count <=0 ) return 0;       tpos  = rbuf->write_pos;trest = rbuf->size - pos;tdiff = rbuf->read_pos - pos;tfree = (diff > 0) ? diff-1 : rbuf->size+diff-1;tif ( rest <= 0 ) return 0;tif ( free < count ) count = free;ttif (count >= rest){ttrr = read (fd, rbuf->buffy+pos, rest);ttif (rr == rest && count - rest)tttrr += read (fd, rbuf->buffy, count - rest);ttif (rr >=0)tttrbuf->write_pos = (pos + rr) % rbuf->size;t} else {ttrr = read (fd, rbuf->buffy+pos, count);ttif (rr >=0)tttrbuf->write_pos += rr;t}treturn rr;}",2,"cwe120,cweother"
"gretl_matrix_block_resample (const gretl_matrix *m, ttttt   int blocklen, ttttt   int *err){    gretl_matrix *R = NULL;    int *z = NULL;    double x;    int b, n, s, r, rmax;    int t1;    int i, j, k;    if (gretl_is_null_matrix(m) || blocklen <= 0) {t*err = E_DATA;treturn NULL;    }    if (blocklen == 1) {treturn gretl_matrix_resample(m, err);    }        r = m->rows;            n = r / blocklen + (r % blocklen > 0);    rmax = r - blocklen;    if (rmax < 0) {t*err = E_DATA;treturn NULL;    }    R = gretl_matrix_alloc(r, m->cols);    z = malloc(n * sizeof *z);    if (R == NULL || z == NULL) {tgretl_matrix_free(R);tfree(z);t*err = E_ALLOC;treturn NULL;    }         gretl_rand_int_minmax(z, n, 0, rmax);         i = 0;    for (b=0; b<n; b++) {tfor (s=0; s<blocklen; s++) {t    if (i < r) {ttk = z[b] + s;ttfor (j=0; j<m->cols; j++) {tt    x = gretl_matrix_get(m, k, j);tt    gretl_matrix_set(R, i, j, x);tt}tti++;t    } else {ttbreak;t    }t}    }    t1 = gretl_matrix_get_t1(m);    if (t1 > 0) {tgretl_matrix_set_t1(R, t1);tgretl_matrix_set_t2(R, t1 + r - 1);    }    free(z);    return R;}",2,"cwe120,cwe476"
"rotate_names(char *name, filebuff_t *fb, int num){inttlast, i;charttname[MAXPATHLEN+16], tname1[MAXPATHLEN+16];    if ( fb == NULL || name == NULL ) return;    if ( !num ) {t tclose(fb->fd);tfb->fd = open(name, O_WRONLY|O_APPEND|O_CREAT, 0660);treturn;    }         last = num - 1;         for(i=last;i>0;i--) {tsnprintf(tname,  sizeof(tname)-1,  ""%s.%d"", name, i-1);t tsnprintf(tname1, sizeof(tname1)-1, ""%s.%d"", name, i);t tRENAME(tname, tname1);ttttt     }    if ( fb->fd != -1 ) close(fb->fd);    RENAME(name, tname);    fb->fd = open(name, O_WRONLY|O_APPEND|O_CREAT, 0660);}",3,"cwe119,cwe120,cweother"
"main (int argc, char **argv){  const char *filename = ""test-fgetc.txt"";   #if HAVE_MSVC_INVALID_PARAMETER_HANDLER     && MSVC_INVALID_PARAMETER_HANDLING == DEFAULT_HANDLING  gl_msvc_inval_ensure_handler ();#endif     {    const char text[] = ""hello world"";    int fd = open (filename, O_RDWR | O_CREAT | O_TRUNC, 0600);    ASSERT (fd >= 0);    ASSERT (write (fd, text, sizeof (text)) == sizeof (text));    ASSERT (close (fd) == 0);  }     {    FILE *fp = fopen (filename, ""r"");    ASSERT (fp != NULL);    ASSERT (close (fileno (fp)) == 0);    errno = 0;    ASSERT (fgetc (fp) == EOF);    ASSERT (errno == EBADF);    ASSERT (ferror (fp));    fclose (fp);  }     {    FILE *fp = fdopen (-1, ""r"");    if (fp != NULL)      {        errno = 0;        ASSERT (fgetc (fp) == EOF);        ASSERT (errno == EBADF);        ASSERT (ferror (fp));        fclose (fp);      }  }  {    FILE *fp;    close (99);    fp = fdopen (99, ""r"");    if (fp != NULL)      {        errno = 0;        ASSERT (fgetc (fp) == EOF);        ASSERT (errno == EBADF);        ASSERT (ferror (fp));        fclose (fp);      }  }     unlink (filename);  return 0;}",2,"cwe120,cweother"
"parse_certid (app_t app, const char *certid,              unsigned char **r_objid, size_t *r_objidlen){  char tmpbuf[10];  const char *s;  size_t objidlen;  unsigned char *objid;  int i;  *r_objid = NULL;  *r_objidlen = 0;  if (app->app_local->home_df)    sprintf (tmpbuf, ""P15-%04hX."", (app->app_local->home_df & 0xffff));  else    strcpy (tmpbuf, ""P15."");  if (strncmp (certid, tmpbuf, strlen (tmpbuf)) )    {      if (!strncmp (certid, ""P15."", 4)          || (!strncmp (certid, ""P15-"", 4)              && hexdigitp (certid+4)              && hexdigitp (certid+5)              && hexdigitp (certid+6)              && hexdigitp (certid+7)              && certid[8] == '.'))        return gpg_error (GPG_ERR_NOT_FOUND);      return gpg_error (GPG_ERR_INV_ID);    }  certid += strlen (tmpbuf);  for (s=certid, objidlen=0; hexdigitp (s); s++, objidlen++)    ;  if (*s || !objidlen || (objidlen%2))    return gpg_error (GPG_ERR_INV_ID);  objidlen /= 2;  objid = xtrymalloc (objidlen);  if (!objid)    return gpg_error_from_syserror ();  for (s=certid, i=0; i < objidlen; i++, s+=2)    objid[i] = xtoi_2 (s);  *r_objid = objid;  *r_objidlen = objidlen;  return 0;}",2,"cwe119,cwe120"
"snd_card_load1(int card){tint res;tchar control[sizeof(SND_FILE_CONTROL) + 10];tsprintf(control, SND_FILE_CONTROL, card);tres = snd_card_load2(control);#ifdef SUPPORT_ALOADtif (res < 0) {ttchar aload[sizeof(SND_FILE_LOAD) + 10];ttsprintf(aload, SND_FILE_LOAD, card);ttres = snd_card_load2(aload);t}#endiftreturn res;}",3,"cwe119,cwe120,cweother"
"parse_envar(int argc, char* argv[]){  int c, prev_optind, d = 0, e = 0;     opterr = 0;     prev_optind = optind;  while((c = getopt(argc, argv, ""vfuw:p:d:e:a:r:s:"")) != -1){    switch(c){    case 'v':        verbose = !verbose;      break;    case 'f':        if(d == 1 || e == 1) envar_use(ASPCMDV);      force = !force;      break;    case 'u':        update = !update;      break;    case 'w':        if(bound_check(optarg, 0, INT_MAX, &recv_delay) != 0){tfprintf(stderr, ""%s: bad wait_time number"", prog_name);texit(EXIT_FAILURE);      };      break;    case 'p':        if(bound_check(optarg, 0, 65535, &port) != 0){tfprintf(stderr, ""%s: bad port number"", prog_name);texit(EXIT_FAILURE);      }      break;    case 'd':        if(force == 1) envar_use(ASPCMDV);      path = optarg;      d = 1;      break;    case 'e':        if(force == 1) envar_use(ASPCMDV);      ext = optarg;      e = 1;      break;    case 'a':        if(bound_check(optarg, 0, 65535, &addresses) != 0){        fprintf(stderr, ""%s: bad addresses number"", prog_name);        exit(EXIT_FAILURE);      }      break;    case 'r':        if(bound_check(optarg, 1, 65535, &rip) != 0){        fprintf(stderr, ""%s: bad repetition number"", prog_name);        exit(EXIT_FAILURE);      }      break;    case 's':        if(bound_check(optarg, 0, 65535, &send_delay) != 0){        fprintf(stderr, ""%s: bad send delay number"", prog_name);        exit(EXIT_FAILURE);      }      break;    default:      envar_use(ASPCMDV);      break;    }  }  if(optind != argc) envar_use(ASPCMDV);  optind = prev_optind;}",2,"cwe120,cweother"
"get_key_value(const char *file, const char *section, const char *key, char *value, int value_size){   char new_key[UTILS_LINE_SIZE];   char new_value[UTILS_LINE_SIZE];   char rcbuf[255];   char new_section[32];   char *tail;   FILE *inFile;   enum UTILS_CONF_RESULT stat = UTILS_CONF_DATFILE_ERROR;   int i,j;   if((inFile = fopen(file, ""r"")) == NULL)    {      BUG(""unable to open %s: %m"", file);      goto bugout;   }    new_section[0] = 0;       while ((fgets(rcbuf, sizeof(rcbuf), inFile) != NULL))   {      if (rcbuf[0] == '[')      {         i = j = 0;         while ((rcbuf[i] != ']') && (j < (sizeof(new_section)-2)))            new_section[j++] = rcbuf[i++];         new_section[j++] = rcbuf[i++];             new_section[j] = 0;                  continue;      }      GetPair(rcbuf, strlen(rcbuf), new_key, new_value, &tail);      if ((strcasecmp(new_section, section) == 0) && (strcasecmp(new_key, key) == 0))      {         strncpy(value, new_value, value_size);         stat = UTILS_CONF_OK;         break;         }   }   if (stat != UTILS_CONF_OK)      BUG(""unable to find %s %s in %s"", section, key, file);        bugout:           if (inFile != NULL)      fclose(inFile);            return stat;}",3,"cwe119,cwe120,cweother"
"drmGetDevice(int fd, drmDevicePtr *device){    drmDevicePtr *local_devices;    drmDevicePtr d;    DIR *sysdir;    struct dirent *dent;    struct stat sbuf;    char node[PATH_MAX + 1];    int node_type, subsystem_type;    int maj, min;    int ret, i, node_count;    int max_count = 16;    if (fd == -1 || device == NULL)        return -EINVAL;    if (fstat(fd, &sbuf))        return -errno;    maj = major(sbuf.st_rdev);    min = minor(sbuf.st_rdev);    if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))        return -EINVAL;    subsystem_type = drmParseSubsystemType(maj, min);    local_devices = calloc(max_count, sizeof(drmDevicePtr));    if (local_devices == NULL)        return -ENOMEM;    sysdir = opendir(DRM_DIR_NAME);    if (!sysdir) {        ret = -errno;        goto free_locals;    }    i = 0;    while ((dent = readdir(sysdir))) {        node_type = drmGetNodeType(dent->d_name);        if (node_type < 0)            continue;        snprintf(node, PATH_MAX, ""%s/%s"", DRM_DIR_NAME, dent->d_name);        if (stat(node, &sbuf))            continue;        maj = major(sbuf.st_rdev);        min = minor(sbuf.st_rdev);        if (maj != DRM_MAJOR || !S_ISCHR(sbuf.st_mode))            continue;        if (drmParseSubsystemType(maj, min) != subsystem_type)            continue;        switch (subsystem_type) {        case DRM_BUS_PCI:            ret = drmProcessPciDevice(&d, dent->d_name, node, node_type,                                      maj, min, true);            if (ret)                goto free_devices;            break;        default:            fprintf(stderr, ""The subsystem type is not supported yet"");            continue;        }        if (i >= max_count) {            drmDevicePtr *temp;            max_count += 16;            temp = realloc(local_devices, max_count * sizeof(drmDevicePtr));            if (!temp)                goto free_devices;            local_devices = temp;        }        local_devices[i] = d;        i++;    }    node_count = i;         drmFoldDuplicatedDevices(local_devices, node_count);    *device = local_devices[0];    for (i = 1; i < node_count && local_devices[i]; i++)            drmFreeDevice(&local_devices[i]);    closedir(sysdir);    free(local_devices);    return 0;free_devices:    drmFreeDevices(local_devices, i);    closedir(sysdir);free_locals:    free(local_devices);    return ret;}",2,"cwe119,cwe120"
"xfs_setsize_buftarg(txfs_buftarg_ttt*btp,tunsigned intttsectorsize){t tbtp->bt_meta_sectorsize = sectorsize;tbtp->bt_meta_sectormask = sectorsize - 1;tif (set_blocksize(btp->bt_bdev, sectorsize)) {ttchar name[BDEVNAME_SIZE];ttbdevname(btp->bt_bdev, name);ttxfs_warn(btp->bt_mount,ttt""Cannot set_blocksize to %u on device %s"",tttsectorsize, name);ttreturn -EINVAL;t}t tbtp->bt_logical_sectorsize = bdev_logical_block_size(btp->bt_bdev);tbtp->bt_logical_sectormask = bdev_logical_block_size(btp->bt_bdev) - 1;treturn 0;}",2,"cwe119,cwe120"
"load_8bit_bmp( FL_IMAGE * im,               SPEC     * sp ){    FILE *fp = im->fpin;    int i,        j,        k,        len,        pix;    unsigned short *ci;    if ( sp->encode == E_RGB )    {        for ( i = im->h - 1; i >= 0 && ! feof( fp ); i--, im->completed++ )        {            ci = im->ci[ i ];            for ( j = 0; j < im->w + sp->pad; j++ )            {                                 if ( ( pix = getc( fp ) ) != EOF && j < im->w )                    *ci++ = pix;            }            if ( ! ( im->completed & FLIMAGE_REPFREQ ) )                im->visual_cue( im, ""Reading 8bit BMP"" );        }    }    else    {        ci = im->ci[ im->h - 1 ];        for ( i = im->h - 1; i >= 0 && ! feof( fp ); )        {            len = getc( fp );            pix = getc( fp );            if ( len )            {                while ( --len >= 0 )                    *ci++ = pix;            }            else            {                if ( pix == 0 )                    ci = im->ci[ --i ];                else if ( pix == 1 )                    goto done;                else if ( pix == 2 )                {                                         ci += getc( fp );                    i += ( pix = getc( fp ) );                    ci -= pix * im->w;                }                else                {                    for ( k = 0; k < pix; k++ )                        *ci++ = getc( fp );                    if ( k & 1 )                        getc( fp );                }            }            if ( ! ( ( im->completed = im->h - i - 1 ) & FLIMAGE_REPFREQ ) )                im->visual_cue( im, ""Reading 8bit encoded BMP"" );        }    } done:    return i < ( 2 * im->h / 3 ) ? 1 : -1;}",2,"cwe120,cweother"
"av_get_tmpfile(char **retp){    int res = 0;    char buf[64];      AV_LOCK(tmplock);    if(tmpdir == NULL) {        char *path;        path = av_strdup(""/tmp/.avfs_tmp_XXXXXX"");        res = make_tmp_dir(path);        if(res < 0)            av_free(path);        else {t    AV_NEW(tmpdir);t    tmpdir->path = path;t    tmpdir->ctr = 0;t}    }    if(tmpdir != NULL) {tsprintf(buf, ""/atmp%06i"", tmpdir->ctr++);t*retp = av_stradd(NULL, tmpdir->path, buf, NULL);    }    AV_UNLOCK(tmplock);    return res;}",2,"cwe119,cwe120"
"addToIsoCbk(GtkButton *button, gpointer data){    GtkTreeSelection* selection;        if(!GBLisoPaneActive)             return;        selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(GBLfsTreeView));             GtkWidget* progressWindow;    GtkWidget* label;             progressWindow = gtk_dialog_new();    gtk_dialog_set_has_separator(GTK_DIALOG(progressWindow), FALSE);    gtk_window_set_modal(GTK_WINDOW(progressWindow), TRUE);    gtk_window_set_title(GTK_WINDOW(progressWindow), _(""Progress""));    gtk_window_set_transient_for(GTK_WINDOW(progressWindow), GTK_WINDOW(GBLmainWindow));    g_signal_connect_swapped(progressWindow, ""delete-event"",                             G_CALLBACK(activityProgressWindowDeleteCbk), NULL);    g_signal_connect_swapped(progressWindow, ""response"",                              G_CALLBACK(cancelOperation), NULL);        label = gtk_label_new(_(""Please wait while I'm adding the selected items...""));    gtk_box_pack_start(GTK_BOX(GTK_DIALOG(progressWindow)->vbox), label, TRUE, TRUE, 0);    gtk_widget_show(label);        if(GBLappSettings.scanForDuplicateFiles)    {        label = gtk_label_new(_(""(scanning for duplicate files)""));        gtk_box_pack_start(GTK_BOX(GTK_DIALOG(progressWindow)->vbox), label, TRUE, TRUE, 0);        gtk_widget_show(label);    }             GBLactivityProgressBar = gtk_progress_bar_new();    gtk_box_pack_start(GTK_BOX(GTK_DIALOG(progressWindow)->vbox), GBLactivityProgressBar, TRUE, TRUE, 0);    gtk_widget_show(GBLactivityProgressBar);             gtk_dialog_add_button(GTK_DIALOG(progressWindow), GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL);             gtk_widget_show(progressWindow);             GBLoperationCanceled = false;        gtk_tree_selection_selected_foreach(selection, addToIsoEachRowCbk, NULL);        gtk_widget_destroy(progressWindow);    GBLactivityProgressBar = NULL;        if(gtk_tree_selection_count_selected_rows(selection) > 0)         {        refreshIsoView();    }             char sizeStr[20];    GBLisoSize = 35845;             GBLisoSize += 2048;    GBLisoSize += bk_estimate_iso_size(&GBLvolInfo, FNTYPE_9660 | FNTYPE_JOLIET | FNTYPE_ROCKRIDGE);    formatSize(GBLisoSize, sizeStr, sizeof(sizeStr));    gtk_label_set_text(GTK_LABEL(GBLisoSizeLbl), sizeStr);}",2,"cwe119,cwe120"
"add_remote_info_ref(struct remote_ls_ctx *ls){tstruct buffer *buf = (struct buffer *)ls->userData;tunsigned char remote_sha1[20];tstruct object *o;tint len;tchar *ref_info;tif (fetch_ref(ls->dentry_name, remote_sha1) != 0) {ttfprintf(stderr,ttt""Unable to fetch ref %s from %s"",tttls->dentry_name, remote->url);ttaborted = 1;ttreturn;t}to = parse_object(remote_sha1);tif (!o) {ttfprintf(stderr,ttt""Unable to parse object %s for remote ref %s"",tttsha1_to_hex(remote_sha1), ls->dentry_name);ttaborted = 1;ttreturn;t}tlen = strlen(ls->dentry_name) + 42;tref_info = xcalloc(len + 1, 1);tsprintf(ref_info, ""%st%s"",ttsha1_to_hex(remote_sha1), ls->dentry_name);tfwrite_buffer(ref_info, 1, len, buf);tfree(ref_info);tif (o->type == OBJ_TAG) {tto = deref_tag(o, ls->dentry_name, 0);ttif (o) {tttlen = strlen(ls->dentry_name) + 45;tttref_info = xcalloc(len + 1, 1);tttsprintf(ref_info, ""%st%s^{}"",ttttsha1_to_hex(o->sha1), ls->dentry_name);tttfwrite_buffer(ref_info, 1, len, buf);tttfree(ref_info);tt}t}}",2,"cwe119,cwe120"
"adv_bignum_num_2_2(Driver * drvthis, int x, int num, int height, int offset, int do_init){tstatic char num_map[][4][3] = {t tt{tt ttt{'|', 0, '|'},ttt""|_|"",ttt""   "",ttt""   ""tt},tt{tt ttt""  |"",ttt""  |"",ttt""   "",ttt""   ""tt},tt{tt ttt{' ', 1, '|'},ttt""|_ "",ttt""   "",ttt""   ""tt},tt{tt ttt{' ', 1, '|'},ttt"" _|"",ttt""   "",ttt""   ""tt},tt{tt ttt""|_|"",ttt""  |"",ttt""   "",ttt""   ""tt},tt{tt ttt{'|', 1, ' '},ttt"" _|"",ttt""   "",ttt""   ""tt},tt{tt ttt{'|', 0, ' '},ttt{'|', 1, '|'},ttt""   "",ttt""   ""tt},tt{tt ttt{' ', 0, '|'},ttt""  |"",ttt""   "",ttt""   ""tt},tt{tt ttt{'|', 1, '|'},ttt""|_|"",ttt""   "",ttt""   ""tt},tt{tt ttt{'|', 1, '|'},ttt"" _|"",ttt""   "",ttt""   ""tt},tt{tt ttt""."",ttt""."",ttt"" "",ttt"" ""tt}t};t tif (do_init) {ttint i;ttstatic unsigned char bignum[2][8] = {t ttt[0] {ttttb__XXXXX,ttttb_______,ttttb_______,ttttb_______,ttttb_______,ttttb_______,ttttb_______,ttttb_______,ttt},ttt[1] {ttttb__XXXXX,ttttb_______,ttttb_______,ttttb_______,ttttb_______,ttttb_______,ttttb__XXXXX,ttttb__XXXXX,ttt}tt};tt ttfor (i = 0; i < 2; i++) {tttdrvthis->set_char(drvthis, offset + i, bignum[i]);tt}t}t tadv_bignum_write_num(drvthis, num_map, x, num, height, offset);}",2,"cwe119,cwe120"
"cbf_end_digest (cbf_file *file, char *digest){  unsigned char raw_digest [16];    void *vdigest;  if (!file || !digest)    return CBF_ARGUMENT;  if (!file->digest)    return CBF_ARGUMENT;       cbf_failnez (cbf_flush_characters (file))       MD5Final (raw_digest, file->digest);           vdigest = (void *)file->digest;  cbf_failnez (cbf_free ((void **) &vdigest, NULL))    file->digest = NULL;       cbf_md5digest_to64 (digest, raw_digest);       return 0;}",2,"cwe119,cwe120"
"_httpd_start_thread(conndata_t * conn){  int err;#ifdef WIN32  conn->tid =    (HANDLE) _beginthreadex(NULL, 65535, httpd_session_main, conn, 0, &err);#else  pthread_attr_init(&(conn->attr));#ifdef PTHREAD_CREATE_DETACHED  pthread_attr_setdetachstate(&(conn->attr), PTHREAD_CREATE_DETACHED);#endif  pthread_sigmask(SIG_BLOCK, &thrsigset, NULL);  if ((err =       pthread_create(&(conn->tid), &(conn->attr), httpd_session_main, conn)))  {    char err_buf[256];    strerror_r(errno, err_buf, sizeof(err_buf));    log_error2(""pthread_create failed (%s)"", err_buf);  }#endif  return;}",2,"cwe119,cwe120"
"error(char *fmt, ...){    va_list args;    char    buf[4096];    if (responseMsg == 0) {        va_start(args, fmt);        vsprintf(buf, fmt, args);        responseStatus = 400;        responseMsg = strdup(buf);        va_end(args);    }    hasError++;}",3,"cwe119,cwe120,cweother"
"zd1201_auth_sta(struct net_device *dev,    struct iw_request_info *info, struct sockaddr *sta, char *extra){tstruct zd1201 *zd = netdev_priv(dev);tunsigned char buffer[10];tif (!zd->ap)ttreturn -EOPNOTSUPP;tmemcpy(buffer, sta->sa_data, ETH_ALEN);t*(short*)(buffer+6) = 0;t t*(short*)(buffer+8) = 0;treturn zd1201_setconfig(zd, ZD1201_RID_AUTHENTICATESTA, buffer, 10, 1);}",2,"cwe119,cwe120"
"pxa168_eth_set_mac_address(struct net_device *dev, void *addr){tstruct sockaddr *sa = addr;tstruct pxa168_eth_private *pep = netdev_priv(dev);tunsigned char oldMac[ETH_ALEN];tu32 mac_h, mac_l;tif (!is_valid_ether_addr(sa->sa_data))ttreturn -EADDRNOTAVAIL;tmemcpy(oldMac, dev->dev_addr, ETH_ALEN);tmemcpy(dev->dev_addr, sa->sa_data, ETH_ALEN);tmac_h = dev->dev_addr[0] << 24;tmac_h |= dev->dev_addr[1] << 16;tmac_h |= dev->dev_addr[2] << 8;tmac_h |= dev->dev_addr[3];tmac_l = dev->dev_addr[4] << 8;tmac_l |= dev->dev_addr[5];twrl(pep, MAC_ADDR_HIGH, mac_h);twrl(pep, MAC_ADDR_LOW, mac_l);tnetif_addr_lock_bh(dev);tupdate_hash_table_mac_address(pep, oldMac, dev->dev_addr);tnetif_addr_unlock_bh(dev);treturn 0;}",2,"cwe119,cwe120"
"process_legacy_cf(Slapi_PBlock *pb){tconsumer_operation_extension *opext;tSlapi_Operation *op;    char *referral_array[2] = {0};    char *referral;tchar *state;tint rc;    const Slapi_DN *replica_root_sdn = NULL;    Slapi_Entry *e;tslapi_pblock_get(pb, SLAPI_OPERATION, &op);topext = (consumer_operation_extension*) repl_con_get_ext (REPL_CON_EXT_OP, op);        if (opext->has_cf)    {        PR_ASSERT (operation_get_type (op) == SLAPI_OPERATION_ADD ||                    operation_get_type (op) == SLAPI_OPERATION_MODIFY);t            if ((PR_FALSE == target_is_a_replica_root(pb, &replica_root_sdn)) ||ttt(NULL == replica_root_sdn)){tttreturn;tt}        slapi_pblock_get (pb, SLAPI_ENTRY_POST_OP, &e);        PR_ASSERT (e);ttif (NULL == e)tttreturn;ttttrc = get_legacy_referral (e, &referral, &state);        if (rc == 0)        {            referral_array[0] = referral;            referral_array[1] = NULL;tttrepl_set_mtn_state_and_referrals(replica_root_sdn, state, NULL, NULL,ttttttttttt referral_array);                         set_legacy_purl (pb, referral);            slapi_ch_free((void **)&referral);t    }ttt        }}",2,"cwe119,cwe120"
"cl_process (GeglOperation       *operation,      GeglBuffer                *input,      GeglBuffer                *output,      const GeglRectangle       *result){  const Babl *in_format  = gegl_operation_get_format (operation, ""input"");  const Babl *out_format = gegl_operation_get_format (operation, ""output"");  gint err;  gint j;  cl_int cl_err;  GeglOperationAreaFilter *op_area = GEGL_OPERATION_AREA_FILTER (operation);  GeglChantO *o = GEGL_CHANT_PROPERTIES (operation);  GeglBufferClIterator *i = gegl_buffer_cl_iterator_new (output,   result, out_format, GEGL_CL_BUFFER_WRITE, GEGL_ABYSS_NONE);  gint read = gegl_buffer_cl_iterator_add_2 (i, input, result, in_format,  GEGL_CL_BUFFER_READ,                                             op_area->left, op_area->right, op_area->top, op_area->bottom, GEGL_ABYSS_NONE);  gint aux  = gegl_buffer_cl_iterator_add_2 (i, NULL, result, in_format,  GEGL_CL_BUFFER_AUX,                                             op_area->left, op_area->right, op_area->top, op_area->bottom, GEGL_ABYSS_NONE);  while (gegl_buffer_cl_iterator_next (i, &err))  {    if (err) return FALSE;    for (j=0; j < i->n; j++)      {        cl_err = cl_noise_reduction(i->tex[read][j],                                    i->tex[aux][j],                                    i->tex[0][j],                                    i->size[0][j],                                    &i->roi[read][j],                                    &i->roi[0][j],                                    o->iterations);        if (cl_err != CL_SUCCESS)        {          g_warning(""[OpenCL] Error in gegl:noise-reduction: %s"", gegl_cl_errstring(cl_err));          return FALSE;        }      }  }  return TRUE;}",2,"cwe120,cweother"
"""from_host_no_find_associated_eth_device(int host_no, nic_t **nic){tnic_t *current_nic = nic_list;tchar *raw = NULL, *raw_tmp;tuint32_t raw_size = 0;tchar temp_path[sizeof(iscsi_host_path_netdev_template) + 8];tint rc = -EIO;t/*  Build the path to determine uio name */tsnprintf(temp_path, sizeof(temp_path),tt iscsi_host_path_netdev_template, host_no);trc = capture_file(&raw, &raw_size, temp_path);tif (rc != 0)ttgoto error;t/* sanitize name string by replacing newline with null termination */traw_tmp = raw;twhile (*raw_tmp != '' && raw_size--)ttraw_tmp++;t*raw_tmp = '0';trc = -EIO;tcurrent_nic = nic_list;twhile (current_nic != NULL) {ttif (strcmp(raw, current_nic->eth_device_name) == 0) {ttt*nic = current_nic;tttrc = 0;tttbreak;tt}ttcurrent_nic = current_nic->next;t}tfree(raw);error:treturn rc;}""",4,"cwe119,cwe120,cwe469,cweother"
"Test_PNG(T_IO_Context * context){  FILE *file;                char filename[MAX_PATH_CHARACTERS];    byte png_header[8];    Get_full_filename(filename, context->File_name, context->File_directory);    File_error=1;     if ((file=fopen(filename, ""rb"")))  {         if (Read_bytes(file,png_header,8))    {      if ( !png_sig_cmp(png_header, 0, 8))        File_error=0;    }    fclose(file);  }}",3,"cwe119,cwe120,cweother"
"snd_pcm_file_replace_fname(snd_pcm_file_t *file, char **new_fname_p){tchar value[VALUE_MAXLEN];tchar *fname = file->fname;tchar *new_fname = NULL;tchar *old_last_ch, *old_index_ch, *new_index_ch;tint old_len, new_len, err;tsnd_pcm_t *pcm = file->gen.slave;t told_len = new_len = strlen(fname);told_last_ch = fname + old_len - 1;tnew_fname = malloc(new_len + 1);tif (!new_fname)ttreturn -ENOMEM;told_index_ch = fname;t tnew_index_ch = new_fname;t twhile (old_index_ch <= old_last_ch) {ttif (*(old_index_ch) == LEADING_KEY &&ttttold_index_ch != old_last_ch) {ttt tttswitch (*(++old_index_ch)) {tttcase RATE_KEY:ttttsnprintf(value, sizeof(value), ""%d"",ttttttpcm->rate);tttterr = snd_pcm_file_append_value(&new_fname,ttttt&new_index_ch, &new_len, value);ttttif (err < 0)tttttreturn err;ttttbreak;tttcase CHANNELS_KEY:ttttsnprintf(value, sizeof(value), ""%d"",ttttttpcm->channels);tttterr = snd_pcm_file_append_value(&new_fname,ttttt&new_index_ch, &new_len, value);ttttif (err < 0)tttttreturn err;ttttbreak;tttcase BWIDTH_KEY:ttttsnprintf(value, sizeof(value), ""%d"",tttttpcm->frame_bits/pcm->channels);tttterr = snd_pcm_file_append_value(&new_fname,tttttt&new_index_ch, &new_len, value);ttttif (err < 0)tttttreturn err;ttttbreak;tttcase FORMAT_KEY:tttterr = snd_pcm_file_append_value(&new_fname,ttttt&new_index_ch, &new_len,tttttsnd_pcm_format_name(pcm->format));ttttif (err < 0)tttttreturn err;ttttbreak;tttdefault:tttt tttt*(new_index_ch++) = *(old_index_ch);ttt}ttt tttold_index_ch++;tt} else {ttt ttt*(new_index_ch++) = *(old_index_ch++);tt}t}t t*(new_index_ch) = '0';t*(new_fname_p) = new_fname;treturn 0;}",2,"cwe119,cwe120"
"pyramid_hbar(Driver *drvthis, int x, int y, int len, int promille, int options){    PrivateData *p = (PrivateData *) drvthis->private_data;    static unsigned char hBars[4][8] = {t{0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10},t{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},t{0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C},t{0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E},    };    if (p->ccmode != hbar) {tint i;tif (p->ccmode != standard) {t    report(RPT_WARNING, ""%s: hbar: cannot combine two modes using user-defined characters"",tt   drvthis->name);t    return;t}tfor (i = 0; i < 4; i++)t    pyramid_set_char(drvthis, i + 1, hBars[i]);tp->ccmode = hbar;    }    lib_hbar_static(drvthis, x, y, len, promille, options, p->cellwidth, 0);}",2,"cwe119,cwe120"
"show_info_popup(GtkWidget *w, GdkEventButton *ev,    ttttgpointer data){  struct city_dialog *pdialog = g_object_get_data(G_OBJECT(w), ""pdialog"");  if (ev->button == 1) {    GtkWidget *p, *label, *frame;    char buf[1024];        switch (GPOINTER_TO_UINT(data)) {    case FIELD_FOOD:      get_city_dialog_output_text(pdialog->pcity, O_FOOD, buf, sizeof(buf));      break;    case FIELD_SHIELD:      get_city_dialog_output_text(pdialog->pcity, O_SHIELD,tttt  buf, sizeof(buf));      break;    case FIELD_TRADE:      get_city_dialog_output_text(pdialog->pcity, O_TRADE, buf, sizeof(buf));      break;    case FIELD_GOLD:      get_city_dialog_output_text(pdialog->pcity, O_GOLD, buf, sizeof(buf));      break;    case FIELD_SCIENCE:      get_city_dialog_output_text(pdialog->pcity, O_SCIENCE,tttt  buf, sizeof(buf));      break;    case FIELD_LUXURY:      get_city_dialog_output_text(pdialog->pcity, O_LUXURY,tttt  buf, sizeof(buf));      break;    case FIELD_POLLUTION:      get_city_dialog_pollution_text(pdialog->pcity, buf, sizeof(buf));      break;    case FIELD_ILLNESS:      get_city_dialog_illness_text(pdialog->pcity, buf, sizeof(buf));      break;    default:      return TRUE;    }        p = gtk_window_new(GTK_WINDOW_POPUP);    gtk_widget_set_name(p, ""Freeciv"");    gtk_container_set_border_width(GTK_CONTAINER(p), 2);    gtk_window_set_position(GTK_WINDOW(p), GTK_WIN_POS_MOUSE);    frame = gtk_frame_new(NULL);    gtk_container_add(GTK_CONTAINER(p), frame);    label = gtk_label_new(buf);    gtk_widget_set_name(label, ""city_info_label"");    gtk_misc_set_padding(GTK_MISC(label), 4, 4);    gtk_container_add(GTK_CONTAINER(frame), label);    gtk_widget_show_all(p);    gdk_device_grab(ev->device, gtk_widget_get_window(p),                    GDK_OWNERSHIP_NONE, TRUE, GDK_BUTTON_RELEASE_MASK, NULL,                    ev->time);    gtk_grab_add(p);    g_signal_connect_after(p, ""button_release_event"",                           G_CALLBACK(show_info_button_release), NULL);  }  return TRUE;}",2,"cwe119,cwe120"
"is_router_version_good_for_possible_guard(const char *platform){  static int parsed_versions_initialized = 0;  static tor_version_t first_good_0_2_1_guard_version;  static tor_version_t first_good_0_2_2_guard_version;  static tor_version_t first_good_later_guard_version;  tor_version_t router_version;        {    char *s, *s2, *start;    char tmp[128];    tor_assert(platform);         if (strcmpstart(platform,""Tor ""))      return 1;    start = (char *)eat_whitespace(platform+3);    if (!*start) return 0;    s = (char *)find_whitespace(start);      s2 = (char*)eat_whitespace(s);    if (!strcmpstart(s2, ""(r"") || !strcmpstart(s2, ""(git-""))      s = (char*)find_whitespace(s2);    if ((size_t)(s-start+1) >= sizeof(tmp))        return 0;    strlcpy(tmp, start, s-start+1);    if (tor_version_parse(tmp, &router_version)<0) {      log_info(LD_DIR,""Router version '%s' unparseable."",tmp);      return 1;      }  }     if (!parsed_versions_initialized) {         tor_assert(tor_version_parse(""0.2.1.31"",                                 &first_good_0_2_1_guard_version)>=0);    tor_assert(tor_version_parse(""0.2.2.34"",                                 &first_good_0_2_2_guard_version)>=0);    tor_assert(tor_version_parse(""0.2.3.6-alpha"",                                 &first_good_later_guard_version)>=0);         parsed_versions_initialized = 1;  }  return ((tor_version_same_series(&first_good_0_2_1_guard_version,                                   &router_version) &&           tor_version_compare(&first_good_0_2_1_guard_version,                               &router_version) <= 0) ||          (tor_version_same_series(&first_good_0_2_2_guard_version,                                   &router_version) &&           tor_version_compare(&first_good_0_2_2_guard_version,                               &router_version) <= 0) ||          (tor_version_compare(&first_good_later_guard_version,                               &router_version) <= 0));}",2,"cwe119,cwe120"
ack_in_line(){    intttsclass;tt         sclass = cls();    for (;;)    {tif (curwin->w_cursor.col == 0)t     t    break;tdec_cursor();tif (cls() != sclass)tt     t{t    inc_cursor();t    break;t}    }},2,"cwe120,cweother"
"sval_display(menu_type *menu, int oid, bool cursor, int row, int col, int width){tchar buf[80];tconst squelch_choice *choice = menu_priv(menu);tint idx = choice[oid].idx;tbyte attr = (cursor ? TERM_L_BLUE : TERM_WHITE);t tobject_kind_name(buf, sizeof(buf), idx, choice[oid].aware);t tc_put_str(attr, format(""[ ] %s"", buf), row, col);tif ((choice[oid].aware && (k_info[idx].squelch & SQUELCH_IF_AWARE)) ||t    ((!choice[oid].aware) && (k_info[idx].squelch & SQUELCH_IF_UNAWARE)))ttc_put_str(TERM_L_RED, ""*"", row, col + 1);}",2,"cwe119,cwe120"
"get_unique_name(void){    const char *prefix = NULL;    const char *env = getenv(""HDF5_PREFIX"");    if (env)        prefix = env;    if (option_prefix)        prefix = option_prefix;    if (prefix)                 filename = (char *) HDmalloc(strlen(prefix) + strlen(ZIP_PERF_FILE) + 2);    else        filename = (char *) HDmalloc(strlen(ZIP_PERF_FILE) + 1);    if (!filename)        error(""out of memory"");    filename[0] = 0;    if (prefix){        strcpy(filename, prefix);        strcat(filename, ""/"");    }    strcat(filename, ZIP_PERF_FILE);}",2,"cwe120,cweother"
"clean_up_path( char *path ){tchar temp[PFS_PATH_MAX];tchar prefix[PFS_PATH_MAX];tchar rest[PFS_PATH_MAX];twhile(1) {ttif(!strncmp(path,""buffer:"",7)) {tttstrcpy(temp,path+7);tttstrcpy(path,temp);tt} else {tttif(sscanf(path,""%[^:/]:%s"",prefix,rest)==2) {ttttint plen = strlen(prefix);ttttif(!strcmp(prefix,""remote"")) {tttttstrcpy(prefix,""chirp/CONDOR"");tttt}ttttsprintf(temp,""/%s/%s"",prefix,path+plen+2);ttttdebug(D_RESOLVE,""%s -> %s"",path,temp);ttttstrcpy(path,temp);ttt} else {ttttbreak;tttt ttt}tt}t}}",4,"cwe119,cwe120,cwe476,cweother"
"initargs(int argc, char **argv){    int c;    CmdName = cmdName(argv[0]);    opterr = 0;    while ((c = getopt(argc, argv, "":gdo:"")) != -1) {tswitch (c) {tcase 'd':t    act = ToGV;t    break;tcase 'g':t    act = ToGXL;t    break;tcase 'o':t    outFile = openFile(optarg, ""w"");t    break;tcase ':':t    fprintf(stderr, ""%s: option -%c missing argument"", CmdName, optopt);t    break;tcase '?':t    if (optopt == '?')ttusage(0);t    else {ttfprintf(stderr, ""%s: option -%c unrecognized"", CmdName,tttoptopt);ttexit(1);t    }t}    }    argv += optind;    argc -= optind;    if (argc > 0)tFiles = argv;    if (!outFile)toutFile = stdout;    if (act == Unset)tsetAction();}",2,"cwe120,cweother"
"write_file(FILE *out, const unsigned char *data, int size){  long flen;  int a, len;  int sync_bits;  struct tape_buf *first, *buffer, *tmp;    flen = 0;  first = 0;  buffer = 0;    a = 0;  len = size;  while (len > 0)    {      tmp = (struct tape_buf *)malloc(sizeof(struct tape_buf));      tmp->buf = (unsigned char *)malloc(129);      tmp->next = 0;      memset(tmp->buf, 0, 129);      if (len > 129)tmemcpy(tmp->buf, data + a, 129);      elsetmemcpy(tmp->buf, data + a, len);      a += 129;      len -= 129;      tmp->blockno = tmp->buf[0];      if (buffer != 0)tbuffer->next = tmp;      if (first == 0)tfirst = tmp;      buffer = tmp;    }  buffer->blockno = 0xff;    sync_bits = 8000;  for (buffer = first;buffer != 0;buffer = buffer->next)    {      flen += write_block(out, buffer->blockno, buffer->buf + 1, sync_bits);      sync_bits = 200;    }    return flen;}",2,"cwe476,cweother"
"WriteUFOFont(char *basedir,SplineFont *sf,enum fontformat ff,int flags,tEncMap *map,int layer) {    char *foo = galloc( strlen(basedir) +20 ), *glyphdir, *gfname;    int err;    FILE *plist;    int i;    SplineChar *sc;         sprintf( foo, ""rm -rf %s"", basedir );    system( foo );    free( foo );         GFileMkDir( basedir );    err  = !UFOOutputMetaInfo(basedir,sf);    err |= !UFOOutputFontInfo(basedir,sf,layer);    err |= !UFOOutputGroups(basedir,sf);    err |= !UFOOutputKerning(basedir,sf);    err |= !UFOOutputVKerning(basedir,sf);    err |= !UFOOutputLib(basedir,sf);#ifndef Version_1    err |= !UFOOutputFeatures(basedir,sf);#endif    if ( err )return( false );    glyphdir = buildname(basedir,""glyphs"");    GFileMkDir( glyphdir );    plist = PListCreate(glyphdir,""contents.plist"");    if ( plist==NULL ) {tfree(glyphdir);return( false );    }    for ( i=0; i<sf->glyphcnt; ++i ) if ( SCWorthOutputting(sc=sf->glyphs[i]) ) {tchar *start, *gstart;tgstart = gfname = galloc(2*strlen(sc->name)+20);tstart = sc->name;tif ( *start=='.' ) {t    *gstart++ = '_';t    ++start;t}twhile ( *start ) {t     t     t     t     t     t     t     t     t    *gstart++ = *start;t    if ( isupper( *start++ ))t        *gstart++ = '_';t}#ifdef __VMSt*gstart ='0';tfor ( gstart=gfname; *gstart; ++gstart ) {t    if ( *gstart=='.' )tt*gstart = '@';tt t}#endiftstrcpy(gstart,"".glif"");tPListOutputString(plist,sc->name,gfname);terr |= !GlifDump(glyphdir,gfname,sc,layer);tfree(gfname);    }    free( glyphdir );    err |= !PListOutputTrailer(plist);return( !err );}",3,"cwe119,cwe120,cweother"
"do_underline( const char * s,              int          n ){    flps_output( ""/len (%s) SW pop def"", s );    if ( n == -1 )    {        flps_output( ""/ty CP exch pop %d sub def "", 1 + has_desc( s ) * 2 );        flps_output( ""/tx CP pop len sub def "" );        flps_output( ""tx ty M len tx add ty LT S"" );    }    else    {        char *t = fl_strdup( s );        t[ n ] = '0';        flps_output( ""/ul (%c) SW pop def"", s[ n ] );        flps_output( ""/ty CP exch pop %d sub def "",                     1 + is_desc( s [ n ] ) * 2 );        flps_output( ""/tx CP pop len sub (%s) SW pop add def"", t );        flps_output( ""tx ty M ul tx add ty LT S"" );        fl_free( t );    }}",2,"cwe119,cwe120"
"do_hardware_irq(struct ctl_table *table, int write,ttt   void __user *result,ttt   size_t *lenp, loff_t *ppos){tstruct parport *port = (struct parport *)table->extra1;tchar buffer[20];tint len = 0;tif (*ppos) {tt*lenp = 0;ttreturn 0;t}tif (write)  ttreturn -EACCES;tlen += sprintf (buffer, ""%d"", port->irq);tif (len > *lenp)ttlen = *lenp;telsett*lenp = len;t*ppos += len;treturn copy_to_user(result, buffer, len) ? -EFAULT : 0;}",2,"cwe119,cwe120"
"open_config() {    FILE *fp = NULL;    char *line;    key_cmd *cmd;    confentry *lastnode = NULL, *newnode = NULL;    int lineno = 1, n = 0, ret = 0;         if (!config)tconfig = CONFIG;    fp = fopen(config, ""r"");    if (fp == NULL) {tlprintf(""Warning: could not open the configuration file %s: %s"", config, strerror(errno));treturn OK;    }    if (verbose > 1)tlprintf(""Using configuration file %s"", config);    while (!feof(fp) && (ret >=0)) {tline = NULL;tret = getline(&line, &n, fp);tif ((ret > 0) && (proc_config(lineno, line, &cmd) == OK)) {t    newnode = (confentry *)(malloc(sizeof(confentry)));t    if (newnode == NULL) {ttlprintf(""Error: memory allocation failed"");ttclose_config();ttfree(line);ttreturn MEMERR;t    }t    newnode->cmd = cmd;t    newnode->next = NULL;t    if (list == NULL) {ttlist = newnode;t    } else {ttlastnode->next = newnode;t    }t    lastnode = newnode;t    if (verbose > 1) {ttlprintf(""Config: "");ttlprint_mask(cmd->keys);ttlprintf("" -:- %s -:- %s -:- %s"", (cmd->type == KEY)?""key"":((cmd->type == REP)?""rep"":""rel""), cmd->module, cmd->command);t    }t}tfree(line);t++lineno;    }    fclose(fp);    return OK;}",2,"cwe476,cweother"
"gbfputint16(const gbint16 i, gbfile* file){  char buf[2];  if (file->big_endian) {    be_write16(buf, i);  } else {    le_write16(buf, i);  }  return gbfwrite(buf, 1, sizeof(buf), file);}",2,"cwe119,cwe120"
"""add_bad_block(FILE *dev_ptr, int64_t thisblk, int aggr_block_size,ttt struct dinode *bb_inode){tint rc = 0;t/* Mark block allocated in map */trc = markit(thisblk, ALLOC | BADBLOCK);tif (rc != 0) {ttreturn (rc);t}t/* Add to inode: add an extent for this block to the inode's tree */trc = xtAppend(dev_ptr, bb_inode, bb_inode->di_size / aggr_block_size,tt      thisblk, 1, badblock_pages, aggr_block_size);tif (!rc) {tt/* append was successful */ttbb_inode->di_size += aggr_block_size;ttbb_inode->di_nblocks++;t}treturn rc;}""",2,"cwe119,cwe120"
"list_ip(void){tint sock, len, offs;tchar buf[512], *b, *s, *ip, *call, *dev, *ct, *mode;ttime_t t;tsock = open_socket();twsock(sock, ""list ip"");toffs = 0;tprintf(""IP Address      Port   Callsign  Mode Last update""); twhile (1) {ttlen = read(sock, buf + offs, sizeof(buf) - offs - 1);ttif (len <= 0) {tttclose(sock);tttreturn;tt}ttbuf[len + offs] = '0';tts = buf;ttfor (s = buf; (b = strchr(s, '')) != NULL; s = b + 1) {ttt*b = '0';tttif (s[0] == '.') {ttttclose(sock);ttttreturn;ttt}tttip = get_next_arg(&s);tttdev = get_next_arg(&s);tttt = strtol(get_next_arg(&s), NULL, 16);tttcall = get_next_arg(&s);tttmode = get_next_arg(&s);tttif (t == 0) {ttttct = ""(permanent)"";ttt} else {ttttct = ctime(&t);ttttct[strlen(ct) - 6] = '0';ttt}tttprintf(""%-15s %-6s %-9s %-4s %s"", ip, dev, call,ttt       mode, ct);tt}ttif (b == NULL && s != NULL) {tttoffs = strlen(s);tttif (offs)ttttmemcpy(buf, s, offs);tt}t}tclose(sock);}",2,"cwe469,cweother"
"oidm_unparse( BerVarray *res, OidMacro *start, OidMacro *end, int sys ){tOidMacro *om;tint i, j, num;tstruct berval *bva = NULL, idx;tchar ibuf[32], *ptr;tif ( !start )ttstart = LDAP_STAILQ_FIRST( &om_list );t ti = 0;tfor ( om=start; om; om=LDAP_STAILQ_NEXT(om, som_next)) {ttif ( sys && !(om->som_flags & SLAP_OM_HARDCODE)) break;ttfor ( j=0; !BER_BVISNULL(&om->som_names[j]); j++ );tti += j;ttif ( om == end ) break;t}tnum = i;tif (!i) return;tbva = ch_malloc( (num+1) * sizeof(struct berval) );tBER_BVZERO( bva+num );tidx.bv_val = ibuf;tif ( sys ) {ttidx.bv_len = 0;ttibuf[0] = '0';t}tfor ( i=0,om=start; om; om=LDAP_STAILQ_NEXT(om, som_next)) {ttif ( sys && !(om->som_flags & SLAP_OM_HARDCODE)) break;ttfor ( j=0; !BER_BVISNULL(&om->som_names[j]); i++,j++ ) {tttif ( !sys ) {ttttidx.bv_len = sprintf(idx.bv_val, ""{%d}"", i );ttt}tttbva[i].bv_len = idx.bv_len + om->som_names[j].bv_len +ttttom->som_subs[j].bv_len + 1;tttbva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );tttptr = lutil_strcopy( bva[i].bv_val, ibuf );tttptr = lutil_strcopy( ptr, om->som_names[j].bv_val );ttt*ptr++ = ' ';tttstrcpy( ptr, om->som_subs[j].bv_val );tt}ttif ( i>=num ) break;ttif ( om == end ) break;t}t*res = bva;}",2,"cwe119,cwe120"
"net_open( DirectStream *stream, const char *filename, int proto ){     DirectResult    ret  = DR_OK;     int             sock = (proto == IPPROTO_TCP) ? SOCK_STREAM : SOCK_DGRAM;     struct addrinfo hints;     char            port[16];          parse_url( filename,                 &stream->remote.host,                &stream->remote.port,                &stream->remote.user,                &stream->remote.pass,                &stream->remote.path );          snprintf( port, sizeof(port), ""%d"", stream->remote.port );     memset( &hints, 0, sizeof(hints) );     hints.ai_flags    = AI_CANONNAME;     hints.ai_socktype = sock;     hints.ai_family   = PF_UNSPEC;          if (getaddrinfo( stream->remote.host, port,                      &hints, &stream->remote.addr )) {          D_ERROR( ""Direct/Stream: ""                   ""failed to resolve host '%s'!"", stream->remote.host );          return DR_FAILURE;     }     ret = net_connect( stream->remote.addr, sock, proto, &stream->remote.sd );     if (ret)          return ret;     stream->fd     = stream->remote.sd;     stream->length = -1;      stream->wait   = net_wait;     stream->peek   = net_peek;     stream->read   = net_read;     return ret;}",2,"cwe119,cwe120"
"pin_code_request(int index, bdaddr_t *dba){tstruct dev_info *dev = &devs[index];tstruct bt_conn *conn;tchar addr[18];tint err;tba2str(dba, addr);tDBG(""hci%d PIN request for %s"", index, addr);tconn = get_connection(dev, dba);tif (conn->handle == 0)ttconn->secmode3 = TRUE;t tif (!dev->pairable && !conn->bonding_initiator) {ttDBG(""Rejecting PIN request in non-pairable mode"");ttgoto reject;t}terr = btd_event_request_pin(&dev->bdaddr, dba, FALSE);tif (err < 0) {tterror(""PIN code negative reply: %s"", strerror(-err));ttgoto reject;t}treturn;reject:thci_send_cmd(dev->sk, OGF_LINK_CTL, OCF_PIN_CODE_NEG_REPLY, 6, dba);}",2,"cwe119,cwe120"
"read_config(f)char *f;{tFILE *cf;tchar buf[256], *p;tinit_config(); tif((cf = fopen(f,""r""))==NULL){ttsyslog(LOG_ERR, ""Config file %s not found or could not be opened"",f);ttreturn -1;t}twhile(fgets(buf, 255, cf)!=NULL){ttclineno++;ttif((p = strtok(buf, "" tr"")) == NULL)continue;ttif(*p=='#' || *p==';')continue;ttif(strcmp(p,""interface"")==0)c_interface(); ttelse cerr(""Unrecognized command: %s"",p);t}tif(ifs_top==0)cerr(""No interfaces defined"","""");tif(debugd)print_config();treturn cerrflag;}",2,"cwe469,cweother"
"MtxOrb_output (Driver *drvthis, int state){tPrivateData *p = drvthis->private_data;tunsigned char out[5] = { 'xFE', 0, 0 };tstate &= 0x3F;t tp->output_state = state;tdebug(RPT_DEBUG, ""MtxOrb: output pins set: %04X"", state);tif (IS_LCD_DISPLAY || IS_VFD_DISPLAY) {tt ttout[1] = (state) ? 'W' : 'V';ttwrite(p->fd, out, 2);t}telse {ttint i;tt ttfor (i = 0; i < 6; i++) {tttout[1] = (state & (1 << i)) ? 'W' : 'V';tttout[2] = i+1;tttwrite(p->fd, out, 3);tt}t}}",2,"cwe119,cwe120"
"maildir_version_requires_migrate (const gchar *meta_filename,                                  gint *maildir_version){tFILE *metafile;tgchar cc;tgint verpos = 0;tgboolean res = FALSE;tg_return_val_if_fail (meta_filename != NULL, FALSE);tg_return_val_if_fail (maildir_version != NULL, FALSE);t t*maildir_version = -1;tif (!g_file_test (meta_filename, G_FILE_TEST_EXISTS))ttreturn TRUE;t t*maildir_version = 0;tmetafile = fopen (meta_filename, ""rb"");tif (!metafile)ttreturn FALSE;twhile (cc = fgetc (metafile), !res && !feof (metafile)) {ttif (verpos > 1 && MAILDIR_CONTENT_VERSION_STR[verpos - 1] == ' ') {tttif (cc >= '0' && cc <= '9') {tttt(*maildir_version) = (*maildir_version) * 10 + cc - '0';ttt} else if (cc == ' ' || cc == '' || cc == 'r' || cc == 't') {ttttbreak;ttt} else {ttttres = TRUE;ttt}tt} else if (cc == MAILDIR_CONTENT_VERSION_STR[verpos]) {tttverpos++;tt} else {tttres = TRUE;tt}t}tfclose (metafile);treturn res || (*maildir_version) < MAILDIR_CONTENT_VERSION;}",2,"cwe120,cweother"
"icmpv6_recv(int fd, gpointer user_data){tstruct msghdr mhdr;tstruct iovec iov;tunsigned char chdr[CMSG_BUF_LEN];tunsigned char buf[1540];tstruct rs_cb_data *data = user_data;tstruct nd_router_advert *hdr;tstruct sockaddr_in6 saddr;tssize_t len;tDBG("""");tiov.iov_len = sizeof(buf);tiov.iov_base = buf;tmhdr.msg_name = (void *)&saddr;tmhdr.msg_namelen = sizeof(struct sockaddr_in6);tmhdr.msg_iov = &iov;tmhdr.msg_iovlen = 1;tmhdr.msg_control = (void *)chdr;tmhdr.msg_controllen = CMSG_BUF_LEN;tlen = recvmsg(fd, &mhdr, 0);tif (len < 0) {ttdata->callback(NULL, 0, data->user_data);ttrs_cleanup(data);ttreturn -errno;t}thdr = (struct nd_router_advert *)buf;tDBG(""code %d len %zd hdr %zd"", hdr->nd_ra_code, len,ttttsizeof(struct nd_router_advert));tif (hdr->nd_ra_code != 0)ttreturn 0;tdata->callback(hdr, len, data->user_data);trs_cleanup(data);treturn len;}",2,"cwe119,cwe120"
"create_cache_notice(PCE *c){    chartmessage[512];    ARTICLEt*art;    art = get_articles(main_thr);    while (art && art->no < c->arts[1])tart = art->next;    if (art->no != c->arts[1])tart = NULL;    if (!art || strlen(art->subject->subject) > 200)tstrcpy(message, ""Have all parts of message/partial."");    else {tif (!art->from || strlen(art->from) > 200)t    sprintf(message,tt    ""Have all parts of message/partial article.""tt    ""Subject: %s"",tt    art->subject->subject);telset    sprintf(message,tt    ""Have all parts of message/partial article.""tt    ""From: %s""tt    ""Subject: %s"",tt    art->from, art->subject->subject);    }    c->notice =tpopup_notice(""partialnotice"", message, ""Assemble"", NULL, ""Forget"",tt     0, partial_dialogue_callback, (XtPointer)c, XtGrabNone);}",3,"cwe119,cwe120,cwe476"
"KeccakF1600_StateXORBytesInLane(void *state, unsigned int lanePosition, const unsigned char *data, unsigned int offset, unsigned int length){    unsigned int i;    for(i=0; i<length; i++)        ((unsigned char *)state)[lanePosition*8+offset+i] ^= data[i];}",2,"cwe119,cwe120"
"find_cb(void *rockp,tt   const char *key, int keylen,tt   const char *data __attribute__((unused)),tt   int datalen __attribute__((unused))){    char namebuf[MAX_MAILBOX_BUFFER];    struct find_rock *rock = (struct find_rock *) rockp;    int r = 0;    long minmatch;    struct glob *g = rock->g;         minmatch = 0;    while (minmatch >= 0) {tlong matchlen;tif(keylen >= (int) sizeof(namebuf)) {t    syslog(LOG_ERR, ""oversize keylen in mboxlist.c:find_cb()"");t    return 0;t}tmemcpy(namebuf, key, keylen);tnamebuf[keylen] = '0';tif (rock->find_namespace != NAMESPACE_INBOX &&t    rock->usermboxname &&t    !strncmp(namebuf, rock->usermboxname, rock->usermboxnamelen)t    && (keylen == rock->usermboxnamelen || ttnamebuf[rock->usermboxnamelen] == '.')) {t     t    return 0;t}t tif (rock->checkmboxlist) {t    r = mboxlist_lookup(namebuf, NULL, NULL);t} else {t    r = 0;tt t}tif (!r && rock->inboxoffset) {t    namebuf[rock->inboxoffset] = rock->inboxcase[0];t    namebuf[rock->inboxoffset+1] = rock->inboxcase[1];t    namebuf[rock->inboxoffset+2] = rock->inboxcase[2];t    namebuf[rock->inboxoffset+3] = rock->inboxcase[3];t    namebuf[rock->inboxoffset+4] = rock->inboxcase[4];t}tmatchlen = glob_test(g, namebuf+rock->inboxoffset,ttt     keylen-rock->inboxoffset, &minmatch);tif (matchlen == -1) {t    r = 0;t    break;t}tswitch (r) {tcase 0:t     t    if (rock->find_namespace == NAMESPACE_SHARED &&ttrock->checkshared && rock->namespace) {tt ttr = (*rock->proc)(rock->namespace->prefix[NAMESPACE_SHARED],tttt  strlen(rock->namespace->prefix[NAMESPACE_SHARED])-1,tttt  1, rock->procrock);ttif (rock->checkshared > 1) {tt     tt     tt    return CYRUSDB_DONE;tt}t    }t    rock->checkshared = 0;t    if (check_name(rock, namebuf+rock->inboxoffset, matchlen))ttr = (*rock->proc)(namebuf+rock->inboxoffset, matchlen,tttt  1, rock->procrock);t    break;tcase IMAP_MAILBOX_NONEXISTENT:t     t    r = 0;t    break;tdefault:t    break;t}tif (r) break;    }    return r;}",2,"cwe119,cwe120"
"gfs_source_hydrostatic_read (GtsObject ** o, GtsFile * fp){  GfsDomain * domain = GFS_DOMAIN (gfs_object_simulation (*o));  GfsSourceHydrostatic * sh;  if (GTS_OBJECT_CLASS (gfs_source_hydrostatic_class ())->parent_class->read)    (* GTS_OBJECT_CLASS (gfs_source_hydrostatic_class ())->parent_class->read) (o, fp);  if (fp->type == GTS_ERROR)    return;  sh = GFS_SOURCE_HYDROSTATIC (*o);  if (fp->type != GTS_STRING) {    gts_file_error (fp, ""expecting a string (rho)"");    return;  }  sh->rho = gfs_variable_from_name (domain->variables, fp->token->str);  if (sh->rho == NULL) {    gts_file_error (fp, ""unknown variable `%s'"", fp->token->str);    return;  }  gts_file_next_token (fp);  if (fp->type != GTS_STRING) {    gts_file_error (fp, ""expecting a string (ph)"");    return;  }  if (!(sh->ph = gfs_domain_get_or_add_variable (domain, fp->token->str, ""Hydrostatic pressure""))) {    gts_file_error (fp, ""`%s' is a reserved keyword"", fp->token->str);    return;  }  gts_file_next_token (fp);  sh->ph1 = gfs_temporary_variable (domain);}",2,"cwe120,cweother"
"main( int argc, char *argv[] ){tconst char *path;tchar buf[4096];tint result;tif(argc<2) {ttpath = ""."";t} else {ttpath = argv[1];t}tif(argc>2 || path[0]=='-') {ttprintf(""use: parrot_locate [path]"");ttreturn 0;t}tresult = parrot_locate(path,buf,sizeof(buf));tif(result < 0) {ttif(errno==ENOSYS || errno==EINVAL)tttfprintf(stderr,""locate: This filesystem doesn't support parrot_locate"");ttelsetttfprintf(stderr, ""locate: %s"", strerror(errno));ttreturn 1;t} else do {ttbuf[result] = 0;ttprintf(""%s"",buf);t} while( (result = parrot_locate(NULL,buf,sizeof(buf))) > 0);treturn 0;}",2,"cwe119,cwe120"
"tw_scsiop_request_sense(TW_Device_Extension *tw_dev, int request_id){tchar request_buffer[18];tdprintk(KERN_NOTICE ""3w-xxxx: tw_scsiop_request_sense()"");tmemset(request_buffer, 0, sizeof(request_buffer));trequest_buffer[0] = 0x70;  trequest_buffer[7] = 10;t t ttw_transfer_internal(tw_dev, request_id, request_buffer,ttt     sizeof(request_buffer));ttw_dev->state[request_id] = TW_S_COMPLETED;ttw_state_request_finish(tw_dev, request_id);t ttw_dev->srb[request_id]->result = (DID_ERROR << 16);ttw_dev->srb[request_id]->scsi_done(tw_dev->srb[request_id]);treturn 0;}",2,"cwe119,cwe120"
"poseseg_colonnes(long piste_cour[NB_FACES], LST_EQUIPO equipo,tLST_SEGMENT segx_occ[NB_FACES], LST_SEGMENT segy_occ[NB_FACES]){tPT_COORDONNEES debut_coor;tLST_PSEUDO_CON con;tLST_SEGMENT    * segcol = NULL;tlongtlargeurmin = 0, largeurvia = 0, largeurseg = 0;tchartmetalcol = 0;tptype_list     * lst_proj;tlst_proj = (equipo->cour).lst_projetes;twhile (NULL != lst_proj) {ttcon = (LST_PSEUDO_CON) ((PT_COORDONNEES)lst_proj->DATA)->proprio;ttif (NULL == con) tttringerreur(ERR_INTERNE_EQ, NULL, NULL);ttdebut_coor = (PT_COORDONNEES) lst_proj->DATA;ttswitch (con->face) {ttcase SUD :ttcase NORD:tttsegcol = segy_occ;tttmetalcol = ymetal;tttlargeurmin = ymetal_width;tttlargeurvia = ymetal_wvia;tttbreak;ttcase EST  :ttcase OUEST:tttsegcol = segx_occ;tttmetalcol = xmetal;tttlargeurvia = xmetal_wvia;tttlargeurmin = xmetal_width;tttbreak;tt}ttif (segment_libre(debut_coor, debut_coor, debut_coor->piste, piste_cour[con->face], con->face, SEG_COL, segcol,tt     metalcol)) {tttif (con->largeur > largeurvia) ttttlargeurseg = largeurvia;tttelse if (con->largeur < largeurmin) ttttlargeurseg = largeurmin;tttelse ttttlargeurseg = con->largeur;tttalloue_etchaine_segment(debut_coor, debut_coor, debut_coor->piste, piste_cour[con->face], con->face,ttt     SEG_COL, segcol, largeurseg, metalcol, VRAI_SEG, AVEC_VIA, equipo);tt}  else tttringerreur(ERR_NOCOL, (void * )con, NULL);ttlst_proj = lst_proj->NEXT;t}}",2,"cwe476,cweother"
"""getfqdomainname(char *fqdomain, size_t n){tchar hname[MAXHOSTNAMELEN], *p;tif( !(n > 0 && fqdomain))ttreturn -1;tif(getfqhostname(hname, sizeof(hname)))ttreturn -1;tp = strchr(hname, (int)'.');tif(p && *(p+1)) {ttmisc_strncpy(fqdomain, p+1, n);ttreturn 0;t}treturn -1;}""",2,"cwe119,cwe120"
"read_polynomial(const qfits_header* hdr, const char* format,ttttttt  int order, double* data, int datastride,ttttttt  anbool skip_linear, anbool skip_zero) {tint i, j;tchar key[64];tdouble nil = -HUGE_VAL;tdouble val;tfor (i=0; i<=order; i++)ttfor (j=0; (i+j)<=order; j++) {tttif (skip_zero && i+j < 1)ttttcontinue;tttif (skip_linear && (i+j < 2))ttttcontinue;tttsprintf(key, format, i, j);tttval = qfits_header_getdouble(hdr, key, nil);tttif (val == nil) {                                 if (i+j >= 2) {                    ERROR(""SIP: warning: key ""%s"" not found; setting to zero."", key);                }ttttval=0.0;ttt}tttdata[i*datastride + j] = val;tt}treturn TRUE;}",3,"cwe119,cwe120,cweother"
"MXCommand(char const *sockname,t  char const *cmd,t  char *buf,t  int len){    int fd;    struct sockaddr_un addr;    int nread;    int n;    fd = socket(AF_LOCAL, SOCK_STREAM, 0);    if (fd < 0) {tsyslog(LOG_ERR, ""MXCommand: socket: %m"");treturn MD_TEMPFAIL;    }    memset(&addr, 0, sizeof(addr));    addr.sun_family = AF_LOCAL;    strncpy(addr.sun_path, sockname, sizeof(addr.sun_path) - 1);    if (connect(fd, (struct sockaddr *) &addr, sizeof(addr)) < 0) {tsyslog(LOG_ERR, ""MXCommand: connect: %m: Is multiplexor running?"");tclose(fd);treturn MD_TEMPFAIL;    }    n = writestr(fd, cmd);    if (n < 0) {tsyslog(LOG_ERR, ""MXCommand: write: %m: Is multiplexor running?"");tclose(fd);treturn MD_TEMPFAIL;    }         nread = readn(fd, buf, len-1);    if (nread < 0) {tsyslog(LOG_ERR, ""MXCommand: read: %m: Is multiplexor running?"");tclose(fd);treturn MD_TEMPFAIL;    }    buf[nread] = 0;         if (nread == len-1) {tchar slop[SMALLBUF];tif (readn(fd, slop, SMALLBUF) > 0) {t    syslog(LOG_WARNING, ""MXCommand: Overlong reply from multiplexor was truncated!"");t     t    while (readn(fd, slop, SMALLBUF) > 0);t}    }    close(fd);    return 0;}",2,"cwe119,cwe120"
"dump_sdma_state(struct qib_pportdata *ppd){tstruct qib_sdma_desc *descq;tstruct qib_sdma_txreq *txp, *txpnext;t__le64 *descqp;tu64 desc[2];tu64 addr;tu16 gen, dwlen, dwoffset;tu16 head, tail, cnt;thead = ppd->sdma_descq_head;ttail = ppd->sdma_descq_tail;tcnt = qib_sdma_descq_freecnt(ppd);tdescq = ppd->sdma_descq;tqib_dev_porterr(ppd->dd, ppd->port,tt""SDMA ppd->sdma_descq_head: %u"", head);tqib_dev_porterr(ppd->dd, ppd->port,tt""SDMA ppd->sdma_descq_tail: %u"", tail);tqib_dev_porterr(ppd->dd, ppd->port,tt""SDMA sdma_descq_freecnt: %u"", cnt);t twhile (head != tail) {ttchar flags[6] = { 'x', 'x', 'x', 'x', 'x', 0 };ttdescqp = &descq[head].qw[0];ttdesc[0] = le64_to_cpu(descqp[0]);ttdesc[1] = le64_to_cpu(descqp[1]);ttflags[0] = (desc[0] & 1<<15) ? 'I' : '-';ttflags[1] = (desc[0] & 1<<14) ? 'L' : 'S';ttflags[2] = (desc[0] & 1<<13) ? 'H' : '-';ttflags[3] = (desc[0] & 1<<12) ? 'F' : '-';ttflags[4] = (desc[0] & 1<<11) ? 'L' : '-';ttaddr = (desc[1] << 32) | ((desc[0] >> 32) & 0xfffffffcULL);ttgen = (desc[0] >> 30) & 3ULL;ttdwlen = (desc[0] >> 14) & (0x7ffULL << 2);ttdwoffset = (desc[0] & 0x7ffULL) << 2;ttqib_dev_porterr(ppd->dd, ppd->port,ttt""SDMA sdmadesc[%u]: flags:%s addr:0x%016llx gen:%u len:%u bytes offset:%u bytes"",ttt head, flags, addr, gen, dwlen, dwoffset);ttif (++head == ppd->sdma_descq_cnt)ttthead = 0;t}t tlist_for_each_entry_safe(txp, txpnext, &ppd->sdma_activelist,tttt list)ttqib_dev_porterr(ppd->dd, ppd->port,ttt""SDMA txp->start_idx: %u txp->next_descq_idx: %u"",ttttxp->start_idx, txp->next_descq_idx);}",2,"cwe119,cwe120"
"H5FD_read(H5FD_t *file, hid_t dxpl_id, H5FD_mem_t type, haddr_t addr,    size_t size, void *buf ){    herr_t      ret_value = SUCCEED;            FUNC_ENTER_NOAPI(FAIL)    HDassert(file && file->cls);    HDassert(H5I_GENPROP_LST == H5I_get_type(dxpl_id));    HDassert(TRUE == H5P_isa_class(dxpl_id, H5P_DATASET_XFER));    HDassert(buf);#ifndef H5_HAVE_PARALLEL                   if(0 == size)        HGOTO_DONE(SUCCEED)#endif           if((file->cls->read)(file, type, dxpl_id, addr + file->base_addr, size, buf) < 0)        HGOTO_ERROR(H5E_VFL, H5E_READERROR, FAIL, ""driver read request failed"")done:    FUNC_LEAVE_NOAPI(ret_value)}",2,"cwe120,cweother"
"displaymessage(struct mame_bitmap *bitmap,const char *text)r{rtstruct DisplayText dt[2];rtint avail;rrrtif (uirotwidth < uirotcharwidth * strlen(text))rt{rttui_displaymessagewindow(bitmap,text);rttreturn;rt}rrtavail = strlen(text)+2;rrtui_drawbox(bitmap,(uirotwidth - uirotcharwidth * avail) / 2,rtttuirotheight - 3*uirotcharheight,rtttavail * uirotcharwidth,rttt2*uirotcharheight);rrtdt[0].text = text;rtdt[0].color = UI_COLOR_NORMAL;rtdt[0].x = (uirotwidth - uirotcharwidth * strlen(text)) / 2;rtdt[0].y = uirotheight - 5*uirotcharheight/2;rtdt[1].text = 0;  rtdisplaytext(bitmap,dt);r}",2,"cwe119,cwe120"
"Generate_Archi(void){  FILE *f, *g;  char str[STR_LENGTH];  char *p1, *p2;  int nb_of_used_regs = 0;  if ((f = fopen(FILE_WAM_ARCHI_DEF, ""rt"")) == NULL)    Fatal_Error(""cannot open %s"", FILE_WAM_ARCHI_DEF);  if ((g = fopen(FILE_WAM_ARCHI_H, ""wb"")) == NULL)    Fatal_Error(""cannot open %s"", FILE_WAM_ARCHI_H);  while (!feof(f) && fgets(str, sizeof(str), f))    {      if (*str != '@')t{t  fputs(str, g);t  continue;t}      strcpy(save_str, str);      p1 = Read_Identifier(str + 1, 1, &p2);      if (strcmp(p1, ""begin"") != 0)tFatal_Error(""Syntax error: incorrect @ declaration in: %s"",tt    save_str);      p1 = Read_Identifier(p2 + 1, 1, &p2);      if (strcmp(p1, ""regs"") == 0)t{t  nb_of_used_regs = Generate_Regs(f, g);t  continue;t}      if (strcmp(p1, ""tags"") == 0)t{t  Generate_Tags(f, g);t  continue;t}      if (strcmp(p1, ""stacks"") == 0)t{t  Generate_Stacks(f, g);t  continue;t}      Fatal_Error(""Syntax error: unknown section in: %s"", save_str);    }  fclose(f);  fclose(g);  return nb_of_used_regs;}",2,"cwe469,cweother"
"cressi_edy_device_read (dc_device_t *abstract, unsigned int address, unsigned char data[], unsigned int size){tcressi_edy_device_t *device = (cressi_edy_device_t*) abstract;tif ((address % SZ_PAGE != 0) ||tt(size    % SZ_PACKET != 0))ttreturn DC_STATUS_INVALIDARGS;tunsigned int nbytes = 0;twhile (nbytes < size) {tt ttunsigned int number = address / SZ_PAGE;ttunsigned char answer[3 + SZ_PACKET + 1] = {0};ttunsigned char command[3] = {0x52,tttt(number >> 8) & 0xFF,  tttt(number     ) & 0xFF};  ttdc_status_t rc = cressi_edy_transfer (device, command, sizeof (command), answer, sizeof (answer), 1);ttif (rc != DC_STATUS_SUCCESS)tttreturn rc;ttmemcpy (data, answer + 3, SZ_PACKET);ttnbytes += SZ_PACKET;ttaddress += SZ_PACKET;ttdata += SZ_PACKET;t}treturn DC_STATUS_SUCCESS;}",2,"cwe119,cwe120"
"InitializeGUCOptions(void){tintttti;tchart   *env;tlongttstack_rlimit;t tpg_timezone_pre_initialize();t tbuild_guc_variables();t tfor (i = 0; i < num_guc_variables; i++)t{ttInitializeOneGUCOption(guc_variables[i]);t}tguc_dirty = false;treporting_enabled = false;t tSetConfigOption(""transaction_isolation"", ""default"",tttttPGC_POSTMASTER, PGC_S_OVERRIDE);tSetConfigOption(""transaction_read_only"", ""no"",tttttPGC_POSTMASTER, PGC_S_OVERRIDE);t tenv = getenv(""PGPORT"");tif (env != NULL)ttSetConfigOption(""port"", env, PGC_POSTMASTER, PGC_S_ENV_VAR);tenv = getenv(""PGDATESTYLE"");tif (env != NULL)ttSetConfigOption(""datestyle"", env, PGC_POSTMASTER, PGC_S_ENV_VAR);tenv = getenv(""PGCLIENTENCODING"");tif (env != NULL)ttSetConfigOption(""client_encoding"", env, PGC_POSTMASTER, PGC_S_ENV_VAR);t tstack_rlimit = get_stack_depth_rlimit();tif (stack_rlimit > 0)t{ttinttttnew_limit = (stack_rlimit - STACK_DEPTH_SLOP) / 1024L;ttif (new_limit > 100)tt{tttcharttlimbuf[16];tttnew_limit = Min(new_limit, 2048);tttsprintf(limbuf, ""%d"", new_limit);tttSetConfigOption(""max_stack_depth"", limbuf,tttttttPGC_POSTMASTER, PGC_S_ENV_VAR);tt}t}}",3,"cwe119,cwe120,cweother"
"closeSocket(MprSocket *sp, bool gracefully){    MprSocketService    *ss;    MprTime             timesUp;    char                buf[16];    ss = MPR->socketService;    lock(sp);    if (sp->flags & MPR_SOCKET_CLOSED) {        unlock(sp);        return;    }    sp->flags |= MPR_SOCKET_CLOSED | MPR_SOCKET_EOF;    if (sp->fd >= 0) {                 mprLog(6, ""Close socket %d, graceful %d"", sp->fd, gracefully);        if (gracefully) {            mprSetSocketBlockingMode(sp, 0);            while (recv(sp->fd, buf, sizeof(buf), 0) > 0) {                ;            }        }        if (shutdown(sp->fd, SHUT_RDWR) == 0) {            if (gracefully) {                timesUp = mprGetTime() + MPR_TIMEOUT_LINGER;                do {                    if (recv(sp->fd, buf, sizeof(buf), 0) <= 0) {                        break;                    }                } while (mprGetTime() < timesUp);            }        }        closesocket(sp->fd);        sp->fd = -1;    }    if (! (sp->flags & (MPR_SOCKET_LISTENER | MPR_SOCKET_CLIENT))) {        mprLock(ss->mutex);        if (--ss->numAccept < 0) {            ss->numAccept = 0;        }        mprUnlock(ss->mutex);    }    unlock(sp);}",2,"cwe119,cwe120"
"dwim_log(const char *str, int len, unsigned char *sha1, char **log){tconst char **p;tint logs_found = 0;t*log = NULL;tfor (p = ref_rev_parse_rules; *p; p++) {ttstruct stat st;ttunsigned char hash[20];ttchar path[PATH_MAX];ttconst char *ref, *it;ttmksnpath(path, sizeof(path), *p, len, str);ttref = resolve_ref(path, hash, 1, NULL);ttif (!ref)tttcontinue;ttif (!stat(git_path(""logs/%s"", path), &st) &&tt    S_ISREG(st.st_mode))tttit = path;ttelse if (strcmp(ref, path) &&ttt !stat(git_path(""logs/%s"", ref), &st) &&ttt S_ISREG(st.st_mode))tttit = ref;ttelsetttcontinue;ttif (!logs_found++) {ttt*log = xstrdup(it);ttthashcpy(sha1, hash);tt}ttif (!warn_ambiguous_refs)tttbreak;t}treturn logs_found;}",2,"cwe119,cwe120"
"opj_getopt(int nargc, char *const *nargv, const char *ostr) {#  define __progname nargv[0]  static char *place = EMSG;t   char *oli = NULL;ttt   if (opj_optreset || !*place) {t     opj_optreset = 0;    if (opj_optind >= nargc || *(place = nargv[opj_optind]) != '-') {      place = EMSG;      return (-1);    }    if (place[1] && *++place == '-') {t       ++opj_optind;      place = EMSG;      return (-1);    }  }tttt   if ((opj_optopt = (int) *place++) == (int) ':' ||      !(oli = strchr(ostr, opj_optopt))) {         if (opj_optopt == (int) '-')      return (-1);    if (!*place)      ++opj_optind;ttif (opj_opterr && *ostr != ':') {      fprintf(stderr,tt     ""%s: illegal option -- %c"", __progname, opj_optopt);tttreturn (BADCH);tt}  }  if (*++oli != ':') {tt     opj_optarg = NULL;    if (!*place)      ++opj_optind;  } else {ttt     if (*place)ttt       opj_optarg = place;    else if (nargc <= ++opj_optind) {t       place = EMSG;      if (*ostr == ':')treturn (BADARG);tttif (opj_opterr) {ttttfprintf(stderr,tt       ""%s: option requires an argument -- %c"",tt       __progname, opj_optopt);ttttreturn (BADCH);ttt}    } elsettt       opj_optarg = nargv[opj_optind];    place = EMSG;    ++opj_optind;  }  return (opj_optopt);tt }",2,"cwe476,cweother"
"verifynsec3(dns_db_t *db, dns_dbversion_t *ver, dns_name_t *origin,t    isc_mem_t *mctx, dns_name_t *name, dns_rdata_t *rdata,t    isc_boolean_t delegation, isc_boolean_t empty,t    unsigned char types[8192], unsigned int maxtype){tchar namebuf[DNS_NAME_FORMATSIZE];tchar hashbuf[DNS_NAME_FORMATSIZE];tdns_rdataset_t rdataset;tdns_rdata_nsec3param_t nsec3param;tdns_fixedname_t fixed;tdns_name_t *hashname;tisc_result_t result;tdns_dbnode_t *node = NULL;tunsigned char rawhash[NSEC3_MAX_HASH_LENGTH];tsize_t rhsize = sizeof(rawhash);tisc_boolean_t optout;tresult = dns_rdata_tostruct(rdata, &nsec3param, NULL);tcheck_result(result, ""dns_rdata_tostruct()"");tif (nsec3param.flags != 0)ttreturn (ISC_R_SUCCESS);tif (!dns_nsec3_supportedhash(nsec3param.hash))ttreturn (ISC_R_SUCCESS);toptout = isoptout(db, ver, origin, rdata);tdns_fixedname_init(&fixed);tresult = dns_nsec3_hashname(&fixed, rawhash, &rhsize, name, origin,tttt    nsec3param.hash, nsec3param.iterations,tttt    nsec3param.salt, nsec3param.salt_length);tcheck_result(result, ""dns_nsec3_hashname()"");t tdns_rdataset_init(&rdataset);thashname = dns_fixedname_name(&fixed);tresult = dns_db_findnsec3node(db, hashname, ISC_FALSE, &node);tif (result == ISC_R_SUCCESS)ttresult = dns_db_findrdataset(db, node, ver, dns_rdatatype_nsec3,ttttt     0, 0, &rdataset, NULL);tif (result != ISC_R_SUCCESS &&t    (!delegation || (empty && !optout) ||t     (!empty && dns_nsec_isset(types, dns_rdatatype_ds))))t{ttdns_name_format(name, namebuf, sizeof(namebuf));ttdns_name_format(hashname, hashbuf, sizeof(hashbuf));ttfprintf(stderr, ""Missing NSEC3 record for %s (%s)"",tttnamebuf, hashbuf);t} else if (result == ISC_R_NOTFOUND &&tt   delegation && (!empty || optout))t{ttresult = ISC_R_SUCCESS;t} else if (result == ISC_R_SUCCESS) {ttresult = match_nsec3(name, mctx, &nsec3param, &rdataset,tttt     types, maxtype, rawhash, rhsize);t}tif (dns_rdataset_isassociated(&rdataset))ttdns_rdataset_disassociate(&rdataset);tif (node != NULL)ttdns_db_detachnode(db, &node);treturn (result);}",2,"cwe119,cwe120"
"processDiskstats( void ) {    char buf[1024];    FILE *file = NULL;    gettimeofday( &currSampling, 0 );t tif ( ( file = fopen( ""/proc/diskstats"", ""r"" ) ) == NULL )ttreturn;  t twhile (fgets(buf, sizeof(buf) - 1, file) != NULL) {ttprocess26DiskIO(buf);t}tfclose( file );t ttimeInterval = currSampling.tv_sec - lastSampling.tv_sec +ttt( currSampling.tv_usec - lastSampling.tv_usec ) / 1000000.0;tlastSampling = currSampling;tcleanup26DiskList();tDirty = 0;}",3,"cwe119,cwe120,cweother"
"xsh_pre_frameset_subtract_frame( cpl_frameset *set,                                            cpl_frame *sub,                                               const char* spec,                                            xsh_instrument *instr ){   int i=0;   int size=0;   cpl_frame* frm=NULL;   cpl_frame* cor=NULL;   cpl_frameset* result=NULL;   char filename[256];   const char * name=NULL;   size=cpl_frameset_get_size(set);   result=cpl_frameset_new();   for(i=0;i<size;i++) {      frm=cpl_frameset_get_frame(set,i);      name=cpl_frame_get_filename(frm);      sprintf(filename,""SUB_%s_%d_%s"",spec,i,name);      cor=xsh_pre_frame_subtract(frm,sub,filename,instr,1);      cpl_frameset_insert(result,cor);   }   return result;}",2,"cwe119,cwe120"
"valid_spank_job_env(char **spank_job_env,ttt        uint32_t spank_job_env_size, uid_t uid){tint i;tchar *entry;tfor (i=0; i<spank_job_env_size; i++) {ttif (!strncmp(spank_job_env[i], ""SPANK_"", 6))tttcontinue;ttentry = spank_job_env[i];ttspank_job_env[i] = xstrdup_printf (""SPANK_%s"", entry);ttxfree (entry);t}treturn true;}",2,"cwe119,cwe120"
"wpa_psk_start ( struct net80211_device *dev ){tchar passphrase[64+1];tu8 pmk[WPA_PMK_LEN];tint len;tstruct wpa_common_ctx *ctx = dev->handshaker->priv;tlen = fetch_string_setting ( netdev_settings ( dev->netdev ),tttt     &net80211_key_setting, passphrase,tttt     64 + 1 );tif ( len <= 0 ) {ttDBGC ( ctx, ""WPA-PSK %p: no passphrase provided!"", ctx );ttnet80211_deauthenticate ( dev, -EACCES );ttreturn -EACCES;t}tpbkdf2_sha1 ( passphrase, len, dev->essid, strlen ( dev->essid ),tt      4096, pmk, WPA_PMK_LEN );tDBGC ( ctx, ""WPA-PSK %p: derived PMK from passphrase `%s':"", ctx,t       passphrase );tDBGC_HD ( ctx, pmk, WPA_PMK_LEN );treturn wpa_start ( dev, ctx, pmk, WPA_PMK_LEN );}",2,"cwe119,cwe120"
"new_messages_string(MAILSTREAM *stream){    char message[80] = {'0'};    long new = 0L, uns = 0L;    int i, imapstatus = 0;    for (i = 0; ps_global->index_disp_format[i].ctype != iNothingtt&& ps_global->index_disp_format[i].ctype != iIStatustt&& ps_global->index_disp_format[i].ctype != iSIStatus; i++)      ;    imapstatus = ps_global->index_disp_format[i].ctype == iIStatustt || ps_global->index_disp_format[i].ctype == iSIStatus;    get_new_message_count(stream, imapstatus, &new, &uns);    if(imapstatus)      snprintf(message, sizeof(message), "" - %s%s%s%s%s%s%s"",t       uns != 0L ? comatose((long) new) : """",t       uns != 0L ? "" "" : """",t       uns != 0L ? _(""recent"") : """",t       uns > 0L  ? "", "" : """",t       uns != -1L ? comatose((long) uns) : """",t       uns != -1L ? "" "" : """",t       uns != -1L ? _(""unseen"") : """");    else if(!imapstatus && new > 0L)      snprintf(message, sizeof(message), "" - %s %s"",t       comatose((long) new), _(""new""));    return(*message ? cpystr(message) : NULL);}",2,"cwe119,cwe120"
"sha1_hmac_starts( sha1_context *ctx, const unsigned char *key, size_t keylen ){    size_t i;    unsigned char sum[20];    if( keylen > 64 )    {        sha1( key, keylen, sum );        keylen = 20;        key = sum;    }    memset( ctx->ipad, 0x36, 64 );    memset( ctx->opad, 0x5C, 64 );    for( i = 0; i < keylen; i++ )    {        ctx->ipad[i] = (unsigned char)( ctx->ipad[i] ^ key[i] );        ctx->opad[i] = (unsigned char)( ctx->opad[i] ^ key[i] );    }    sha1_starts( ctx );    sha1_update( ctx, ctx->ipad, 64 );    memset( sum, 0, sizeof( sum ) );}",2,"cwe119,cwe120"
"preempt(void){  int pid1, pid2, pid3;  int pfds[2];  printf(1, ""preempt: "");  pid1 = fork();  if(pid1 == 0)    for(;;)      ;  pid2 = fork();  if(pid2 == 0)    for(;;)      ;  pipe(pfds);  pid3 = fork();  if(pid3 == 0){    close(pfds[0]);    if(write(pfds[1], ""x"", 1) != 1)      printf(1, ""preempt write error"");    close(pfds[1]);    for(;;)      ;  }  close(pfds[1]);  if(read(pfds[0], buf, sizeof(buf)) != 1){    printf(1, ""preempt read error"");    return;  }  close(pfds[0]);  printf(1, ""kill... "");  kill(pid1);  kill(pid2);  kill(pid3);  printf(1, ""wait... "");  wait();  wait();  wait();  printf(1, ""preempt ok"");}",2,"cwe120,cweother"
"init(void){tconst char *path;t tif (!_root[0])t{ttconst char *dir;ttttpath = FILE_find_gambas();ttdir = FILE_get_dir(FILE_get_dir(path));ttif (dir)tttstrncpy(_root, dir, PATH_MAX);t}t#ifdef OS_64BITStstrcpy(_lib_path, FILE_cat(_root, GAMBAS_LIB64_PATH, NULL));tif (access(FILE_cat(_lib_path, ""gb.component"", NULL), F_OK))t#endifttstrcpy(_lib_path, FILE_cat(_root, GAMBAS_LIB_PATH, NULL));tttstrcpy(_info_path, FILE_cat(_root, ""share/gambas"" GAMBAS_VERSION_STRING ""/info"", NULL));tif (lt_dlinit())tterror(TRUE, ""Cannot initialize plug-in management: %s"", lt_dlerror());t }",2,"cwe120,cweother"
"fc_bsg_hostadd(struct Scsi_Host *shost, struct fc_host_attrs *fc_host){tstruct device *dev = &shost->shost_gendev;tstruct fc_internal *i = to_fc_internal(shost->transportt);tstruct request_queue *q;tint err;tchar bsg_name[20];tfc_host->rqst_q = NULL;tif (!i->f->bsg_request)ttreturn -ENOTSUPP;tsnprintf(bsg_name, sizeof(bsg_name),tt ""fc_host%d"", shost->host_no);tq = __scsi_alloc_queue(shost, fc_bsg_host_handler);tif (!q) {ttprintk(KERN_ERR ""fc_host%d: bsg interface failed to ""tttt""initialize - no request queue"",tttt shost->host_no);ttreturn -ENOMEM;t}tq->queuedata = shost;tqueue_flag_set_unlocked(QUEUE_FLAG_BIDI, q);tblk_queue_softirq_done(q, fc_bsg_softirq_done);tblk_queue_rq_timed_out(q, fc_bsg_job_timeout);tblk_queue_rq_timeout(q, FC_DEFAULT_BSG_TIMEOUT);terr = bsg_register_queue(q, dev, bsg_name, NULL);tif (err) {ttprintk(KERN_ERR ""fc_host%d: bsg interface failed to ""tttt""initialize - register queue"",ttttshost->host_no);ttblk_cleanup_queue(q);ttreturn err;t}tfc_host->rqst_q = q;treturn 0;}",2,"cwe119,cwe120"
"Monitor_HandleException(short Vector){tchar Buffer[128];tchar dump_info = 1;tchar enter_monitor = 1;tstruct _Address Source,Destination;tunsigned long SValue, DValue;tunsigned long current_PC;t tMemory_Retr(&current_PC, 32, memory_core.a[7]+4);t tMonitor_BR_EnterException();tTRACE(""handling vector=%d"", Vector);ttswitch(Vector) {tcase 2:  ttprintf(""Memory access out of bounds"");ttMonitor_RD(1, NULL);tt ttdump_info=0;ttbreak;tcase 3:  ttprintf(""Address Error: FS=4, Physical bus errror on instruction fetch"");ttbreak;tcase 4:  tt ttMonitor_BR_Entry(Vector, &enter_monitor, &dump_info);ttbreak;tcase 8:  ttprintf(""Privilege violation"");ttbreak;tcase 9:  ttMonitor_TRACE_Entry(Vector, &enter_monitor, &dump_info);ttbreak;tcase 25: case 26: case 27: case 28: case 29: case 30: case 31: tt ttprintf(""Autovector interrupt level %d"", Vector - 24);ttbreak;tcase 47:  tt ttEA_GetFromPC(&Source, 32, 0, 0);ttEA_GetValue(&SValue, &Source);ttEA_GetFromPC(&Destination, 8, 0, 1);ttTRACE(""TRAP #15: Function is 0x%02lx"", SValue);ttswitch(SValue) {ttcase 0:  tttTRACE(""TRAP #15:0x00: Return to Monitor"");tttif(!Monitor_Initialized) {ttttTRACE(""First time into the monitor.  Initializing it..."");ttttMonitor_Init();ttttMonitor_Initialized=1;ttt}tttbreak;ttcase 0x10:  ttt tttTRACE(""TRAP #15:0x10: InChar, Blocking waiting for a character..."");tttDValue=serial_getch(1);tttTRACE(""TRAP #15:0x10: Char=0x%02x(%c), storing it in D1"", DValue, DValue);ttt tttEA_PutValue(&Destination, DValue);tttenter_monitor = 0;tttbreak;ttcase 0x13:  ttt tttEA_GetValue(&DValue, &Destination);tttTRACE(""TRAP #15:0x10: Put Char=0x%02x(%c)"", DValue, DValue);tttTRACE(""mbar=%08lx"", memory_core.mbar);tttserial_putch(1, DValue);tttenter_monitor = 0;tttbreak;ttdefault:tttprintf(""Unhandled TRAP #15 exception, func=0x%lx"", SValue);tttbreak;tt}tt ttEA_PutValue(&Source, 0);tt ttdump_info=0;ttbreak;tdefault:ttprintf(""Unhandled exception, vector = 0x%x"", Vector);ttbreak;t}ttif(dump_info) {ttMonitor_RD(1, NULL);ttMonitor_InstructionDI(current_PC,Buffer);ttprintf(""%s"", Buffer);t}tif(enter_monitor) {ttMonitor_Entry();t}tt tMonitor_BR_ExitException();}",2,"cwe119,cwe120"
"encrypt9(void *key, void *vbuf, int n){tchar ekey[128], *buf;tint i, r;tif(n < 8)ttreturn 0;tkey_setup(key, ekey);tbuf = vbuf;tn--;tr = n % 7;tn /= 7;tfor(i = 0; i < n; i++){ttblock_cipher(ekey, buf, 0);ttbuf += 7;t}tif(r)ttblock_cipher(ekey, buf - 7 + r, 0);treturn 1;}",2,"cwe119,cwe120"
"test_attrname(hid_t fid, const char * string){  hid_t group_id, attr_id;  hid_t dtype_id, space_id;  hsize_t dims=1;  char read_buf[MAX_STRING_LENGTH];  herr_t ret;    group_id = H5Gcreate2(fid, GROUP4_NAME, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);  CHECK(group_id, FAIL, ""H5Gcreate2"");  space_id = H5Screate_simple(RANK, &dims, NULL);  CHECK(space_id, FAIL, ""H5Screate_simple"");  dtype_id = H5Tcopy(H5T_C_S1);  CHECK(dtype_id, FAIL, ""H5Tcopy"");  ret = H5Tset_size(dtype_id, (size_t)MAX_STRING_LENGTH);  CHECK(ret, FAIL, ""H5Tset_size"");     attr_id = H5Acreate2(group_id, string, dtype_id, space_id, H5P_DEFAULT, H5P_DEFAULT);  CHECK(attr_id, FAIL, ""H5Acreate2"");  ret = H5Aget_name(attr_id, (size_t)MAX_STRING_LENGTH, read_buf);  CHECK(ret, FAIL, ""H5Aget_name"");  ret = strcmp(read_buf, string);  VERIFY(ret, 0, ""strcmp"");  read_buf[0] = '0';     ret = H5Awrite(attr_id, dtype_id, string);  CHECK(ret, FAIL, ""H5Awrite"");  ret = H5Aread(attr_id, dtype_id, read_buf);  CHECK(ret, FAIL, ""H5Aread"");  ret = strcmp(read_buf, string);  VERIFY(ret, 0, ""strcmp"");     ret = H5Aclose(attr_id);  CHECK(ret, FAIL, ""H5Aclose"");  ret = H5Tclose(dtype_id);  CHECK(ret, FAIL, ""H5Tclose"");  ret = H5Sclose(space_id);  CHECK(ret, FAIL, ""H5Sclose"");  ret = H5Gclose(group_id);  CHECK(ret, FAIL, ""H5Gclose"");}",2,"cwe119,cwe120"
"gcm_starts( gcm_context *ctx,                int mode,                const unsigned char *iv,                size_t iv_len,                const unsigned char *add,                size_t add_len ){    int ret;    unsigned char work_buf[16];    size_t i;    const unsigned char *p;    size_t use_len, olen = 0;    memset( ctx->y, 0x00, sizeof(ctx->y) );    memset( ctx->buf, 0x00, sizeof(ctx->buf) );    ctx->mode = mode;    ctx->len = 0;    ctx->add_len = 0;    if( iv_len == 12 )    {        memcpy( ctx->y, iv, iv_len );        ctx->y[15] = 1;    }    else    {        memset( work_buf, 0x00, 16 );        PUT_UINT32_BE( iv_len * 8, work_buf, 12 );        p = iv;        while( iv_len > 0 )        {            use_len = ( iv_len < 16 ) ? iv_len : 16;            for( i = 0; i < use_len; i++ )                ctx->y[i] ^= p[i];            gcm_mult( ctx, ctx->y, ctx->y );            iv_len -= use_len;            p += use_len;        }        for( i = 0; i < 16; i++ )            ctx->y[i] ^= work_buf[i];        gcm_mult( ctx, ctx->y, ctx->y );    }    if( ( ret = cipher_update( &ctx->cipher_ctx, ctx->y, 16, ctx->base_ectr,                             &olen ) ) != 0 )    {        return( ret );    }    ctx->add_len = add_len;    p = add;    while( add_len > 0 )    {        use_len = ( add_len < 16 ) ? add_len : 16;        for( i = 0; i < use_len; i++ )            ctx->buf[i] ^= p[i];        gcm_mult( ctx, ctx->buf, ctx->buf );        add_len -= use_len;        p += use_len;    }    return( 0 );}",3,"cwe119,cwe120,cwe469"
"printListenerInfo (InnListener listener, FILE *fp, unsigned int indentAmt){  char indent [INDENT_BUFFER_SIZE] ;  unsigned int i ;    for (i = 0 ; i < MIN(INDENT_BUFFER_SIZE - 1,indentAmt) ; i++)    indent [i] = ' ' ;  indent [i] = '0' ;  fprintf (fp,""%sInnListener : %p {"",indent,(void *) listener) ;  fprintf (fp,""%s    endpoint : %p"", indent,(void *) listener->myep) ;  fprintf (fp,""%s    dummy-listener : %s"",indent,           boolToString (listener->dummyListener)) ;  fprintf (fp,""%s    dynamicPeers : %s"",indent,           boolToString (listener->dynamicPeers)) ;  fprintf (fp,""%s    input-buffer {"",indent) ;  printBufferInfo (listener->inputBuffer,fp,indentAmt + INDENT_INCR) ;  fprintf (fp,""%s    }"",indent) ;  fprintf (fp,""%s    hosts {"",indent) ;  for (i = 0 ; i < listener->hostLen ; i++)    {#if 0      if (listener->myHosts [i] != NULL)        printHostInfo (listener->myHosts [i],fp,indentAmt + INDENT_INCR) ;#else      fprintf (fp,""%s        %p"",indent,(void *) listener->myHosts[i]) ;#endif    }    fprintf (fp,""%s    }"",indent) ;    fprintf (fp,""%s}"",indent) ;}",2,"cwe119,cwe120"
"url_stream_auth (auth_client *auth_user){    ice_config_t *config;    int port;    client_t *client = auth_user->client;    auth_url *url = client->auth->state;    char *mount, *host, *user, *pass, *ipaddr, *admin="""";    char post [4096];    if (strchr (url->stream_auth, '@') == NULL)    {        if (url->userpwd)            curl_easy_setopt (url->handle, CURLOPT_USERPWD, url->userpwd);        else            curl_easy_setopt (url->handle, CURLOPT_USERPWD, """");    }    else        curl_easy_setopt (url->handle, CURLOPT_USERPWD, """");    curl_easy_setopt (url->handle, CURLOPT_URL, url->stream_auth);    curl_easy_setopt (url->handle, CURLOPT_POSTFIELDS, post);    curl_easy_setopt (url->handle, CURLOPT_WRITEHEADER, auth_user);    if (strcmp (auth_user->mount, httpp_getvar (client->parser, HTTPP_VAR_URI)) != 0)        admin = ""&admin=1"";    mount = util_url_escape (auth_user->mount);    config = config_get_config ();    host = util_url_escape (config->hostname);    port = config->port;    config_release_config ();    ipaddr = util_url_escape (client->con->ip);    if (client->username) {        user = util_url_escape(client->username);    } else {        user = strdup("""");    }    if (client->password) {        pass = util_url_escape(client->password);    } else {        pass = strdup("""");    }    snprintf (post, sizeof (post),            ""action=stream_auth&mount=%s&ip=%s&server=%s&port=%d&user=%s&pass=%s%s"",            mount, ipaddr, host, port, user, pass, admin);    free (ipaddr);    free (user);    free (pass);    free (mount);    free (host);    client->authenticated = 0;    if (curl_easy_perform (url->handle))        WARN2 (""auth to server %s failed with %s"", url->stream_auth, url->errormsg);}",2,"cwe119,cwe120"
"convert_bdb_to_sqlite3(const char *bdb_dbname){tDB *bdb;tDBT key = { 0, }, value = { 0, }, last_key = { 0, };tint res, last = 0;tchar last_key_s[MAX_DB_FIELD];tif (!(bdb = dbopen(bdb_dbname, O_RDONLY, AST_FILE_MODE, DB_BTREE, NULL))) {ttfprintf(stderr, ""Unable to open Asterisk database '%s'"", bdb_dbname);ttreturn -1;t}tif (bdb->seq(bdb, &last_key, &value, R_LAST)) {tt ttreturn 0;t}tmemcpy(last_key_s, last_key.data, MIN(last_key.size - 1, sizeof(last_key_s)));tlast_key_s[last_key.size - 1] = '0';tfor (res = bdb->seq(bdb, &key, &value, R_FIRST);ttt!res; res = bdb->seq(bdb, &key, &value, R_NEXT)) {ttlast = !strcmp(key.data, last_key_s);ttdb_put_raw((const char *) key.data, key.size - 1, (const char *) value.data, value.size - 1);ttif (last) {tttbreak;tt}t}tbdb->close(bdb);treturn 0;}",2,"cwe119,cwe120"
"setup_qualitybar (void){  int rc;  char line[ASSUAN_LINELENGTH];  char *tmpstr, *tmpstr2;  const char *tooltip;       tmpstr = try_percent_escape (_(""Quality:""), ""trfv"");  snprintf (line, DIM(line)-1, ""SETQUALITYBAR %s"", tmpstr? tmpstr:"""");  line[DIM(line)-1] = 0;  xfree (tmpstr);  rc = assuan_transact (entry_ctx, line, NULL, NULL, NULL, NULL, NULL, NULL);  if (rc == 103        || gpg_err_code (rc) == GPG_ERR_ASS_UNKNOWN_CMD)    ;    else if (rc)    return rc;    tmpstr2 = gnupg_get_help_string (""pinentry.qualitybar.tooltip"", 0);  if (tmpstr2)    tooltip = tmpstr2;  else    {             tooltip =  _(""pinentry.qualitybar.tooltip"");      if (!strcmp (""pinentry.qualitybar.tooltip"", tooltip))        tooltip = (""The quality of the text entered above.""                   ""Please ask your administrator for ""                   ""details about the criteria."");    }  tmpstr = try_percent_escape (tooltip, ""trfv"");  xfree (tmpstr2);  snprintf (line, DIM(line)-1, ""SETQUALITYBAR_TT %s"", tmpstr? tmpstr:"""");  line[DIM(line)-1] = 0;  xfree (tmpstr);  rc = assuan_transact (entry_ctx, line, NULL, NULL, NULL, NULL, NULL, NULL);  if (rc == 103            || gpg_err_code (rc) == GPG_ERR_ASS_UNKNOWN_CMD)    ;    else if (rc)    return rc;  return 0;}",3,"cwe119,cwe120,cwe469"
"OSRExportToProj4( OGRSpatialReferenceH hSRS,                                      char ** ppszReturn ){    VALIDATE_POINTER1( hSRS, ""OSRExportToProj4"", CE_Failure );    *ppszReturn = NULL;    return ((OGRSpatialReference *) hSRS)->exportToProj4( ppszReturn );}",3,"cwe119,cwe120,cweother"
"get_content_part(dchat_pdu_t* pdu, int offset, char term, char** content){    int line_end;      char* ptr;              if (offset >= pdu->content_length)    {        ui_log(LOG_ERR, ""Could not extract partial content!"");        return -1;    }      or end of content    for (ptr = (pdu->content + offset), line_end = offset; *ptr != term &&         line_end < pdu->content_length; ptr++, line_end++);         if (line_end == pdu->content_length && *(ptr - 1) != term)    {        ui_log(LOG_ERR, ""Could not extract partial content!"");        return -1;    }         *content = malloc(line_end + 2);      if (*content == NULL)    {        ui_fatal(""Memory allocation for partial content failed!"");    }         strncpy(*content, &pdu->content[offset], (line_end - offset + 1));    (*content)[line_end + 1] = '0';    return line_end;}",2,"cwe120,cweother"
"print_branch(winid win, int dnum, int lower_bound, int upper_bound, bool bymenu, struct lchoice *lchoices){    branch *br;    char buf[BUFSZ];    anything any;         for (br = branches; br; br = br->next)    {        if (br->end1.dnum == dnum && lower_bound < br->end1.dlevel &&            br->end1.dlevel <= upper_bound)        {            sprintf(buf,""   %s to %s: %d"",                    br_string(br->type),                    dungeons[br->end2.dnum].dname,                    depth(&br->end1));            if (bymenu)            {                lchoices->lev[lchoices->idx] = br->end1.dlevel;                lchoices->dgn[lchoices->idx] = br->end1.dnum;                lchoices->playerlev[lchoices->idx] = depth(&br->end1);                any.a_void = 0;                any.a_int = lchoices->idx + 1;                add_menu(win, NO_GLYPH, &any, lchoices->menuletter,                         0, ATR_NONE, buf, MENU_UNSELECTED);                if (lchoices->menuletter == 'z') lchoices->menuletter = 'A';                else lchoices->menuletter++;                lchoices->idx++;            }            else                    putstr(win, 0, buf);        }    }}",2,"cwe119,cwe120"
"set_initial_nick(struct Client *client_p, struct Client *source_p, char *nick){tchar buf[USERLEN + 1];tchar note[NICKLEN + 10];t tsource_p->tsinfo = rb_current_time();tif(!EmptyString(source_p->name))ttdel_from_hash(HASH_CLIENT, source_p->name, source_p);tmake_user(source_p);tstrcpy(source_p->user->name, nick);tsource_p->name = source_p->user->name;tadd_to_hash(HASH_CLIENT, nick, source_p);trb_snprintf(note, sizeof(note), ""Nick: %s"", nick);trb_note(client_p->localClient->F, note);tif(HasSentUser(source_p))t{ttrb_strlcpy(buf, source_p->username, sizeof(buf));tt ttregister_local_user(client_p, source_p, buf);t}}",2,"cwe119,cwe120"
"ipmi_print_user_list(tt     struct ipmi_intf *intf,tt     uint8_t channel_number){t tchar user_name[17];tstruct user_access_rsp  user_access;tuint8_t current_user_id = 1;tdot{ttif (ipmi_get_user_access(intf,ttttt channel_number,ttttt current_user_id,ttttt &user_access))tttreturn -1;ttif (ipmi_get_user_name(intf,tttt       current_user_id,tttt       user_name))tttreturn -1;ttif ((current_user_id == 0)t      ||tt    user_access.link_auth_access      ||tt    user_access.ipmi_messaging_access ||tt    strcmp("""", user_name))tt{tttif (csv_output)ttttdump_user_access_csv(current_user_id,tttttt     user_name, &user_access);tttelsettttdump_user_access(current_user_id,tttttt user_name,tttttt &user_access);tt}tt++current_user_id;t} while((current_user_id <= user_access.maximum_ids) &&ttt(current_user_id <= IPMI_UID_MAX));  treturn 0;}",3,"cwe119,cwe120,cwe469"
"add_sums_to_file(const char* hash_file_path, char* dir_path, file_set *files_to_add){tstruct rsh_stat_struct st;tFILE* fd;tunsigned i;tint ch;t tint print_banner = (opt.fmt == FMT_SFV);tst.st_size = 0;tif(rsh_stat(hash_file_path, &st) == 0) {ttif(print_banner && st.st_size > 0) print_banner = 0;t}t tif( !(fd = fopen(hash_file_path, ""r+"") )) {ttlog_file_error(hash_file_path);ttreturn -1;t}trhash_data.upd_fd = fd;tif(st.st_size > 0) {tt ttif(fseek(fd, -1, SEEK_END) != 0) {tttlog_file_error(hash_file_path);tttreturn -1;tt}ttch = fgetc(fd);tt ttif(fseek(fd, 0, SEEK_END) != 0) {tttlog_file_error(hash_file_path);tttreturn -1;tt}tt ttif(ch != '' && ch != 'r') {ttt tttfprintf(fd, """");tt}t}t tfor(i = 0; i < files_to_add->size; i++, rhash_data.processed++)t{ttfile_t file;ttchar *print_path = file_set_get(files_to_add, i)->filepath;ttfile.wpath = 0;ttif(dir_path[0] != '.' || dir_path[1] != 0) {ttt tttfile.path = make_path(dir_path, print_path);tt} else {tttfile.path = rsh_strdup(print_path);tt}ttif(opt.fmt == FMT_SFV) {tttif(print_banner) {ttttprint_sfv_banner(fd);ttttprint_banner = 0;ttt}tt}ttrsh_file_stat2(&file, 0);tt ttcalculate_and_print_sums(fd, &file, print_path);ttrsh_file_cleanup(&file);ttif(rhash_data.interrupted) {tttfclose(fd);tttreturn 0;tt}t}tfclose(fd);tlog_msg(_(""Updated: %s""), hash_file_path);treturn 0;}",2,"cwe120,cweother"
"wbt201_data_read(void){  char                line_buf[100];  struct read_state   st;  unsigned            tries;  const char          *tmp;  double              ver_hw;  double              ver_sw;  double              ver_fmt;  unsigned            log_addr_start;  unsigned            log_addr_end;  unsigned            log_area_start;  unsigned            log_area_end;  unsignedtttwantbytes;  unsignedtttread_pointer;  unsignedtttread_limit;     tmp = get_param(""@AL,7,1"", BUFSPEC(line_buf));  db(1, ""Reading device ""%s"""", tmp);  ver_hw         = get_param_float(""@AL,8,1"");  ver_sw         = get_param_float(""@AL,8,2"");  ver_fmt        = get_param_float(""@AL,8,3"");  db(2, ""versions: hw=%f, sw=%f, fmt=%f"",     ver_hw, ver_sw, ver_fmt);  log_addr_start = get_param_int(""@AL,5,1"");     log_addr_end   = get_param_int(""@AL,5,2"");     log_area_start = get_param_int(""@AL,5,9"");     log_area_end   = get_param_int(""@AL,5,10"");    db(2, ""Log addr=(%d..%d), area=(%d..%d)"",     log_addr_start, log_addr_end,     log_area_start, log_area_end);  state_init(&st);  tries = 10;     wantbytes = (log_addr_start < log_addr_end) ? log_addr_end - log_addr_start : log_area_end - (log_addr_start - log_addr_end);  read_pointer = log_addr_start;  read_limit = (log_addr_start < log_addr_end) ? log_addr_end : log_area_end;  db(2, ""Want %d bytes from device"", wantbytes);  while (wantbytes > 0) {    db(2, ""Read params: Want %d bytes, read_pointer = %d, read_limit = %d"", wantbytes, read_pointer, read_limit);    if (wbt201_read_chunk(&st, read_pointer, read_limit)) {      buf_rewind(&st.data);      wbt201_process_chunk(&st);      wantbytes -= st.data.used;      read_pointer += st.data.used;      if (read_pointer >= log_area_end) {        read_pointer = log_area_start;        read_limit = log_addr_end;      }    } else {      if (--tries <= 0) {        fatal(MYNAME "": Too many data errors during read"");      }    }  }  if (*erase != '0') {         do_simple(""@AL,5,6"", BUFSPEC(line_buf));  }  state_empty(&st);  do_simple(""@AL,2,1"", BUFSPEC(line_buf));}",2,"cwe119,cwe120"
"ras_update( void ) {    long int i, k, b, target;    long int *help_b;    TRACE ( printf(""Rank-based Ant System pheromone deposit""); );    help_b = malloc( n_ants  * sizeof(long int) );    for ( k = 0 ; k < n_ants ; k++ )thelp_b[k] = ant[k].tour_length;    for ( i = 0 ; i < ras_ranks-1 ; i++ ) {tb = help_b[0]; target = 0;tfor ( k = 0 ; k < n_ants ; k++ ) {t    if ( help_b[k] < b ) {ttb = help_b[k]; target = k;t    }t}thelp_b[target] = LONG_MAX;tglobal_update_pheromone_weighted( &ant[target], ras_ranks-i-1 );    }    global_update_pheromone_weighted( best_so_far_ant, ras_ranks );    free ( help_b );}",2,"cwe120,cweother"
"setup_hostname(void){tchar name[HOST_NAME_MAX + 1];tmemset(system_hostname, 0, sizeof(system_hostname));tif (gethostname(system_hostname, HOST_NAME_MAX) < 0) {ttconnman_error(""Failed to get current hostname"");ttreturn -EIO;t}tif (strlen(system_hostname) > 0 &&ttttstrcmp(system_hostname, ""(none)"") != 0)ttconnman_info(""System hostname is %s"", system_hostname);telsettcreate_hostname();tmemset(name, 0, sizeof(name));tif (getdomainname(name, HOST_NAME_MAX) < 0) {ttconnman_error(""Failed to get current domainname"");ttreturn -EIO;t}tif (strlen(name) > 0 && strcmp(name, ""(none)"") != 0)ttconnman_info(""System domainname is %s"", name);treturn 0;}",3,"cwe119,cwe120,cwe469"
"PyFF_ProcessInitFiles(void) {    static int done = false;    char buffer[1025], *pt;    if ( done )return;    done = true;    pt = getFontForgeShareDir();    if ( pt!=NULL ) {tsnprintf(buffer,sizeof(buffer),""%s/python"", pt );t tLoadFilesInPythonInitDir( buffer );    }         if ( getPfaEditDir(buffer)!=NULL ) {tstrcpy(buffer,getPfaEditDir(buffer));tstrcat(buffer,""/python"");tLoadFilesInPythonInitDir(buffer);    }}",2,"cwe119,cwe120"
"add_vs(const char* vs_name,            int32 file_id,            int32 vgroup_id){    int32   vdata_ref,                   vdata_tag,                   vdata_id;            int32   attr_n_values   = 3;      int32   field_n_values  = 4;      char    vd_attr[3]      = {'A', 'B', 'C'};     int32   fld_attr[4]     = {2, 4, 6, 8};        float32 data_buf[N_RECORDS][N_VALS_PER_REC];      int     i;             Vstart (file_id);             vdata_ref = -1,        vdata_id = VSattach (file_id, vdata_ref, ""w"");             if (VSsetname (vdata_id, vs_name)==FAIL){        printf( ""Could not set name for VS"");        return FAIL;    }    if (VSsetclass (vdata_id, CLASS_NAME)==FAIL){        printf( ""Could not set class for VS"");        return FAIL;    }             VSfdefine (vdata_id, FIELD1_NAME, DFNT_FLOAT32, ORDER_1 );    VSfdefine (vdata_id, FIELD2_NAME, DFNT_FLOAT32, ORDER_2 );    VSfdefine (vdata_id, FIELD3_NAME, DFNT_FLOAT32, ORDER_3 );             if (VSsetfields (vdata_id, FIELDNAME_LIST)==FAIL){        printf( ""Could not set fields for VS"");        return FAIL;    }             for (i = 0; i < N_RECORDS; i++)    {        data_buf[i][0] = (float32)1.0 * i;        data_buf[i][1] = (float32)2.0 * i;        data_buf[i][2] = (float32)3.0 * i;        data_buf[i][3] = (float32)0.1 + i;        data_buf[i][4] = 0.0;        data_buf[i][5] = 65.0;    }             if (VSwrite (vdata_id, (uint8 *)data_buf, N_RECORDS,FULL_INTERLACE)==FAIL){        printf( ""Could not write VS"");        return FAIL;    }             if (VSsetattr (vdata_id,_HDF_VDATA,""Myattr"",DFNT_CHAR,        attr_n_values, vd_attr)==FAIL){        printf( ""Could not set attr for VS"");        return FAIL;    }             if (VSsetattr (vdata_id, 0, ""Myfattr"", DFNT_INT32,         field_n_values, fld_attr)==FAIL){        printf( ""Could not set attr for VS"");        return FAIL;    }             vdata_tag = VSQuerytag (vdata_id);    vdata_ref = VSQueryref (vdata_id);             if (vgroup_id)    {        if (Vaddtagref (vgroup_id, vdata_tag, vdata_ref)==FAIL){            printf( ""Could not set group for VS"");            return FAIL;        }    }             if (VSdetach (vdata_id)==FAIL){        printf( ""Could not detach VS"");        return FAIL;    }             if (Vend (file_id)==FAIL){        printf( ""Could not end VS"");        return FAIL;    }             if (add_an(file_id, vdata_tag, vdata_ref)<0)        return FAIL;        return SUCCEED;}",2,"cwe119,cwe120"
"swap_location(ulonglong pte, char *buf){tchar swapdev[BUFSIZE];        if (!pte)                return NULL;tif (THIS_KERNEL_VERSION >= LINUX(2,6,0))ttsprintf(buf, ""%s  OFFSET: %lld"", tttget_swapdev(__swp_type(pte), swapdev), __swp_offset(pte));telsettsprintf(buf, ""%s  OFFSET: %llx"", tttget_swapdev(SWP_TYPE(pte), swapdev), SWP_OFFSET(pte));        return buf;}",2,"cwe119,cwe120"
"message(int where, const char *fmt, ...){tva_list arguments;tunsigned l;tchar msg[128];tmsg[0] = 'r';tva_start(arguments, fmt);tl = 1 + vsnprintf(msg + 1, sizeof(msg) - 2, fmt, arguments);tif (l > sizeof(msg) - 1)ttl = sizeof(msg) - 1;tva_end(arguments);#if ENABLE_FEATURE_INIT_SYSLOGtmsg[l] = '0';tif (where & L_LOG) {tt ttopenlog(applet_name, 0, LOG_DAEMON);tt ttsyslog(LOG_INFO, ""%s"", msg + 1);ttcloselog();t}tmsg[l++] = '';tmsg[l] = '0';#elset{ttstatic int log_fd = -1;ttmsg[l++] = '';ttmsg[l] = '0';tt ttif (log_fd < 0) {tttif (!log_console) {ttttlog_fd = STDERR_FILENO;ttt} else {ttttlog_fd = device_open(log_console, O_WRONLY | O_NONBLOCK | O_NOCTTY);ttttif (log_fd < 0) {tttttbb_error_msg(""can't log to %s"", log_console);tttttwhere = L_CONSOLE;tttt} else {tttttclose_on_exec_on(log_fd);tttt}ttt}tt}ttif (where & L_LOG) {tttfull_write(log_fd, msg, l);tttif (log_fd == STDERR_FILENO)ttttreturn;  tt}t}#endiftif (where & L_CONSOLE) {tt ttfull_write(STDERR_FILENO, msg, l);t}}",3,"cwe119,cwe120,cweother"
"addUserGroup (LDAP * ld, gid_t tg, char *grpnm){  LDAPMod **mods;  char *object_vals = NULL;  char **tval = NULL;  int num_tokens, i;  char *cn;  char *tn[2];  char *gn[2];  char *dn;  int num_mods = 3;  num_tokens = 0;  cn = cfg_get_str (""LDAP"", ""GROUP_CN_STRING"");  if (cn == NULL)    cn = strdup (""cn"");  tn[0] = grpnm;  tn[1] = NULL;  gn[0] = (char *) malloc (sizeof (char) * 16);  if (gn[0] == NULL)    return;  bzero (gn[0], sizeof (char) * 16);  snprintf (gn[0], sizeof (char) * 16, ""%d"", (int)tg);  gn[1] = NULL;  if ((object_vals =       strdup (cfg_get_str (""LDAP"", ""GROUP_OBJECT_CLASS""))) == NULL)    {      fprintf (stderr,t       ""GROUP_OBJECT_CLASS was not found in the configuration ""t       ""file and is required"");      return;    }  while (object_vals != NULL && *object_vals)    {      tval =t(char **) realloc (tval, sizeof (char *) * ((num_tokens + 1) * 4));      tval[num_tokens] = getToken (&object_vals, "","");      num_tokens++;    }  tval[num_tokens] = NULL;  mods = (LDAPMod **) malloc ((num_mods + 1) * sizeof (LDAPMod *));  if (mods == NULL)    {      return;    }  for (i = 0; i < num_mods; i++)    {      if ((mods[i] = (LDAPMod *) malloc (sizeof (LDAPMod))) == NULL)t{t  return;t}    }  mods[0]->mod_op = LDAP_MOD_ADD;  mods[0]->mod_type = ""objectclass"";  mods[0]->mod_values = tval;  mods[1]->mod_op = LDAP_MOD_ADD;  mods[1]->mod_type = cn;  mods[1]->mod_values = tn;  mods[2]->mod_op = LDAP_MOD_ADD;  mods[2]->mod_type = ""gidnumber"";  mods[2]->mod_values = gn;  mods[num_mods] = NULL;  dn = buildDn (GROUPADD, grpnm);  if (ldap_add_s (ld, dn, mods) != LDAP_SUCCESS)    {      CPU_ldapPerror (ld, globalLdap, ""addUserGroup: ldap_add_s"");      return;    }  return;}",5,"cwe119,cwe120,cwe476,cwe469,cweother"
"free_netbitdrv_putv_sched(struct net_t *np, int32 bi, struct itree_t *itp, i_tev_ndx tevpi) { register struct dltevlst_t *dlp; int32 evi; struct teputv_t *tepvp; struct vpi_drv_t *vpidrvp; evi = np->nwid*itp->itinum + bi; tepvp = __tevtab[tevpi].tu.teputvp; vpidrvp = np->vpi_ndrvs[tepvp->di];  dlp = vpidrvp->putv_drv_tedlst[evi];   for (; dlp != NULL; dlp = dlp->terp)    { if (tevpi == dlp->tevpi) goto found_event; }found_event:   if (dlp->telp == NULL)  {   vpidrvp->putv_drv_tedlst[evi] = dlp->terp;   if (dlp->terp != NULL) dlp->terp->telp = NULL;  }   else if (dlp->terp == NULL) dlp->telp->terp = NULL;   else { dlp->telp->terp = dlp->terp; dlp->terp->telp = dlp->telp; }   __my_free((char *) tepvp->putv_wp, 2*WRDBYTES); tepvp->putv_wp = NULL;   tepvp->np =  (struct net_t *) __teputvfreelst; __teputvfreelst = tepvp;     dlp->terp = __dltevfreelst; __dltevfreelst = dlp;   __tevtab[tevpi].tu.teputvp = NULL; __tevtab[tevpi].te_cancel = TRUE;}",2,"cwe119,cwe120"
"SWsetfillvalue(int32 swathID, char *fieldname, VOIDP fillval){    intn            status;t     int32           fid;t     int32           sdInterfaceID;t     int32           swVgrpID;t     int32           sdid;t     int32           nt;tt     int32           dims[8];t     int32           dum;t     int32           solo;t     char            name[80];t          status = SWchkswid(swathID, ""SWsetfillvalue"",tt       &fid, &sdInterfaceID, &swVgrpID);    if (status == 0)    {t tstatus = SWfieldinfo(swathID, fieldname, &dum, dims, &nt, NULL);tif (status == 0)t{t     t    status = SWSDfldsrch(swathID, sdInterfaceID, fieldname,tttt &sdid, &dum, &dum, &dum,tttt dims, &solo);t     t    if (solo == 1)t    {ttstatus = SDsetfillvalue(sdid, fillval);t    }t     t    strcpy(name, ""_FV_"");t    strcat(name, fieldname);t    status = SWwriteattr(swathID, name, nt, 1, fillval);t}telset{t    HEpush(DFE_GENAPP, ""SWsetfillvalue"", __FILE__, __LINE__);t    HEreport(""Fieldname ""%s"" does not exist."", fieldname);t}    }    return (status);}",2,"cwe119,cwe120"
"loadSound(int index, char *name){  char path[PATH_SIZE];  sprintf(path, xstr(BASE_DIR) PATH_SEP SOUND_DIR PATH_SEP ""%s.wav"", name);  fprintf(stderr, ""Loading sound: path=%s"", path);  sound[index] = Mix_LoadWAV(path);  if(!sound[index]) {    printf(""Mix_LoadWAV: name=%s path=%s error=%s"", name, path,           Mix_GetError());    SDL_Quit();  }}",3,"cwe119,cwe120,cweother"
"popd_canon_user(sasl_conn_t *conn, void *context,ttt   const char *user, unsigned ulen,ttt   unsigned flags, const char *user_realm,ttt   char *out, unsigned out_max, unsigned *out_ulen){    char userbuf[MAX_MAILBOX_BUFFER], *p;    size_t n;    int r;    if (!ulen) ulen = strlen(user);    if (config_getswitch(IMAPOPT_POPSUBFOLDERS)) {t tif (ulen >= MAX_MAILBOX_BUFFER) {t    sasl_seterror(conn, 0, ""buffer overflow while canonicalizing"");t    return SASL_BUFOVER;t}tmemcpy(userbuf, user, ulen);tuserbuf[ulen] = '0';tuser = userbuf;t tif ((p = strchr(userbuf, '+'))) {t    n = config_virtdomains ? strcspn(p, ""@"") : strlen(p);t    if (flags & SASL_CU_AUTHZID) {tt ttif (popd_subfolder) free(popd_subfolder);ttpopd_subfolder = xstrndup(p, n);t    }t     t    memmove(p, p+n, strlen(p+n)+1);t    ulen -= n;t}    }    r = mysasl_canon_user(conn, context, user, ulen, flags, user_realm,ttt  out, out_max, out_ulen);    if (!r && popd_subfolder && flags == SASL_CU_AUTHZID) {t tn = strlen(popd_subfolder);tif (*out_ulen + n > out_max) {t    sasl_seterror(conn, 0, ""buffer overflow while canonicalizing"");t    r = SASL_BUFOVER;t}telse {t    p = (config_virtdomains && (p = strchr(out, '@'))) ?ttp : out + *out_ulen;t    memmove(p+n, p, strlen(p)+1);t    memcpy(p, popd_subfolder, n);t    *out_ulen += n;t}    }    return r;}",2,"cwe119,cwe120"
"_conformant_part_geometry_get_from_env(const char *part,                                       int *sx,                                       int *sy,                                       int *sw,                                       int *sh){   const char delimiters[] = "" ,;"";   char *env_val, *token;   char buf[PATH_MAX];   int tsx, tsy, tsw;   if (!(env_val = getenv(part))) return EINA_FALSE;       strncpy(buf, env_val, sizeof(buf));   buf[PATH_MAX - 1] = '0';   token = strtok(buf, delimiters);   if (!token) return EINA_FALSE;   tsx = atoi(token);   token = strtok(NULL, delimiters);   if (!token) return EINA_FALSE;   tsy = atoi(token);   token = strtok(NULL, delimiters);   if (!token) return EINA_FALSE;   tsw = atoi(token);   token = strtok(NULL, delimiters);   if (!token) return EINA_FALSE;   *sh = atoi(token);   *sx = tsx;   *sy = tsy;   *sw = tsw;   return EINA_TRUE;}",3,"cwe119,cwe120,cweother"
"adns_reply_callback(void *data, int source, inputevt_cond_t condition){tstatic struct adns_response ans;tstatic void *buf;tstatic size_t size, pos;tg_assert(NULL == data);tg_assert(condition & INPUT_EVENT_RX);t tfor (;;) {ttssize_t ret;ttsize_t n;ttif (pos == size) {tttpos = 0;tttif (cast_to_pointer(&ans.common) == buf) {tttt ttttg_assert(ADNS_COMMON_MAGIC == ans.common.magic);ttttif (ans.common.reverse) {tttttbuf = &ans.reply.reverse;tttttsize = sizeof ans.reply.reverse;tttt} else {tttttbuf = &ans.reply.by_addr;tttttsize = sizeof ans.reply.by_addr;tttt}ttt} else {ttttif (buf) {ttttt tttttadns_reply_ready(&ans);tttt}tttt ttttbuf = &ans.common;ttttsize = sizeof ans.common;ttttans.common.magic = 0;ttt}tt}ttg_assert(buf);ttg_assert(size > 0);ttg_assert(pos < size);ttn = size - pos;ttret = read(source, cast_to_gchar_ptr(buf) + pos, n);ttif ((ssize_t) -1 == ret) {tt   tif (!is_temporary_error(errno)) {ttttg_warning(""%s: read() failed: %m"", G_STRFUNC);ttttgoto error;ttt}tttbreak;tt} else if (0 == ret) {tttg_warning(""%s: read() failed: EOF"", G_STRFUNC);tttgoto error;tt} else {tttg_assert(ret > 0);tttg_assert(UNSIGNED(ret) <= n);tttpos += (size_t) ret;tt}t}treturn;terror:tinputevt_remove(&adns_reply_event_id);tg_warning(""%s: removed myself"", G_STRFUNC);tfd_close(&source);}",2,"cwe120,cweother"
"""jid_prep(jid_t jid){    char node[MAXLEN_JID_COMP+1];    char domain[MAXLEN_JID_COMP+1];    char resource[MAXLEN_JID_COMP+1];    if(jid->node != NULL) {        strncpy(node, jid->node, MAXLEN_JID_COMP);        node[MAXLEN_JID_COMP]='0';    }    else        node[0] = '0';    if(jid->domain != NULL) {        strncpy(domain, jid->domain, MAXLEN_JID_COMP);        domain[MAXLEN_JID_COMP]='0';    }    else        domain[0] = '0';    if(jid->resource != NULL) {        strncpy(resource, jid->resource, MAXLEN_JID_COMP);        resource[MAXLEN_JID_COMP]='0';    }    else        resource[0] = '0';    if(jid_prep_pieces(node, domain, resource) != 0)        return 1;    /* put prepared components into jid */    jid_reset_components_internal(jid, node, domain, resource, 0);    return 0;}""",2,"cwe119,cwe120"
"r6rs_bytevect_to_double (s48_call_t call, s48_ref_t sch_bytevect, s48_ref_t sch_index){  long index = s48_extract_long_2(call, sch_index);  char values[8];   double resval;  long ref = 0;  while (ref < 8)    {      values[ref] = s48_byte_vector_ref_2(call, sch_bytevect, index + ref);      ++ref;    }  resval = *((double*) values);  return s48_enter_double_2(call, resval);}",2,"cwe119,cwe120"
"tps65912_irq_init(struct tps65912 *tps65912, int irq,ttt    struct tps65912_platform_data *pdata){tint ret, cur_irq;tint flags = IRQF_ONESHOT;tu8 reg;tif (!irq) {ttdev_warn(tps65912->dev, ""No interrupt support, no core IRQ"");ttreturn 0;t}tif (!pdata || !pdata->irq_base) {ttdev_warn(tps65912->dev, ""No interrupt support, no IRQ base"");ttreturn 0;t}t ttps65912->read(tps65912, TPS65912_INT_STS, 1, &reg);ttps65912->write(tps65912, TPS65912_INT_STS, 1, &reg);ttps65912->read(tps65912, TPS65912_INT_STS2, 1, &reg);ttps65912->write(tps65912, TPS65912_INT_STS2, 1, &reg);ttps65912->read(tps65912, TPS65912_INT_STS3, 1, &reg);ttps65912->write(tps65912, TPS65912_INT_STS3, 1, &reg);ttps65912->read(tps65912, TPS65912_INT_STS4, 1, &reg);ttps65912->write(tps65912, TPS65912_INT_STS4, 1, &reg);t ttps65912->irq_mask = 0xFFFFFFFF;tmutex_init(&tps65912->irq_lock);ttps65912->chip_irq = irq;ttps65912->irq_base = pdata->irq_base;ttps65912->irq_num = TPS65912_NUM_IRQ;t tfor (cur_irq = tps65912->irq_base;t     cur_irq < tps65912->irq_num + tps65912->irq_base;t     cur_irq++) {ttirq_set_chip_data(cur_irq, tps65912);ttirq_set_chip_and_handler(cur_irq, &tps65912_irq_chip,ttttt handle_edge_irq);ttirq_set_nested_thread(cur_irq, 1);ttirq_clear_status_flags(cur_irq, IRQ_NOREQUEST | IRQ_NOPROBE);t}tret = request_threaded_irq(irq, NULL, tps65912_irq, flags,tttt   ""tps65912"", tps65912);tirq_set_irq_type(irq, IRQ_TYPE_LEVEL_LOW);tif (ret != 0)ttdev_err(tps65912->dev, ""Failed to request IRQ: %d"", ret);treturn ret;}",2,"cwe120,cweother"
"c_plscmap0(PLINT *r, PLINT *g, PLINT *b, PLINT ncol0){    int i;    plscmap0n(ncol0);    for (i = 0; i < plsc->ncol0; i++) {tif ((r[i] < 0 || r[i] > 255) ||t    (g[i] < 0 || g[i] > 255) ||t    (b[i] < 0 || b[i] > 255)) {t    char buffer[256];t    sprintf(buffer, ""plscmap0: Invalid RGB color: %d, %d, %d"",tt    (int) r[i], (int) g[i], (int) b[i]);t    plabort(buffer);t    return;t}tplsc->cmap0[i].r = r[i];tplsc->cmap0[i].g = g[i];tplsc->cmap0[i].b = b[i];    }    if (plsc->level > 0)tplP_state(PLSTATE_CMAP0);}",2,"cwe119,cwe120"
"read_hypervisor_cpuid(struct lscpu_desc *desc){tunsigned int eax = 0, ebx = 0, ecx = 0, edx = 0;tchar hyper_vendor_id[13];tmemset(hyper_vendor_id, 0, sizeof(hyper_vendor_id));tcpuid(HYPERVISOR_INFO_LEAF, &eax, &ebx, &ecx, &edx);tmemcpy(hyper_vendor_id + 0, &ebx, 4);tmemcpy(hyper_vendor_id + 4, &ecx, 4);tmemcpy(hyper_vendor_id + 8, &edx, 4);thyper_vendor_id[12] = '0';tif (!hyper_vendor_id[0])ttreturn;tif (!strncmp(""XenVMMXenVMM"", hyper_vendor_id, 12))ttdesc->hyper = HYPER_XEN;telse if (!strncmp(""KVMKVMKVM"", hyper_vendor_id, 9))ttdesc->hyper = HYPER_KVM;telse if (!strncmp(""Microsoft Hv"", hyper_vendor_id, 12))ttdesc->hyper = HYPER_MSHV;telse if (!strncmp(""VMwareVMware"", hyper_vendor_id, 12))ttdesc->hyper = HYPER_VMWARE;}",2,"cwe119,cwe120"
"x86_64_framesize_cache_func(int cmd, ulong textaddr, int *framesize, int exception){tint i, n;tstruct framesize_cache *fc;tchar buf[BUFSIZE];tif (!x86_64_framesize_cache) {ttframesize_cache_entries = FRAMESIZE_CACHE_INCR;ttif ((x86_64_framesize_cache = calloc(framesize_cache_entries,tt    sizeof(struct framesize_cache))) == NULL)ttterror(FATAL, ttt    ""cannot calloc x86_64_framesize_cache space!"");t}tswitch (cmd) t{tcase FRAMESIZE_QUERY:ttfc = &x86_64_framesize_cache[0];ttfor (i = 0; i < framesize_cache_entries; i++, fc++) {tttif (fc->textaddr == textaddr) {ttttif (fc->exception != exception)tttttreturn FALSE;tttt*framesize = fc->framesize;ttttreturn TRUE;ttt}tt}ttreturn FALSE;tcase FRAMESIZE_ENTER:retry:ttfc = &x86_64_framesize_cache[0];ttfor (i = 0; i < framesize_cache_entries; i++, fc++) {tttif ((fc->textaddr == 0) ||ttt    (fc->textaddr == textaddr)) {ttttif (*framesize == -1) {tttttfc->textaddr = 0;tttttfc->framesize = 0;tttttfc->exception = 0;tttttfor (n = i+1; n < framesize_cache_entries; ttttt    i++, n++)ttttttx86_64_framesize_cache[i] = tttttttx86_64_framesize_cache[n];tttttreturn 0;tttt}ttttfc->textaddr = textaddr;ttttfc->framesize = *framesize;ttttfc->exception = exception;ttttreturn fc->framesize;ttt}tt}ttif (x86_64_framesize_cache_resize())tttgoto retry;ttreturn *framesize;tcase FRAMESIZE_DUMP:ttfc = &x86_64_framesize_cache[0];ttfor (i = 0; i < framesize_cache_entries; i++, fc++) {tttif (fc->textaddr == 0) {ttttif (i < (framesize_cache_entries-1)) {tttttfprintf(fp, ""[%d-%d]: (unused)"",tttttti, framesize_cache_entries-1);tttt}ttttbreak;ttt}tttfprintf(fp, ""[%3d]: %lx %3d %s (%s)"", i,ttttfc->textaddr, fc->framesize,ttttfc->exception ? ""EX"" : ""CF"",ttttvalue_to_symstr(fc->textaddr, buf, 0));tt}ttbreak;t}treturn TRUE;}",2,"cwe119,cwe120"
"work(char *mmp ) {   float a, b = 0.1;   char c;    char *miter = NULL, *miter_max = NULL;   char buffer[2];   if (mmp) {      miter = mmp;      miter_max = &mmp[1024*1024*malloc_mb];   }   while (!should_stop) {      a += b;       if (mmp) {         c = *miter + 1;         *miter = c;         miter += 8;         if (miter>miter_max)         miter =  mmp;      }      if (in)          read(in, buffer, 1);      if (out)          write(out, buffer, 1);   }}",3,"cwe119,cwe120,cweother"
"JustifiedPutStringFont(SDL_Surface * Surface, BFont_Info * Font, int y, char *text){tint spaces = 0;tint gap;tint single_gap;tint dif;tchar *strtmp;tchar *p;tint pos = -1;tint xpos = 0;tif (strchr(text, ' ') == NULL) {ttPutStringFont(Surface, Font, 0, y, text);t} else {ttgap = (Surface->w - 1) - TextWidthFont(Font, text);ttif (gap <= 0) {tttPutStringFont(Surface, Font, 0, y, text);tt} else {tttspaces = count(text);tttdif = gap % spaces;tttsingle_gap = (gap - dif) / spaces;tttxpos = 0;tttpos = -1;tttwhile (spaces > 0) {ttttp = strstr(&text[pos + 1], "" "");ttttstrtmp = NULL;ttttstrtmp = (char *)calloc((p - &text[pos + 1]) + 1, sizeof(char));ttttif (strtmp != NULL) {tttttstrncpy(strtmp, &text[pos + 1], (p - &text[pos + 1]));tttttPutStringFont(Surface, Font, xpos, y, strtmp);tttttxpos = xpos + TextWidthFont(Font, strtmp) + single_gap + CharWidth(Font, ' ');tttttif (dif >= 0) {ttttttxpos++;ttttttdif--;ttttt}tttttpos = p - text;tttttspaces--;tttttfree(strtmp);tttt}ttt}tttstrtmp = NULL;tttstrtmp = (char *)calloc(strlen(&text[pos + 1]) + 1, sizeof(char));tttif (strtmp != NULL) {ttttstrncpy(strtmp, &text[pos + 1], strlen(&text[pos + 1]));ttttPutStringFont(Surface, Font, xpos, y, strtmp);ttttfree(strtmp);ttt}tt}t}}",2,"cwe120,cweother"
"set_entry_int_from_field (GtkWidget * widget, const Tuple * tuple, int fieldn, bool_t editable){    char scratch[32];    if (tuple_get_value_type (tuple, fieldn, NULL) == TUPLE_INT)        snprintf (scratch, sizeof scratch, ""%d"", tuple_get_int (tuple, fieldn,         NULL));    else        scratch[0] = 0;    gtk_entry_set_text ((GtkEntry *) widget, scratch);    gtk_editable_set_editable ((GtkEditable *) widget, editable);}",2,"cwe119,cwe120"
"_calculate_cipher_keys (ipmipower_powercmd_t ip){  uint8_t managed_system_random_number[IPMI_MANAGED_SYSTEM_RANDOM_NUMBER_LENGTH];  int managed_system_random_number_len;  char *username;  char username_buf[IPMI_MAX_USER_NAME_LENGTH+1];  unsigned int username_len;  char *password;  unsigned int password_len;  void *k_g;  assert (ip);  assert (ip->protocol_state == PROTOCOL_STATE_RAKP_MESSAGE_1_SENT);     if (cmd_args.common.workaround_flags_outofband_2_0 & IPMI_PARSE_WORKAROUND_FLAGS_OUTOFBAND_2_0_INTEL_2_0_SESSION)    {      memset (username_buf, '0', IPMI_MAX_USER_NAME_LENGTH+1);      if (cmd_args.common.username)        strcpy (username_buf, cmd_args.common.username);      username = username_buf;      username_len = IPMI_MAX_USER_NAME_LENGTH;    }  else    {      username = cmd_args.common.username;      username_len = (username) ? strlen (username) : 0;    }  password = cmd_args.common.password;  password_len = (password) ? strlen (password) : 0;     if ((cmd_args.common.workaround_flags_outofband_2_0 & IPMI_PARSE_WORKAROUND_FLAGS_OUTOFBAND_2_0_INTEL_2_0_SESSION)      && ip->authentication_algorithm == IPMI_AUTHENTICATION_ALGORITHM_RAKP_HMAC_MD5      && password_len > IPMI_1_5_MAX_PASSWORD_LENGTH)    password_len = IPMI_1_5_MAX_PASSWORD_LENGTH;  if (cmd_args.common.k_g_len)    k_g = cmd_args.common.k_g;  else    k_g = NULL;  if ((managed_system_random_number_len = fiid_obj_get_data (ip->obj_rakp_message_2_res,                                                             ""managed_system_random_number"",                                                             managed_system_random_number,                                                             IPMI_MANAGED_SYSTEM_RANDOM_NUMBER_LENGTH)) < 0)    {      IPMIPOWER_ERROR ((""fiid_obj_get_data: 'managed_system_random_number': %s"",                        fiid_obj_errormsg (ip->obj_rakp_message_2_res)));      exit (1);    }  if (ipmi_calculate_rmcpplus_session_keys (ip->authentication_algorithm,                                            ip->integrity_algorithm,                                            ip->confidentiality_algorithm,                                            password,                                            password_len,                                            k_g,                                            (k_g) ? cmd_args.common.k_g_len : 0,                                            ip->remote_console_random_number,                                            IPMI_REMOTE_CONSOLE_RANDOM_NUMBER_LENGTH,                                            managed_system_random_number,                                            managed_system_random_number_len,                                            ip->name_only_lookup,                                            cmd_args.common.privilege_level,                                            username,                                            username_len,                                            &(ip->sik_key_ptr),                                            &(ip->sik_key_len),                                            &(ip->integrity_key_ptr),                                            &(ip->integrity_key_len),                                            &(ip->confidentiality_key_ptr),                                            &(ip->confidentiality_key_len)) < 0)    {      IPMIPOWER_ERROR ((""_calculate_cipher_keys(%s:%d): ipmi_calculate_rmcpplus_session_keys: %s"",                        ip->ic->hostname, ip->protocol_state, strerror (errno)));      exit (1);    }  return (0);}",2,"cwe119,cwe120"
"""_bt_search(Relation rel, int keysz, ScanKey scankey, bool nextkey,tt   Buffer *bufP, int access){tBTStackttstack_in = NULL;t/* Get the root page to start with */t*bufP = _bt_getroot(rel, access);t/* If index is empty and access = BT_READ, no root page is created. */tif (!BufferIsValid(*bufP))ttreturn (BTStack) NULL;t/* Loop iterates once per level descended in the tree */tfor (;;)t{ttPagettpage;ttBTPageOpaque opaque;ttOffsetNumber offnum;ttItemIdttitemid;ttIndexTupletitup;ttBlockNumber blkno;ttBlockNumber par_blkno;ttBTStackttnew_stack;tt/*tt * Race -- the page we just grabbed may have split since we read itstt * pointer in the parent (or metapage).  If it has, we may need tott * move right to its new sibling.  Do that.tt *tt * In write-mode, allow _bt_moveright to finish any incomplete splitstt * along the way.  Strictly speaking, we'd only need to finish antt * incomplete split on the leaf page we're about to insert to, not ontt * any of the upper levels (they are taken care of in _bt_getstackbuf,tt * if the leaf page is split and we insert to the parent page).  Buttt * this is a good opportunity to finish splits of internal pages too.tt */tt*bufP = _bt_moveright(rel, *bufP, keysz, scankey, nextkey,ttttttt  (access == BT_WRITE), stack_in,ttttttt  BT_READ);tt/* if this is a leaf page, we're done */ttpage = BufferGetPage(*bufP);ttopaque = (BTPageOpaque) PageGetSpecialPointer(page);ttif (P_ISLEAF(opaque))tttbreak;tt/*tt * Find the appropriate item on the internal page, and get the childtt * page that it points to.tt */ttoffnum = _bt_binsrch(rel, *bufP, keysz, scankey, nextkey);ttitemid = PageGetItemId(page, offnum);ttitup = (IndexTuple) PageGetItem(page, itemid);ttblkno = ItemPointerGetBlockNumber(&(itup->t_tid));ttpar_blkno = BufferGetBlockNumber(*bufP);tt/*tt * We need to save the location of the index entry we chose in thett * parent page on a stack. In case we split the tree, we'll use thett * stack to work back up to the parent page.  We also save the actualtt * downlink (TID) to uniquely identify the index entry, in case ittt * moves right while we're working lower in the tree.  See the papertt * by Lehman and Yao for how this is detected and handled. (We use thett * child link to disambiguate duplicate keys in the index -- Lehmantt * and Yao disallow duplicate keys.)tt */ttnew_stack = (BTStack) palloc(sizeof(BTStackData));ttnew_stack->bts_blkno = par_blkno;ttnew_stack->bts_offset = offnum;ttmemcpy(&new_stack->bts_btentry, itup, sizeof(IndexTupleData));ttnew_stack->bts_parent = stack_in;tt/* drop the read lock on the parent page, acquire one on the child */tt*bufP = _bt_relandgetbuf(rel, *bufP, blkno, BT_READ);tt/* okay, all set to move down a level */ttstack_in = new_stack;t}treturn stack_in;}""",2,"cwe120,cweother"
"link_player_skills(object *op) {    FOR_INV_PREPARE(op, tmp) {        if (tmp->type == SKILL) {                         if (op->contr->last_skill_ob[tmp->subtype] && op->contr->last_skill_ob[tmp->subtype] != tmp) {                LOG(llevError, ""Multiple skills with the same subtype? %s, %s"", op->contr->last_skill_ob[tmp->subtype]->skill, tmp->skill);            }            if (tmp->subtype >= NUM_SKILLS) {                LOG(llevError, ""Invalid subtype number %d (range 0-%d)"", tmp->subtype, NUM_SKILLS);            } else {                op->contr->last_skill_ob[tmp->subtype] = tmp;                op->contr->last_skill_exp[tmp->subtype] = -1;            }        }    } FOR_INV_FINISH();}",2,"cwe119,cwe120"
"ompi_io_ompio_break_file_view (mca_io_ompio_file_t *fh,                                   struct iovec *iov,                                   int count,                                   int stripe_count,                                   size_t stripe_size,                                   struct iovec **broken_iov,                                   int *broken_count){    struct iovec *temp_iov = NULL;    int i = 0;    int k = 0;    int block = 1;    int broken = 0;    size_t remaining = 0;    size_t temp = 0;    OPAL_PTRDIFF_TYPE current_offset = 0;         temp_iov = (struct iovec *) malloc         (count * sizeof (struct iovec));    if (NULL == temp_iov) {        opal_output(1, ""OUT OF MEMORY"");        return OMPI_ERR_OUT_OF_RESOURCE;    }    while (i < count) {        if (count*block <= k) {            block ++;            temp_iov = (struct iovec *)realloc                (temp_iov, count * block *sizeof(struct iovec));            if (NULL == temp_iov) {                opal_output(1, ""OUT OF MEMORY"");                return OMPI_ERR_OUT_OF_RESOURCE;            }        }        if (0 == broken) {            temp = (OPAL_PTRDIFF_TYPE)(iov[i].iov_base)%stripe_size;            if ((stripe_size-temp) >= iov[i].iov_len) {                temp_iov[k].iov_base = iov[i].iov_base;                temp_iov[k].iov_len = iov[i].iov_len;                i++;                k++;            }            else {                temp_iov[k].iov_base = iov[i].iov_base;                temp_iov[k].iov_len = stripe_size-temp;                current_offset = (OPAL_PTRDIFF_TYPE)(temp_iov[k].iov_base) +                     temp_iov[k].iov_len;                remaining = iov[i].iov_len - temp_iov[k].iov_len;                k++;                broken ++;            }            continue;        }        temp = current_offset%stripe_size;        if ((stripe_size-temp) >= remaining) {            temp_iov[k].iov_base = (IOVBASE_TYPE *)current_offset;            temp_iov[k].iov_len = remaining;            i++;            k++;            broken = 0;            current_offset = 0;            remaining = 0;        }        else {            temp_iov[k].iov_base = (IOVBASE_TYPE *)current_offset;            temp_iov[k].iov_len = stripe_size-temp;            current_offset += temp_iov[k].iov_len;            remaining -= temp_iov[k].iov_len;            k++;            broken ++;        }    }    *broken_iov = temp_iov;    *broken_count = k;    return 1;}",2,"cwe120,cweother"
"smsc2_cleanup(void){    SMSCConn *conn;    long i;    if (!smsc_running)        return;    debug(""smscconn"", 0, ""final clean-up for SMSCConn"");        gw_rwlock_wrlock(&smsc_list_lock);    for (i = 0; i < gwlist_len(smsc_list); i++) {        conn = gwlist_get(smsc_list, i);        smscconn_destroy(conn);    }    gwlist_destroy(smsc_list, NULL);    smsc_list = NULL;    gw_rwlock_unlock(&smsc_list_lock);    gwlist_destroy(smsc_groups, NULL);    octstr_destroy(unified_prefix);        numhash_destroy(white_list);    numhash_destroy(black_list);    octstr_destroy(white_list_url);    octstr_destroy(black_list_url);    if (white_list_regex != NULL)        gw_regex_destroy(white_list_regex);    if (black_list_regex != NULL)        gw_regex_destroy(black_list_regex);         counter_destroy(split_msg_counter);    gw_rwlock_destroy(&smsc_list_lock);         shutdown_concat_handler();    smsc_running = 0;}",2,"cwe119,cwe120"
"auth_ip_addr(int unit,u_int32_t addr){tu_int32_t a;tint       accept;tu_int32_t mask;tu_char    *ptr_word, *ptr_mask;tstruct hostent *hp;tstruct netent *np;tstruct wordlist *addrs;t tif (bad_ip_adrs(addr))ttreturn 0;tif ((addrs = lns[unit].addresses) == NULL)ttreturn 1;                 tfor (; addrs != NULL; addrs = addrs->next) {tt ttptr_word = addrs->word;ttif (strcmp(ptr_word, ""-"") == 0)tttbreak;tt ttif (strcmp(ptr_word, ""*"") == 0)tttreturn 1;ttaccept = 1;ttif (*ptr_word == '!') {tttaccept = 0;ttt++ptr_word;tt}ttptr_mask = strchr (ptr_word, '/');ttif (ptr_mask == NULL)tttmask = 0xFFFFFFFFUL;ttelse {tttint bit_count;ttt*ptr_mask = '0';tttbit_count = (int) strtol (ptr_mask, (char **) 0, 10);tttif (bit_count <= 0 || bit_count > 32) {ttttsyslog (LOG_WARNING,tttttt""invalid address length %s in auth. address list"",ttttttptr_mask);tttt*ptr_mask = '/';tttt continue;ttt}tttmask = ~((1UL << (32 - bit_count)) - 1UL);tt }tthp = gethostbyname(ptr_word);ttif (hp != NULL && hp->h_addrtype == AF_INET) {ttta    = *(u_int32_t *)hp->h_addr;tttmask = -1L;tt} else {tttnp = getnetbyname (ptr_word);tttif (np != NULL && np->n_addrtype == AF_INET)tttta = htonl ((unsigned long)np->n_net);tttelsetttta = inet_addr (ptr_word);tt}ttif (ptr_mask)ttt*ptr_mask = '/';ttif (a == (u_int32_t)-1L)tttsyslog (LOG_WARNING,ttttt""unknown host %s in auth. address list"",tttttaddrs->word);ttelsetttif (((addr ^ a) & mask) == 0)ttttreturn accept;t  }t return 0;                         }",2,"cwe469,cweother"
"_cb_del(void *data, void *data2 __UNUSED__){   char buf[4096];   E_Config_Dialog_Data *cfdata;   E_Confirm_Dialog *dialog;   cfdata = data;   if (cfdata->dialog_delete) return;   snprintf(buf, sizeof(buf), _(""You requested to delete ""%s"".<br><br>""                                ""Are you sure you want to delete this bar source?""),            cfdata->dir);   dialog = e_confirm_dialog_show(_(""Are you sure you want to delete this bar source?""),                                  ""application-exit"", buf, _(""Delete""), _(""Keep""),                                  _cb_confirm_dialog_yes, NULL, cfdata, NULL,                                  _cb_confirm_dialog_destroy, cfdata);   cfdata->dialog_delete = dialog;}",2,"cwe119,cwe120"
"mh_initialize(mailmessage * msg_info){  struct generic_message_t * msg;  int r;  char * uid;  char static_uid[PATH_MAX];  struct mailmh_msg_info * mh_msg_info;  chashdatum key;  chashdatum data;  struct mailmh_folder * folder;  folder = get_mh_cur_folder(msg_info);    key.data = &msg_info->msg_index;  key.len = sizeof(msg_info->msg_index);  r = chash_get(folder->fl_msgs_hash, &key, &data);  if (r < 0)    return MAIL_ERROR_INVAL;    mh_msg_info = data.data;  snprintf(static_uid, PATH_MAX, ""%u-%lu-%lu"", msg_info->msg_index,t   mh_msg_info->msg_mtime, (unsigned long) mh_msg_info->msg_size);  uid = strdup(static_uid);  if (uid == NULL)    return MAIL_ERROR_MEMORY;  r = mailmessage_generic_initialize(msg_info);  if (r != MAIL_NO_ERROR) {    free(uid);    return r;  }  msg = msg_info->msg_data;  msg->msg_prefetch = mh_prefetch;  msg->msg_prefetch_free = mh_prefetch_free;  msg_info->msg_uid = uid;  return MAIL_NO_ERROR;}",2,"cwe119,cwe120"
"DWBinit(char *prog, dwbinit *paths){    chart*prefix;    chart*value;    chart*path;    intttplen;    intttlength;    dwbinitt*opaths = paths;     if ( (prefix = DWBhome()) == NULL ) {tfprintf(stderr, ""%s: no DWB home directory"", prog);texit(1);    }t     DWBdebug(opaths, 0);    plen = strlen(prefix);    for ( ; paths->value != NULL || paths->address != NULL; paths++ ) {tif ( paths->address == NULL ) {t    length = 0;t    value = paths->value;t} else {t    length = paths->length;t    value = *paths->address;t}    tlength += plen + 1 + strlen(value);t tif ( (path = malloc(length+1)) == NULL ) {t    fprintf(stderr, ""%s: can't allocate pathname memory"", prog);t    exit(1);t}    tif ( *value != '0' ) {t    char *eop = prefix;t    while(*eop++)tt;t    eop -= 2;t    if (*value != '/' && *eop != '/') {ttsprintf(path, ""%s/%s"", prefix, value);t    } else if (*value == '/' && *eop == '/') {ttvalue++;ttsprintf(path, ""%s%s"", prefix, value);t    } elsettsprintf(path, ""%s%s"", prefix, value);t} elsettsprintf(path, ""%s"", prefix);tif ( paths->address == NULL ) {t    if ( strlen(path) >= paths->length ) {ttfprintf(stderr, ""%s: no room for %s"", prog, path);ttexit(1);t    }t t    strcpy(paths->value, path);t    free(path);t} else *paths->address = path;    }t     DWBdebug(opaths, 1);}",2,"cwe120,cweother"
"VALUE_to_string(VALUE *value, char **addr, int *len){tstatic void *jump[16] = {tt&&__VOID, &&__BOOLEAN, &&__BYTE, &&__SHORT, &&__INTEGER, &&__LONG, &&__SINGLE, &&__FLOAT, &&__DATE,tt&&__STRING, &&__STRING, &&__POINTER, &&__VARIANT, &&__FUNCTION, &&__CLASS, &&__NULLtt};__CONV:tif (TYPE_is_object(value->type))ttgoto __OBJECT;telsettgoto *jump[value->type];__NULL:t*addr = """";  t*len = 0;treturn;__BOOLEAN:tif (value->_boolean.value)t{tt*addr = (char *)LOCAL_gettext(""True"");tt*len = strlen(*addr);t}telset{tt*addr = (char *)LOCAL_gettext(""False"");tt*len = strlen(*addr);tt tt t}treturn;__BYTE:__SHORT:__INTEGER:t*len = sprintf(COMMON_buffer, ""%d"", value->_integer.value);t*addr = COMMON_buffer;treturn;__LONG:t*len = sprintf(COMMON_buffer, ""%"" PRId64, value->_long.value);t*addr = COMMON_buffer;treturn;__DATE:tLOCAL_format_date(DATE_split(value), LF_STANDARD, NULL, 0, addr, len);treturn;__SINGLE:tLOCAL_format_number(value->_single.value, LF_SHORT_NUMBER, NULL, 0, addr, len, TRUE);treturn;__FLOAT:tLOCAL_format_number(value->_float.value, LF_STANDARD, NULL, 0, addr, len, TRUE);treturn;__STRING:t*len = value->_string.len;t*addr = value->_string.addr + value->_string.start;treturn;__OBJECT:tif (VALUE_is_null(value))ttgoto __NULL;t*len = sprintf(COMMON_buffer, ""(%s %p)"", OBJECT_class(value->_object.object)->name, value->_object.object);t*addr = COMMON_buffer;treturn;__POINTER:tif (VALUE_is_null(value))ttgoto __NULL;t*len = sprintf(COMMON_buffer, ""(Pointer %p)"", value->_pointer.value);t*addr = COMMON_buffer;treturn;__VARIANT:tVARIANT_undo(value);tgoto __CONV;__VOID:tTHROW(E_NRETURN);__CLASS:t*len = sprintf(COMMON_buffer, ""(Class %s)"", value->_class.class->name);t*addr = COMMON_buffer;treturn;__FUNCTION:t t tt*len = sprintf(COMMON_buffer, ""(Function %s:%d)"", value->_function.class->name, value->_function.index);t*addr = COMMON_buffer;}",2,"cwe120,cweother"
"main(int argc, char **argv){  extern char *optarg;  int optindex = 0;  int c;  char temp[CF_BUFSIZE];  memset(PATHNAME, 0, sizeof(PATHNAME));  PROG_NAME = argv[0];  if (argc < 2)  {    Syntax();    exit(1);  }  NAME = argv[1];  if(NAME[0] == '-') {    Syntax();    exit(1);  }  argv++;  argc--;  while ((c =          getopt_long(argc, argv, ""Thtrndwyp:"", GRAPHOPTIONS, &optindex)) != EOF)  {    switch ((char)c)    {      case 't':        TITLES = true;        break;      case 'T':        TIMESTAMPS = true;        break;      case 'r':        HIRES = true;        break;      case 'n':        NOSCALING = true;        break;      case 'p':        strcpy(PATHNAME,optarg);        break;      case 'd':        daily = true;        break;      case 'w':        weekly = true;        break;      case 'y':        yearly = true;        break;      default:        Syntax();        exit(1);    }  }  if(PATHNAME[0] != '0')    sprintf(LOCATION, ""%s/%s"", PATHNAME, NAME);  else    sprintf(LOCATION, ""./%s"", NAME);  if(daily) {    snprintf(FILENAME, CF_BUFSIZE, ""%s/daily.db"", LOCATION);    ReadAverages(DAILY);    SummarizeAverages();    WriteGraphFiles(DAILY);    WriteHistogram(DAILY);    FindHurstExponents(DAILY);  }  if(weekly || (!daily && !yearly)) {    snprintf(FILENAME, CF_BUFSIZE, ""%s/weekly.db"", LOCATION);    ReadAverages(WEEKLY);    SummarizeAverages();    WriteGraphFiles(WEEKLY);    WriteHistogram(WEEKLY);    FindHurstExponents(WEEKLY);  }  if(yearly) {    snprintf(FILENAME, CF_BUFSIZE, ""%s/yearly.db"", LOCATION);    ReadAverages(YEARLY);    SummarizeAverages();    WriteGraphFiles(YEARLY);    WriteHistogram(YEARLY);    FindHurstExponents(YEARLY);  }  printf(""Done. Graph files created in directory:%s"", DIRNAME);  return 0;}",3,"cwe119,cwe120,cweother"
"""dnpds40_cleanup_string(char *start, int len){tchar *ptr = strchr(start, 0x0d);tif (ptr && (ptr - start < len)) {tt*ptr = 0x00; /* If there is a <CR>, terminate there */ttlen = ptr - start;t} else {ttstart[--len] = 0x00;  /* force null-termination */t}t/* Trim trailing spaces */twhile (len && start[len-1] == ' ') {ttstart[--len] = 0;t}}""",3,"cwe119,cwe120,cweother"
"xmt_new_od_link(GF_XMTParser *parser, GF_ObjectDescriptor *od, char *name, u32 ID){tu32 i, j, count;tXMT_ODLink *odl;tif (!ID) {ttif (!strnicmp(name, ""od"", 2)) ID = atoi(name + 2);ttelse if (!strnicmp(name, ""iod"", 3)) ID = atoi(name+ 3);tt ttelse if (sscanf(name, ""%u"", &ID) == 1) {tttchar szURL[20];tttsprintf(szURL, ""%u"", ID);tttif (strcmp(szURL, name)) {ttttID = 0;ttt} else {ttttname = NULL;ttt}tt}t}tcount = gf_list_count(parser->od_links);tfor (i=0; i<count; i++) {ttodl = (XMT_ODLink*)gf_list_get(parser->od_links, i);ttif ( (ID && (odl->ID == ID))ttt|| (odl->od == od)ttt|| (odl->desc_name && name && !strcmp(odl->desc_name, name))tt) {tttif (!odl->od) odl->od = od;tttif (!odl->desc_name && name) odl->desc_name = gf_strdup(name);tttif (!od->objectDescriptorID) {ttttod->objectDescriptorID = ID;ttt} else if (ID && (od->objectDescriptorID != ID)) {ttttxmt_report(parser, GF_BAD_PARAM, ""Conflicting OD IDs %d vs %d"", ID, od->objectDescriptorID);ttt}ttttttfor (j=i+1; j<count; j++) {ttttXMT_ODLink *l2 = (XMT_ODLink*)gf_list_get(parser->od_links, j);ttttif (l2->od == od) {tttttodl->ID = od->objectDescriptorID = odl->od->objectDescriptorID;tttttgf_list_rem(parser->od_links, j);tttttif (l2->desc_name) gf_free(l2->desc_name);tttttgf_list_del(l2->mf_urls);tttttgf_free(l2);tttttbreak;tttt}ttt}tttreturn;tt}t}tGF_SAFEALLOC(odl, XMT_ODLink);todl->mf_urls = gf_list_new();todl->od = od;tif (ID) od->objectDescriptorID = ID;tif (name) odl->desc_name = gf_strdup(name);tgf_list_add(parser->od_links, odl);}",4,"cwe119,cwe120,cwe469,cweother"
"jid_random_part(jid_t jid, jid_part_t part){    char hashBuf[41];    char randomBuf[257];    int i,r;         for(i = 0; i < 256; i++) {        r = (int) (36.0 * rand() / RAND_MAX);        randomBuf[i] = (r >= 0 && r <= 0) ? (r + 48) : (r + 87);    }    randomBuf[256] = 0;         shahash_r(randomBuf, hashBuf);         switch(part) {       case jid_NODE:           jid_reset_components(jid, hashBuf, jid->domain, jid->resource);           break;       case jid_DOMAIN:             jid_reset_components(jid, jid->node, hashBuf, jid->resource);           break;       case jid_RESOURCE:           jid_reset_components(jid, jid->node, jid->domain, hashBuf);           break;     }         jid_prep(jid);}",2,"cwe119,cwe120"
"old_save(void){tang_file *file;tchar new_savefile[1024];tchar old_savefile[1024];t tstrnfmt(new_savefile, sizeof(new_savefile), ""%s.new"", savefile);tstrnfmt(old_savefile, sizeof(old_savefile), ""%s.old"", savefile);t tsafe_setuid_grab();tfile_delete(new_savefile);tfile_delete(old_savefile);tsafe_setuid_drop();t tsafe_setuid_grab();tfile = file_open(new_savefile, MODE_WRITE, FTYPE_SAVE);tsafe_setuid_drop();tif (file)t{ttfile_write(file, (char *) &savefile_magic, 4);ttfile_write(file, (char *) &savefile_name, 4);ttcharacter_saved = try_save(file);ttfile_close(file);t}tif (character_saved)t{ttbool err = FALSE;ttsafe_setuid_grab();ttif (file_exists(savefile) && !file_move(savefile, old_savefile))ttterr = TRUE;ttif (!err)tt{tttif (!file_move(new_savefile, savefile))tttterr = TRUE;tttif (err)ttttfile_move(old_savefile, savefile);tttelsettttfile_delete(old_savefile);tt}ttsafe_setuid_drop();ttreturn err ? FALSE : TRUE;t}t tsafe_setuid_grab();tfile_delete(new_savefile);tsafe_setuid_drop();treturn FALSE;}",2,"cwe119,cwe120"
"writets(FILE *fp, long pos, struct exiftags *t, struct exifprop *p,    const unsigned char *buf, const char *ttype, const char *nts){tint ch, checkch;tlong psave;t tif (strlen(nts) != EXIFTIMELEN - 1) {ttfprintf(stderr, ""%s: invalid timestamp -- %s"", fname, nts);ttreturn (1);t}tif (!strcmp(nts, p->str)) {ttfprintf(stderr, ""%s: new %s timestamp identical to old"",tt    fname, ttype);ttreturn (1);t}t tif (iflag) {ttfprintf(stderr, ""adjust time %s in %s from  %s to %s? ""tt    ""(y/n [n]) "", ttype, fname, p->str, nts);ttcheckch = ch = getchar();ttwhile (ch != '' && ch != EOF)tttch = getchar();ttif (checkch != 'y' && checkch != 'Y') {tttfprintf(stderr, ""not adjusted"");tttreturn (1);tt}t}t tpsave = ftell(fp);tif (fseek(fp, pos + (t->md.btiff - buf) + p->value, SEEK_SET))ttexifdie((const char *)strerror(errno));t tif (fwrite(nts, EXIFTIMELEN, 1, fp) != 1)ttexifdie((const char *)strerror(errno));t tif (fseek(fp, psave, SEEK_SET))ttexifdie((const char *)strerror(errno));tif (!qflag)ttprintf(""%s%s%s -> %s"", p->descr, delim, p->str, nts);treturn (0);}",2,"cwe120,cweother"
"geo_group_id( element_model_t *model, char *name,int open ){   group_t *group,*prevgroup;   int groupid = 0;   static char str[128];   prevgroup  = model->Groups;   for( group = model->Groups; group!=NULL; group=group->Next )    {      if ( strcmp(group->Name, name) == 0 ) break;      groupid++;      prevgroup = group;   }   if ( !group )   {      if ( !prevgroup )         group = model->Groups = (group_t *)malloc(sizeof(group_t));      else         group = prevgroup->Next = (group_t *)malloc(sizeof(group_t));       sprintf( str, ""GroupStatus(%d)"", groupid );       Tcl_LinkVar( TCLInterp,str,(char *)&group->status,TCL_LINK_INT );       group->status = 1;       group->Next = NULL;       group->Name = (char *)malloc(strlen(name)+1);       strcpy(group->Name,name);   }   group->Open = open;   return groupid;}",3,"cwe119,cwe120,cweother"
"xmlRelaxNGLoadExternalRef(xmlRelaxNGParserCtxtPtr ctxt,                          const xmlChar * URL, const xmlChar * ns){    xmlRelaxNGDocumentPtr ret = NULL;    xmlDocPtr doc;    xmlNodePtr root;    int i;         for (i = 0; i < ctxt->docNr; i++) {        if (xmlStrEqual(ctxt->docTab[i]->href, URL)) {            xmlRngPErr(ctxt, NULL, XML_RNGP_EXTERNALREF_RECURSE,                       ""Detected an externalRef recursion for %s"", URL,                       NULL);            return (NULL);        }    }         doc = xmlReadFile((const char *) URL,NULL,0);    if (doc == NULL) {        xmlRngPErr(ctxt, NULL, XML_RNGP_PARSE_ERROR,                   ""xmlRelaxNG: could not load %s"", URL, NULL);        return (NULL);    }         ret = (xmlRelaxNGDocumentPtr) xmlMalloc(sizeof(xmlRelaxNGDocument));    if (ret == NULL) {        xmlRngPErr(ctxt, (xmlNodePtr) doc, XML_ERR_NO_MEMORY,                   ""xmlRelaxNG: allocate memory for doc %s"", URL, NULL);        xmlFreeDoc(doc);        return (NULL);    }    memset(ret, 0, sizeof(xmlRelaxNGDocument));    ret->doc = doc;    ret->href = xmlStrdup(URL);    ret->next = ctxt->documents;    ctxt->documents = ret;         if (ns != NULL) {        root = xmlDocGetRootElement(doc);        if (root != NULL) {            if (xmlHasProp(root, BAD_CAST ""ns"") == NULL) {                xmlSetProp(root, BAD_CAST ""ns"", ns);            }        }    }         xmlRelaxNGDocumentPush(ctxt, ret);         doc = xmlRelaxNGCleanupDoc(ctxt, doc);    if (doc == NULL) {        ctxt->doc = NULL;        return (NULL);    }    xmlRelaxNGDocumentPop(ctxt);    return (ret);}",2,"cwe119,cwe120"
"openit(const char *dirname, const char *filename){    char dirbuf[MAXPDSTRING], *nameptr;    int fd = open_via_path(dirname, filename, """", dirbuf, &nameptr,        MAXPDSTRING, 0);    if (fd >= 0)    {        close (fd);        glob_evalfile(0, gensym(nameptr), gensym(dirbuf));    }    else        error(""%s: can't open"", filename);}",2,"cwe119,cwe120"
"igb_read_pba_num_generic(struct e1000_hw *hw, u32 *pba_num){ts32  ret_val;tu16 nvm_data;tDEBUGFUNC(""igb_read_pba_num_generic"");tret_val = hw->nvm.ops.read(hw, NVM_PBA_OFFSET_0, 1, &nvm_data);tif (ret_val) {ttDEBUGOUT(""NVM Read Error"");ttgoto out;t}t*pba_num = (u32)(nvm_data << 16);tret_val = hw->nvm.ops.read(hw, NVM_PBA_OFFSET_1, 1, &nvm_data);tif (ret_val) {ttDEBUGOUT(""NVM Read Error"");ttgoto out;t}t*pba_num |= nvm_data;out:treturn ret_val;}",2,"cwe120,cweother"
"stack_set_card_size(int width, int height){  static char *suits = ""hdcs"";  static char *values = "" a234567890jqk"";  int s, v, t;  char name[30];  Stack *st;  image *ak;  if (!fronts)    fronts = (Picture **)calloc(56, sizeof(Picture *));  for (s=0; s<4; s++)    for (v=1; v<=13; v++)    {      sprintf(name, ""%c%c"", values[v], suits[s]);      fronts[v*4+s] = (Picture *)get_image(name, width, height, 0);    }  get_picture_default_width = card_width = fronts[1*4+0]->w;  get_picture_default_height = card_height = fronts[1*4+0]->h;  back = (Picture *)get_image(""back"", card_width, card_height, 0);  nodrop = (Picture *)get_image(""no-drop"", width, height, 0);  ak = get_image (""a-k"", width*4/11, width*26/11, 0);  stack_fan_right = ak->width/ak->list->across + 4;  if (stack_fan_right > card_width/3)    stack_fan_right = card_width/3;  stack_fan_down = ak->height/ak->list->down + 7;  if (stack_fan_down > card_height*2/5)    stack_fan_down = card_height*2/5;  stack_fan_tbright = 6;  stack_fan_tbdown = 6;  for (st=stacks; st; st=st->next)    stack_set_offset(st, st->fan_type);}",2,"cwe119,cwe120"
H5AC_term_interface(void){    inttn = 0;    FUNC_ENTER_NOAPI_NOINIT_NOERR    if (H5_interface_initialize_g) {#ifdef H5_HAVE_PARALLEL        if(H5AC_dxpl_id > 0 || H5AC_ind_dxpl_id > 0) {                         n = 1;                           if(H5I_dec_ref(H5AC_dxpl_id) < 0 ||                    H5I_dec_ref(H5AC_ind_dxpl_id) < 0)                H5E_clear_stack(NULL);              else {                                 H5AC_dxpl_id = (-1);                H5AC_ind_dxpl_id = (-1);                                 H5_interface_initialize_g = 0;            }          }          else#else                           H5AC_dxpl_id=(-1);            H5AC_ind_dxpl_id=(-1);#endif                           H5_interface_initialize_g = 0;    }      FUNC_LEAVE_NOAPI(n)},2,"cwe119,cwe120"
"hw_ostc_device_dump (dc_device_t *abstract, dc_buffer_t *buffer){thw_ostc_device_t *device = (hw_ostc_device_t*) abstract;t tif (!dc_buffer_clear (buffer)) {ttERROR (abstract->context, ""Insufficient buffer space available."");ttreturn DC_STATUS_NOMEMORY;t}t tdc_event_progress_t progress = EVENT_PROGRESS_INITIALIZER;tprogress.maximum = SZ_HEADER + SZ_FW_NEW;tdevice_event_emit (abstract, DC_EVENT_PROGRESS, &progress);t tunsigned char command[1] = {'a'};tint rc = serial_write (device->port, command, sizeof (command));tif (rc != sizeof (command)) {ttERROR (abstract->context, ""Failed to send the command."");ttreturn EXITCODE (rc);t}t tunsigned char header[SZ_HEADER] = {0};tint n = serial_read (device->port, header, sizeof (header));tif (n != sizeof (header)) {ttERROR (abstract->context, ""Failed to receive the header."");ttreturn EXITCODE (n);t}t tunsigned char preamble[] = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x55};tif (memcmp (header, preamble, sizeof (preamble)) != 0) {ttERROR (abstract->context, ""Unexpected answer header."");ttreturn DC_STATUS_DATAFORMAT;t}t tunsigned int firmware = array_uint16_be (header + 264);t tunsigned int size = sizeof (header);tif (firmware > FW_190)ttsize += SZ_FW_NEW;telsettsize += SZ_FW_190;t tprogress.current = sizeof (header);tprogress.maximum = size;tdevice_event_emit (abstract, DC_EVENT_PROGRESS, &progress);t tif (!dc_buffer_resize (buffer, size)) {ttERROR (abstract->context, ""Insufficient buffer space available."");ttreturn DC_STATUS_NOMEMORY;t}tunsigned char *data = dc_buffer_get_data (buffer);t tmemcpy (data, header, sizeof (header));tunsigned int nbytes = sizeof (header);twhile (nbytes < size) {tt ttunsigned int len = 1024;tt ttint available = serial_get_received (device->port);ttif (available > len)tttlen = available;tt ttif (nbytes + len > size)tttlen = size - nbytes;tt ttint n = serial_read (device->port, data + nbytes, len);ttif (n != len) {tttERROR (abstract->context, ""Failed to receive the answer."");tttreturn EXITCODE (n);tt}tt ttprogress.current += len;ttdevice_event_emit (abstract, DC_EVENT_PROGRESS, &progress);ttnbytes += len;t}treturn DC_STATUS_SUCCESS;}",2,"cwe119,cwe120"
"pre_shared_decode_hash(struct message *msg){tstruct exchange *exchange = msg->exchange;tstruct ipsec_exch *ie = exchange->data;tstruct payload *payload;tsize_t          hashsize = ie->hash->hashsize;tchar            header[80];tint             initiator = exchange->initiator;tu_int8_t      **hash_p;t thash_p = initiator ? &ie->hash_r : &ie->hash_i;tpayload = payload_first(msg, ISAKMP_PAYLOAD_HASH);tif (!payload) {ttlog_print(""pre_shared_decode_hash: no HASH payload found"");ttreturn -1;t}t tif (GET_ISAKMP_GEN_LENGTH(payload->p) - ISAKMP_GEN_SZ != hashsize)ttreturn -1;t t*hash_p = malloc(hashsize);tif (!*hash_p) {ttlog_error(""pre_shared_decode_hash: malloc (%lu) failed"",tt    (unsigned long)hashsize);ttreturn -1;t}tmemcpy(*hash_p, payload->p + ISAKMP_HASH_DATA_OFF, hashsize);tsnprintf(header, sizeof header, ""pre_shared_decode_hash: HASH_%c"",t    initiator ? 'R' : 'I');tLOG_DBG_BUF((LOG_MISC, 80, header, *hash_p, hashsize));tpayload->flags |= PL_MARK;treturn 0;}",2,"cwe119,cwe120"
"HandleReadList(char *args,char *value){ char argv[CF_MAXFARGS][CF_EXPANDSIZE];  char *sp,*filename=argv[0],*maxbytes=argv[3],*formattype=argv[1];  char *commentchar=argv[2],buffer[CF_BUFSIZE];  int val = 0;  struct Item *list = NULL,*ip;  FILE *fp;FunctionArgs(args,argv,4); val = atoi(maxbytes);   if (strcmp(formattype,""lines"") != 0)   {   snprintf(OUTPUT,CF_BUFSIZE,""Unknown format type in ReadList(%s)"",args);   CfLog(cferror,OUTPUT,"""");   }    if ((fp = fopen(filename,""r"")) == NULL)   {   snprintf(OUTPUT,CF_BUFSIZE,""Could not open ReadFile(%s)"",filename);   CfLog(cferror,OUTPUT,""fopen"");   return;   }while (!feof(fp))   {   memset(buffer,0,CF_BUFSIZE);   fgets(buffer,CF_BUFSIZE,fp);      if (strlen(commentchar) > 0)      {      for (sp = buffer; sp < buffer+strlen(buffer); sp++)           {         if (strncmp(sp,commentchar,strlen(commentchar)) == 0)            {            *sp = '0';            break;            }         }      }      Chop(buffer);   if (strlen(buffer) > 0)      {      PrependItem(&list,buffer,NULL);      }   }fclose(fp); for (ip = list; ip != NULL; ip=ip->next)   {   if (ip->name == NULL)      {      continue;      }      if (strlen(value) + strlen(ip->name) > CF_BUFSIZE)      {      snprintf(OUTPUT,CF_BUFSIZE,""Variable size exceeded in ReadList(%s)"", args);      CfLog(cferror,OUTPUT,"""");      return;      }   snprintf(value+strlen(value),CF_BUFSIZE,""%s%c"",ip->name,LISTSEPARATOR);   Verbose("" %s (added peer) = %s"",ip->name,value);               }value[strlen(value)-1] = '0';}",4,"cwe119,cwe120,cwe476,cweother"
"glusterd_start_gsync (glusterd_volinfo_t *master_vol, char *slave,                      char *glusterd_uuid_str, char **op_errstr){        int32_t         ret     = 0;        int32_t         status  = 0;        char            buf[PATH_MAX]   = {0,};        char            uuid_str [64] = {0};        runner_t        runner = {0,};        xlator_t        *this = NULL;        glusterd_conf_t *priv = NULL;        int             errcode = 0;        this = THIS;        GF_ASSERT (this);        priv = this->private;        GF_ASSERT (priv);        uuid_utoa_r (priv->uuid, uuid_str);        if (strcmp (uuid_str, glusterd_uuid_str))                goto out;        ret = gsync_status (master_vol->volname, slave, &status);        if (status == 0)                goto out;        snprintf (buf, PATH_MAX, ""%s/""GEOREP""/%s"", priv->workdir, master_vol->volname);        ret = mkdir_if_missing (buf);        if (ret) {                errcode = -1;                goto out;        }        snprintf (buf, PATH_MAX, DEFAULT_LOG_FILE_DIRECTORY""/""GEOREP""/%s"",                  master_vol->volname);        ret = mkdir_if_missing (buf);        if (ret) {                errcode = -1;                goto out;        }        uuid_utoa_r (master_vol->volume_id, uuid_str);        runinit (&runner);        runner_add_args  (&runner, GSYNCD_PREFIX""/gsyncd"", ""-c"", NULL);        runner_argprintf (&runner, ""%s/""GSYNC_CONF, priv->workdir);        runner_argprintf (&runner, "":%s"", master_vol->volname);        runner_add_args  (&runner, slave, ""--config-set"", ""session-owner"",                          uuid_str, NULL);        ret = runner_run (&runner);        if (ret == -1) {                errcode = -1;                goto out;        }        runinit (&runner);        runner_add_args  (&runner, GSYNCD_PREFIX""/gsyncd"", ""--monitor"", ""-c"", NULL);        runner_argprintf (&runner, ""%s/""GSYNC_CONF, priv->workdir);        runner_argprintf (&runner, "":%s"", master_vol->volname);        runner_add_arg   (&runner, slave);        ret = runner_run (&runner);        if (ret == -1) {                gf_asprintf (op_errstr, GEOREP"" start failed for %s %s"",                             master_vol->volname, slave);                goto out;        }        ret = 0;out:        if ((ret != 0) && errcode == -1) {                if (op_errstr)                        *op_errstr = gf_strdup (""internal error, cannot start""                                                ""the "" GEOREP "" session"");        }        gf_log ("""", GF_LOG_DEBUG, ""Returning %d"", ret);        return ret;}",4,"cwe119,cwe120,cwe469,cweother"
"AHB_SWIFT_ReadDocument(GWEN_FAST_BUFFER *fb,ttt   AHB_SWIFT_TAG_LIST *tl,ttt   unsigned int maxTags) {  int rv;  int c;  int isFullSwift=0;  int subDocs=0;     for (;;) {    GWEN_FASTBUFFER_PEEKBYTE(fb, c);    if (c<0) {      if (c==GWEN_ERROR_EOF) {tDBG_INFO(AQBANKING_LOGDOMAIN,tt ""EOF met, empty document"");treturn 1;      }      DBG_ERROR(AQBANKING_LOGDOMAIN,tt""Error reading from BIO (%d)"", c);      return c;    }    if (c=='{') {      isFullSwift=1;      break;    }    else if (c>3)             break;    GWEN_FASTBUFFER_READBYTE(fb, c);  }    if (isFullSwift) {         for (;;) {      int err;      char swhead[4];      unsigned int bsize;      int curls=0;             for (;;) {tGWEN_FASTBUFFER_PEEKBYTE(fb, c);tif (c<0) {t  if (c==GWEN_ERROR_EOF) {t    DBG_INFO(AQBANKING_LOGDOMAIN, ""EOF met, empty block"");t    if (subDocs>0) {t      DBG_INFO(AQBANKING_LOGDOMAIN, ""We got %d data blocks, returning"", subDocs);t      return 0;t    }t    return 1;t  }t  DBG_ERROR(AQBANKING_LOGDOMAIN,tt    ""Error reading from BIO (%d)"", c);t  return c;t}tif (c=='{') {t  break;t}tGWEN_FASTBUFFER_READBYTE(fb, c);      }               bsize=3;      GWEN_FASTBUFFER_READFORCED(fb, err, swhead, bsize);      if (err<0) {        DBG_ERROR_ERR(AQBANKING_LOGDOMAIN, err);treturn err;      }      if (swhead[2]!=':') {        DBG_ERROR(AQBANKING_LOGDOMAIN, ""Not a SWIFT block"");tGWEN_Text_DumpString(swhead, 4, 2);treturn GWEN_ERROR_BAD_DATA;      }             DBG_DEBUG(0, ""Reading block %d"", swhead[1]-'0');      if (swhead[1]=='4') {t trv=AHB_SWIFT__ReadDocument(fb, tl, maxTags);tif (rv) {t  DBG_INFO(AQBANKING_LOGDOMAIN, ""here (%d)"", rv);t  return rv;t}tsubDocs++;      }             for (;;) {tGWEN_FASTBUFFER_READBYTE(fb, c);tif (c<0) {t  if (c==GWEN_ERROR_EOF) {t    DBG_ERROR(AQBANKING_LOGDOMAIN,tt      ""EOF met (%d)"", c);t    return GWEN_ERROR_EOF;t  }t  DBG_ERROR(AQBANKING_LOGDOMAIN,tt    ""Error reading from BIO (%d)"", c);t  return GWEN_ERROR_READ;t}tif (c=='{')t  curls++;telse if (c=='}') {t  if (curls==0)t    break;t  elset    curls--;t}      }      }    }  else {         rv=AHB_SWIFT__ReadDocument(fb, tl, maxTags);    if (rv)      return rv;  }  return 0;}",3,"cwe119,cwe120,cweother"
"derive_keys(const struct krb5_enc_provider *enc, krb5_key key,            krb5_keyusage usage, krb5_key *ke_out, krb5_key *ki_out){    krb5_error_code ret;    unsigned char buf[K5CLENGTH];    krb5_data constant = make_data(buf, K5CLENGTH);    krb5_key ke, ki;    *ke_out = *ki_out = NULL;         store_32_be(usage, buf);    buf[4] = 0xAA;    ret = krb5int_derive_key(enc, key, &ke, &constant, DERIVE_SP800_108_CMAC);    if (ret != 0)        return ret;         buf[4] = 0x55;    ret = krb5int_derive_key(enc, key, &ki, &constant, DERIVE_SP800_108_CMAC);    if (ret != 0) {        krb5_k_free_key(NULL, ke);        return ret;    }    *ke_out = ke;    *ki_out = ki;    return 0;}",2,"cwe119,cwe120"
"maildir_cache_save(const char *a, time_t b, const char *homedir,tt      uid_t u, gid_t g){chartbuf[2048];chartbuf2[NUMBUFSIZE];pid_ttp;inttwaitstat;tstrcat(strcpy(buf, a), "" "");tstrcat(strcat(buf, libmail_str_time_t(b, buf2)), "" "");tstrcat(strcat(buf, libmail_str_uid_t(u, buf2)), "" "");tstrcat(strcat(buf, libmail_str_gid_t(g, buf2)), "" "");tstrncat(buf, homedir, sizeof(buf)-2-strlen(homedir));tstrcat(buf, """");tif (savebuf(buf, strlen(buf)) == 0)t{tintti;ttfor (i=0; authvars[i]; i++)tt{ttconst char *p;tttstrcat(strcpy(buf, authvars[i]), ""="");tttp=getenv(authvars[i]);tttif (!p || strlen(p)+strlen(buf) >= sizeof(buf)-2 ||ttttstrchr(p, ''))ttttcontinue;tttstrcat(strcat(buf, p), """");tttif (savebuf(buf, strlen(buf)))tbreak;tt}t}tclose(childpipe);twhile ((p=wait(&waitstat)) != -1 && p != childproc)tt;tchildproc= -1;}",3,"cwe119,cwe120,cweother"
"giraffe_image_copy_matrix(GiImage *self, cpl_matrix *matrix){    const cxchar *const fctid = ""giraffe_image_copy_matrix"";    cxint nrow = 0;    cxint ncol = 0;    cxdouble *elements = NULL;    cx_assert(self != NULL);    if (matrix == NULL) {        return 1;    }    nrow = cpl_matrix_get_nrow(matrix);    ncol = cpl_matrix_get_ncol(matrix);    cx_assert(nrow > 0 && ncol > 0);    elements = cpl_matrix_get_data(matrix);    cx_assert(elements != NULL);    if (self->pixels != NULL) {        if (cpl_image_get_size_x(self->pixels) != ncol ||            cpl_image_get_size_y(self->pixels) != nrow) {                cpl_image_delete(self->pixels);                self->pixels = cpl_image_new(ncol, nrow, self->type);            }    }    else {        self->pixels = cpl_image_new(ncol, nrow, self->type);    }    switch (self->type) {    case CPL_TYPE_INT:    {        cxsize i;        cxsize sz = nrow * ncol;        cxint *pixels = cpl_image_get_data_int(self->pixels);        for (i = 0; i < sz; i++) {            pixels[i] = (cxint) elements[i];        }        break;    }    case CPL_TYPE_FLOAT:    {        cxsize i;        cxsize sz = nrow * ncol;        cxfloat *pixels = cpl_image_get_data_float(self->pixels);        for (i = 0; i < sz; i++) {            pixels[i] = (cxfloat) elements[i];        }        break;    }    case CPL_TYPE_DOUBLE:    {        cxsize sz = nrow * ncol * sizeof(cxdouble);        cxptr pixels = cpl_image_get_data(self->pixels);        memcpy(pixels, elements, sz);        break;    }    default:        cpl_error_set(fctid, CPL_ERROR_INVALID_TYPE);        return 1;        break;    }    return 0;}",2,"cwe120,cwe476"
"Update(double value, time_t u_time, int dbtype){ struct Average average;  char *timekey;  int i, j;update_time = u_time;VALUE = value;if(PATHNAME[0] != '0')   {   sprintf(LOCATION, ""%s/%s"", PATHNAME, NAME);   }else   {   sprintf(LOCATION, ""./%s"", NAME);   }switch(dbtype)   {   case DAILY:       sprintf(AVDB, ""%s/daily.db"", LOCATION);       break;   case YEARLY:       sprintf(AVDB, ""%s/yearly.db"", LOCATION);       break;   default:         sprintf(AVDB, ""%s/weekly.db"", LOCATION);       break;   }Verbose(""Updating database: %s"", AVDB);LOCALAV.expect = 0.0;LOCALAV.var = 0.0;ITER = 0.0;for (i = 0; i < 7; i++)   {   for (j = 0; j < CF_GRAINS; j++)      {      HISTOGRAM[i][j] = 0;      }   }if (OpenDatabase(false) != 0)   {   exit(1);   }srand((unsigned int)time(NULL));LoadHistogram(dbtype);GetDatabaseAge(dbtype);timekey = GenTimeKey2(update_time, dbtype);Verbose(""Time key is: %s"", timekey);average = EvalAvQ(timekey, dbtype, true);CloseDatabase();return ArmClasses(average, timekey);}",2,"cwe120,cweother"
"printauth(struct authinfo *authinfo, void *vp){tinttfd= *(int *)vp;tchartbuf2[NUMBUFSIZE];tchart*fullopt;twriteptr=buf;twriteleft=sizeof(buf);tcourier_authdebug_authinfo(""Authenticated: "", authinfo,tttt   authinfo->clearpasswd,tttt   authinfo->passwd);tif (authinfo->sysusername)ttif (writeenvval(fd, ""USERNAME"", authinfo->sysusername))tttreturn (1);tif (authinfo->sysuserid)ttif (writeenvval(fd, ""UID"", libmail_str_uid_t(*authinfo->sysuserid,tttbuf2)))tttreturn (1);tif (writeenvval(fd, ""GID"", libmail_str_uid_t(authinfo->sysgroupid, buf2)))tttreturn (1);tif (writeenvval(fd, ""HOME"", authinfo->homedir))tttreturn (1);tif (authinfo->address)ttif (writeenvval(fd, ""ADDRESS"", authinfo->address))tttreturn (1);tif (authinfo->fullname)t{tt t tchar *fullname;ttchar *p;ttint retval;ttfullname=strdup(authinfo->fullname);ttif(fullname == NULL)tt{tttperror(""strdup"");tttreturn (1);tt}ttp = fullname;ttwhile (*p != ',' && *p != '0')tttp++;tt*p=0; ttretval = writeenvval(fd, ""NAME"", fullname);ttfree(fullname);ttif(retval)tttreturn (1);t}tif (authinfo->maildir)ttif (writeenvval(fd, ""MAILDIR"", authinfo->maildir))tttreturn (1);tif (authinfo->quota)ttif (writeenvval(fd, ""QUOTA"", authinfo->quota))tttreturn (1);tif (authinfo->passwd)ttif (writeenvval(fd, ""PASSWD"", authinfo->passwd))tttreturn (1);tif (authinfo->clearpasswd)ttif (writeenvval(fd, ""PASSWD2"", authinfo->clearpasswd))tttreturn (1);tfullopt = mergeoptions(authinfo->options);tif (fullopt)t{ttint rc = writeenvval(fd, ""OPTIONS"", fullopt);ttfree(fullopt);ttif (rc)tttreturn (1);t}tif (writeauthbuf(fd, ""."", 2) || writeauthflush(fd))ttreturn (1);treturn (0);}",2,"cwe119,cwe120"
"check_files() {ttokens fields;ttttt tchar *character;tfile_list *current_file;tchar current_line[LINE_LENGTH];  tsize_t tabs;t tif (verbose) {ttglobal_comments = 0;ttlocal_comments = 0;ttmaximum_no_of_spines = 0;ttminimum_no_of_spines = 0;ttnumber_of_data_records = 0;ttnull_tokens = 0;ttadded_spines = 0;ttterminated_spines = 0;ttsplit_spines = 0;ttjoined_spines = 0;ttexchanged_spines = 0;t}t tcurrent_file = file_header->next_file;twhile (current_file != NULL) {ttif (strcmp(current_file->file_name,""STDIN"") == 0) {tttcurrent_file->stream = stdin;tt} else {tttcurrent_file->stream = fopen(current_file->file_name,READ_ONLY);tt}tt ttfnr = 1;ttstrcpy(current_filename,current_file->file_name);ttnew_path = FALSE;ttcurrent_no_of_spines = 0;ttfirst_interpretation_yet = FALSE;tt ttfgets(current_line,LINE_LENGTH,current_file->stream);ttcharacter = strchr(current_line,NEWLINE);ttif (character != NULL) {ttt*character = TERMINATE;tt}ttwhile (!feof(current_file->stream)) {ttt tttif (strcmp(current_line,""0"") == 0) {tttttprint_syntax_error(ERROR2);ttt} else {tttt ttttif (strncmp(current_line,TAB,1) == 0) {tttttprint_syntax_error(ERROR3);tttt}tttt tttt tttttabs = strspn(current_line,TAB);ttttcharacter = current_line + tabs;ttttif (strncmp(character,""!!"",2) == 0) {tttttprocess_global();tttt} else {ttttt tttttcharacter = strrchr(current_line,TAB_CHAR);tttttif (character != NULL) {ttttttcharacter += 1;ttttttif (*character == TERMINATE) {tttttttprint_syntax_error(ERROR4);tttttt}ttttt}tttttif (strstr(current_line,CONSECUTIVE_TABS) != NULL) {ttttttprint_syntax_error(ERROR5);ttttt} tttttt ttttt ttttt ttttttsplit_string(current_line,TAB,&fields);ttttttif (fields.number > 0)tttttt{ttttttif (strncmp(fields.token[0],""!"",1) == 0)tttttttprocess_local(fields);ttttttelse if (strncmp(fields.token[0],""*"",1) == 0)tttttttprocess_interpretation(fields);ttttttelsetttttttprocess_data(fields);ttttttfree_tokens(fields);tttttt}tttt}ttt}tttfnr += 1;tttfgets(current_line,LINE_LENGTH,current_file->stream);tttcharacter = strchr(current_line,NEWLINE);tttif (character != NULL) {tttt*character = TERMINATE;ttt}tt}tt ttif (current_no_of_spines != 0) {tttprint_syntax_error(ERROR14);tt}ttfclose(current_file->stream);ttcurrent_file = current_file->next_file;t}t tif (verbose) {ttprint_verbose();t}}",4,"cwe119,cwe120,cwe476,cweother"
"arg2_check(const char *name, ScmObj x, ScmObj y, int const_ok){    int size = SCM_UVECTOR_SIZE(x);    if (SCM_UVECTORP(y)) {        if (SCM_UVECTOR_SIZE(y) != size) size_mismatch(name, SCM_OBJ(x), y);        return ARGTYPE_UVECTOR;    } else if (SCM_VECTORP(y)) {        if (SCM_VECTOR_SIZE(y) != size) size_mismatch(name, SCM_OBJ(x), y);        return ARGTYPE_VECTOR;    } else if (SCM_LISTP(y)) {        if (Scm_Length(y) != size) size_mismatch(name, SCM_OBJ(x), y);        return ARGTYPE_LIST;    } else if (!const_ok) {        Scm_Error(""%s: second operand must be either a matching uvector, a vector, or a list, but got %S"", name, y);    } else if (!SCM_REALP(y)) {        Scm_Error(""%s: second operand must be either a matching uvector, a vector, a list or a number, but got %S"", name, y);    }    return ARGTYPE_CONST;}",2,"cwe119,cwe120"
"uildquotalist(char *domain, char **roots, int nroots){    int i, r;    char buf[MAX_MAILBOX_BUFFER], *tail;    size_t domainlen = 0;    buf[0] = '0';    tail = buf;    if (domain) {tdomainlen = snprintf(buf, sizeof(buf), ""%s!"", domain);ttail += domainlen;    }         if (!nroots) {tr = quota_foreach(buf, fixquota_addroot, NULL);tif (r) {t    errmsg(""failed building quota list for '%s'"", buf, IMAP_IOERROR);t}    }         for (i = 0; i < nroots; i++) {tstrlcpy(tail, roots[i], sizeof(buf) - domainlen);t tmboxname_hiersep_tointernal(&quota_namespace, tail, 0);tr = quota_foreach(buf, fixquota_addroot, NULL);tif (r) {t    errmsg(""failed building quota list for '%s'"", buf, IMAP_IOERROR);t    break;t}    }    return r;}",3,"cwe119,cwe120,cweother"
"sendto_channel_local(int type, int nodeaf, struct Channel *chptr,                     const char *pattern, ...){  va_list args;  char buffer[IRCD_BUFSIZE];  int len;  dlink_node *ptr;  struct Membership *ms;  struct Client *target_p;  va_start(args, pattern);  len = send_format(buffer, IRCD_BUFSIZE, pattern, args);  va_end(args);  DLINK_FOREACH(ptr, chptr->members.head)  {    ms = ptr->data;    target_p = ms->client_p;    if (type != 0 && (ms->flags & type) == 0)      continue;    if (!MyConnect(target_p) || IsDefunct(target_p) ||        (nodeaf && IsDeaf(target_p)))      continue;    send_message(target_p, buffer, len);  }}",2,"cwe119,cwe120"
"transfer(char * from_account, char * to_account,             char * value, char * date, char * timestr,             char * date_format,             char * currency, char * VATrate){  int retval=0;  char description[STRING_BLOCK];  char transfer_identifier[STRING_BLOCK];  if (is_value(value)==0) {    printf(""%s is not a value"",value);    return 0;  }  if ((from_account==0) || (to_account==0)) {    if (from_account==0) {          printf(""%s"",""From account not specified"");    }    else {      printf(""%s"",""To account not specified"");    }    return 0;  }  if (strcmp(from_account, to_account)==0) {    printf(""Account names are the same (%s)"",from_account);    return 0;  }  if ((strlen(from_account)==0) || (strlen(to_account)==0)) {    if (strlen(from_account)==0) {      printf(""%s"",""From account not specified"");    }    else {      printf(""%s"",""To account not specified"");    }    return 0;  }  get_transfer_identifier(value, transfer_identifier);  sprintf((char*)description,          get_text_from_identifier(TRANSFER_TO),          transfer_identifier,to_account);  retval = database_save_short(from_account,                               date, timestr,                               date_format,                               """", description,                               currency, VATrate,                               0, """", ""0"", value);  if (retval!=0) {    sprintf((char*)description,            get_text_from_identifier(TRANSFER_FROM),            transfer_identifier,from_account);    retval = database_save_short(to_account,                                 date, timestr,                                 date_format,                                 """", description,                                 currency, VATrate,                                 0, """", value, ""0"");  }  return retval;}",3,"cwe119,cwe120,cweother"
"jtagmkII_chip_erase32(PROGRAMMER * pgm, AVRPART * p){  int status=0, loops;  unsigned char *resp, buf[3], x, ret[4], *retP;  unsigned long val=0;  unsigned int lineno;  if(verbose) fprintf(stderr,          ""%s: jtagmkII_chip_erase32()"",          progname);  status = jtagmkII_reset32(pgm, AVR32_RESET_CHIP_ERASE);  if(status != 0) {lineno = __LINE__; goto eRR;}     ret[0] = 0x01;  ret[1] = 0x05;  ret[2] = 0x01;  ret[3] = 0x00;  retP = ret;  for(loops=0; loops<1000; ++loops) {    buf[0] = CMND_GET_IR;    buf[1] = 0x0F;    status = jtagmkII_send(pgm, buf, 2);    if(status < 0) {lineno = __LINE__; goto eRR;}    status = jtagmkII_recv(pgm, &resp);    if (status != 2 || resp[0] != 0x87) {      {lineno = __LINE__; goto eRR;}    }    x = resp[1];    free(resp);    if(x == *retP) ++retP;    if(*retP == 0x00) break;  }  if(loops == 1000) {lineno = __LINE__; goto eRR;}  status = jtagmkII_avr32_reset(pgm, 0x00, 0x01, 0x01);  if(status < 0) {lineno = __LINE__; goto eRR;}  val = jtagmkII_read_SABaddr(pgm, 0x00000010, 0x06);  if(val != 0x00000000) {lineno = __LINE__; goto eRR;}     buf[0] = CMND_SET_PARAMETER;  buf[1] = 0x03;  buf[2] = 0x02;  jtagmkII_send(pgm, buf, 3);  status = jtagmkII_recv(pgm, &resp);  if(status < 0 || resp[0] != RSP_OK) {lineno = __LINE__; goto eRR;}  free(resp);  return 0;  eRR:    fprintf(stderr,t    ""%s: jtagmkII_reset32(): ""t    ""failed at line %d (status=%x val=%lx)"",t    progname, lineno, status, val);    return -1;}",2,"cwe119,cwe120"
"getDriverIndex(const char* aPath){    char driverName[128];    char *path, *last;    char *firstDot;    int i;         path = normalizePath(strdup(aPath ? aPath : "".""));    last = strrchr(path, PATH_SEPARATOR);    memset(driverName, 0, sizeof(driverName));    strncpy(driverName, last ? last + 1 : path, sizeof(driverName) - 1);    free(path);             firstDot = strchr(driverName, '.');    if(firstDot)       *firstDot = 0;         for (i = 0; drivers[i]; i++)    {       if(strcmp(driverName, drivers[i]->name) == 0)       {          fprintf(stderr, ""Found game: %s [%s]."", driverName, drivers[i]->name);          return i;       }    }        return -1;}",2,"cwe119,cwe120"
"SetOutputDataFormat(void) {tcmsIT8DefineDblFormat(hIT8out, ""%.4g"");    cmsIT8SetPropertyStr(hIT8out, ""ORIGINATOR"", ""icctrans"");    if (IncludePart != NULL)         cmsIT8SetPropertyStr(hIT8out, "".INCLUDE"", IncludePart);    cmsIT8SetComment(hIT8out, ""Data follows"");    cmsIT8SetPropertyDbl(hIT8out, ""NUMBER_OF_SETS"", nMaxPatches);    switch (OutputColorSpace) {             case cmsSigXYZData:        cmsIT8SetPropertyDbl(hIT8out, ""NUMBER_OF_FIELDS"", 4);        cmsIT8SetDataFormat(hIT8out, 0, ""SAMPLE_ID"");        cmsIT8SetDataFormat(hIT8out, 1, ""XYZ_X"");        cmsIT8SetDataFormat(hIT8out, 2, ""XYZ_Y"");        cmsIT8SetDataFormat(hIT8out, 3, ""XYZ_Z"");        break;    case cmsSigLabData:        cmsIT8SetPropertyDbl(hIT8out, ""NUMBER_OF_FIELDS"", 4);        cmsIT8SetDataFormat(hIT8out, 0, ""SAMPLE_ID"");        cmsIT8SetDataFormat(hIT8out, 1, ""LAB_L"");        cmsIT8SetDataFormat(hIT8out, 2, ""LAB_A"");        cmsIT8SetDataFormat(hIT8out, 3, ""LAB_B"");        break;    case cmsSigRgbData:        cmsIT8SetPropertyDbl(hIT8out, ""NUMBER_OF_FIELDS"", 4);        cmsIT8SetDataFormat(hIT8out, 0, ""SAMPLE_ID"");        cmsIT8SetDataFormat(hIT8out, 1, ""RGB_R"");        cmsIT8SetDataFormat(hIT8out, 2, ""RGB_G"");        cmsIT8SetDataFormat(hIT8out, 3, ""RGB_B"");        break;    case cmsSigGrayData:                        cmsIT8SetPropertyDbl(hIT8out, ""NUMBER_OF_FIELDS"", 2);        cmsIT8SetDataFormat(hIT8out, 0, ""SAMPLE_ID"");        cmsIT8SetDataFormat(hIT8out, 1, ""GRAY"");        break;    case cmsSigCmykData:        cmsIT8SetPropertyDbl(hIT8out, ""NUMBER_OF_FIELDS"", 5);        cmsIT8SetDataFormat(hIT8out, 0, ""SAMPLE_ID"");        cmsIT8SetDataFormat(hIT8out, 1, ""CMYK_C"");        cmsIT8SetDataFormat(hIT8out, 2, ""CMYK_M"");        cmsIT8SetDataFormat(hIT8out, 3, ""CMYK_Y"");        cmsIT8SetDataFormat(hIT8out, 4, ""CMYK_K"");        break;    case cmsSigCmyData:        cmsIT8SetPropertyDbl(hIT8out, ""NUMBER_OF_FIELDS"", 4);        cmsIT8SetDataFormat(hIT8out, 0, ""SAMPLE_ID"");        cmsIT8SetDataFormat(hIT8out, 1, ""CMY_C"");        cmsIT8SetDataFormat(hIT8out, 2, ""CMY_M"");        cmsIT8SetDataFormat(hIT8out, 3, ""CMY_Y"");                           break;    default: {        int i, n;        char Buffer[255];        n = cmsChannelsOf(OutputColorSpace);        cmsIT8SetPropertyDbl(hIT8out, ""NUMBER_OF_FIELDS"", n+1);        cmsIT8SetDataFormat(hIT8out, 0, ""SAMPLE_ID"");        for (i=1; i <= n; i++) {            sprintf(Buffer, ""CHAN_%d"", i);            cmsIT8SetDataFormat(hIT8out, i, Buffer);        }    }    }}",2,"cwe119,cwe120"
date_series_ok (const DATASET *dset){    if (calendar_data(dset)) {treturn 1;    } else if (quarterly_or_monthly(dset)) {treturn 1;    } else if (annual_data(dset) || decennial_data(dset)) {treturn 1;    } else if (dataset_has_panel_time(dset)) {treturn 1;    } else {treturn 0;    }},3,"cwe119,cwe120,cweother"
"countscripts(char *name){    DIR *dp;    struct dirent *dir;    size_t length;    int number=0;    char myname[1024];        snprintf(myname, 1023, ""%s.script"", name);        if ((dp = opendir(""."")) == NULL) {treturn -1;    }        while ((dir=readdir(dp)) != NULL) {tlength=strlen(dir->d_name);tif (length >= strlen("".script"") && t    (strcmp(dir->d_name + (length - 7), "".script"") == 0)) {t     t    if (strcmp(myname, dir->d_name) != 0) {tt ttnumber++;t    }t}    }        closedir(dp);    return number;}",3,"cwe119,cwe120,cwe469"
"scontrol_print_front_end_list(char *node_list){tfront_end_info_msg_t *front_end_info_ptr = NULL;tint error_code;thostlist_t host_list;tchar *this_node_name;terror_code = scontrol_load_front_end(&front_end_info_ptr);tif (error_code) {ttexit_code = 1;ttif (quiet_flag != 1)tttslurm_perror (""slurm_load_front_end error"");ttreturn;t}tif (quiet_flag == -1) {ttchar time_str[32];ttslurm_make_time_str((time_t *)&front_end_info_ptr->last_update,ttt            time_str, sizeof(time_str));ttprintf (""last_update_time=%s, records=%d"",ttttime_str, front_end_info_ptr->record_count);t}tif (node_list == NULL) {ttscontrol_print_front_end(NULL, front_end_info_ptr);t} else {ttif ((host_list = hostlist_create (node_list))) {tttwhile ((this_node_name = hostlist_shift (host_list))) {ttttscontrol_print_front_end(this_node_name,ttttttt front_end_info_ptr);ttttfree(this_node_name);ttt}ttthostlist_destroy(host_list);tt} else {tttexit_code = 1;tttif (quiet_flag != 1) {ttttif (errno == EINVAL) {tttttfprintf(stderr,ttttt        ""unable to parse node list %s"",ttttt        node_list);tttt } else if (errno == ERANGE) {tttttfprintf(stderr,ttttt        ""too many nodes in supplied range %s"",ttttt        node_list);tttt} elsetttttperror(""error parsing node list"");ttt}tt}t}treturn;}",2,"cwe119,cwe120"
"main (int argc, char **argv) {  struct stat st;  char *in_buffer, *in_end;  char *out_buffer, *out_end;  char *key_p, *in_p, *out_p;  int fd;  char occur_str[128];  char *occur_p, *occur_end;  char *occur_diff;  if (argc != 3) {    fprintf (stderr, ""Format: %s textfile key"", argv[0]);    return 1;  }  key_p = argv[2];  if (*key_p == '0') {    return 0;  }  if (stat (argv[1], &st) != 0) {    fprintf (stderr, ""Unable to stat file %s"", argv[1]);    return 1;  }  memset (occur_str, 0, 128);  in_buffer = (char *) malloc (st.st_size);  out_buffer = (char *) malloc (st.st_blksize * BS_MUL);  in_end = in_buffer + st.st_size;  out_end = out_buffer + st.st_blksize * BS_MUL;  START_TIMER;  if ((fd = open (argv[1], O_RDWR)) < 0) {    fprintf (stderr, ""Unable to open file %s for reading"", argv[1]);    return 1;  }  if (read (fd, in_buffer, st.st_size) != st.st_size) {    fprintf (stderr, ""Unable to read file %s"", argv[1]);    return 1;  }  END_TIMER (""Time to read in file"");  lseek(fd, 0, SEEK_SET);   in_p = in_buffer;  out_p = out_buffer;  occur_str[0] = '('; occur_str[1] = '1'; occur_str[2] = ')'; occur_str[3] = '0';  occur_p = occur_str;  occur_end = occur_str + 3;  START_TIMER;  while (in_p < in_end) {    *out_p ++ = *in_p;    if (*in_p == *key_p) {      key_p ++;      if (*key_p == '0') {        occur_diff = occur_p + (out_end - out_p);        if (occur_diff < occur_end) {            while (occur_p < occur_diff) {              *out_p ++ = *occur_p ++;            }            CHECK_WRITE;        }        while (*occur_p != '0') {          *out_p ++ = *occur_p ++;        }        UPDATE_OCCUR;        key_p = argv[2];      }    } else {      key_p = argv[2];      if (*in_p == *key_p) {        key_p ++;      }    }    CHECK_WRITE;    in_p ++;  }  if (out_p > out_buffer) {    write (fd, out_buffer, out_p - out_buffer);  }  close (fd);  END_TIMER (""Time to write in file"");   PRINT_W_TIMES  free (in_buffer);  free (out_buffer);  return 0;}",3,"cwe119,cwe120,cweother"
"jxrc_write_container_post_alpha(jxr_container_t cp){      uint32_t mark = ftell(cp->fd);      mark = (mark+1)&~1;            uint32_t count = mark - cp->alpha_begin_mark;      DEBUG(""CONTAINER: measured alpha count=%u"", count);            if(cp->separate_alpha_image_plane)      {          unsigned char scr[4];          fseek(cp->fd, cp->alpha_count_mark, SEEK_SET);                    count = mark;          scr[0] = (count >>  0) & 0xff;          scr[1] = (count >>  8) & 0xff;          scr[2] = (count >> 16) & 0xff;          scr[3] = (count >> 24) & 0xff;          fwrite(scr, 1, 4, cp->fd);      }            fseek(cp->fd, mark, SEEK_SET);      return 0;}",2,"cwe119,cwe120"
"pdf_meta(pdf_document *doc, int key, void *ptr, int size){tswitch(key)t{t tcase FZ_META_FORMAT_INFO:ttsprintf((char *)ptr, ""PDF %d.%d"", doc->version/10, doc->version % 10);ttreturn FZ_META_OK;tcase FZ_META_CRYPT_INFO:ttif (doc->crypt)tttsprintf((char *)ptr, ""Standard V%d R%d %d-bit %s"",ttttpdf_crypt_version(doc),ttttpdf_crypt_revision(doc),ttttpdf_crypt_length(doc),ttttpdf_crypt_method(doc));ttelsetttsprintf((char *)ptr, ""None"");ttreturn FZ_META_OK;tcase FZ_META_HAS_PERMISSION:t{ttint i;ttswitch (size)tt{ttcase FZ_PERMISSION_PRINT:ttti = PDF_PERM_PRINT;tttbreak;ttcase FZ_PERMISSION_CHANGE:ttti = PDF_PERM_CHANGE;tttbreak;ttcase FZ_PERMISSION_COPY:ttti = PDF_PERM_COPY;tttbreak;ttcase FZ_PERMISSION_NOTES:ttti = PDF_PERM_NOTES;tttbreak;ttdefault:tttreturn 0;tt}ttreturn pdf_has_permission(doc, i);t}tcase FZ_META_INFO:t{ttpdf_obj *info = pdf_dict_gets(doc->trailer, ""Info"");ttif (!info)tt{tttif (ptr)tttt*(char *)ptr = 0;tttreturn 0;tt}ttinfo = pdf_dict_gets(info, *(char **)ptr);ttif (!info)tt{tttif (ptr)tttt*(char *)ptr = 0;tttreturn 0;tt}ttif (info && ptr && size)tt{tttchar *utf8 = pdf_to_utf8(doc, info);tttstrncpy(ptr, utf8, size);ttt((char *)ptr)[size-1] = 0;tttfz_free(doc->ctx, utf8);tt}ttreturn 1;t}tdefault:ttreturn FZ_META_UNKNOWN_KEY;t}}",3,"cwe119,cwe120,cweother"
"RecvSocketStream(int sd,char buffer[CF_BUFSIZE],int toget,int nothing) { int already, got;  static int fraction;Debug(""RecvSocketStream(%d)"",toget);if (toget > CF_BUFSIZE-1)   {   CfLog(cferror,""Bad software request for overfull buffer"","""");   return -1;   }for (already = 0; already != toget; already += got)   {   got = recv(sd,buffer+already,toget-already,0);   if (got == -1)      {      CfLog(cfverbose,""Couldn't recv"",""recv"");      return -1;      }    if (got == 0)          {      Debug(""Transmission empty or timed out..."");      fraction = 0;      buffer[already] = '0';      return already;      }   Debug(""    (Concatenated %d from stream)"",got);   if (strncmp(buffer,""AUTH"",4) == 0 && (already == CF_BUFSIZE))      {      fraction = 0;      buffer[already] = '0';      return already;      }   }buffer[toget] = '0';return toget;}",2,"cwe119,cwe120"
"gftp_clear_cache_files (void){  char *indexfile, buf[BUFSIZ];  gftp_getline_buffer * rbuf;  gftp_cache_entry centry;  int indexfd;  indexfile = gftp_expand_path (NULL, BASE_CONF_DIR ""/cache/index.db"");  if ((indexfd = gftp_fd_open (NULL, indexfile, O_RDONLY, 0)) == -1)    {      g_free (indexfile);      return;    }  *buf = '0';  rbuf = NULL;  while (gftp_get_line (NULL, &rbuf, buf, sizeof (buf), indexfd) > 0)    {      if (gftp_parse_cache_line (NULL, &centry, buf) < 0)        continue;      unlink (centry.file);    }  close (indexfd);  unlink (indexfile);  g_free (indexfile);}",2,"cwe119,cwe120"
"qs_deleteOldFiles(const char *file_name, int generations) {  char dirname[QS_HUGE_STR];  char *p;  strcpy(dirname, file_name);  p = strrchr(dirname, '/');  if(strlen(file_name) > (QS_HUGE_STR - 10)) {         return;  }  if(p) {    DIR *dir;    p[0] = '0'; p++;    dir = opendir(dirname);    if(dir) {      int num = 0;      struct dirent *de;      char filename[QS_HUGE_STR];      snprintf(filename, sizeof(filename), ""%s.20"", p);             while((de = readdir(dir)) != 0) {tif(de->d_name && (strncmp(de->d_name, filename, strlen(filename)) == 0)) {t  num++;t}      }             while(num > generations) {tchar old[QS_HUGE_STR];told[0] = '0';trewinddir(dir);twhile((de = readdir(dir)) != 0) {t  if(de->d_name && (strncmp(de->d_name, filename, strlen(filename)) == 0)) {t    if(strcmp(old, de->d_name) > 0) {t      snprintf(old, sizeof(old), ""%s"", de->d_name);t    } else {t      if(old[0] == '0') {ttsnprintf(old, sizeof(old), ""%s"", de->d_name);t      }t    }t  }t}t{t   t  char unl[QS_HUGE_STR];t  snprintf(unl, sizeof(unl), ""%s/%s"", dirname, old);t  unlink(unl);t}tnum--;      }      closedir(dir);    }  }}",2,"cwe119,cwe120"
"scan_ip6_flat(const char *s,char ip[16]){  int i;  for (i=0; i<16; i++) {    int tmp;    tmp=scan_fromhex(*s++);    if (tmp<0) return 0;    ip[i]=tmp << 4;    tmp=scan_fromhex(*s++);    if (tmp<0) return 0;    ip[i]+=tmp;  }  return 32;}",2,"cwe119,cwe120"
"snmp_config_when(char *line, int when){    char           *cptr, buf[STRINGMAX];    struct config_line *lptr = NULL;    struct config_files *ctmp = config_files;    char           *st;    if (line == NULL) {        config_perror(""snmp_config() called with a null string."");        return SNMPERR_GENERR;    }    strlcpy(buf, line, STRINGMAX);    cptr = strtok_r(buf, SNMP_CONFIG_DELIMETERS, &st);    if (!cptr) {        netsnmp_config_warn(""Wrong format: %s"", line);        return SNMPERR_GENERR;    }    if (cptr[0] == '[') {        if (cptr[strlen(cptr) - 1] != ']') {t    netsnmp_config_error(""no matching ']' for type %s."", cptr + 1);            return SNMPERR_GENERR;        }        cptr[strlen(cptr) - 1] = '0';        lptr = read_config_get_handlers(cptr + 1);        if (lptr == NULL) {t    netsnmp_config_error(""No handlers regestered for type %s."",tttt cptr + 1);            return SNMPERR_GENERR;        }        cptr = strtok_r(NULL, SNMP_CONFIG_DELIMETERS, &st);        lptr = read_config_find_handler(lptr, cptr);    } else {                 for (; ctmp != NULL && lptr == NULL; ctmp = ctmp->next)            lptr = read_config_find_handler(ctmp->start, cptr);    }    if (lptr == NULL && netsnmp_ds_get_boolean(NETSNMP_DS_LIBRARY_ID, ttttt  NETSNMP_DS_LIB_NO_TOKEN_WARNINGS)) {tnetsnmp_config_warn(""Unknown token: %s."", cptr);        return SNMPERR_GENERR;    }         line = skip_white(line + (cptr - buf) + strlen(cptr) + 1);    return (run_config_handler(lptr, cptr, line, when));}",3,"cwe119,cwe120,cwe469"
"set_exponents(unsigned long *ei, char *r)r{r  char *s, b[MPQS_STRING_LENGTH];r  long e;rr  strcpy(b, r);r  s = strtok(b, "" "");r  while (s != NULL)r  {r    e = atol(s); if (!e) break;r    s = strtok(NULL, "" "");r    ei[atol(s)] += e;r    s = strtok(NULL, "" "");r  }r}",3,"cwe119,cwe120,cweother"
"session_password_set(session_t *s, const char *password){txfree(s->password);ts->password = (password) ? base64_encode(password, xstrlen(password)+1) : NULL;t treturn 0;}",2,"cwe119,cwe120"
"client3_1_fsyncdir (call_frame_t *frame, xlator_t *this, void *data){        clnt_args_t       *args     = NULL;        int64_t            remote_fd = -1;        clnt_conf_t       *conf     = NULL;        int                op_errno = ESTALE;        gfs3_fsyncdir_req  req      = {{0,},};        int                ret        = 0;        if (!frame || !this || !data)                goto unwind;        args = data;        conf = this->private;        CLIENT_GET_REMOTE_FD(conf, args->fd, remote_fd, unwind);        req.fd   = remote_fd;        req.data = args->flags;        memcpy (req.gfid, args->fd->inode->gfid, 16);        conf = this->private;        ret = client_submit_request (this, &req, frame, conf->fops,                                     GFS3_OP_FSYNCDIR, client3_1_fsyncdir_cbk,                                     NULL, NULL, 0,                                     NULL, 0, NULL,                                     (xdrproc_t)xdr_gfs3_fsyncdir_req);        if (ret) {                op_errno = ENOTCONN;                goto unwind;        }        return 0;unwind:        gf_log (this->name, GF_LOG_WARNING, ""failed to send the fop: %s"", strerror (op_errno));        STACK_UNWIND_STRICT (fsyncdir, frame, -1, op_errno);        return 0;}",2,"cwe120,cwe476"
"sci0_get_compression_method(int resh){tguint16 compressedLength;tguint16 compressionMethod;tguint16 result_size;t tif (read(resh, &result_size, 2) != 2)ttreturn SCI_ERROR_IO_ERROR;tif ((read(resh, &compressedLength, 2) != 2) ||t    (read(resh, &result_size, 2) != 2) ||t    (read(resh, &compressionMethod, 2) != 2))ttreturn SCI_ERROR_IO_ERROR;#ifdef WORDS_BIGENDIANtcompressionMethod = GUINT16_SWAP_LE_BE_CONSTANT(compressionMethod);#endiftreturn compressionMethod;}",2,"cwe120,cweother"
"xc_core_elf_pfn_valid(ulong pfn){        int i, b, start_index;toff_t offset;tsize_t size;tuint nr_pages;        ulong tmp;        uint64_t pfn_batch[MAX_BATCH_SIZE];        offset = xd->xc_core.header.xch_index_offset;tnr_pages = xd->xc_core.header.xch_nr_pages;t txd->xc_core.last_batch.accesses++;tstart_index = 0;tif ((pfn >= xd->xc_core.last_batch.start) &&t    (pfn <= xd->xc_core.last_batch.end)) {ttxd->xc_core.last_batch.duplicates++;ttstart_index = xd->xc_core.last_batch.index;t} else {ttfor (i = 0; i <= INDEX_PFN_COUNT; i++) {tttif ((i == INDEX_PFN_COUNT) ||ttt    (pfn < xd->xc_core.elf_index_pfn[i].pfn)) {ttttif (--i < 0)ttttti = 0;ttttstart_index = xd->xc_core.elf_index_pfn[i].index;ttttbreak;ttt}tt}t}toffset += (start_index * sizeof(uint64_t));        if (lseek(xd->xfd, offset, SEEK_SET) == -1)                error(FATAL, ""cannot lseek to page index"");        for (b = start_index; b < nr_pages; b += MAX_BATCH_SIZE) {ttsize = sizeof(uint64_t) * MIN(MAX_BATCH_SIZE, nr_pages - b);                if (read(xd->xfd, &pfn_batch[0], size) != size) {                        error(INFO, ""cannot read index page %d"", b);tttreturn PFN_NOT_FOUND;tt}ttfor (i = 0; i < MAX_BATCH_SIZE; i++) {tttif ((b+i) >= nr_pages)ttttbreak;tttttttmp = (ulong)pfn_batch[i];                tif (tmp == pfn) {ttttif (CRASHDEBUG(4))                        ttfprintf(xd->ofp, tttt            ""index: batch: %d found pfn %ld (0x%lx) at index %d"",                                ttb/MAX_BATCH_SIZE, pfn, pfn, i+b);ttttif ((b+MAX_BATCH_SIZE) < nr_pages) {tttttxd->xc_core.last_batch.index = b;tttttxd->xc_core.last_batch.start = (ulong)pfn_batch[0];tttttxd->xc_core.last_batch.end = (ulong)pfn_batch[MAX_BATCH_SIZE-1];tttt}                        treturn (i+b);                t}tt}        }        return PFN_NOT_FOUND;}",2,"cwe120,cweother"
"read_key_file(const char *filename, ldns_rr_list *key_list, bool silently){tint line_len = 0;tint line_nr = 0;tint key_count = 0;tchar line[LDNS_MAX_LINELEN];tldns_status status;tFILE *input_file;tldns_rr *rr;tinput_file = fopen(filename, ""r"");tif (!input_file) {ttif (! silently) {tttfprintf(stderr, ""Error opening %s: %s"",ttttfilename, strerror(errno));tt}ttreturn LDNS_STATUS_ERR;t}twhile (line_len >= 0) {ttline_len = (int) read_line(input_file, line, sizeof(line));ttline_nr++;ttif (line_len > 0 && line[0] != ';') {tttstatus = ldns_rr_new_frm_str(&rr, line, 0, NULL, NULL);tttif (status != LDNS_STATUS_OK) {ttttif (! silently) {tttttfprintf(stderr,tttttt""Error parsing DNSKEY RR ""tttttt""in line %d: %s"", line_nr,ttttttldns_get_errorstr_by_id(status)tttttt);tttt}ttt} else if (ldns_rr_get_type(rr) == LDNS_RR_TYPE_DNSKEY || ttttt   ldns_rr_get_type(rr) == LDNS_RR_TYPE_DS) {ttttldns_rr_list_push_rr(key_list, rr);ttttkey_count++;ttt} else {ttttldns_rr_free(rr);ttt}tt}t}tfclose(input_file);tif (key_count > 0) {ttreturn LDNS_STATUS_OK;t} else {tt ttreturn LDNS_STATUS_ERR;t}}",3,"cwe119,cwe120,cweother"
"read_net_udp6(struct stats_net_udp6 *st_net_udp6){tFILE *fp;tchar line[128];tif ((fp = fopen(NET_SNMP6, ""r"")) == NULL)ttreturn;twhile (fgets(line, 128, fp) != NULL) {ttif (!strncmp(line, ""Udp6InDatagrams "", 16)) {tttsscanf(line + 16, ""%lu"", &st_net_udp6->InDatagrams6);tt}ttelse if (!strncmp(line, ""Udp6OutDatagrams "", 17)) {tttsscanf(line + 17, ""%lu"", &st_net_udp6->OutDatagrams6);tt}ttelse if (!strncmp(line, ""Udp6NoPorts "", 12)) {tttsscanf(line + 12, ""%lu"", &st_net_udp6->NoPorts6);tt}ttelse if (!strncmp(line, ""Udp6InErrors "", 13)) {tttsscanf(line + 13, ""%lu"", &st_net_udp6->InErrors6);tt}t}ttfclose(fp);}",3,"cwe119,cwe120,cweother"
"menu_getfloat(const char *s, const char **error){#ifdef HAVE_LONG_DOUBLE    long double param = 0;#else    double param = 0;#endif#ifdef HAVE_LONG_DOUBLE#ifndef USE_ATOLD#ifdef USE_XLDIO    param = x_strtold(s, NULL);    if (0)#else    if (sscanf(s, ""%LG"", &param) == 0)#endif#else    param = _atold(s);    if (0)#endif    {#else    if (sscanf(s, ""%lG"", &param) == 0) {#endift*error = ""Floating point number expected"";treturn 0;    }    return (param);}",2,"cwe119,cwe120"
"file_ota_load(FILE *file, gn_bmp *bitmap, gn_phone *info){tchar buffer[4];t tif (fread(buffer, 1, 4, file) != 4)ttreturn GN_ERR_FAILED;tbitmap->width = buffer[1];tbitmap->height = buffer[2];tbitmap->size = bitmap->width * bitmap->height / 8;tif (((bitmap->height == 48) && (bitmap->width == 84)) ||  t    ((bitmap->height == 60) && (bitmap->width == 96)) ||  t    (info && ((bitmap->height == info->startup_logo_height) && (bitmap->width == info->startup_logo_width)))) {ttbitmap->type = GN_BMP_StartupLogo;t} else if (((bitmap->height == 14) && (bitmap->width == 72)) ||  tt   (info && ((bitmap->height == info->caller_logo_height) && (bitmap->width == info->caller_logo_width)))) {ttbitmap->type = GN_BMP_CallerLogo;t} else {ttdprintf(""Invalid Image Size (%dx%d)."", bitmap->width, bitmap->height);ttreturn GN_ERR_INVALIDSIZE;t}tif (fread(bitmap->bitmap, 1, bitmap->size,file) != bitmap->size)ttreturn GN_ERR_INVALIDSIZE;treturn GN_ERR_NONE;}",3,"cwe119,cwe120,cweother"
"update_att_screen_titlebar(void){    long        raw_msgno;    COLOR_PAIR *returned_color = NULL;    COLOR_PAIR *titlecolor = NULL;    int         colormatch;    SEARCHSET  *ss = NULL;    PAT_STATE  *pstate = NULL;    if(ps_global->titlebar_color_style != TBAR_COLOR_DEFAULT){traw_msgno = mn_m2raw(ps_global->msgmap, mn_get_cur(ps_global->msgmap));tss = mail_newsearchset();tss->first = ss->last = (unsigned long) raw_msgno;tif(ss){t    colormatch = get_index_line_color(ps_global->mail_stream,ttttt      ss, &pstate, &returned_color);t    mail_free_searchset(&ss);t     t    if(colormatch){ttif(returned_color)tt  titlecolor = returned_color;ttelsett  titlecolor = new_color_pair(ps_global->VAR_NORM_FORE_COLOR,ttttt      ps_global->VAR_NORM_BACK_COLOR);t    }t    if(titlecolort       && ps_global->titlebar_color_style == TBAR_COLOR_REV_INDEXLINE){ttchar cbuf[MAXCOLORLEN+1];ttstrncpy(cbuf, titlecolor->fg, sizeof(cbuf));ttcbuf[sizeof(cbuf)-1] = '0';ttstrncpy(titlecolor->fg, titlecolor->bg, MAXCOLORLEN);tttitlecolor->fg[MAXCOLORLEN] = '0';ttstrncpy(titlecolor->bg, cbuf, MAXCOLORLEN);tttitlecolor->bg[MAXCOLORLEN] = '0';t    }t}tt tif((!titlecolor && att_screen->titlecolor)t   ||t   (titlecolor && !att_screen->titlecolor)t   ||t   (titlecolor && att_screen->titlecolort    && (strcmp(titlecolor->fg, att_screen->titlecolor->fg)tt|| strcmp(titlecolor->bg, att_screen->titlecolor->bg)))){t    if(att_screen->titlecolor)t      free_color_pair(&att_screen->titlecolor);t    att_screen->titlecolor = titlecolor;t    titlecolor = NULL;t}tif(titlecolor)t  free_color_pair(&titlecolor);    }    set_titlebar(_(""ATTACHMENT INDEX""), ps_global->mail_stream,tt ps_global->context_current, ps_global->cur_folder,tt ps_global->msgmap, 1, MessageNumber, 0, 0,tt att_screen->titlecolor);}",2,"cwe119,cwe120"
"append_environ (char *str[], LINE_T ** ref_l, int *line_num, char *name){  int k;  for (k = 0; str[k] != NO_TEXT; k ++) {    int zero_line_num = 0;    (*line_num)++;    append_source_line (str[k], ref_l, &zero_line_num, name);  }  }",2,"cwe476,cweother"
"""advance_file_pointer(struct archive_read_filter *filter, int64_t request){tint64_t bytes_skipped, total_bytes_skipped = 0;tssize_t bytes_read;tsize_t min;tif (filter->fatal)ttreturn (-1);t/* Use up the copy buffer first. */tif (filter->avail > 0) {ttmin = minimum(request, (int64_t)filter->avail);ttfilter->next += min;ttfilter->avail -= min;ttrequest -= min;ttfilter->position += min;tttotal_bytes_skipped += min;t}t/* Then use up the client buffer. */tif (filter->client_avail > 0) {ttmin = minimum(request, (int64_t)filter->client_avail);ttfilter->client_next += min;ttfilter->client_avail -= min;ttrequest -= min;ttfilter->position += min;tttotal_bytes_skipped += min;t}tif (request == 0)ttreturn (total_bytes_skipped);t/* If there's an optimized skip function, use it. */tif (filter->skip != NULL) {ttbytes_skipped = (filter->skip)(filter, request);ttif (bytes_skipped < 0) {t/* error */tttfilter->fatal = 1;tttreturn (bytes_skipped);tt}ttfilter->position += bytes_skipped;tttotal_bytes_skipped += bytes_skipped;ttrequest -= bytes_skipped;ttif (request == 0)tttreturn (total_bytes_skipped);t}t/* Use ordinary reads as necessary to complete the request. */tfor (;;) {ttbytes_read = (filter->read)(filter, &filter->client_buff);ttif (bytes_read < 0) {tttfilter->client_buff = NULL;tttfilter->fatal = 1;tttreturn (bytes_read);tt}ttif (bytes_read == 0) {tttfilter->client_buff = NULL;tttfilter->end_of_file = 1;tttreturn (total_bytes_skipped);tt}ttif (bytes_read >= request) {tttfilter->client_next =ttt    ((const char *)filter->client_buff) + request;tttfilter->client_avail = bytes_read - request;tttfilter->client_total = bytes_read;ttttotal_bytes_skipped += request;tttfilter->position += request;tttreturn (total_bytes_skipped);tt}ttfilter->position += bytes_read;tttotal_bytes_skipped += bytes_read;ttrequest -= bytes_read;t}}""",2,"cwe120,cweother"
"fill_dataset_dates_series (const DATASET *dset, double *x){    double sd0;    int pd, T;    int err = 0;    if (dataset_is_panel(dset)) {t tpd = dset->panel_pd;tsd0 = dset->panel_sd0;tT = dset->pd;    } else {t tpd = dset->pd;tsd0 = dset->sd0;tT = dset->n;    }    if (dataset_has_panel_time(dset)) {tif (pd == 4 || pd == 12) {t    err = monthly_or_quarterly_dates(dset, pd, sd0, T, x);t} else if (pd == 1 || pd == 10) {t    err = annual_or_decennial_dates(dset, pd, sd0, T, x);t} else if (pd == 5 || pd == 6 || pd == 7 || pd == 52) {t    panel_daily_or_weekly(dset, x);t}    } else if (calendar_data(dset)) {terr = regular_daily_or_weekly(dset, x);    } else if (quarterly_or_monthly(dset)) {terr = monthly_or_quarterly_dates(dset, pd, sd0, T, x);    } else if (annual_data(dset) || decennial_data(dset)) {terr = annual_or_decennial_dates(dset, pd, sd0, T, x);    } else {terr = E_PDWRONG;    }    if (!err && dataset_is_panel(dset)) {t tint i, N = dset->n / dset->pd;tsize_t bytes = dset->pd * sizeof *x;tdouble *dest = x + dset->pd;tfor (i=1; i<N; i++) {t    memcpy(dest, x, bytes);t    dest += dset->pd;t}    }    return err;}",2,"cwe120,cwe476"
"try_open_full(snd_mixer_class_t *class, snd_mixer_t *mixer,ttt const char *lib, const char *device){tclass_priv_t *priv = snd_mixer_class_get_private(class);tsnd_mixer_event_t event_func;tsnd_mixer_sfbasic_init_t init_func = NULL;tchar *xlib, *path;tvoid *h;tint err = 0;tpath = getenv(""ALSA_MIXER_SIMPLE_MODULES"");tif (!path)ttpath = SO_PATH;txlib = malloc(strlen(lib) + strlen(path) + 1 + 1);tif (xlib == NULL)ttreturn -ENOMEM;tstrcpy(xlib, path);tstrcat(xlib, ""/"");tstrcat(xlib, lib);t th = snd_dlopen(xlib, RTLD_NOW|RTLD_GLOBAL);tif (h == NULL) {ttSNDERR(""Unable to open library '%s'"", xlib);ttfree(xlib);ttreturn -ENXIO;t}tpriv->dlhandle = h;tevent_func = snd_dlsym(h, ""alsa_mixer_simple_event"", NULL);tif (event_func == NULL) {ttSNDERR(""Symbol 'alsa_mixer_simple_event' was not found in '%s'"", xlib);tterr = -ENXIO;t}tif (err == 0) {ttinit_func = snd_dlsym(h, ""alsa_mixer_simple_finit"", NULL);ttif (init_func == NULL) {tttSNDERR(""Symbol 'alsa_mixer_simple_finit' was not found in '%s'"", xlib);ttterr = -ENXIO;tt}t}tfree(xlib);terr = err == 0 ? init_func(class, mixer, device) : err;tif (err < 0)ttreturn err;tsnd_mixer_class_set_event(class, event_func);treturn 1;}",2,"cwe120,cweother"
"_ds_ff_pref_load(  config_t config,  const char *user,  const char *home,  void *ignore){  char filename[MAX_FILENAME_LENGTH];  agent_pref_t PTX = malloc(sizeof(agent_attrib_t )*PREF_MAX);  char buff[258];  FILE *file;  char *p, *q;  int i = 0;  config = config;    ignore = ignore;    if (PTX == NULL) {    LOG(LOG_CRIT, ERR_MEM_ALLOC);    return NULL;  }  PTX[0] = NULL;  if (user == NULL) {    snprintf(filename, MAX_FILENAME_LENGTH, ""/etc/dspam/default.prefs"", home);  } else {    _ds_userdir_path (filename, home, user, ""prefs"");  }  file = fopen(filename, ""r"");     if (file != NULL) {    char *ptrptr;    while(i<(PREF_MAX-1) && fgets(buff, sizeof(buff), file)!=NULL) {      if (buff[0] == '#' || buff[0] == 0)        continue;      chomp(buff);      p = strtok_r(buff, ""="", &ptrptr);      if (p == NULL)        continue;      q = p + strlen(p)+1;      LOGDEBUG(""Loading preference '%s' = '%s'"", p, q);      PTX[i] = _ds_pref_new(p, q);      PTX[i+1] = NULL;      i++;    }    fclose(file);  } else {    free(PTX);    return NULL;  }  return PTX;}",4,"cwe119,cwe120,cwe476,cweother"
"c_update_tool(ClientData cdata, Tcl_Interp * interp, int argc,tt  char *argv[]){    char buf[100];    int x, y, b;    G_debug(3, ""c_update_tool()"");    if (argc < 4) {tTcl_SetResult(interp, ""Usage: c_update_tool x y b"", TCL_VOLATILE);treturn (TCL_ERROR);    }    if (!tool_update)treturn TCL_OK;    Tcl_GetInt(interp, argv[1], &x);    Tcl_GetInt(interp, argv[2], &y);    Tcl_GetInt(interp, argv[3], &b);    switch (mode) {    case MOUSE_POINT:tbreak;    case MOUSE_LINE:tsprintf(buf, ""get_update_line %d %d %d %d"", sxo, syo, x, y);tTcl_Eval(Toolbox, buf);tbreak;    case MOUSE_BOX:tsprintf(buf, ""get_update_box %d %d %d %d"", sxo, syo, x, y);tTcl_Eval(Toolbox, buf);tbreak;    }    if (b < 0) {tupdate(x, y);treturn TCL_OK;    }    if (b == 0) {tend_tool();treturn TCL_OK;    }    if ((*tool_update) (tool_closure, x, y, b)) {tend_tool();treturn TCL_OK;    }    return TCL_OK;}",2,"cwe119,cwe120"
"imapdriver_get_cached_envelope(struct mail_cache_db * cache_db,    MMAPString * mmapstr,    mailsession * session, mailmessage * msg,    struct mailimf_fields ** result){#if 0  mailsession * imap_session;#endif  mailimap * imap;  int r;  struct mailimf_fields * fields;  int res;  char keyname[PATH_MAX];  #if 0  imap_session = cached_session_get_ancestor(session);  imap = ((struct imap_session_state_data *) (imap_session->data))->session;#endif  imap = cached_session_get_imap_session(session);  generate_key_from_message(keyname, PATH_MAX,ttt    msg, MAILIMAP_MSG_ATT_ENVELOPE);  r = generic_cache_fields_read(cache_db, mmapstr, keyname, &fields);  if (r != MAIL_NO_ERROR) {    res = r;    goto err;  }  * result = fields;  return MAIL_NO_ERROR;err:  return res;}",2,"cwe119,cwe120"
"""private_getline (gchar **lineptr,                 gsize *n,                 FILE *stream){tgint nchars_avail;tgchar *read_pos;tif (!lineptr || !n || !stream)ttreturn -1;tif (!*lineptr) {tt*n = MIN_CHUNK;tt*lineptr = (char *)malloc (*n);ttif (!*lineptr)tttreturn -1;t}tnchars_avail = (gint) *n;tread_pos = *lineptr;tfor (;;) {ttgint c = getc (stream);ttif (nchars_avail < 2) {tttif (*n > MIN_CHUNK)tttt*n *= 2;tttelsetttt*n += MIN_CHUNK;tttnchars_avail = (gint)(*n + *lineptr - read_pos);ttt*lineptr = (char *)realloc (*lineptr, *n);tttif (!*lineptr)ttttreturn -1;tttread_pos = *n - nchars_avail + *lineptr;tt}ttif (ferror (stream) || c == EOF) {tttif (read_pos == *lineptr)ttttreturn -1;tttelsettttbreak;tt}tt*read_pos++ = c;ttnchars_avail--;ttif (c == '')ttt/* Return the line.  */tttbreak;t}t*read_pos = '0';treturn (gint)(read_pos - (*lineptr));}""",2,"cwe120,cweother"
"widget_icon_read_bitmap(const char *section, WIDGET_ICON * Icon){    int row, n;    char key[15];    char *val, *v;    unsigned char *map;    for (row = 0; row < YRES; row++) {tqprintf(key, sizeof(key), ""Bitmap.Row%d"", row + 1);tval = cfg_get(section, key, """");tmap = Icon->bitmap + row;tn = 0;tfor (v = val; *v != '0'; v++) {t    if (n >= Icon->maxmap) {ttIcon->maxmap++;ttIcon->bitmap = realloc(Icon->bitmap, Icon->maxmap * YRES * sizeof(char));ttmemset(Icon->bitmap + n * YRES, 0, YRES * sizeof(char));ttmap = Icon->bitmap + n * YRES + row;t    }t    switch (*v) {t    case '|':ttn++;ttmap += YRES;ttbreak;t    case '*':tt(*map) <<= 1;tt(*map) |= 1;ttbreak;t    default:tt(*map) <<= 1;t    }t}tfree(val);    }}",2,"cwe119,cwe120"
"sockconnect(char *host, I port){  int sock;  struct sockaddr_in server;  int toggle;  struct hostent *hp=0;#if defined(APLUS_THREAD_SAFE_FUNCTIONS)  struct hostent hostentStruct;  char charBuf[1024];  int err;#endif     if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {    (void)perror(""socket"");    return -1;  }     APLUS_GETHOSTBYNAME(host,&hostentStruct,charBuf,1024,&err,hp);  if (hp==0)    {      (void)perror(""gethostbyname"");      (void)close(sock);      return -1;    }  (void)bcopy((char *)hp->h_addr, (char *)&server.sin_addr, hp->h_length);  server.sin_port = htons((u_short)port);  server.sin_family = AF_INET;  if (connect(sock, (struct sockaddr *)&server, sizeof(server))) {    (void)perror(""connect"");    (void)close(sock);    return -1;  }  toggle = 1;  if (setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,tt(char *)(&toggle), sizeof(toggle)) < 0)  {    (void)perror(""setsockopt"");  }  return (I)sock;}",2,"cwe119,cwe120"
"lo_export(PGconn *conn, Oid lobjId, const char *filename){tinttttresult = 1;tinttttfd;tinttttnbytes,tttttmp;tcharttbuf[LO_BUFSIZE];tinttttlobj;tcharttsebuf[256];t tlobj = lo_open(conn, lobjId, INV_READ);tif (lobj == -1)t{tt ttreturn -1;t}t tfd = open(filename, O_CREAT | O_WRONLY | O_TRUNC | PG_BINARY, 0666);tif (fd < 0)t{tt ttinttttsave_errno = errno;tt(void) lo_close(conn, lobj);ttprintfPQExpBuffer(&conn->errorMessage,tttttt  libpq_gettext(""could not open file ""%s"": %s""),tttttt  filename,tttttt  pqStrerror(save_errno, sebuf, sizeof(sebuf)));ttreturn -1;t}t twhile ((nbytes = lo_read(conn, lobj, buf, LO_BUFSIZE)) > 0)t{tttmp = write(fd, buf, nbytes);ttif (tmp != nbytes)tt{ttt tttinttttsave_errno = errno;ttt(void) lo_close(conn, lobj);ttt(void) close(fd);tttprintfPQExpBuffer(&conn->errorMessage,ttttt   libpq_gettext(""could not write to file ""%s"": %s""),ttttttt  filename,ttttttt  pqStrerror(save_errno, sebuf, sizeof(sebuf)));tttreturn -1;tt}t}t tif (nbytes < 0 ||ttlo_close(conn, lobj) != 0)t{tt ttresult = -1;t}t tif (close(fd) && result >= 0)t{ttprintfPQExpBuffer(&conn->errorMessage,ttttt   libpq_gettext(""could not write to file ""%s"": %s""),tttttt  filename, pqStrerror(errno, sebuf, sizeof(sebuf)));ttresult = -1;t}treturn result;}",3,"cwe119,cwe120,cweother"
"CwLnx_hbar(Driver *drvthis, int x, int y, int len, int promille, int options){    PrivateData *p = drvthis->private_data;    if (p->ccmode != hbar) {tunsigned char hBar[p->cellheight];tint i;tif (p->ccmode != standard) {t     t    report(RPT_WARNING, ""%s: hbar: cannot combine two modes using user-defined characters"",tt      drvthis->name);t    return;t}tp->ccmode = hbar;tfor (i = 1; i <= p->cellwidth; i++) {t     t    memset(hBar, 0xFF & ~((1 << (p->cellwidth - i)) - 1), sizeof(hBar));#if defined(SEAMLESS_HBARS)t    CwLnx_set_char_unrestricted(drvthis, i+1, hBar);#elset    CwLnx_set_char(drvthis, i+1, hBar);#endift}    }    lib_hbar_static(drvthis, x, y, len, promille, options, p->cellwidth, 1);}",2,"cwe119,cwe120"
"md5_one(const char *fn){tunsigned char buf[4096], digest[16];tMD5_CTX md5;tint l;tFILE *fp;tfp = strcmp(fn, ""-"")? fopen(fn, ""r"") : stdin;tif (fp == 0) {ttfprintf(stderr, ""md5sum: %s: No such file or directory"", fn);ttexit(1);t}tMD5Init(&md5);twhile ((l = fread(buf, 1, 4096, fp)) > 0)ttMD5Update(&md5, buf, l);tMD5Final(digest, &md5);tif (fp != stdin) fclose(fp);tfor (l = 0; l < 16; ++l)ttprintf(""%c%c"", HEX_STR[digest[l]>>4&0xf], HEX_STR[digest[l]&0xf]);tprintf(""  %s"", fn);}",2,"cwe469,cweother"
"APC_open_serialport(const char *port, speed_t speed){tstruct termios tio;tint fd;tint rc;tint errno_save;tint fflags;tif (Debug) {ttLOG(PIL_DEBUG, ""%s: called."", __FUNCTION__);t}tif ((rc = OurImports->TtyLock(port)) < 0) {ttLOG(PIL_CRIT, ""%s: Could not lock tty %s [rc=%d].""tt,t__FUNCTION__, port, rc);ttreturn -1;t}tSTONITH_SIGNAL(SIGALRM, APC_sh_serial_timeout);talarm(SERIAL_TIMEOUT);tf_serialtimeout = FALSE;tfd = open(port, O_RDWR | O_NOCTTY | O_NONBLOCK | O_EXCL);terrno_save = errno;talarm(0);tSTONITH_IGNORE_SIG(SIGALRM);tif (fd < 0) {ttLOG(PIL_CRIT, ""%s: Open of %s %s [%s]."", __FUNCTION__tt,tporttt,tf_serialtimeout ? ""timed out"" : ""failed""tt,tstrerror(errno_save));ttOurImports->TtyUnlock(port);ttreturn -1;t}tif ((fflags = fcntl(fd, F_GETFL)) < 0t||tfcntl(fd, F_SETFL, (fflags & ~O_NONBLOCK)) < 0) {ttLOG(PIL_CRIT, ""%s: Setting flags on %s failed [%s].""tt,t__FUNCTION__tt,tporttt,tstrerror(errno_save));ttclose(fd);ttOurImports->TtyUnlock(port);ttreturn -1;t}tif (tcgetattr(fd, &old_tio) < 0) {ttLOG(PIL_CRIT, ""%s: tcgetattr of %s failed [%s]."", __FUNCTION__tt,tporttt,tstrerror(errno));ttclose(fd);ttOurImports->TtyUnlock(port);ttreturn -1;t}tmemcpy(&tio, &old_tio, sizeof(struct termios));ttio.c_cflag = CS8 | CLOCAL | CREAD;ttio.c_iflag = IGNPAR;ttio.c_oflag = 0;ttio.c_lflag = 0;ttio.c_cc[VMIN] = 1;ttio.c_cc[VTIME] = 0;tcfsetispeed(&tio, speed);tcfsetospeed(&tio, speed);ttcflush(fd, TCIOFLUSH);ttcsetattr(fd, TCSANOW, &tio);treturn (fd);}",2,"cwe120,cweother"
"crypt_aescbc_decrypt(unsigned char *key, unsigned int keybits, unsigned char *ivec, unsigned int iveclen, unsigned char *inbuf, unsigned int inlen, unsigned char *outbuf, unsigned int *outlen) {tunsigned char ivecbuf[AES_BLOCK_SIZE];tunsigned char *databuf = cryptbuf;tAES_KEY akey;t tif(inlen < AES_BLOCK_SIZE || inlen % AES_BLOCK_SIZE != 0) return CRYPT_MISCERR;t tif(keybits != 128 && keybits != 192 && keybits != 256) return CRYPT_MISCERR;t tcrypt_aescbc_getivec(ivec, iveclen, ivecbuf);t tAES_set_decrypt_key(key, keybits, &akey);t tif(CRYPTBUFLEN < inlen) return CRYPT_TOOBIG;t tAES_cbc_encrypt(inbuf, databuf, inlen, &akey, ivecbuf, AES_DECRYPT);t tif(databuf[inlen - 1] >= AES_BLOCK_SIZE) return CRYPT_MISCERR;t t*outlen = inlen - databuf[inlen - 1] - 1;t tmemcpy(outbuf, databuf, *outlen);t treturn CRYPT_OK;}",2,"cwe119,cwe120"
"removeAllInFolder(HFSCatalogNodeID folderID, Volume* volume, const char* parentName) {tCatalogRecordList* list;tCatalogRecordList* theList;tchar fullName[1024];tchar* name;tchar* pathComponent;tint pathLen;tchar isRoot;ttHFSPlusCatalogFolder* folder;ttheList = list = getFolderContents(folderID, volume);ttstrcpy(fullName, parentName);tpathComponent = fullName + strlen(fullName);ttisRoot = FALSE;tif(strcmp(fullName, ""/"") == 0) {ttisRoot = TRUE;t}ttwhile(list != NULL) {ttname = unicodeToAscii(&list->name);ttif(isRoot && (name[0] == '0' || strncmp(name, "".HFS+ Private Directory Data"", sizeof("".HFS+ Private Directory Data"") - 1) == 0)) {tttfree(name);tttlist = list->next;tttcontinue;tt}ttttstrcpy(pathComponent, name);ttpathLen = strlen(fullName);ttttif(list->record->recordType == kHFSPlusFolderRecord) {tttfolder = (HFSPlusCatalogFolder*)list->record;tttfullName[pathLen] = '/';tttfullName[pathLen + 1] = '0';tttremoveAllInFolder(folder->folderID, volume, fullName);tt} else {tttprintf(""%s"", fullName);tttremoveFile(fullName, volume);tt}ttttfree(name);ttlist = list->next;t}ttreleaseCatalogRecordList(theList);ttif(!isRoot) {tt*(pathComponent - 1) = '0';ttprintf(""%s"", fullName);ttremoveFile(fullName, volume);t}}",2,"cwe119,cwe120"
"msp430_set_watchpoint (char *mode, char *name){  int addr = 0;  char *endptr;  if (strcmp (name, ""all""))    addr = -1;     addr = strtol (name, &endptr, 0);     if (*endptr != '' && *endptr != 't' && *endptr != ' ' && *endptr != 0)    {      addr = msp430_lookup_symbol (name);    }  if (!addr || (addr < 0 && addr != -1) || addr > 0xffff)    {      fprintf (stderr, ""Error: canont find '%s' symbol"", name);      return;    }  switch (*mode)    {    case 'r':      wpr[addr] = 1;      break;    case 'w':      wpw[addr] = 1;      break;    case 'a':      wpw[addr] = 1;      wpr[addr] = 1;      break;    case 'd':      wpw[addr] = 0;      wpr[addr] = 0;      break;    case 'c':      if (addr == -1)t{t  memset (wpw, 0, sizeof (wpw));t  memset (wpr, 0, sizeof (wpr));t}    default:      fprintf (stderr, ""Error: Invalid mode: %s"", mode);      return;    }  if (*mode != 'd')    {      fprintf (stderr, ""Add symbol %s at 0x%04x to watchpoins list"", name,t       addr);      return;    }  else    {      fprintf (stderr, ""Remove watchpoint at 0x%04x"", addr);    }  return;}",2,"cwe469,cweother"
"SMB_Connect_Server(SMB_Handle_Type Con_Handle,tttt   char *server, char *NTdomain){ SMB_Handle_Type con;  char temp[80], called[80], calling[80], *address;  int i;     con = Con_Handle;  if (Con_Handle == NULL) {    if ((con = (struct SMB_Connect_Def *)malloc(sizeof(struct SMB_Connect_Def))) == NULL) {      SMBlib_errno = SMBlibE_NoSpace;      return NULL;    }  }     strcpy(con -> service, """");  strcpy(con -> username, """");  strcpy(con -> password, """");  strcpy(con -> sock_options, """");  strcpy(con -> address, """");  strcpy(con -> desthost, server);  strcpy(con -> PDomain, NTdomain);  strcpy(con -> OSName, SMBLIB_DEFAULT_OSNAME);  strcpy(con -> LMType, SMBLIB_DEFAULT_LMTYPE);  con -> first_tree = con -> last_tree = NULL;   SMB_Get_My_Name(con -> myname, sizeof(con -> myname));  con -> port = 0;                          con -> pid = getpid();  con -> mid = con -> pid;         con -> uid = 0;                   con -> gid = getgid();     for (i=0; i < strlen(server); i++)    called[i] = toupper(server[i]);tt         called[strlen(server)] = 0;       for (i=0; i < strlen(con -> myname); i++)    calling[i] = toupper(con -> myname[i]);tt         calling[strlen(con -> myname)] = 0;       if (strcmp(con -> address, """") == 0)    address = con -> desthost;  else    address = con -> address;  con -> Trans_Connect = RFCNB_Call(called,tttt    calling,tttt    address,  tttt    con -> port);     if (con -> Trans_Connect == NULL) {    if (Con_Handle == NULL) {      Con_Handle = NULL;      free(con);    }    SMBlib_errno = -SMBlibE_CallFailed;    return NULL;  }  return(con);}",3,"cwe119,cwe120,cwe469"
"throw_at_monster(object *monster, object *weapon){    short damage, hit_chance;    short t;    hit_chance = get_hit_chance(weapon);    damage = get_weapon_damage(weapon);    if ((weapon->which_kind == ARROW) &&t(rogue.weapon && (rogue.weapon->which_kind == BOW))) {tdamage += get_weapon_damage(rogue.weapon);tdamage = ((damage * 2) / 3);thit_chance += (hit_chance / 3);    } else if ((weapon->in_use_flags & BEING_WIELDED) &&t       ((weapon->which_kind == DAGGER) ||tt(weapon->which_kind == SHURIKEN) ||tt(weapon->which_kind == DART))) {tdamage = ((damage * 3) / 2);thit_chance += (hit_chance / 3);    }    t = weapon->quantity;    weapon->quantity = 1;    sprintf(hit_message, mesg[212], name_of(weapon));    weapon->quantity = t;    if (!rand_percent(hit_chance)) {t(void) strcat(hit_message, mesg[213]);treturn 0;    }    (void) strcat(hit_message, mesg[214]);    if ((weapon->what_is == WAND) && rand_percent(75)) {tzap_monster(monster, weapon->which_kind);#if !defined( ORIGINAL )    } else if (weapon->what_is == POTION) {tpotion_monster(monster, weapon->which_kind);#endif      } else {t(void) mon_damage(monster, damage);    }    return 1;}",2,"cwe120,cweother"
"encodeqp(const char *ptr, size_t len,tt    const char *charset,tt    int (*qp_allow)(char),tt    int (*func)(const char *, size_t, void *), void *arg){tsize_t i;tint rc;tchar buf[3];tif ((rc=(*func)(""=?"", 2, arg)) ||t    (rc=(*func)(charset, strlen(charset), arg))||t    (rc=(*func)(""?Q?"", 3, arg)))ttreturn rc;tfor (i=0; i<len; ++i)t{ttsize_t j;ttfor (j=i; j<len; ++j)tt{tttif (ptr[j] == ' ' || DOENCODEWORD(ptr[j]))ttttbreak;tt}ttif (j > i)tt{tttrc=(*func)(ptr+i, j-i, arg);tttif (rc)ttttreturn rc;tttif (j >= len)ttttbreak;tt}tti=j;ttif (ptr[i] == ' ')tttrc=(*func)(""_"", 1, arg);ttelsett{tttbuf[0]='=';tttbuf[1]=xdigit[ ( ptr[i] >> 4) & 0x0F ];tttbuf[2]=xdigit[ ptr[i] & 0x0F ];tttrc=(*func)(buf, 3, arg);tt}ttif (rc)tttreturn rc;t}treturn (*func)(""?="", 2, arg);}",2,"cwe119,cwe120"
"pm_command(transport_type transport, char* serial,                      int argc, char** argv){    char buf[4096];    snprintf(buf, sizeof(buf), ""shell:pm"");    while(argc-- > 0) {        char *quoted;        quoted = dupAndQuote(*argv++);        strncat(buf, "" "", sizeof(buf)-1);        strncat(buf, quoted, sizeof(buf)-1);        free(quoted);    }    send_shellcommand(transport, serial, buf);    return 0;}",4,"cwe119,cwe120,cwe476,cweother"
"init_xtra_windows(void){tint i = 0;tterm_data *main_term = &data[0];tGtkWidget *font_button;tt#ifdef USE_GTK_BUILDERtGtkBuilder *xml;t#elsetGladeXML *xml;t#endif ttchar buf[1024];t tpath_build(buf, sizeof(buf), ANGBAND_DIR_XTRA, GTK_XML);txml = get_gtk_xml(buf, NULL);ttfor (i = 0; i < MAX_XTRA_WIN_DATA; i++)t{ttxtra_win_data *xd = &xdata[i];tttttfont_button = get_widget(xml, xd->font_button_name);ttxd->win = get_widget(xml, xd->win_name);ttxd->text_view = get_widget(xml, xd->text_view_name);ttxd->drawing_area = get_widget(xml, xd->drawing_area_name);ttttgtk_font_button_set_font_name(GTK_FONT_BUTTON(font_button), xd->font.name);ttgtk_widget_realize(xd->win);ttgtk_window_set_title(GTK_WINDOW(xd->win), xd->name);ttttif (xd->text_view != NULL)tt{tttwhite_on_black_textview(xd);tttgtk_widget_modify_font(GTK_WIDGET(xd->text_view), pango_font_description_from_string(xd->font.name));tt}ttif (xd->drawing_area != NULL)tt{tttcairo_rectangle_t r;tttgtk_widget_realize(xd->drawing_area); tttttgtk_widget_modify_bg(xd->win, GTK_STATE_NORMAL, &black);tttgtk_widget_modify_bg(xd->drawing_area, GTK_STATE_NORMAL, &black);tttttxd->surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 255 * main_term->font.w, 255 * main_term->font.h);tttinit_cairo_rect(&r, 0, 0, 255 * main_term->font.w, 255 * main_term->font.h);tttcairo_clear(xd->surface, r, TERM_DARK);tt}ttt}t#ifdef USE_GTK_BUILDERtgtk_builder_connect_signals(xml, NULL);t#elsetglade_xml_signal_autoconnect(xml);t#endiftg_object_unref(G_OBJECT(xml));}",2,"cwe119,cwe120"
"HandleSlashCmds(PsqlScanState scan_state,ttttPQExpBuffer query_buf){tbackslashResult status = PSQL_CMD_SKIP_LINE;tchart   *cmd;tchart   *arg;tpsql_assert(scan_state);t tcmd = psql_scan_slash_command(scan_state);t tstatus = exec_command(cmd, scan_state, query_buf);tif (status == PSQL_CMD_UNKNOWN && strlen(cmd) > 1)t{tt ttcharttnew_cmd[2];tt ttnew_cmd[0] = cmd[0];ttnew_cmd[1] = '0';ttpsql_scan_slash_pushback(scan_state, cmd + 1);ttstatus = exec_command(new_cmd, scan_state, query_buf);ttif (status != PSQL_CMD_UNKNOWN)tt{ttt tttcmd[1] = '0';tt}t}tif (status == PSQL_CMD_UNKNOWN)t{ttif (pset.cur_cmd_interactive)tttfprintf(stderr, _(""Invalid command %s. Try ? for help.""), cmd);ttelsetttpsql_error(""invalid command %s"", cmd);ttstatus = PSQL_CMD_ERROR;t}tif (status != PSQL_CMD_ERROR)t{tt tt ttwhile ((arg = psql_scan_slash_option(scan_state,ttttttttttt OT_VERBATIM, NULL, false)))tt{tttpsql_error(""%s: extra argument ""%s"" ignored"", cmd, arg);tttfree(arg);tt}t}telset{tt ttwhile ((arg = psql_scan_slash_option(scan_state,ttttttttttt OT_WHOLE_LINE, NULL, false)))tttfree(arg);t}t tpsql_scan_slash_command_end(scan_state);tfree(cmd);treturn status;}",2,"cwe119,cwe120"
"GetFQHN(){ FILE *pp;  char cfcom[CF_BUFSIZE];  static char line[CF_BUFSIZE],*sp;snprintf(cfcom,CF_BUFSIZE-1,""%s/bin/cfagent -Q fqhost"",CFWORKDIR); if ((pp=popen(cfcom,""r"")) ==  NULL)   {   Verbose(""Couldn't open cfengine data "");   perror(""popen"");   exit(0);   }line[0] = '0'; fgets(line,CF_BUFSIZE,pp);for (sp = line; *sp != '0'; sp++)   {   if (*sp == '=')      {      sp++;      break;      }   }strcpy(VFQNAME,line);if (strlen(VFQNAME) == 0)   {   struct utsname sys;   if (uname(&sys) == -1)      {      perror(""uname "");      exit(0);      }   strcpy(VFQNAME,sys.sysname);   } else   {   VFQNAME[strlen(VFQNAME)-1] = '0';   Verbose(""Got fully qualified name (%s)"",VFQNAME);   } pclose(pp);}",3,"cwe119,cwe120,cweother"
"lookup_init(const char *mapfmt, int argc, const char *const *argv, void **context){tstruct lookup_context *ctxt;tchar buf[MAX_ERR_BUF];tstruct stat st;t*context = NULL;tctxt = malloc(sizeof(struct lookup_context));tif (!ctxt) {ttchar *estr = strerror_r(errno, buf, MAX_ERR_BUF);ttlogerr(MODPREFIX ""malloc: %s"", estr);ttreturn 1;t}tif (argc < 1) {ttfree(ctxt);ttlogerr(MODPREFIX ""No map name"");ttreturn 1;t}tctxt->mapname = argv[0];tif (ctxt->mapname[0] != '/') {ttfree(ctxt);ttlogmsg(MODPREFIXtt     ""dir map %s is not an absolute pathname"", argv[0]);ttreturn 1;t}tif (access(ctxt->mapname, R_OK)) {ttfree(ctxt);ttwarn(LOGOPT_NONE, MODPREFIXtt     ""dir map %s missing or not readable"", argv[0]);ttreturn 1;t}tif (stat(ctxt->mapname, &st)) {ttfree(ctxt);ttwarn(LOGOPT_NONE, MODPREFIXtt     ""dir map %s, could not stat"", argv[0]);ttreturn 1;t}tif ( (!S_ISDIR(st.st_mode)) && (!S_ISLNK(st.st_mode)) ) {ttfree(ctxt);ttwarn(LOGOPT_NONE, MODPREFIXtt     ""dir map %s, is not a directory"", argv[0]);t}t*context = ctxt;treturn 0;}",3,"cwe119,cwe120,cweother"
"ArgusProcessRemoteSocket(struct ArgusClientData *client, int fd){   char buf[MAXBUFSIZE];   int retn = 0, cnt;       bzero (buf, sizeof(buf));   if ((cnt = recv (fd, buf, MAXBUFSIZE, 0)) != 0) {#ifdef ARGUSDEBUG      ArgusDebug (3, ""ArgusProcessRemoteSocket: read '%s' from remote"", buf);#endif      if ((strncmp (buf, ""DONE: "", 6)) == 0)         retn = -4;      if ((strncmp (buf, ""FILTER: "", 8)) == 0) {         if (ArgusFilterCompile (&ArgusBPFcode, &buf[7], 0, 0) < 0) {            retn = -2;         } else {            ArgusFilterInitialized++;            retn = 0;            if (Argusbpflag)               Argusbpf_dump (&ArgusBPFcode, Argusbpflag);#ifdef ARGUSDEBUG            ArgusDebug (2, ""ArgusProcessRemoteSocket: ArgusFilter %s initialized."", &buf[7]);#endif         }      }   } else {      close (fd);      fd = -1;      retn = -1;   }#ifdef ARGUSDEBUG   ArgusDebug (6, ""ArgusProcessRemoteSocket: returning %d"", retn);#endif   return (retn);}",2,"cwe119,cwe120"
"""ParseIdentifier(FILE *f, char *token){  int current;  int pos_in_token=0;  /* the first char is available */  token[pos_in_token++] = fgetc(f);  /* read the identifier name */  do {    current = fgetc(f);    if(current==EOF) return(-1);    if(isalnum(current) || current=='_') token[pos_in_token++]=current;    else if(!isspace(current)) return(-1);    if(pos_in_token+1>=MAX_ENTRY_LENGTH) return(-1);  } while(!isspace(current));    token[pos_in_token] = (char) 0;  while(isspace(current)) {    if(current=='') return(-1);    current=fgetc(f);    if(current==EOF) return(-1);  }    /* check if it's a list or a variable */  switch(current) {  case '{':    /* this is a list */    current=fgetc(f);    while(current!='') {      if(!isspace(current)) return(-1);      current=fgetc(f);      if(current==EOF) return(-1);    }    while(current=='') {      DbmParseLineNumber++;      current=fgetc(f);    }        return(DBM_TOKEN_LIST_ID);    break;  case '=' :    /* this is a variable */    do {      current=fgetc(f);      if(current==EOF || current=='') return(-1);    } while(isspace(current));    ungetc((int) current, f);       return(DBM_TOKEN_VAR_ID);     break;  default :    return(-1);  }    return(-1);  }""",2,"cwe120,cweother"
"eb_set_binary_color_graphic(EB_Book *book, const EB_Position *position){    EB_Error_Code error_code;    EB_Binary_Context *context;    char buffer[EB_COLOR_GRAPHIC_HEADER_LENGTH];    eb_lock(&book->lock);    LOG((""in: eb_set_binary_color_graphic(book=%d, position={%d,%d})"",t(int)book->code, position->page, position->offset));    eb_reset_binary_context(book);         if (book->subbook_current == NULL) {terror_code = EB_ERR_NO_CUR_SUB;tgoto failed;    }         if (zio_file(&book->subbook_current->graphic_zio) < 0) {terror_code = EB_ERR_NO_SUCH_BINARY;tgoto failed;    }         if (position->page <= 0 || position->offset < 0) {terror_code = EB_ERR_FAIL_SEEK_BINARY;tgoto failed;    }    context = &book->binary_context;    context->code = EB_BINARY_COLOR_GRAPHIC;    context->zio = &book->subbook_current->graphic_zio;    context->location = ((off_t) position->page - 1) * EB_SIZE_PAGEt+ position->offset;    context->offset = 0;    context->cache_length = 0;    context->cache_offset = 0;         if (zio_lseek(context->zio, context->location, SEEK_SET) < 0) {terror_code = EB_ERR_FAIL_SEEK_BINARY;tgoto failed;    }         if (zio_read(context->zio, buffer, EB_COLOR_GRAPHIC_HEADER_LENGTH)t!= EB_COLOR_GRAPHIC_HEADER_LENGTH) {terror_code = EB_ERR_FAIL_READ_BINARY;tgoto failed;    }    if (memcmp(buffer, ""data"", 4) == 0) {tcontext->size = eb_uint4_le(buffer + 4);tcontext->location += EB_COLOR_GRAPHIC_HEADER_LENGTH;    } else {tcontext->size = 0;tif (zio_lseek(context->zio, context->location, SEEK_SET) < 0) {t    error_code = EB_ERR_FAIL_SEEK_BINARY;t    goto failed;t}    }    LOG((""out: eb_set_binary_color_graphic() = %s"",teb_error_string(EB_SUCCESS)));    eb_unlock(&book->lock);    return EB_SUCCESS;       failed:    eb_reset_binary_context(book);    LOG((""out: eb_set_binary_color_graphic() = %s"",teb_error_string(error_code)));    eb_unlock(&book->lock);    return error_code;}",2,"cwe119,cwe120"
"e_book_backend_open (EBookBackend *backend,                     GCancellable *cancellable,                     GAsyncReadyCallback callback,                     gpointer user_data){tEBookBackendClass *class;tGSimpleAsyncResult *simple;tg_return_if_fail (E_IS_BOOK_BACKEND (backend));tclass = E_BOOK_BACKEND_GET_CLASS (backend);tsimple = g_simple_async_result_new (ttG_OBJECT (backend), callback,ttuser_data, e_book_backend_open);tg_simple_async_result_set_check_cancellable (simple, cancellable);tif (class->open_sync != NULL) {ttbook_backend_push_operation (tttbackend, simple, cancellable, TRUE,tttbook_backend_open_thread);ttbook_backend_dispatch_next_operation (backend);t} else if (class->open != NULL) {ttbook_backend_push_operation (tttbackend, simple, cancellable, TRUE,tttbook_backend_open_thread_old_style);ttbook_backend_dispatch_next_operation (backend);t} else {ttg_simple_async_result_set_error (tttsimple, E_CLIENT_ERROR,tttE_CLIENT_ERROR_NOT_SUPPORTED,ttt""%s"", e_client_error_to_string (tttE_CLIENT_ERROR_NOT_SUPPORTED));ttg_simple_async_result_complete_in_idle (simple);t}tg_object_unref (simple);}",2,"cwe476,cweother"
"""SFileFindFirstFile(HANDLE hMpq, const char * szMask, SFILE_FIND_DATA * lpFindFileData, const char * szListFile)r{r    TMPQArchive * ha = (TMPQArchive *)hMpq;r    TMPQSearch * hs = NULL;r    size_t nSize  = 0;r    int nError = ERROR_SUCCESS;rr    // Check for the valid parametersr    if(!IsValidMpqHandle(ha))r        nError = ERROR_INVALID_HANDLE;r    if(szMask == NULL || lpFindFileData == NULL)r        nError = ERROR_INVALID_PARAMETER;rr    // Include the listfile into the MPQ's internal listfiler    // Note that if the listfile name is NULL, do nothing because ther    // internal listfile is always included.r    if(nError == ERROR_SUCCESS && szListFile != NULL && *szListFile != 0)r        nError = SFileAddListFile((HANDLE)ha, szListFile);rr    // Allocate the structure for MPQ searchr    if(nError == ERROR_SUCCESS)r    {r        nSize = sizeof(TMPQSearch) + strlen(szMask) + 1;r        if((hs = (TMPQSearch *)ALLOCMEM(char, nSize)) == NULL)r            nError = ERROR_NOT_ENOUGH_MEMORY;r    }rr    // Perform the first searchr    if(nError == ERROR_SUCCESS)r    {r        memset(hs, 0, sizeof(TMPQSearch));r        strcpy(hs->szSearchMask, szMask);r        hs->dwFlagMask = MPQ_FILE_EXISTS;r        hs->ha = ha;rr        // If the archive is patched archive, we have to create a merge tabler        // to prevent files being repeatedr        if(ha->haPatch != NULL)r        {r            hs->dwSearchTableItems = GetSearchTableItems(ha);r            hs->pSearchTable = ALLOCMEM(TFileEntry *, hs->dwSearchTableItems);r            hs->dwFlagMask = MPQ_FILE_EXISTS | MPQ_FILE_PATCH_FILE;r            if(hs->pSearchTable != NULL)r                memset(hs->pSearchTable, 0, hs->dwSearchTableItems * sizeof(TFileEntry *));r            elser                nError = ERROR_NOT_ENOUGH_MEMORY;r        }r    }rr    // Perform first item searchingr    if(nError == ERROR_SUCCESS)r    {r        nError = DoMPQSearch(hs, lpFindFileData);r    }rr    // Cleanupr    if(nError != ERROR_SUCCESS)r    {r        FreeMPQSearch(hs);r        SetLastError(nError);r    }r    r    // Return the result valuer    return (HANDLE)hs;r}""",2,"cwe120,cweother"
"get_sectorsize(struct scsi_cd *cd){tunsigned char cmd[10];tunsigned char buffer[8];tint the_result, retries = 3;tint sector_size;tstruct request_queue *queue;tdo {ttcmd[0] = READ_CAPACITY;ttmemset((void *) &cmd[1], 0, 9);ttmemset(buffer, 0, sizeof(buffer));tt ttthe_result = scsi_execute_req(cd->device, cmd, DMA_FROM_DEVICE,ttttt      buffer, sizeof(buffer), NULL,ttttt      SR_TIMEOUT, MAX_RETRIES, NULL);ttretries--;t} while (the_result && retries);tif (the_result) {ttcd->capacity = 0x1fffff;ttsector_size = 2048;t t} else {ttlong last_written;ttcd->capacity = 1 + ((buffer[0] << 24) | (buffer[1] << 16) |tttt    (buffer[2] << 8) | buffer[3]);tt ttif (!cdrom_get_last_written(&cd->cdi, &last_written))tttcd->capacity = max_t(long, cd->capacity, last_written);ttsector_size = (buffer[4] << 24) |tt    (buffer[5] << 16) | (buffer[6] << 8) | buffer[7];ttswitch (sector_size) {ttt ttcase 0:ttcase 2340:ttcase 2352:tttsector_size = 2048;ttt ttcase 2048:tttcd->capacity *= 4;ttt ttcase 512:tttbreak;ttdefault:tttsr_printk(KERN_INFO, cd,tttt  ""unsupported sector size %d."", sector_size);tttcd->capacity = 0;tt}ttcd->device->sector_size = sector_size;tt ttset_capacity(cd->disk, cd->capacity);t}tqueue = cd->device->request_queue;tblk_queue_logical_block_size(queue, sector_size);treturn;}",2,"cwe119,cwe120"
"tda18271_read_extended(struct dvb_frontend *fe){tstruct tda18271_priv *priv = fe->tuner_priv;tunsigned char *regs = priv->tda18271_regs;tunsigned char regdump[TDA18271_NUM_REGS];tunsigned char buf = 0x00;tint ret, i;tstruct i2c_msg msg[] = {tt{ .addr = priv->i2c_props.addr, .flags = 0,tt  .buf = &buf, .len = 1 },tt{ .addr = priv->i2c_props.addr, .flags = I2C_M_RD,tt  .buf = regdump, .len = TDA18271_NUM_REGS }t};ttda18271_i2c_gate_ctrl(fe, 1);t tret = i2c_transfer(priv->i2c_props.adap, msg, 2);ttda18271_i2c_gate_ctrl(fe, 0);tif (ret != 2)tttda_err(""ERROR: i2c_transfer returned: %d"", ret);tfor (i = 0; i < TDA18271_NUM_REGS; i++) {tt ttif ((i != R_EB9)  &&tt    (i != R_EB16) &&tt    (i != R_EB17) &&tt    (i != R_EB19) &&tt    (i != R_EB20))tttregs[i] = regdump[i];t}tif (tda18271_debug & DBG_REG)tttda18271_dump_regs(fe, 1);treturn (ret == 2 ? 0 : ret);}",2,"cwe119,cwe120"
"parse_checksum_line(char *line, char **filename, uint8_t *hash,ttint *binary, struct program_settings *settings){tregex_t checksum_expression;tregmatch_t matches[4];tchar pattern[64];tsprintf(pattern, ""^([0-9A-Fa-f]{%u}) (*| )(.*)$"",tttsettings->hash_len*2);tregcomp(&checksum_expression, pattern, REG_EXTENDED);tif (regexec(&checksum_expression, line, 4, matches, 0) == 0)t{tt ttparse_hash(line, hash, settings->hash_len);ttif (line[matches[2].rm_so] == '*')tt{ttt*binary = 1;tt}ttelsett{ttt*binary = 0;tt}tt*filename = line + matches[3].rm_so;t}telset{ttregfree(&checksum_expression);ttsprintf(pattern, ""^%s ((.*)) = ([0-9A-Fa-f]{%u})$"",ttttsettings->hash_name, settings->hash_len*2);ttregcomp(&checksum_expression, pattern, REG_EXTENDED);ttif (regexec(&checksum_expression, line, 4, matches, 0) == 0)tt{ttt tttparse_hash(line+matches[2].rm_so, hash, settings->hash_len);tttline[matches[1].rm_eo] = '0';ttt*filename = line + matches[1].rm_so;ttt*binary = settings->binary;tt}ttelsett{tttregfree(&checksum_expression);tttreturn -1;tt}t}tregfree(&checksum_expression);treturn 1;}",2,"cwe119,cwe120"
"RegisterTTFImage(void){  static char    version[MaxTextExtent];  MagickInfo    *entry;  *version='0';#if defined(FREETYPE_MAJOR) && defined(FREETYPE_MINOR)  FormatString(version,""%d.%d"",FREETYPE_MAJOR,FREETYPE_MINOR);#endif  entry=SetMagickInfo(""TTF"");#if defined(HasTTF)  entry->decoder=(DecoderHandler) ReadTTFImage;#endif  entry->magick=(MagickHandler) IsTTF;  entry->adjoin=False;  entry->description=""TrueType font"";  if (*version != '0')    entry->version=version;  entry->module=""TTF"";  entry->coder_class=PrimaryCoderClass;  (void) RegisterMagickInfo(entry);  entry=SetMagickInfo(""PFA"");#if defined(HasTTF)  entry->decoder=(DecoderHandler) ReadTTFImage;#endif  entry->magick=(MagickHandler) IsPFA;  entry->adjoin=False;  entry->description=""Postscript Type 1 font (ASCII)"";  if (*version != '0')    entry->version=version;  entry->module=""TTF"";  entry->coder_class=PrimaryCoderClass;  (void) RegisterMagickInfo(entry);  entry=SetMagickInfo(""PFB"");#if defined(HasTTF)  entry->decoder=(DecoderHandler) ReadTTFImage;#endif  entry->magick=(MagickHandler) IsPFA;  entry->adjoin=False;  entry->description=""Postscript Type 1 font (binary)"";  if (*version != '0')    entry->version=version;  entry->module=""TTF"";  entry->coder_class=PrimaryCoderClass;  (void) RegisterMagickInfo(entry);}",2,"cwe119,cwe120"
"print_msg(int Level, const char *fmt, ...){     auto int     SLevel = PRT_NOTHING, l;  auto char    String[LONG_STRING_SIZE], s[LONG_STRING_SIZE];  auto va_list ap;  va_start(ap, fmt);  l = vsnprintf(String, LONG_STRING_SIZE, fmt, ap);  va_end(ap);  if (width) {    memcpy(s, String, l + 1);    if (l > width) {      if (s[l - 1] < ' ') {        s[width] = s[l - 1];        s[width + 1] = 0;      }      else        s[width] = 0;    }    }    SLevel = IS_DEBUG(Level) ? LOG_DEBUG : LOG_INFO;  if (Level & syslogmessage)    syslog(SLevel, ""%s"", String);  if (Level & stdoutput) {    (void)fputs(width ? s : String, stdout);    fflush(stdout);  }    if (Level & message)  {              if (!fout && !fcons && !isdaemon) {      fputs(width ? s : String, stderr);      fflush(stderr);    }         if (fcons != NULL) {      fputs(width ? s : String, fcons);      fflush(fcons);    }           if (fout != NULL)    {      fputs(width ? s : String, fout);      fflush(fout);    }  }  if (Level & xinfo)    print_from_server(String);  if (verbose && (Level & PRT_LOG)) {    fprintf(fprot, ""%s  %s"", stl, String);    if (synclog)      fflush(fprot);  }    return(0);}",3,"cwe119,cwe120,cweother"
"cut_abort(const char *s, unsigned short reason){t tReplace(saved_errmsg, NewString(s));t tctlr_add(RO_FRAME_TYPE, RFT_CONTROL_CODE, 0);tctlr_add(RO_FRAME_SEQ, ea_buf[O_DT_FRAME_SEQ].cc, 0);tctlr_add(RO_REASON_CODE, HIGH8(reason), 0);tctlr_add(RO_REASON_CODE+1, LOW8(reason), 0);ttrace_ds(""> FT CONTROL_CODE ABORT"");taction_internal(PF_action, IA_FT, ""2"", CN);t tft_aborting();}",3,"cwe119,cwe120,cweother"
"ossl_recv(struct connectdata *conn,                           int num,                                            char *buf,                                          size_t buffersize,                                  CURLcode *curlcode){  char error_buffer[120];    unsigned long sslerror;  ssize_t nread;  int buffsize;  ERR_clear_error();  buffsize = (buffersize > (size_t)INT_MAX) ? INT_MAX : (int)buffersize;  nread = (ssize_t)SSL_read(conn->ssl[num].handle, buf, buffsize);  if(nread <= 0) {         int err = SSL_get_error(conn->ssl[num].handle, (int)nread);    switch(err) {    case SSL_ERROR_NONE:      case SSL_ERROR_ZERO_RETURN:        break;    case SSL_ERROR_WANT_READ:    case SSL_ERROR_WANT_WRITE:             *curlcode = CURLE_AGAIN;      return -1;    default:                    sslerror = ERR_get_error();      if((nread < 0) || sslerror) {                 failf(conn->data, ""SSL read: %s, errno %d"",              ERR_error_string(sslerror, error_buffer),              SOCKERRNO);        *curlcode = CURLE_RECV_ERROR;        return -1;      }    }  }  return nread;}",2,"cwe119,cwe120"
"_daemon_init (){        if (!cmd_args.common.debug)    {      unsigned int i;      pid_t pid;      FILE *pidfile;      int fds[2];      if ( pipe(fds) < 0 )        _err_exit (""pipe: %s"", strerror (errno));      if ( (pidfile = fopen(BMC_WATCHDOG_PIDFILE, ""w"")) == NULL )        _err_exit (""fopen: %s"", strerror (errno));      if ((pid = fork ()) < 0)        _err_exit (""fork: %s"", strerror (errno));      if (pid)        {                     char buf;          if (read(fds[0], &buf, 1) < 0)            _err_exit (""read: %s"", strerror (errno));          close(fds[1]);          close(fds[0]);          exit (0);        }      setsid ();      if (signal (SIGHUP, SIG_IGN) == SIG_ERR)        _err_exit (""signal: %s"", strerror (errno));      if ((pid = fork ()) < 0)        _err_exit (""fork: %s"", strerror (errno));      if (pid) {                 fprintf(pidfile, ""%u"", pid);        fclose(pidfile);        exit (0);                          }      if (chdir (""/"") < 0)        _err_exit (""chdir: %s"", strerror (errno));      umask (0);      if (write(fds[1], ""a"", 1) < 0)        _err_exit (""write: %s"", strerror (errno));      close(fds[1]);      close(fds[0]);      for (i = 0; i < 64; i++)        close (i);    }  _init_bmc_watchdog (LOG_DAEMON, 0);}",2,"cwe120,cweother"
"new_functor_name(int arity){  char s1[MAX_NAME], s2[MAX_NAME];  static int functor_num;  int_str(++functor_num, s1);  cat_str(""k"", s1, s2);  while (in_sym_tab(s2)) {    int_str(++functor_num, s1);    cat_str(""k"", s1, s2);  }  return(str_to_sn(s2, arity));}",2,"cwe119,cwe120"
"preadfd(void){tint nr;tchar *buf =  parsefile->buf;tparsenextc = buf;retry:#ifndef SMALLtif (parsefile->fd == 0 && el) {ttstatic const char *rl_cp;ttstatic int el_len;ttif (rl_cp == NULL)tttrl_cp = el_gets(el, &el_len);ttif (rl_cp == NULL)tttnr = 0;ttelse {tttnr = el_len;tttif (nr > IBUFSIZ - 1)ttttnr = IBUFSIZ - 1;tttmemcpy(buf, rl_cp, nr);tttif (nr != el_len) {ttttel_len -= nr;ttttrl_cp += nr;ttt} elsettttrl_cp = 0;tt}t} else#endif#ifdef HETIOttnr = hetio_read_input(parsefile->fd);ttif (nr == -255)#endifttnr = read(parsefile->fd, buf, IBUFSIZ - 1);tif (nr < 0) {ttif (errno == EINTR)tttgoto retry;ttif (parsefile->fd == 0 && errno == EWOULDBLOCK) {tttint flags = fcntl(0, F_GETFL, 0);tttif (flags >= 0 && flags & O_NONBLOCK) {ttttflags &=~ O_NONBLOCK;ttttif (fcntl(0, F_SETFL, flags) >= 0) {tttttout2str(""sh: turning off NDELAY mode"");tttttgoto retry;tttt}ttt}tt}t}treturn nr;}",2,"cwe120,cweother"
"middle_table_row (struct middletab *mt, int j, PRN *prn){    const char *s1 = mt->key[j];    const char *s2 = mt->key[j+1];    char x1[48], x2[48];    int k = j + 1;    if (tex_format(prn)) {tif (mt->multi) {t    pprintf(prn, ""%s & %s %s & %s "",tt    A_(s1), print_fifteen(x1, mt->val[j], mt->minus),tt    A_(s2), print_fifteen(x2, mt->val[k], mt->minus));t} else {t    pprintf(prn, ""%s & %s & %s & %s "",tt    A_(s1), print_eight(x1, mt, j),tt    A_(s2), print_eight(x2, mt, k));t}    } else if (rtf_format(prn)) {tif (mt->multi) {t    pputs(prn, RTF_MULTI_ROW);t    pprintf(prn, RTF_MULTI_FMT, A_(s1), tt    print_fifteen(x1, mt->val[j], mt->minus));t    pputs(prn, RTF_MULTI_ROW);t    pprintf(prn, RTF_MULTI_FMT, A_(s2), tt    print_fifteen(x1, mt->val[k], mt->minus));t} else {t    pputs(prn, RTF_MT_ROW);t    pprintf(prn, RTF_MT_FMT, tt    A_(s1), print_eight(x1, mt, j),tt    A_(s2), print_eight(x2, mt, k));t}    } else if (csv_format(prn)) {tpprintf(prn, """"%s""%c%s%c""%s""%c%s"",ttA_(s1), mt->d, print_csv(x1, mt->val[j]), mt->d,ttA_(s2), mt->d, print_csv(x2, mt->val[k]));    } else {tif (mt->nls || mt->multi) {t    middletab_prepare_format(mt, j);t}tif (mt->multi) {t    pprintf(prn, mt->txt_fmt, tt    _(s1), print_fifteen(x1, mt->val[j], mt->minus),tt    _(s2), print_fifteen(x2, mt->val[k], mt->minus));t} else {t    pprintf(prn, mt->txt_fmt, tt    _(s1), print_eight(x1, mt, j),tt    _(s2), print_eight(x2, mt, k));t}    }}",2,"cwe119,cwe120"
"read_sadump(int fd, void *bufptr, int cnt, ulong addr, physaddr_t paddr){tphysaddr_t curpaddr ATTRIBUTE_UNUSED;tuint64_t pfn, whole_offset, perdisk_offset, block;tulong page_offset;tint dfd;tif (sd->flags & SADUMP_KDUMP_BACKUP &&t    paddr >= sd->backup_src_start &&t    paddr < sd->backup_src_start + sd->backup_src_size) {ttulong orig_paddr;ttorig_paddr = paddr;ttpaddr += sd->backup_offset - sd->backup_src_start;ttif (CRASHDEBUG(1))ttterror(INFO, ""sadump: kdump backup region: %#llx => %#llx"",ttt      orig_paddr, paddr);t}tpfn = paddr_to_pfn(paddr);tcurpaddr = paddr & ~((physaddr_t)(sd->block_size-1));tpage_offset = paddr & ((physaddr_t)(sd->block_size-1));tif ((pfn >= sd->dump_header->max_mapnr) || !page_is_ram(pfn))ttreturn SEEK_ERROR;tif (!page_is_dumpable(pfn)) {ttif (sd->flags & SADUMP_ZERO_EXCLUDED)tttreturn PAGE_EXCLUDED;ttmemset(bufptr, 0, cnt);ttreturn cnt;t}tblock = pfn_to_block(pfn);twhole_offset = block * sd->block_size;tif (sd->flags & SADUMP_DISKSET) {ttint diskid;ttif (!lookup_diskset(whole_offset, &diskid, &perdisk_offset))tttreturn SEEK_ERROR;ttdfd = sd->sd_list[diskid]->dfd;ttperdisk_offset += sd->sd_list[diskid]->data_offset;t} else {ttdfd = sd->dfd;ttperdisk_offset = whole_offset + sd->data_offset;t}tif (lseek(dfd, perdisk_offset, SEEK_SET) == failed)ttreturn SEEK_ERROR;tif (read(dfd, sd->page_buf, sd->block_size) != sd->block_size)ttreturn READ_ERROR;tmemcpy(bufptr, sd->page_buf + page_offset, cnt);treturn cnt;}",2,"cwe120,cweother"
"sendhelpfile(struct Client *source_p, const char *path, const char *topic){  FBFILE *file;  char line[HELPLEN];  char started = 0;  int type;  if ((file = fbopen(path, ""r"")) == NULL)  {    sendto_one(source_p, form_str(ERR_HELPNOTFOUND),               me.name, source_p->name, topic);    return;  }  if (fbgets(line, sizeof(line), file) == NULL)  {    sendto_one(source_p, form_str(ERR_HELPNOTFOUND),               me.name, source_p->name, topic);    return;  }  else if (line[0] != '#')  {    line[strlen(line) - 1] = '0';t      sendto_one(source_p, form_str(RPL_HELPSTART),             me.name, source_p->name, topic, line);    started = 1;  }  while (fbgets(line, sizeof(line), file))  {    line[strlen(line) - 1] = '0';    if (line[0] != '#')    {      if (!started)      {        type = RPL_HELPSTART;        started = 1;      }      else        type = RPL_HELPTXT;            sendto_one(source_p, form_str(RPL_HELPTXT),                 me.name, source_p->name, topic, line);    }  }  fbclose(file);  sendto_one(source_p, form_str(RPL_HELPTXT),             me.name, source_p->name, topic, """");  sendto_one(source_p, form_str(RPL_ENDOFHELP),             me.name, source_p->name, topic);}",2,"cwe119,cwe120"
"spawn_pipe(void (*child_proc) (int to_parent, int from_parent),t   int *to_child, int *from_child){    int pipe_to_child[2], pipe_from_child[2];    pid_t pid;    if (pipe(pipe_to_child) < 0) {tlog_perror(""SPAWNING: Couldn't create first pipe"");    } else if (pipe(pipe_from_child) < 0) {tlog_perror(""SPAWNING: Couldn't create second pipe"");tclose(pipe_to_child[0]);tclose(pipe_to_child[1]);    } else if ((pid = fork()) < 0) {tlog_perror(""SPAWNING: Couldn't fork middleman"");tclose(pipe_to_child[0]);tclose(pipe_to_child[1]);tclose(pipe_from_child[0]);tclose(pipe_from_child[1]);    } else if (pid != 0) {t tint status;tclose(pipe_to_child[0]);tclose(pipe_from_child[1]);t*to_child = pipe_to_child[1];t*from_child = pipe_from_child[0];t twait((void *) &status);t tif (status != 0) {t    errlog(""SPAWNING: Middleman died with status %d!"", status);t    close(pipe_to_child[1]);t    close(pipe_from_child[0]);t} else if (read(*from_child, &pid, sizeof(pid)) != sizeof(pid)) {t    errlog(""SPAWNING: Bad read() for pid"");t    close(pipe_to_child[1]);t    close(pipe_from_child[0]);t} else {t    return pid;t}    } else {ttt tclose(pipe_to_child[1]);tclose(pipe_from_child[0]);tif ((pid = fork()) < 0) {t    log_perror(""SPAWNING: Couldn't fork child"");t    exit(1);t} else if (pid != 0) {t t    write(pipe_from_child[1], &pid, sizeof(pid));t    exit(0);t} else {tt t    (*child_proc) (pipe_from_child[1], pipe_to_child[0]);t    exit(0);t}    }    return 0;}",2,"cwe120,cweother"
"vqt_extent(int handle, char *string, int coords[8]){  DEFINE_VPB;  int i;    i=0;  while(string[i])  {    o_vdipb.intin[i] = (short)string[i];    i++;  }    o_vdipb.contrl[VDI_HANDLE] = handle;  o_vdipb.contrl[ROUTINE] = 116;  o_vdipb.contrl[N_PTSIN] = 0;  o_vdipb.contrl[N_INTIN] = i;  vdi_call(&o_vdipb);    for(i=0 ; i<8 ; i++)    coords[i] = o_vdipb.ptsout[i];}",2,"cwe119,cwe120"
"sspm_get_parameter(char* line, char* parameter){    char *p,*s,*q;    static char name[1024];             p = strstr(line,parameter);    if( p == 0){treturn 0;    }         p+=strlen(parameter);    while(*p==' ' || *p == '='){tp++;    }         s = strchr(p,';');         q = strchr(p,'""');    if(q !=0){tp = q+1;    }    if(s != 0){tstrncpy(name,p,(size_t)s-(size_t)p);    } else {tstrcpy(name,p);    }    /* Strip off trailing quote, if it exists */    q = strrchr(name,'""');    if (q != 0){t*q='0';    }        return name;}",2,"cwe119,cwe120"
"mnode_print_stub(mnode* vp, unsigned char* p){    static unsigned char buf [256];    if (!vp)treturn;    if (!p)tp = &buf[0];    p[0] = MNODE_GET_CH(vp);    p[1] = '0';    if (vp->list)tprintf(""%s (list=%p)"", buf, vp->list);    if (vp->child)tmnode_print_stub(vp->child, p + 1);    if (vp->next)tmnode_print_stub(vp->next, p);}",2,"cwe119,cwe120"
"set_image_col_types (fitsfile * fptr, const char * name, int bitpix,                DataInfo * varInfo, iteratorCol *colIter) {   int istatus;   double tscale, tzero;   char temp[80];   switch (bitpix) {      case BYTE_IMG:      case SHORT_IMG:      case LONG_IMG:         istatus = 0;         if (fits_read_key(fptr, TDOUBLE, ""BZERO"", &tzero, NULL, &istatus))            tzero = 0.0;         istatus = 0;         if (fits_read_key(fptr, TDOUBLE, ""BSCALE"", &tscale, NULL, &istatus))            tscale = 1.0;         if (tscale == 1.0 && (tzero == 0.0 || tzero == 32768.0 )) {            varInfo->type     = LONG;            colIter->datatype = TLONG;         }         else {            varInfo->type     = DOUBLE;            colIter->datatype = TDOUBLE;            if (DEBUG_PIXFILTER)                printf(""use DOUBLE for %s with BSCALE=%g/BZERO=%g"",                        name, tscale, tzero);         }         break;      case LONGLONG_IMG:      case FLOAT_IMG:      case DOUBLE_IMG:         varInfo->type     = DOUBLE;         colIter->datatype = TDOUBLE;         break;      default:         sprintf(temp, ""set_image_col_types: unrecognized image bitpix [%d]"",                bitpix);         ffpmsg(temp);         return gParse.status = PARSE_BAD_TYPE;   }   return 0;}",2,"cwe119,cwe120"
"get_subclass(FILE * fd, struct SigSet *S, struct ClassSig *C){    struct SubSig *Sp;    char tag[1024];    Sp = I_NewSubSig(S, C);    while (gettag(fd, tag)) {tif (eq(tag, ""endsubclass:""))t    break;tif (eq(tag, ""pi:""))t    get_subclass_pi(fd, Sp);tif (eq(tag, ""means:""))t    get_subclass_means(fd, Sp, S->nbands);tif (eq(tag, ""covar:""))t    get_subclass_covar(fd, Sp, S->nbands);    }    return 0;}",2,"cwe119,cwe120"
"pyramid_set_char(Driver *drvthis, int n, unsigned char *dat){    char tele[10] = ""G@ABCDEFGH"";    int row, pixels;    PrivateData *p = (PrivateData *) drvthis->private_data;    unsigned char mask = (1 << p->cellwidth) - 1;    if (n < 0 && n > 7) {tdebug(RPT_WARNING, ""only characters 0-7 can be changed"");treturn;    }    if (!dat) {tdebug(RPT_WARNING, ""no character data"");treturn;    }    if (memcmp(dat, p->cc_cache[n], CELLHEIGHT)) {tmemcpy(p->cc_cache[n], dat, CELLHEIGHT);t ttele[1] = n + 0x40;tfor (row = 0; row < p->cellheight; row++) {t    pixels = dat[row] & mask;t     t    pixels |= 0x40;t    tele[row + 2] = pixels;t}treal_send_tele(p, tele, 10);tusleep(200);tt     }}",3,"cwe119,cwe120,cweother"
"date_test_fmt(date d, char *fmt){tstatic int i;tchar buf[200];tint r;tr = rfmtdate(d, fmt, buf);tprintf(""r: %d "", r);tif (r != 0)ttcheck_return(r);telsettprintf(""date: %d: %s"", i++, buf);}",2,"cwe119,cwe120"
"_print_aliases (char* node_hostname){tchar me[MAX_SLURM_NAME], *n = NULL, *a = NULL;tchar *s;tslurm_conf_init(NULL);tif (!node_hostname) {ttgethostname_short(me, MAX_SLURM_NAME);tts = me;t} elsetts = node_hostname;tif (!(n = slurm_conf_get_aliases(s)) && (s == me)) {ttif (!(a = slurm_conf_get_aliased_nodename()))ttta = slurm_conf_get_nodename(""localhost"");ttif (a) {tttn = slurm_conf_get_aliases(a);tttxfree(a);tt}t}tif (n) {ttfprintf(stdout, ""%s"", n);ttxfree(n);t}}",2,"cwe119,cwe120"
"textiowrapper_parse_cookie(cookie_type *cookie, PyObject *cookieObj){    unsigned char buffer[COOKIE_BUF_LEN];    PyLongObject *cookieLong = (PyLongObject *)PyNumber_Long(cookieObj);    if (cookieLong == NULL)        return -1;    if (_PyLong_AsByteArray(cookieLong, buffer, sizeof(buffer),                            PY_LITTLE_ENDIAN, 0) < 0) {        Py_DECREF(cookieLong);        return -1;    }    Py_DECREF(cookieLong);    memcpy(&cookie->start_pos, buffer + OFF_START_POS, sizeof(cookie->start_pos));    memcpy(&cookie->dec_flags, buffer + OFF_DEC_FLAGS, sizeof(cookie->dec_flags));    memcpy(&cookie->bytes_to_feed, buffer + OFF_BYTES_TO_FEED, sizeof(cookie->bytes_to_feed));    memcpy(&cookie->chars_to_skip, buffer + OFF_CHARS_TO_SKIP, sizeof(cookie->chars_to_skip));    memcpy(&cookie->need_eof, buffer + OFF_NEED_EOF, sizeof(cookie->need_eof));    return 0;}",2,"cwe119,cwe120"
"podcast_item_download(podcast_download_t * pd, GSList ** list, GSList * node) {tpodcast_item_t * item = (podcast_item_t *)node->data;tchar * file;tchar path[MAXLEN];tfloat duration;tstruct stat statbuf;ttfile = podcast_file_from_url(item->url);tsnprintf(path, MAXLEN-1, ""%s/%s"", pd->podcast->dir, file);tfree(file);tpd->ncurrent++;tpd->percent = 0;tstore_podcast_update_podcast_download(pd);tif (podcast_generic_download(pd->podcast, item->url, path, store_podcast_update_podcast_download, pd) < 0) {ttgoto failed;t}tif (stat(path, &statbuf) < 0) {ttgoto failed;t}tif ((duration = get_file_duration(path)) < 0.0f) {ttgoto failed;t}titem->duration = duration;titem->size = statbuf.st_size;titem->file = strdup(path);tpd->podcast->items = g_slist_prepend(pd->podcast->items, item);tstore_podcast_add_item(pd->podcast, item);treturn; failed:t*list = podcast_list_remove_item(pd->podcast, *list, node);}",2,"cwe119,cwe120"
"cmd_chhandle(struct userrec *u, int idx, char *par){  char hand[HANDLEN + 1], newhand[HANDLEN + 1];  int i, atr = u ? u->flags : 0, atr2;  struct userrec *u2;  strncpyz(hand, newsplit(&par), sizeof hand);  strncpyz(newhand, newsplit(&par), sizeof newhand);  if (!hand[0] || !newhand[0]) {    dprintf(idx, ""Usage: chhandle <oldhandle> <newhandle>"");    return;  }  for (i = 0; i < strlen(newhand); i++)    if ((newhand[i] <= 32) || (newhand[i] >= 127) || (newhand[i] == '@'))      newhand[i] = '?';  if (strchr(BADHANDCHARS, newhand[0]) != NULL)    dprintf(idx, ""Bizarre quantum forces prevent nicknames from starting with ""            ""'%c'."", newhand[0]);  else if (get_user_by_handle(userlist, newhand) &&           egg_strcasecmp(hand, newhand))    dprintf(idx, ""Somebody is already using %s."", newhand);  else {    u2 = get_user_by_handle(userlist, hand);    atr2 = u2 ? u2->flags : 0;    if ((atr & USER_BOTMAST) && !(atr & USER_MASTER) && !(atr2 & USER_BOT))      dprintf(idx, ""You can't change handles for non-bots."");    else if ((bot_flags(u2) & BOT_SHARE) && !(atr & USER_OWNER))      dprintf(idx, ""You can't change share bot's nick."");    else if ((atr2 & USER_OWNER) && !(atr & USER_OWNER) &&             egg_strcasecmp(dcc[idx].nick, hand))      dprintf(idx, ""You can't change a bot owner's handle."");    else if (isowner(hand) && egg_strcasecmp(dcc[idx].nick, hand))      dprintf(idx, ""You can't change a permanent bot owner's handle."");    else if (!egg_strcasecmp(newhand, botnetnick) && (!(atr2 & USER_BOT) ||             nextbot(hand) != -1))      dprintf(idx, ""Hey! That's MY name!"");    else if (change_handle(u2, newhand)) {      putlog(LOG_CMDS, ""*"", ""#%s# chhandle %s %s"", dcc[idx].nick,             hand, newhand);      dprintf(idx, ""Changed."");    } else      dprintf(idx, ""Failed."");  }}",2,"cwe119,cwe120"
"unbind_command(char *arg, struct session *ses){    char left[BUFFER_SIZE], result[BUFFER_SIZE];    if (!ui_keyboard)    {        tintin_eprintf(ses, ""#UI: no access to keyboard => no keybindings"");        return;    }    arg = get_arg_in_braces(arg, left, 1);    substitute_vars(left, result);    substitute_myvars(result, left, ses);    delete_hashlist(ses, ses->binds, left,        ses->mesvar[8]? ""#Ok. {%s} is no longer bound."" : 0,        ses->mesvar[8]? ""#No match(es) found for {%s}"" : 0);}",2,"cwe119,cwe120"
"stl_write_off(stl_file *stl, char *file) {  int i;  FILE      *fp;  char      *error_msg;  if (stl->error) return;     fp = fopen(file, ""w"");  if(fp == NULL) {    error_msg = (char*)                malloc(81 + strlen(file));      sprintf(error_msg, ""stl_write_ascii: Couldn't open %s for writing"",            file);    perror(error_msg);    free(error_msg);    stl->error = 1;    return;  }  fprintf(fp, ""OFF"");  fprintf(fp, ""%d %d 0"",          stl->stats.shared_vertices, stl->stats.number_of_facets);  for(i = 0; i < stl->stats.shared_vertices; i++) {    fprintf(fp, ""t%f %f %f"",            stl->v_shared[i].x, stl->v_shared[i].y, stl->v_shared[i].z);  }  for(i = 0; i < stl->stats.number_of_facets; i++) {    fprintf(fp, ""t3 %d %d %d"", stl->v_indices[i].vertex[0],            stl->v_indices[i].vertex[1], stl->v_indices[i].vertex[2]);  }  fclose(fp);}",2,"cwe120,cweother"
"_clear_expired_job_states(slurm_cred_ctx_t ctx){tstatic time_t last_scan = 0;ttime_t        now = time(NULL);tListIterator  i   = NULL;tjob_state_t  *j   = NULL;tif ((now - last_scan) < 2)t ttreturn;tlast_scan = now;ti = list_iterator_create(ctx->job_list);tif (!i)ttfatal(""list_iterator_create: malloc failure"");twhile ((j = list_next(i))) {#if DEBUG_TIMEttchar t1[64], t2[64], t3[64];ttif (j->revoked) {tttstrcpy(t2, "" revoked:"");ttttimestr(&j->revoked, (t2+9), (64-9));tt} else {tttt2[0] = '0';tt}ttif (j->expiration) {tttstrcpy(t3, "" expires:"");ttttimestr(&j->revoked, (t3+9), (64-9));tt} else {tttt3[0] = '0';tt}ttdebug3(""state for jobid %u: ctime:%s%s%s"",tt       j->jobid, timestr(&j->ctime, t1, 64), t2, t3);#elsettdebug3(""state for jobid %u: ctime:%""PRIu64"" revoked:%""PRIu64"" ""tt       ""expires:%""PRIu64"""",tt       j->jobid, (uint64_t)j->ctime, (uint64_t)j->revoked,tt       (uint64_t)j->revoked);#endifttif (j->revoked && (now > j->expiration)) {tttlist_delete_item(i);tt}t}tlist_iterator_destroy(i);}",2,"cwe119,cwe120"
"patchup_chordtie(int chordstart,int chordend){int i,tieloc;for (i=chordend;i>=chordstart;i--) {tif(feature[i]==NOTE && feature[i+1] != TIE) {             insertfeature(TIE,0,0,0,i+1);t     tieloc = i+1;t}     } return tieloc;}",3,"cwe119,cwe120,cweother"
"adc_msg_add_named_argument(struct adc_message* cmd, const char prefix[2], const char* string){tint ret = 0;tif (!string)ttreturn -1;tADC_MSG_ASSERT(cmd);tadc_msg_unterminate(cmd);tadc_msg_cache_append(cmd, "" "", 1);tadc_msg_cache_append(cmd, prefix, 2);tadc_msg_cache_append(cmd, string, strlen(string));tadc_msg_terminate(cmd);treturn ret;}",2,"cwe119,cwe120"
"GC_log_printf(const char *format, ...){    va_list args;    char buf[BUFSZ+1];    va_start(args, format);    buf[BUFSZ] = 0x15;    (void) vsnprintf(buf, BUFSZ, format, args);    va_end(args);    if (buf[BUFSZ] != 0x15) ABORT(""GC_printf clobbered stack"");    if (WRITE(GC_log, buf, strlen(buf)) < 0)      ABORT(""write to log failed"");}",3,"cwe119,cwe120,cweother"
"""mtree_quote(struct archive_string *s, const char *str){tconst char *start;tchar buf[4];tunsigned char c;tfor (start = str; *str != '0'; ++str) {ttif (safe_char[*(const unsigned char *)str])tttcontinue;ttif (start != str)tttarchive_strncat(s, start, str - start);ttc = (unsigned char)*str;ttbuf[0] = '';ttbuf[1] = (c / 64) + '0';ttbuf[2] = (c / 8 % 8) + '0';ttbuf[3] = (c % 8) + '0';ttarchive_strncat(s, buf, 4);ttstart = str + 1;t}tif (start != str)ttarchive_strncat(s, start, str - start);}""",2,"cwe119,cwe120"
"init_tty(void){#ifdef USE_HPUX_TERMIO    struct ltchars chars;#endif#ifdef USE_SGTTY    struct ltchars chars;#endif    char bs[2], dline[2], bword[2], refresh[2], lnext[2];    bs[0] = dline[0] = bword[0] = refresh[0] = lnext[0] = '0';    no_tty = !isatty(STDIN_FILENO) || !isatty(STDOUT_FILENO);    cbreak_noecho_mode();    if (!no_tty) {#ifdef USE_TERMIOS        *bs = old_tty.c_cc[VERASE];        *dline = old_tty.c_cc[VKILL];# ifdef VWERASE          *bword = old_tty.c_cc[VWERASE];# endif# ifdef VREPRINT          *refresh = old_tty.c_cc[VREPRINT];# endif# ifdef VLNEXT          *lnext = old_tty.c_cc[VLNEXT];# endif#endif#ifdef USE_HPUX_TERMIO        *bs = old_tty.c_cc[VERASE];        *dline = old_tty.c_cc[VKILL];        if (ioctl(STDIN_FILENO, TIOCGLTC, &chars) < 0) perror(""TIOCGLTC ioctl"");        else {            *bword = chars.t_werasc;            *refresh = chars.t_rprntc;                        }#endif#ifdef USE_SGTTY        *bs = old_tty.sg_erase;        *dline = old_tty.sg_kill;        if (ioctl(STDIN_FILENO, TIOCGLTC, &chars) < 0) perror(""TIOCGLTC ioctl"");        else {            *bword = chars.t_werasc;            *refresh = chars.t_rprntc;            *lnext = chars.t_lnextc;        }#endif    }    bs[1] = dline[1] = bword[1] = refresh[1] = lnext[1] = '0';         if (is_cntrl(*bs)      && *bs       && *bs != 'b' && *bs != '177')                                       add_ibind(bs,      ""/DOKEY BSPC"");    if (is_cntrl(*bword)   && *bword)   add_ibind(bword,   ""/DOKEY BWORD"");     if (is_cntrl(*refresh) && *refresh) add_ibind(refresh, ""/DOKEY REFRESH"");    if (is_cntrl(*lnext)   && *lnext)   add_ibind(lnext,   ""/DOKEY LNEXT"");}",2,"cwe119,cwe120"
"dofirst(BW *bw, int back, int repl, unsigned char *hint){tSRCH *srch;tBW *pbw;tunsigned char bf1[80];tunsigned char buf[80];tif (smode && globalsrch) {ttglobalsrch->backwards = back;ttglobalsrch->replace = repl;ttreturn pfnext(bw);t}tif (bw->parent->huh == srchstr) {ttlong byte;ttp_goto_eol(bw->cursor);ttbyte = bw->cursor->byte;ttp_goto_bol(bw->cursor);ttif (byte == bw->cursor->byte)tttprgetc(bw->cursor);ttreturn urtn((BASE *)bw, -1);t}tsrch = mksrch(NULL, NULL, 0, back, -1, repl, 0, 0);tsrch->addr = bw->cursor->byte;tsrch->wrap_p = pdup(bw->cursor, USTR ""dofirst"");tsrch->wrap_p->owner = &srch->wrap_p;tif (pico && globalsrch && globalsrch->pattern) {ttunesc_genfmt(bf1, sv(globalsrch->pattern), 30);ttjoe_snprintf_1(buf,sizeof(buf),joe_gettext(_(""Find (^C to abort) [%s]: "")),bf1);t} elsettzcpy(buf, joe_gettext(_(""Find (^C to abort): "")));tif ((pbw=wmkpw(bw->parent, buf, &findhist, set_pattern, srchstr, pfabort, srch_cmplt, srch, NULL, bw->b->o.charmap, 0))) {ttif (hint) {tttbinss(pbw->cursor, hint);tttpset(pbw->cursor, pbw->b->eof);tttpbw->cursor->xcol = piscol(pbw->cursor);tt}ttreturn 0;t} else {ttrmsrch(srch);ttreturn -1;t}}",2,"cwe119,cwe120"
"pipe_file_offset(FILE* fin, off_t offset, off_t length, FILE* fout) {    char buf[1024];    off_t i;    if (fseeko(fin, offset, SEEK_SET)) {        SYSERROR(""Failed to seek to offset %zu"", (size_t)offset);        return -1;    }    for (i=0; i<length; i+=sizeof(buf)) {        int n = sizeof(buf);        if (i + n > length) {            n = length - i;        }        if (fread(buf, 1, n, fin) != n) {            SYSERROR(""Failed to read %i bytes"", n);            return -1;        }        if (fwrite(buf, 1, n, fout) != n) {            SYSERROR(""Failed to write %i bytes"", n);            return -1;        }    }    return 0;}",3,"cwe119,cwe120,cweother"
"parse_cardoptions(char *opts, struct patchinfo *infop){tchar buf[4096];tchar *s, *option, *p;tchar save;tstrncpy(buf, opts, sizeof(buf)-1);tbuf[sizeof(buf)-1] = 0;ts = buf;twhile (*s) {tts = skip_whitespace(s);ttoption = s;tts = skip_nonwhitespace(option);ttsave = *s;tt*s = 0;ttif (*option == 0 || *option == '#')tttbreak;ttif (strcasecmp(option, ""p2p"") == 0) {tttinfop->p2p = 1;ttt*s = save;tttif (*s) s++;tttcontinue;tt}ttif ((p = strchr(option, ':')) != 0) {t tttchar *dn, *spid;ttt*p = 0;tttdn = strdup(option);tttspid = strdup(p+1);ttt*p = ':';tttif (infop->dn1 == 0) {ttttinfop->dn1 = dn;ttttinfop->spid1 = spid;ttt} else {ttttif (infop->dn2) free(infop->dn2);ttttif (infop->spid2) free(infop->spid2);ttttinfop->dn2 = dn;ttttinfop->spid2 = spid;ttt}ttt*s = save;tttif (*s) s++;tttcontinue;tt}ttfprintf(stderr, ""ERROR: cardoptions: unknown option ""%s"""", option);tt*s = save;ttreturn -1;t}treturn 0;}",3,"cwe119,cwe120,cwe469"
"fopen_local (char *fn, char *mode){  char path[512];  int bytes = 0;  char *p = NULL;  if (configDir ||      ((configDir = getenv(""RCOMAGE_DATADIR"")) != NULL) ||      (is_dir(DATADIR) && (configDir = DATADIR)) ) {    strcpy (path, configDir);    if (path[strlen (path) - 1] != '/' && path[strlen (path) - 1] != '') {      char sepAdd[2] = { DIR_SEPARATOR, '0' };      strcat (path, sepAdd);    }    strcat (path, fn);  } else {          #ifdef WIN32    bytes = GetModuleFileName (NULL, path, 512);    if (bytes)      p = strrchr (path, '');#else    char szTmp[32];    sprintf (szTmp, ""/proc/%d/exe"", getpid ());    bytes = readlink (szTmp, path, 512);    if (bytes > 511)      bytes = 511;    if (bytes >= 0)      path[bytes] = 0;    else      bytes = 0;    if (bytes)      p = strrchr (path, '/');#endif    if (p)      strcpy (p + 1, fn);    else      strcpy (path, fn);  }  return fopen (path, mode);}",3,"cwe119,cwe120,cweother"
"iax2_key_rotate(const void *vpvt){tint res = 0;tstruct chan_iax2_pvt *pvt = (void *) vpvt;tstruct MD5Context md5;tchar key[17] = """";tstruct iax_ie_data ied = {tt.pos = 0,t};tast_mutex_lock(&iaxsl[pvt->callno]);tpvt->keyrotateid = ast_sched_add(sched, 120000 + (ast_random() % 180001), iax2_key_rotate, vpvt);tsnprintf(key, sizeof(key), ""%lX"", ast_random());tMD5Init(&md5);tMD5Update(&md5, (unsigned char *) key, strlen(key));tMD5Final((unsigned char *) key, &md5);tIAX_DEBUGDIGEST(""Sending"", key);tiax_ie_append_raw(&ied, IAX_IE_CHALLENGE, key, 16);tres = send_command(pvt, AST_FRAME_IAX, IAX_COMMAND_RTKEY, 0, ied.buf, ied.pos, -1);tbuild_ecx_key((unsigned char *) key, pvt);tast_mutex_unlock(&iaxsl[pvt->callno]);treturn res;}",2,"cwe119,cwe120"
"everything_local(struct ref **refs, int nr_match, char **match){tstruct ref *ref;tint retval;tunsigned long cutoff = 0;ttrack_object_refs = 0;tsave_commit_buffer = 0;tfor (ref = *refs; ref; ref = ref->next) {ttstruct object *o;tto = parse_object(ref->old_sha1);ttif (!o)tttcontinue;tt ttif (o->type == OBJ_COMMIT) {tttstruct commit *commit = (struct commit *)o;tttif (!cutoff || cutoff < commit->date)ttttcutoff = commit->date;tt}t}tif (!depth) {ttfor_each_ref(mark_complete, NULL);ttif (cutoff)tttmark_recent_complete_commits(cutoff);t}t tfor (ref = *refs; ref; ref = ref->next) {ttstruct object *o = deref_tag(lookup_object(ref->old_sha1),ttttt     NULL, 0);ttif (!o || o->type != OBJ_COMMIT || !(o->flags & COMPLETE))tttcontinue;ttif (!(o->flags & SEEN)) {tttrev_list_push((struct commit *)o, COMMON_REF | SEEN);tttmark_common((struct commit *)o, 1, 1);tt}t}tfilter_refs(refs, nr_match, match);tfor (retval = 1, ref = *refs; ref ; ref = ref->next) {ttconst unsigned char *remote = ref->old_sha1;ttunsigned char local[20];ttstruct object *o;tto = lookup_object(remote);ttif (!o || !(o->flags & COMPLETE)) {tttretval = 0;tttif (!verbose)ttttcontinue;tttfprintf(stderr,tttt""want %s (%s)"", sha1_to_hex(remote),ttttref->name);tttcontinue;tt}tthashcpy(ref->new_sha1, local);ttif (!verbose)tttcontinue;ttfprintf(stderr,ttt""already have %s (%s)"", sha1_to_hex(remote),tttref->name);t}treturn retval;}",3,"cwe119,cwe120,cweother"
"glusterd_bricks_select_rebalance_volume (dict_t *dict, char **op_errstr,                                         struct list_head *selected){        int                                     ret = -1;        char                                    *volname = NULL;        glusterd_volinfo_t                      *volinfo = NULL;        xlator_t                                *this = NULL;        char                                    msg[2048] = {0,};        glusterd_pending_node_t                 *pending_node = NULL;        this = THIS;        GF_ASSERT (this);        ret = dict_get_str (dict, ""volname"", &volname);        if (ret) {                gf_log (""glusterd"", GF_LOG_ERROR, ""volume name get failed"");                goto out;        }        ret = glusterd_volinfo_find (volname, &volinfo);        if (ret) {                snprintf (msg, sizeof (msg), ""Volume %s does not exist"",                          volname);                *op_errstr = gf_strdup (msg);                gf_log ("""", GF_LOG_ERROR, ""%s"", msg);                goto out;        }        pending_node = GF_CALLOC (1, sizeof (*pending_node),                                  gf_gld_mt_pending_node_t);        if (!pending_node) {                ret = -1;                goto out;        } else {                pending_node->node = volinfo;                pending_node->type = GD_NODE_REBALANCE;                list_add_tail (&pending_node->list,                               &opinfo.pending_bricks);                pending_node = NULL;        }out:        return ret;}",3,"cwe119,cwe120,cwe476"
"evthread_notify_drain_default(evutil_socket_t fd, short what, void *arg){tunsigned char buf[128];#ifdef WIN32twhile (recv(fd, (char*)buf, sizeof(buf), 0) > 0)tt;#elsetwhile (read(fd, (char*)buf, sizeof(buf)) > 0)tt;#endif}",3,"cwe119,cwe120,cweother"
"amdlibStoreRawData(const char      *filename,                                    amdlibRAW_DATA  *rawData,                                    amdlibERROR_MSG errMsg){    struct stat  statBuf;    char         fitsioMsg[256];    fitsfile     *filePtr;    int          status = 0;    amdlibLogTrace(""amdlibStoreRawData()"");             if (stat(filename, &statBuf) != 0)    {        amdlibSetErrMsg(""File '%.80s' does not exist"", filename);        return amdlibFAILURE;    }         if (rawData->thisPtr != rawData)    {        amdlibSetErrMsg(""Raw data is not initialized"");        return amdlibFAILURE;    }         if (fits_open_file(&filePtr, filename, READWRITE, &status) != 0)    {        amdlibReturnFitsError(filename);    }         if (amdlibWriteRegionData(filePtr, rawData->region,                            rawData->nbRegions,                            errMsg) != amdlibSUCCESS)    {        return amdlibFAILURE;    }         if (amdlibWriteTimeTag(filePtr, rawData, errMsg) != amdlibSUCCESS)    {        return amdlibFAILURE;    }         if (fits_close_file(filePtr, &status) != 0)    {        amdlibReturnFitsError(filename);    }    return amdlibSUCCESS;}",2,"cwe119,cwe120"
__remove_database(DB *dbp){tHTAB *hashp = (HTAB *)dbp->internal;tassert(0);tif (!hashp)ttreturn;thdestroy(hashp);tdbp->internal = NULL; },2,"cwe120,cweother"
"gnutls_i2d_X509_fp(FILE *fp, gnutls_x509_crt_t x509_cert){tchar output[10*1024];tsize_t cert_size = 10*1024;tint r;ttif ((r = gnutls_x509_crt_export(x509_cert, GNUTLS_X509_FMT_DER, output, &cert_size)) < 0) {ttg_warning(""couldn't export cert %s (%zd)"", gnutls_strerror(r), cert_size);ttreturn;t}tdebug_print(""writing %zd bytes"",cert_size);tif (fwrite(&output, 1, cert_size, fp) < cert_size) {ttg_warning(""failed to write cert"");t}}",2,"cwe119,cwe120"
"write_dict(GByteArray * bplist, GNode * node, GHashTable * ref_table, uint8_t dict_param_size){    uint64_t idx1 = 0;    uint64_t idx2 = 0;    uint8_t *buff = NULL;    GNode *cur = NULL;    uint64_t i = 0;    uint64_t size = g_node_n_children(node) / 2;    uint8_t marker = BPLIST_DICT | (size < 15 ? size : 0xf);    g_byte_array_append(bplist, &marker, sizeof(uint8_t));    if (size >= 15)    {        GByteArray *int_buff = g_byte_array_new();        write_int(int_buff, size);        g_byte_array_append(bplist, int_buff->data, int_buff->len);        g_byte_array_free(int_buff, TRUE);    }    buff = (uint8_t *) malloc(size * 2 * dict_param_size);    for (i = 0, cur = node->children; cur && i < size; cur = cur->next->next, i++)    {        idx1 = *(uint64_t *) (g_hash_table_lookup(ref_table, cur));#if G_BYTE_ORDER == G_BIG_ENDIANtidx1 = idx1 << ((sizeof(uint64_t) - dict_param_size) * 8);#endif        memcpy(buff + i * dict_param_size, &idx1, dict_param_size);        byte_convert(buff + i * dict_param_size, dict_param_size);        idx2 = *(uint64_t *) (g_hash_table_lookup(ref_table, cur->next));#if G_BYTE_ORDER == G_BIG_ENDIANtidx2 = idx2 << ((sizeof(uint64_t) - dict_param_size) * 8);#endif        memcpy(buff + (i + size) * dict_param_size, &idx2, dict_param_size);        byte_convert(buff + (i + size) * dict_param_size, dict_param_size);    }         g_byte_array_append(bplist, buff, size * 2 * dict_param_size);    free(buff);}",2,"cwe120,cweother"
"FS_ExecConfig (const char *filename){tconst char *dir;tchar name[MAX_QPATH];tdir = Cvar_VariableString(""gamedir"");tif (*dir)ttCom_sprintf(name, sizeof(name), ""%s/%s/%s"", fs_basedir->string, dir, filename); telsettCom_sprintf(name, sizeof(name), ""%s/%s/%s"", fs_basedir->string, BASEDIRNAME, filename); tif (Sys_FindFirst(name, 0, SFF_SUBDIR | SFF_HIDDEN | SFF_SYSTEM))ttCbuf_AddText (va(""exec %s"", filename));tSys_FindClose();}",2,"cwe119,cwe120"
"GetNewsOwnerships(){    struct stattSb;         if (stat(INNDDIR, &Sb) < 0)treturn FALSE;    if (!S_ISDIR(Sb.st_mode))treturn FALSE;    NewsUID = Sb.st_uid;    NewsGID = Sb.st_gid;    return TRUE;}",3,"cwe119,cwe120,cweother"
"temperature_face_update_config(Config_Face *inst){   char buf[8192];   if (inst->tempget_exe)     {        ecore_exe_terminate(inst->tempget_exe);        ecore_exe_free(inst->tempget_exe);        inst->tempget_exe = NULL;     }#ifdef HAVE_EEZE   if (inst->backend == TEMPGET)     {        if (inst->temp_poller)          {             ecore_poller_del(inst->temp_poller);             inst->temp_poller = NULL;          }tif (!inst->tempget_exe) t  {t     snprintf(buf, sizeof(buf),tt      ""%s/%s/tempget %i ""%s"" %i"", tt      e_module_dir_get(temperature_config->module), MODULE_ARCH, tt      inst->sensor_type,tt      (inst->sensor_name ? inst->sensor_name : ""(null)""),tt      inst->poll_interval);t     inst->tempget_exe = t       ecore_exe_pipe_run(buf, ECORE_EXE_PIPE_READ | tttt  ECORE_EXE_PIPE_READ_LINE_BUFFERED |tttt  ECORE_EXE_NOT_LEADER, inst);t  }     }   else if (inst->backend == UDEV)     {t         if (inst->temp_poller)          ecore_poller_poller_interval_set(inst->temp_poller, ttttt   inst->poll_interval);        else t  {t     inst->temp_poller = t       ecore_poller_add(ECORE_POLLER_CORE, inst->poll_interval, tttttemperature_udev_update_poll, inst);t  }     }#else   if (!inst->tempget_exe)      {tsnprintf(buf, sizeof(buf),tt ""%s/%s/tempget %i ""%s"" %i"", tt e_module_dir_get(temperature_config->module), MODULE_ARCH, tt inst->sensor_type,tt (inst->sensor_name ? inst->sensor_name : ""(null)""),tt inst->poll_interval);tinst->tempget_exe = t  ecore_exe_pipe_run(buf, ECORE_EXE_PIPE_READ | ttt     ECORE_EXE_PIPE_READ_LINE_BUFFERED |ttt     ECORE_EXE_NOT_LEADER, inst);     }#endif}",2,"cwe119,cwe120"
"""equal_filename(const char* zipfile, const char* file) {rtconst char* s1 = file;rt/* start comparison after last / */rtconst char* s2 = strrchr(zipfile,'/');rtif (s2)rtt++s2;rtelsertts2 = zipfile;rtwhile (*s1 && toupper(*s1)==toupper(*s2)) {rtt++s1;rtt++s2;rt}rtreturn !*s1 && !*s2;r}""",2,"cwe119,cwe120"
"xml_check (char *filename){tFILE *file;tchar buf[bufsize];tint j;tfile = fopen (filename, ""r"");tif (file == NULL)ttreturn -1;tfor (j = 0; j < 2; j++) {ttif (fgets (buf, bufsize, file) == NULL) {tttfclose (file);tttreturn 0;tt}ttif (strstr (buf, ""xml"") != 0) {tttfclose (file);tttreturn 1;tt}t}tfclose (file);treturn 0;}",3,"cwe119,cwe120,cweother"
"fi_gui_regex_error(regex_t *expr, int error){    char buf[1024];tg_return_if_fail(expr);tregerror(error, expr, buf, sizeof buf);   tstatusbar_gui_warning(15, _(""regex error: %s""),ttlazy_locale_to_ui_string(buf));}",2,"cwe119,cwe120"
"init_sasl(char *service, char *serverFQDN, int minssf, int maxssf,tt     unsigned flags){    int saslresult;    sasl_security_properties_t *secprops=NULL;    socklen_t addrsize;    char localip[60], remoteip[60];    struct sockaddr_storage saddr_l;    struct sockaddr_storage saddr_r;        addrsize=sizeof(struct sockaddr_storage);    if (getpeername(sock,(struct sockaddr *)&saddr_r,&addrsize)!=0)treturn IMTEST_FAIL;        addrsize=sizeof(struct sockaddr_storage);    if (getsockname(sock,(struct sockaddr *)&saddr_l,&addrsize)!=0)treturn IMTEST_FAIL;        if(iptostring((struct sockaddr *)&saddr_l, addrsize, localip, 60))treturn IMTEST_FAIL;        if(iptostring((struct sockaddr *)&saddr_r, addrsize, remoteip, 60))treturn IMTEST_FAIL;                 saslresult=sasl_client_new(service,ttt       serverFQDN,ttt       localip,ttt       remoteip,ttt       NULL,ttt       flags,ttt       &conn);        if (saslresult!=SASL_OK) return IMTEST_FAIL;             secprops = make_secprops(minssf, maxssf);    if (secprops != NULL)t{t    sasl_setprop(conn, SASL_SEC_PROPS, secprops);t    free(secprops);t}        return IMTEST_OK;}",2,"cwe119,cwe120"
"wm8776_field_enum_info(struct snd_kcontrol *ctl,tttt  struct snd_ctl_elem_info *info){tstatic const char *const hld[16] = {tt""0 ms"", ""2.67 ms"", ""5.33 ms"", ""10.6 ms"",tt""21.3 ms"", ""42.7 ms"", ""85.3 ms"", ""171 ms"",tt""341 ms"", ""683 ms"", ""1.37 s"", ""2.73 s"",tt""5.46 s"", ""10.9 s"", ""21.8 s"", ""43.7 s"",t};tstatic const char *const atk_lim[11] = {tt""0.25 ms"", ""0.5 ms"", ""1 ms"", ""2 ms"",tt""4 ms"", ""8 ms"", ""16 ms"", ""32 ms"",tt""64 ms"", ""128 ms"", ""256 ms"",t};tstatic const char *const atk_alc[11] = {tt""8.40 ms"", ""16.8 ms"", ""33.6 ms"", ""67.2 ms"",tt""134 ms"", ""269 ms"", ""538 ms"", ""1.08 s"",tt""2.15 s"", ""4.3 s"", ""8.6 s"",t};tstatic const char *const dcy_lim[11] = {tt""1.2 ms"", ""2.4 ms"", ""4.8 ms"", ""9.6 ms"",tt""19.2 ms"", ""38.4 ms"", ""76.8 ms"", ""154 ms"",tt""307 ms"", ""614 ms"", ""1.23 s"",t};tstatic const char *const dcy_alc[11] = {tt""33.5 ms"", ""67.0 ms"", ""134 ms"", ""268 ms"",tt""536 ms"", ""1.07 s"", ""2.14 s"", ""4.29 s"",tt""8.58 s"", ""17.2 s"", ""34.3 s"",t};tstatic const char *const tranwin[8] = {tt""0 us"", ""62.5 us"", ""125 us"", ""250 us"",tt""500 us"", ""1 ms"", ""2 ms"", ""4 ms"",t};tu8 max;tconst char *const *names;tmax = (ctl->private_value >> 12) & 0xf;tswitch ((ctl->private_value >> 24) & 0x1f) {tcase WM8776_ALCCTRL2:ttnames = hld;ttbreak;tcase WM8776_ALCCTRL3:ttif (((ctl->private_value >> 20) & 0xf) == 0) {tttif (ctl->private_value & LC_CONTROL_LIMITER)ttttnames = atk_lim;tttelsettttnames = atk_alc;tt} else {tttif (ctl->private_value & LC_CONTROL_LIMITER)ttttnames = dcy_lim;tttelsettttnames = dcy_alc;tt}ttbreak;tcase WM8776_LIMITER:ttnames = tranwin;ttbreak;tdefault:ttreturn -ENXIO;t}treturn snd_ctl_enum_info(info, 1, max + 1, names);}",2,"cwe119,cwe120"
"parse_lldiff_command(const char *var, const char *ep, const char *value){tconst char *name;tint namelen;tstruct ll_diff_driver *drv;tname = var + 5;tnamelen = ep - name;tfor (drv = user_diff; drv; drv = drv->next)ttif (!strncmp(drv->name, name, namelen) && !drv->name[namelen])tttbreak;tif (!drv) {ttchar *namebuf;ttdrv = xcalloc(1, sizeof(struct ll_diff_driver));ttnamebuf = xmalloc(namelen + 1);ttmemcpy(namebuf, name, namelen);ttnamebuf[namelen] = 0;ttdrv->name = namebuf;ttdrv->next = NULL;ttif (!user_diff_tail)tttuser_diff_tail = &user_diff;tt*user_diff_tail = drv;ttuser_diff_tail = &(drv->next);t}tif (!value)ttreturn error(""%s: lacks value"", var);tdrv->cmd = strdup(value);treturn 0;}",2,"cwe120,cweother"
"verify_envelope(char *env){    char errbuf[100];    lcase(env);    if (!config_getswitch(IMAPOPT_RFC3028_STRICT) ||t!strcmp(env, ""from"") || !strcmp(env, ""to"") || !strcmp(env, ""auth"")) {treturn 1;    }    snprintf(errbuf, sizeof(errbuf),t     ""env-part '%s': not a valid part for an envelope test"", env);    yyerror(errbuf);    return 0;}",2,"cwe119,cwe120"
"static_number (GtkWidget *widget, void *data){gamgi_window *window = GAMGI_CAST_WINDOW data;GtkWidget *dialog = window->dialog0;GtkWidget *entry;const char *name;char token[GAMGI_ENGINE_TOKEN];int number;entry = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""entry_element""); g_signal_handlers_block_by_func (entry, static_element, window); name = gtk_entry_get_text (GTK_ENTRY (widget));if (gamgi_io_token_int_scan (name, &number,0, GAMGI_CHEM_ATOM_MAX) == TRUE)  {  gamgi_chem_atom_name (number, token);  static_default (number, token, window);  gtk_entry_set_text (GTK_ENTRY (entry), token);  }else  {  static_default (-1, NULL, window);  gtk_entry_set_text (GTK_ENTRY (entry), """");  } g_signal_handlers_unblock_by_func (entry, static_element, window);}",2,"cwe119,cwe120"
"zReadGTFfeature (FILE *stream, zGTFfeature *f) {tcoor_t  i;tint  number_read;tchar name[128], source[128], type[32], start[10], end[10],t    score[10], strand[2], frame[2], gene_id[128], transcript_id[128];tchar line[1024];tdo {  ttif (fgets(line, sizeof(line)-1, stream) == NULL) return 0;ttline[sizeof(line)-1] = '0';  ttt ttfor (i = 0; i < sizeof(line); i++) {tttif ('0' == line[i] || '#'  == line[i] || '' == line[i]) {ttttline[i] = '0'; break; ttt}tt}tttt ttnumber_read = sscanf(line, GTF_READ_FORMAT,ttttttt name, source, type, start, end, score, ttttttt strand, frame, gene_id, transcript_id);t} while (0 == number_read || EOF == number_read);  tif (number_read != 10) {ttreturn 0;t}ttt tf->seqname       = zMalloc(strlen(name)+1,   ""zReadGTFFeature name"");tf->source        = zMalloc(strlen(source)+1, ""zReadGTFFeature source"");tf->gene_id       = zMalloc(strlen(gene_id)+1,""zReadGTFFeature gene_id"");tf->transcript_id = zMalloc(strlen(transcript_id)+1,ttttttt   ""zReadGTFFeature transcript_id"");tt tstrcpy(f->seqname, name);tstrcpy(f->source,  source);tf->type          = zText2GTF(type);tf->start         = zText2Coor(start)-1;  tf->end           = zText2Coor(end)-1;    tf->score         = zText2Score(score);tf->strand        = zText2Strand(strand);tf->frame         = zText2Frame(frame);tstrcpy(f->gene_id, gene_id);tstrcpy(f->transcript_id, transcript_id);treturn 1;}",3,"cwe119,cwe120,cweother"
"""der_decode_utctime(const unsigned char *in, unsigned long *inlen,                             ltc_utctime   *out){   unsigned char buf[32];   unsigned long x;   int           y;   LTC_ARGCHK(in    != NULL);   LTC_ARGCHK(inlen != NULL);   LTC_ARGCHK(out   != NULL);   /* check header */   if (*inlen < 2UL || (in[1] >= sizeof(buf)) || ((in[1] + 2UL) > *inlen)) {      return CRYPT_INVALID_PACKET;   }   /* decode the string */   for (x = 0; x < in[1]; x++) {       y = der_ia5_value_decode(in[x+2]);       if (y == -1) {          return CRYPT_INVALID_PACKET;       }       buf[x] = y;   }   *inlen = 2 + x;   /* possible encodings are YYMMDDhhmmZYYMMDDhhmm+hh'mm'YYMMDDhhmm-hh'mm'YYMMDDhhmmssZYYMMDDhhmmss+hh'mm'YYMMDDhhmmss-hh'mm'    So let's do a trivial decode upto [including] mm    */    x = 0;    DECODE_V(out->YY, 100);    DECODE_V(out->MM, 13);    DECODE_V(out->DD, 32);    DECODE_V(out->hh, 24);    DECODE_V(out->mm, 60);    /* clear timezone and seconds info */    out->off_dir = out->off_hh = out->off_mm = out->ss = 0;    /* now is it Z, +, - or 0-9 */    if (buf[x] == 'Z') {       return CRYPT_OK;    } else if (buf[x] == '+' || buf[x] == '-') {       out->off_dir = (buf[x++] == '+') ? 0 : 1;       DECODE_V(out->off_hh, 24);       DECODE_V(out->off_mm, 60);       return CRYPT_OK;    }    /* decode seconds */    DECODE_V(out->ss, 60);    /* now is it Z, +, - */    if (buf[x] == 'Z') {       return CRYPT_OK;    } else if (buf[x] == '+' || buf[x] == '-') {       out->off_dir = (buf[x++] == '+') ? 0 : 1;       DECODE_V(out->off_hh, 24);       DECODE_V(out->off_mm, 60);       return CRYPT_OK;    } else {       return CRYPT_INVALID_PACKET;    }}""",4,"cwe119,cwe120,cwe469,cweother"
"test_serverstart(){    int result;    sasl_conn_t *saslconn;    const char *out;    unsigned outlen;    struct sockaddr_in addr;    struct hostent *hp;    char buf[8192];    if (sasl_server_init(emptysasl_cb,""TestSuite"")!=SASL_OK)tfatal(""can't sasl_server_init in test_serverstart"");    if ((hp = gethostbyname(myhostname)) == NULL) {        perror(""gethostbyname"");        fatal(""can't gethostbyname in test_serverstart"");    }    addr.sin_family = 0;    memcpy(&addr.sin_addr, hp->h_addr, hp->h_length);    addr.sin_port = htons(0);    sprintf(buf,""%s;%d"", inet_ntoa(addr.sin_addr), 0);    if (sasl_server_new(""rcmd"", myhostname, NULL,tttbuf, buf, NULL, 0, ttt&saslconn) != SASL_OK) {tfatal(""can't sasl_server_new in test_serverstart"");    }         result = sasl_server_start(NULL,ttt       ""foobar"",ttt       NULL,ttt       0,ttt       NULL,ttt       NULL);        if (result == SASL_OK) fatal(""Said ok to null sasl_conn_t in sasl_server_start()"");         result = sasl_server_start(saslconn,ttt       ""foobar"",ttt       NULL,ttt       0,ttt       &out,ttt       &outlen);    if (result == SASL_OK) fatal(""Said ok to invalid mechanism"");         result = sasl_server_start(saslconn,ttt       really_long_string,ttt       NULL,ttt       0,ttt       &out,ttt       &outlen);    if (result == SASL_OK) fatal(""Said ok to invalid mechanism"");    sasl_dispose(&saslconn);    sasl_done();}",2,"cwe119,cwe120"
"folder_for_config(int flags){    char      *rs = NULL;    STRLIST_S *folders;    FSTATE_S   fs;    dprint((1, ""=== folder_for_config called ====""));         memset(&fs, 0, sizeof(FSTATE_S));    fs.combined_view = F_ON(F_CMBND_FOLDER_DISP, ps_global) != 0;    fs.f.validt     = fl_val_gen;    fs.f.title.bar   = _(""SELECT FOLDER"");    fs.f.title.style = FolderName;    fs.kmt     = &folder_sela_km;    if(flags & FOR_PATTERN){tfs.f.help.text   = h_folder_pattern_roles;tfs.f.help.title  = _(""HELP FOR SELECTING CURRENT FOLDER"");    }    else if(flags & FOR_OPTIONSCREEN){tfs.f.help.text   = h_folder_stayopen_folders;tfs.f.help.title  = _(""HELP FOR SELECTING FOLDER"");    }    else{tfs.f.help.text   = h_folder_action_roles;tfs.f.help.title  = _(""HELP FOR SELECTING FOLDER"");    }         fs.context = ps_global->context_current;    do{tif((folders = folder_lister(ps_global, &fs)) != NULL){t    char *name = NULL;t     t    if(!(flags & (FOR_PATTERN | FOR_OPTIONSCREEN)))t      name = folder_is_nick((char *) folders->name,tttt    FOLDERS(fs.context), 0);t    if(!name)t      name = (char *) folders->name;t    if(context_isambig(name) &&t       !(flags & (FOR_PATTERN | FOR_OPTIONSCREEN) &&t         folder_is_nick(name, FOLDERS(fs.context), 0))){ttchar path_in_context[MAILTMPLEN];ttcontext_apply(path_in_context, fs.context, name,ttt      sizeof(path_in_context));tt ttif(!(IS_REMOTE(path_in_context) ||tt     path_in_context[0] == '#')){tt    if(strlen(path_in_context) < (MAILTMPLEN/2)){tttchar  tmp[MAX(MAILTMPLEN,NETMAXMBX)];tttchar *t;tttt = mailboxfile(tmp, path_in_context);tttrs = cpystr(t);tt    }tt    else{t tttbuild_path(tmp_20k_buf, ps_global->ui.homedir,tttt   path_in_context, SIZEOF_20KBUF);tttrs = cpystr(tmp_20k_buf);tt    }tt}ttelsett  rs = cpystr(path_in_context);t    }t    elset      rs = cpystr(name);t    free_strlist(&folders);t    break;t}telse if(!(fs.context && (fs.context->next || fs.context->prev))tt|| fs.combined_view)t  break;    }    while((fs.context = context_screen(fs.context, &c_fcc_km, 0)) != NULL);    return(rs);}",2,"cwe119,cwe120"
"c_clear_hops(struct Luser *lptr, struct NickInfo *nptr, int                         ac, char **av){tstruct ChannelUser *cuser;tchar hops[MAXLINE + 1];tstruct Channel *chptr;tint jj = 1;tif (!(chptr = FindChannel(av[1])))t{ttnotice(n_ChanServ, lptr->nick,tt       ""The channel [002%s002] is not active"", av[1]);ttreturn;t}thops[0] = '0';tfor (cuser = chptr->firstuser; cuser; cuser = cuser->next)t{ttif (FindService(cuser->lptr) ||tt        !(cuser->flags & CH_HOPPED))tttcontinue;ttif (jj * (NICKLEN + 1) >= sizeof(hops))tt{tttSetModes(n_ChanServ, 0, 'h', chptr, hops);ttthops[0] = '0';tttjj = 1;tt}ttstrlcat(hops, cuser->lptr->nick, sizeof(hops));ttstrlcat(hops, "" "", sizeof(hops));tt++jj;t}tSetModes(n_ChanServ, 0, 'h', chptr, hops);}",2,"cwe119,cwe120"
"lcrt_terminal_set_status(struct lcrt_terminal *lterminal, char *label_name, lcrt_terminal_status_t status){    struct lcrt_toolbar *ltoolbar = lterminal->parent->parent->w_toolbar;    char buf[256];    gboolean sensitive;    char *title = (label_name == NULL) ? lterminal->user->name : label_name;    if (lterminal == NULL)        return EINVAL;    switch (status) {    case LCRT_TERMINAL_DISCONNECT:    case LCRT_TERMINAL_CHILD_EXIT:        sprintf(buf, ""<span foreground=""#CD0000"">%s</span>"", title);        sensitive = TRUE;        break;    case LCRT_TERMINAL_CONNECTED:        sprintf(buf, ""<span foreground=""#009900"">%s</span>"", title);        sensitive = FALSE;        break;    default:        sprintf(buf, ""%s"", lterminal->user->name);        sensitive = TRUE;        break;    }    gtk_label_set_markup(GTK_LABEL(lterminal->label), buf);    lterminal->connected = status;    if (lterminal != lterminal->parent->current_terminal)        goto out;    gtk_widget_set_sensitive(ltoolbar->toolitem[LCRT_B_RECONNECT], sensitive);    gtk_widget_set_sensitive(ltoolbar->toolitem[LCRT_B_DISCONNECT], !sensitive);    gtk_widget_set_sensitive(ltoolbar->toolitem[LCRT_B_COPY], FALSE);    gtk_widget_set_sensitive(ltoolbar->toolitem[LCRT_B_PASTE], !sensitive);out:    return LCRTE_OK;}",2,"cwe119,cwe120"
"ftmap_ifalias_new2(char *ip, char *ifIndex_list,  char *name){  struct ftmap_ifalias *ftmia;  u_int32 bip;  u_int16 *list, entries;  int n;  char *c, *buf;  entries = 0;     for (n = 1, c = ifIndex_list; *c; ++c)    if (*c == ',')      ++entries;  if (!(list = malloc(entries * sizeof (u_int16))))    return (struct ftmap_ifalias*)0L;  buf = ifIndex_list;  n = 0;  for (;;) {    c = strsep(&buf, "","");    if (!c)      break;    list[n++] = atoi(c);  }  bip = scan_ip(ip);  ftmia = ftmap_ifalias_new(bip, list, entries, name);  free (list);  return ftmia;}",2,"cwe120,cweother"
"output(void){    int i;    FILE *f;    ocount=0;    strcat(dicname,"".sorted"");    f=fopen(dicname,""w""); if(f==NULL) return;    for(i=0;i<entrycount;i++) {tif(i>0 && strcmp(entry[i].original,entry[i-1].original)==0t   && strcmp(entry[i].replace,entry[i-1].replace)==0)t  continue;tif(grpchar!=0) {t    if(i>0 && strcmp(entry[i].original,entry[i-1].original)==0)t      fprintf(f,""%c%s"",grpchar, entry[i].replace);t    else {ttif(i>0) fprintf(f,"""");ttfprintf(f,""%s%c%s"",entry[i].original,sepchar,entry[i].replace);ttocount++;t    }t    t}telse {t    fprintf(f,""%s%c%s"",entry[i].original,sepchar,entry[i].replace);t    ocount++;t}    }    if(grpchar!=0) fprintf(f,"""");    fclose(f);}",2,"cwe120,cweother"
"init_iconv_start(struct text_object *obj, void *free_at_crash, const char *arg){tchar iconv_from[ICONV_CODEPAGE_LENGTH];tchar iconv_to[ICONV_CODEPAGE_LENGTH];tif (iconv_converting) {ttCRIT_ERR(obj, free_at_crash, ""You must stop your last iconv conversion before ""tttt""starting another"");t}tif (sscanf(arg, ""%s %s"", iconv_from, iconv_to) != 2) {ttCRIT_ERR(obj, free_at_crash, ""Invalid arguments for iconv_start"");t} else {tticonv_t new_iconv;ttnew_iconv = iconv_open(iconv_to, iconv_from);ttif (new_iconv == (iconv_t) (-1)) {tttNORM_ERR(""Can't convert from %s to %s."", iconv_from, iconv_to);tt} else {tttobj->data.i = register_iconv(&new_iconv);ttticonv_converting = 1;tt}t}}",3,"cwe119,cwe120,cweother"
"send_error_body( int s, char* title, char* text )    {    char filename[1000];    char buf[10000];    int buflen;    if ( vhost && req_hostname != (char*) 0 )t{t t(void) snprintf(t    filename, sizeof(filename), ""%s/%s/err%d.html"",t    req_hostname, ERR_DIR, s );tif ( send_error_file( filename ) )t    return;t}         (void) snprintf(tfilename, sizeof(filename), ""%s/err%d.html"", ERR_DIR, s );    if ( send_error_file( filename ) )treturn;         buflen = snprintf(tbuf, sizeof(buf), ""<HTML><HEAD><TITLE>%d %s</TITLE></HEAD><BODY BGCOLOR=""#cc9999"" TEXT=""#000000"" LINK=""#2020ff"" VLINK=""#4040cc""><H4>%d %s</H4>"",ts, title, s, title );    add_to_response( buf, buflen );    buflen = snprintf( buf, sizeof(buf), ""%s"", text );    add_to_response( buf, buflen );    }",2,"cwe119,cwe120"
"fetch_fp_info(Oid func_id, struct fp_info * fip){tHeapTupletfunc_htp;tForm_pg_proc pp;tAssert(OidIsValid(func_id));tAssert(fip != NULL);t tMemSet(fip, 0, sizeof(struct fp_info));tfip->funcid = InvalidOid;tfmgr_info(func_id, &fip->flinfo);tfunc_htp = SearchSysCache(PROCOID,ttttttt  ObjectIdGetDatum(func_id),ttttttt  0, 0, 0);tif (!HeapTupleIsValid(func_htp))ttereport(ERROR,tttt(errcode(ERRCODE_UNDEFINED_FUNCTION),tttt errmsg(""function with OID %u does not exist"", func_id)));tpp = (Form_pg_proc) GETSTRUCT(func_htp);t tif (pp->pronargs > FUNC_MAX_ARGS)ttelog(ERROR, ""function %s has more than %d arguments"",ttt NameStr(pp->proname), FUNC_MAX_ARGS);tfip->namespace = pp->pronamespace;tfip->rettype = pp->prorettype;tmemcpy(fip->argtypes, pp->proargtypes.values, pp->pronargs * sizeof(Oid));tstrlcpy(fip->fname, NameStr(pp->proname), NAMEDATALEN);tReleaseSysCache(func_htp);t tfip->funcid = func_id;}",2,"cwe120,cwe476"
"""gf_svg_parse_style(GF_Node *n, char *style){tu32 i = 0;tchar *str = style;ts32 psemi = -1;twhile (1) {ttif (str[i] == ';' || str[i] == 0) {tttu32 single_value_len = 0;tttsingle_value_len = i - (psemi+1);tttif (single_value_len) {ttttchar c = str[psemi+1 + single_value_len];ttttstr[psemi+1 + single_value_len] = 0;ttttsvg_parse_one_style(n, str + psemi+1);ttttstr[psemi+1 + single_value_len] = c;ttttpsemi = i;ttt}tttif (!str[i]) return;tt}tti++;t}}""",2,"cwe119,cwe120"
"ftpSendPort(FtpStateData * ftpState){    int fd;    struct sockaddr_in addr;    socklen_t addr_len;    unsigned char *addrptr;    unsigned char *portptr;    debug(9, 3) (""This is ftpSendPort"");    ftpState->flags.pasv_supported = 0;    fd = ftpOpenListenSocket(ftpState, 0);    addr_len = sizeof(addr);    if (getsockname(fd, (struct sockaddr *) &addr, &addr_len)) {tdebug(9, 0) (""ftpSendPort: getsockname(%d,..): %s"", fd, xstrerror());t tftpFail(ftpState);treturn;    }    addrptr = (unsigned char *) &addr.sin_addr.s_addr;    portptr = (unsigned char *) &addr.sin_port;    snprintf(cbuf, 1024, ""PORT %d,%d,%d,%d,%d,%dr"",taddrptr[0], addrptr[1], addrptr[2], addrptr[3],tportptr[0], portptr[1]);    ftpWriteCommand(cbuf, ftpState);    ftpState->state = SENT_PORT;}",2,"cwe469,cweother"
"event_id_read(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppos){tint id = (long)event_file_data(filp);tchar buf[32];tint len;tif (*ppos)ttreturn 0;tif (unlikely(!id))ttreturn -ENODEV;tlen = sprintf(buf, ""%d"", id);treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, len);}",2,"cwe119,cwe120"
"iwch_post_zb_read(struct iwch_ep *ep){tunion t3_wr *wqe;tstruct sk_buff *skb;tu8 flit_cnt = sizeof(struct t3_rdma_read_wr) >> 3;tPDBG(""%s enter"", __func__);tskb = alloc_skb(40, GFP_KERNEL);tif (!skb) {ttprintk(KERN_ERR ""%s cannot send zb_read!!"", __func__);ttreturn -ENOMEM;t}twqe = (union t3_wr *)skb_put(skb, sizeof(struct t3_rdma_read_wr));tmemset(wqe, 0, sizeof(struct t3_rdma_read_wr));twqe->read.rdmaop = T3_READ_REQ;twqe->read.reserved[0] = 0;twqe->read.reserved[1] = 0;twqe->read.rem_stag = cpu_to_be32(1);twqe->read.rem_to = cpu_to_be64(1);twqe->read.local_stag = cpu_to_be32(1);twqe->read.local_len = cpu_to_be32(0);twqe->read.local_to = cpu_to_be64(1);twqe->send.wrh.op_seop_flags = cpu_to_be32(V_FW_RIWR_OP(T3_WR_READ));twqe->send.wrh.gen_tid_len = cpu_to_be32(V_FW_RIWR_TID(ep->hwtid)|ttttttV_FW_RIWR_LEN(flit_cnt));tskb->priority = CPL_PRIORITY_DATA;treturn iwch_cxgb3_ofld_send(ep->com.qp->rhp->rdev.t3cdev_p, skb);}",2,"cwe120,cweother"
"cmd_log(void){tint c;tint msg_flags;tmsg_flags = 0;        while ((c = getopt(argcnt, args, ""tdm"")) != EOF) {                switch(c)                {ttcase 't':tttmsg_flags |= SHOW_LOG_TEXT;tttbreak;ttcase 'd': tttmsg_flags |= SHOW_LOG_DICT;tttbreak;                case 'm':                        msg_flags |= SHOW_LOG_LEVEL;                        break;                default:                        argerrs++;                        break;                }        }        if (argerrs)                cmd_usage(pc->curcmd, SYNOPSIS);tdump_log(msg_flags);}",2,"cwe120,cweother"
"safer_k64_test(void){ #ifndef LTC_TEST    return CRYPT_NOP; #else       static const unsigned char k64_pt[]  = { 1, 2, 3, 4, 5, 6, 7, 8 },                              k64_key[] = { 8, 7, 6, 5, 4, 3, 2, 1 },                              k64_ct[]  = { 200, 242, 156, 221, 135, 120, 62, 217 };   symmetric_key skey;   unsigned char buf[2][8];   int err;       if ((err = safer_k64_setup(k64_key, 8, 6, &skey)) != CRYPT_OK) {      return err;   }   safer_ecb_encrypt(k64_pt, buf[0], &skey);   safer_ecb_decrypt(buf[0], buf[1], &skey);   if (XMEMCMP(buf[0], k64_ct, 8) != 0 || XMEMCMP(buf[1], k64_pt, 8) != 0) {      return CRYPT_FAIL_TESTVECTOR;   }   return CRYPT_OK; #endif}",2,"cwe119,cwe120"
"""fc_utf8_validate_len(const char *utf8_string, size_t byte_len,                          const char **end){  char size;  fc_assert_ret_val(NULL != utf8_string, FALSE);  while ('0' != *utf8_string) {    size = FC_UTF8_CHAR_SIZE(utf8_string);    if (!base_fc_utf8_char_validate(utf8_string, size)) {      if (NULL != end) {        *end = utf8_string;      }      return FALSE;    }    if (size > byte_len) {      if (NULL != end) {        *end = utf8_string;      }      return FALSE;    } else {      byte_len -= size;    }    utf8_string += size;  }  if (NULL != end) {    *end = utf8_string;  }  return TRUE;}""",2,"cwe119,cwe120"
"path_list_local_init(PathNodeTree pnt){    struct pathlist *pl, *npl;    struct stat st;    char buf[PATH_MAX+2];    for (pl = defpathlist; pl != NULL; pl = pl->next) {tif (pl->path[pl->pathlen-1] == '/') {t    snprintf(buf, PATH_MAX, ""/%s"", pl->path);t    if (stat(buf, &st) == 0tt&& S_ISDIR(st.st_mode)) {ttnpl = (struct pathlist *)malloc(sizeof(struct pathlist));ttif (npl == NULL)tt    continue;ttmemset(npl, 0, sizeof(struct pathlist));ttnpl->path = strdup(pl->path);ttnpl->path[pl->pathlen-1] = '0';ttnpl->pathlen = pl->pathlen -1;ttnpl->pkg = pl->pkg;ttnpl->n = pkgcdb_put(pnt, npl->path, npl->pkg, NULL);ttnpl->next = pl->next;ttpl->next = npl;ttpl = npl;t    }t}    }    return 0;}",2,"cwe119,cwe120"
"sam_hdr_dump(SAM_hdr *hdr) {    khint_t k;    int i;    printf(""===DUMP==="");    for (k = kh_begin(hdr->h); k != kh_end(hdr->h); k++) {tSAM_hdr_type *t1, *t2;tchar c[2];tif (!kh_exist(hdr->h, k))t    continue;tt1 = t2 = kh_val(hdr->h, k);tc[0] = kh_key(hdr->h, k)>>8;tc[1] = kh_key(hdr->h, k)&0xff;tprintf(""Type %.2s, count %d"", c, t1->prev->order+1);tdo {t    SAM_hdr_tag *tag;t    printf("">>>%d "", t1->order);t    for (tag = t1->tag; tag; tag=tag->next) {ttprintf(""""%.2s"":""%.*s""t"",tt       tag->str, tag->len-3, tag->str+3);t    }t    putchar('');t    t1 = t1->next;t} while (t1 != t2);    }         printf(""@PG chains:"");    for (i = 0; i < hdr->npg_end; i++) {tint j;tprintf(""  %d:"", i);tfor (j = hdr->pg_end[i]; j != -1; j = hdr->pg[j].prev_id) {t    printf(""%s%d(%.*s)"", tt   j == hdr->pg_end[i] ? "" "" : ""->"",tt   j, hdr->pg[j].name_len, hdr->pg[j].name);t}tprintf("""");    }    puts(""===END DUMP==="");}",2,"cwe119,cwe120"
"linked_search(glui32 key, glui32 keysize,   glui32 start, glui32 keyoffset, glui32 nextoffset, glui32 options){  unsigned char keybuf[4];  int ix;  glui32 val;  int zeroterm = ((options & serop_ZeroKeyTerminates) != 0);  fetchkey(keybuf, key, keysize, options);  while (start != 0) {    int match = TRUE;    if (keysize <= 4) {      for (ix=0; match && ix<keysize; ix++) {        if (Mem1(start + keyoffset + ix) != keybuf[ix])          match = FALSE;      }    }    else {      for (ix=0; match && ix<keysize; ix++) {        if (Mem1(start + keyoffset + ix) != Mem1(key + ix))          match = FALSE;      }    }    if (match) {      return start;    }    if (zeroterm) {      match = TRUE;      for (ix=0; match && ix<keysize; ix++) {        if (Mem1(start + keyoffset + ix) != 0)          match = FALSE;      }      if (match) {        break;      }    }        val = start + nextoffset;    start = Mem4(val);  }  return 0;}",2,"cwe119,cwe120"
initStrArr(char **arr){    if (!arr && (arr = Malloc(sizeof(char *))))        arr[0] = 0;    return arr;},2,"cwe119,cwe120"
"cli_cmd_volume_set_parse (const char **words, int wordcount, dict_t **options){        dict_t  *dict = NULL;        char    *volname = NULL;        int     ret = -1;        int     count = 0;        char    *key = NULL;        char    *value = NULL;        int     i = 0;        char    str[50] = {0,};        GF_ASSERT (words);        GF_ASSERT (options);        dict = dict_new ();        if (!dict)                goto out;        if (wordcount < 3)                goto out;        volname = (char *)words[2];        GF_ASSERT (volname);        ret = dict_set_str (dict, ""volname"", volname);        if (ret)                goto out;        if (!strcmp (volname, ""help"") && wordcount == 3 )                ret = dict_set_str (dict, ""help"", volname);        if (!strcmp (volname, ""help-xml"") && wordcount == 3 )                ret = dict_set_str (dict, ""help-xml"", volname);        if (ret)                goto out;        for (i = 3; i < wordcount; i+=2) {ttkey = (char *) words[i];ttvalue = (char *) words[i+1];ttif ( !key || !value) {tttret = -1;tttgoto out;        t}                count++;                sprintf (str, ""key%d"", count);                ret = dict_set_str (dict, str, key);                if (ret)                        goto out;                sprintf (str, ""value%d"", count);                ret = dict_set_str (dict, str, value);                if (ret)                        goto out;        }        ret = dict_set_int32 (dict, ""count"", wordcount-3);        if (ret)                goto out;        *options = dict;out:        if (ret) {                if (dict)                        dict_destroy (dict);        }        return ret;}",5,"cwe119,cwe120,cwe476,cwe469,cweother"
"strBetween(char *pStart, char *pNext, char *pStop)#elsechar *strBetween(pStart, pNext, pStop)char *pStart;char *pNext;char *pStop;#endif{  char *p;  char *q = strBetweenWorkArea;  const char *pEnd;  pEnd = (pNext != NULL) ? pNext : pStop;  require (pEnd != NULL, ""pEnd == NULL"");  require (pEnd >= pStart, ""pEnd < pStart"");  for (pEnd--; pEnd >= pStart; pEnd--) {  tif (! isspace(*pEnd)) break;  }  for (p = pStart;       p <= pEnd && q < &strBetweenWorkArea[MAX_STR_BETWEEN_WORK_AREA-2];t   p++, q++) {t *q = *p;  }  *q = 0;  return strBetweenWorkArea;}",2,"cwe476,cweother"
"read_msr(int cpu, unsigned int idx, unsigned long long *val){tchar cpuname[16];tunsigned char buffer[8];tunsigned long lo, hi;tint fh;tstatic int nodriver=0;tif (nodriver==1)ttreturn 0;t(void)snprintf(cpuname, sizeof(cpuname), ""/dev/cpu/%d/msr"", cpu);tfh = open(cpuname, O_RDONLY);tif (fh==-1) {ttif (!silent)tttperror(cpuname);ttnodriver=1;ttreturn 0;t}tif (lseek(fh, idx, SEEK_CUR)==-1) {ttperror(""lseek"");ttexit(EXIT_FAILURE);t}tif (fh != -1) {ttif (read(fh, &buffer[0], 8) != 8) {tttif (close(fh) == -1) {ttttperror(""close"");ttttexit(EXIT_FAILURE);ttt}tttreturn 0;tt}ttlo = (*(unsigned long *)buffer);tthi = (*(unsigned long *)(buffer+4));tt*val = hi;tt*val = (*val<<32) | lo;t}tif (close(fh)==-1) {ttperror(""close"");ttexit(EXIT_FAILURE);t}treturn 1;}",3,"cwe119,cwe120,cweother"
"xlread(LVAL fptr, LVAL *pval, int rflag){    int sts;         while ((sts = readone(fptr,pval)) == FALSE)#ifdef DEBUG_INPUT    if (debug_input_fp) {        int c = getc(debug_input_fp);        ungetc(c, debug_input_fp);    }#endif        ;         return (sts == EOF ? FALSE : TRUE);}",2,"cwe120,cweother"
"""restorealldir(lofig_list *lf){int ret = OK, res;lofig_list *lof;loins_list *li;locon_list *ic, *fc;   for (li = lf->LOINS; li; li = li->NEXT) {      /* get model of the instance and restore connector direction in it */      for (lof = HEAD_LOFIG; lof; lof = lof->NEXT)         if (lof->NAME == li->FIGNAME)            break;      if (!lof) {         lof = getlofig(li->FIGNAME, 'P');         res = restoredirvbe(lof);         if (res == PROBLEM)            ret = PROBLEM;         else if (res == NOVBE) {            lof = getlofig(lof->NAME, 'A');            res = restorealldir(lof);            if (res == PROBLEM)               ret = PROBLEM;            res = guessextdir(lof);            if (res == PROBLEM)               ret = PROBLEM;         }      } else if (lof->LOCON->DIRECTION == UNKNOWN) {         res = restoredirvbe(lof);         if (res == PROBLEM)            ret = PROBLEM;         else if (res == NOVBE) {            if (lof->MODE != 'A')               lof = getlofig(lof->NAME, 'A');            res = restorealldir(lof);            if (res == PROBLEM)               ret = PROBLEM;            res = guessextdir(lof);            if (res == PROBLEM)               ret = PROBLEM;         }      }      /* restore connector direction in the instance */      for (ic = li->LOCON; ic; ic = ic->NEXT) {         fc = getlocon(lof, ic->NAME);         ic->DIRECTION = fc->DIRECTION;      }   }   return ret;}""",3,"cwe119,cwe120,cweother"
"open_via_helppath(const char *name, const char *dir){    char realname[MAXPDSTRING], dirbuf[MAXPDSTRING], *basename;             const char *usedir = (*dir ? dir : ""./"");    int fd;             strncpy(realname, name, MAXPDSTRING-10);    realname[MAXPDSTRING-10] = 0;    if (strlen(realname) > 3 && !strcmp(realname+strlen(realname)-3, "".pd""))        realname[strlen(realname)-3] = 0;    strcat(realname, ""-help.pd"");    if ((fd = do_open_via_path(dir, realname, """", dirbuf, &basename,         MAXPDSTRING, 0, sys_helppath)) >= 0)            goto gotone;             strcpy(realname, ""help-"");    strncat(realname, name, MAXPDSTRING-10);    realname[MAXPDSTRING-1] = 0;    if ((fd = do_open_via_path(dir, realname, """", dirbuf, &basename,         MAXPDSTRING, 0, sys_helppath)) >= 0)            goto gotone;             if ((fd = do_open_via_path(dir, name, """", dirbuf, &basename,         MAXPDSTRING, 0, sys_helppath)) >= 0)            goto gotone;    post(""sorry, couldn't find help patch for ""%s"""", name);    return;gotone:    close (fd);    glob_evalfile(0, gensym((char*)basename), gensym(dirbuf));}",3,"cwe119,cwe120,cwe469"
"get_header(FILE *file,mp3header *header){    unsigned char buffer[FRAME_HEADER_SIZE];    int fl;    if(fread(&buffer,FRAME_HEADER_SIZE,1,file)<1) {theader->sync=0;treturn 0;    }    header->sync=(((int)buffer[0]<<4) | ((int)(buffer[1]&0xE0)>>4));    if(buffer[1] & 0x10) header->version=(buffer[1] >> 3) & 1;    else header->version=2;    header->layer=(buffer[1] >> 1) & 3;    header->bitrate=(buffer[2] >> 4) & 0x0F;    if((header->sync != 0xFFE) || (header->layer != 1) || (header->bitrate == 0xF)) {theader->sync=0;treturn 0;    }    header->crc=buffer[1] & 1;    header->freq=(buffer[2] >> 2) & 0x3;    header->padding=(buffer[2] >>1) & 0x1;    header->extension=(buffer[2]) & 0x1;    header->mode=(buffer[3] >> 6) & 0x3;    header->mode_extension=(buffer[3] >> 4) & 0x3;    header->copyright=(buffer[3] >> 3) & 0x1;    header->original=(buffer[3] >> 2) & 0x1;    header->emphasis=(buffer[3]) & 0x3;         if (header->bitrate == 0x0f || header->bitrate == 0) {      g_warning( _(""Invalid bitrate %0x in mp3 header.""), header->bitrate);      return 0;    }    if (header->freq == 0x03) {      g_warning(_(""Invalid frequency %0x in mp3 header.""), header->freq);      return 0;    }    return ((fl=frame_length(header)) >= MIN_FRAME_SIZE ? fl : 0); }",2,"cwe119,cwe120"
"fsync_pgdata(void){tboolttxlog_is_symlink;tcharttpg_xlog[MAXPGPATH];tcharttpg_tblspc[MAXPGPATH];tfputs(_(""syncing data to disk ... ""), stdout);tfflush(stdout);tsnprintf(pg_xlog, MAXPGPATH, ""%s/pg_xlog"", pg_data);tsnprintf(pg_tblspc, MAXPGPATH, ""%s/pg_tblspc"", pg_data);t txlog_is_symlink = false;#ifndef WIN32t{ttstruct stat st;ttif (lstat(pg_xlog, &st) < 0)tttfprintf(stderr, _(""%s: could not stat file ""%s"": %s""),tttttprogname, pg_xlog, strerror(errno));ttelse if (S_ISLNK(st.st_mode))tttxlog_is_symlink = true;t}#elsetif (pgwin32_is_junction(pg_xlog))ttxlog_is_symlink = true;#endift #ifdef PG_FLUSH_DATA_WORKStwalkdir(pg_data, pre_sync_fname, false);tif (xlog_is_symlink)ttwalkdir(pg_xlog, pre_sync_fname, false);twalkdir(pg_tblspc, pre_sync_fname, true);#endift twalkdir(pg_data, fsync_fname_ext, false);tif (xlog_is_symlink)ttwalkdir(pg_xlog, fsync_fname_ext, false);twalkdir(pg_tblspc, fsync_fname_ext, true);tcheck_ok();}",2,"cwe119,cwe120"
"_send_event_to_client(stats_event_t *event, client_t *client){    int len;    char buf [200];         len = snprintf (buf, sizeof (buf), ""EVENT %s %s %s"",            (event->source != NULL) ? event->source : ""global"",            event->name ? event->name : ""null"",            event->value ? event->value : ""null"");    if (len > 0 && len < (int)sizeof (buf))    {        client_send_bytes (client, buf, len);        if (client->con->error)            return -1;    }    return 0;}",2,"cwe119,cwe120"
"fold_builtin_fpclassify (location_t loc, tree exp){  tree fp_nan, fp_infinite, fp_normal, fp_subnormal, fp_zero,    arg, type, res, tmp;  enum machine_mode mode;  REAL_VALUE_TYPE r;  char buf[128];     if (!validate_arglist (exp, INTEGER_TYPE, INTEGER_TYPE,ttt INTEGER_TYPE, INTEGER_TYPE,ttt INTEGER_TYPE, REAL_TYPE, VOID_TYPE))    return NULL_TREE;  fp_nan = CALL_EXPR_ARG (exp, 0);  fp_infinite = CALL_EXPR_ARG (exp, 1);  fp_normal = CALL_EXPR_ARG (exp, 2);  fp_subnormal = CALL_EXPR_ARG (exp, 3);  fp_zero = CALL_EXPR_ARG (exp, 4);  arg = CALL_EXPR_ARG (exp, 5);  type = TREE_TYPE (arg);  mode = TYPE_MODE (type);  arg = builtin_save_expr (fold_build1_loc (loc, ABS_EXPR, type, arg));     tmp = fold_build2_loc (loc, EQ_EXPR, integer_type_node, arg,tt     build_real (type, dconst0));  res = fold_build3_loc (loc, COND_EXPR, integer_type_node,tt     tmp, fp_zero, fp_subnormal);  sprintf (buf, ""0x1p%d"", REAL_MODE_FORMAT (mode)->emin - 1);  real_from_string (&r, buf);  tmp = fold_build2_loc (loc, GE_EXPR, integer_type_node,tt     arg, build_real (type, r));  res = fold_build3_loc (loc, COND_EXPR, integer_type_node, tmp, fp_normal, res);  if (HONOR_INFINITIES (mode))    {      real_inf (&r);      tmp = fold_build2_loc (loc, EQ_EXPR, integer_type_node, arg,ttt build_real (type, r));      res = fold_build3_loc (loc, COND_EXPR, integer_type_node, tmp,ttt fp_infinite, res);    }  if (HONOR_NANS (mode))    {      tmp = fold_build2_loc (loc, ORDERED_EXPR, integer_type_node, arg, arg);      res = fold_build3_loc (loc, COND_EXPR, integer_type_node, tmp, res, fp_nan);    }  return res;}",2,"cwe119,cwe120"
"get_filter(PyObject *category, PyObject *text, Py_ssize_t lineno,           PyObject *module, PyObject **item){    PyObject *action;    Py_ssize_t i;    PyObject *warnings_filters;    warnings_filters = get_warnings_attr(""filters"");    if (warnings_filters == NULL) {        if (PyErr_Occurred())            return NULL;    }    else {        Py_DECREF(_filters);        _filters = warnings_filters;    }    if (_filters == NULL || !PyList_Check(_filters)) {        PyErr_SetString(PyExc_ValueError,                        MODULE_NAME "".filters must be a list"");        return NULL;    }         for (i = 0; i < PyList_GET_SIZE(_filters); i++) {        PyObject *tmp_item, *action, *msg, *cat, *mod, *ln_obj;        Py_ssize_t ln;        int is_subclass, good_msg, good_mod;        tmp_item = *item = PyList_GET_ITEM(_filters, i);        if (PyTuple_Size(tmp_item) != 5) {            PyErr_Format(PyExc_ValueError,                         MODULE_NAME "".filters item %zd isn't a 5-tuple"", i);            return NULL;        }                 action = PyTuple_GET_ITEM(tmp_item, 0);        msg = PyTuple_GET_ITEM(tmp_item, 1);        cat = PyTuple_GET_ITEM(tmp_item, 2);        mod = PyTuple_GET_ITEM(tmp_item, 3);        ln_obj = PyTuple_GET_ITEM(tmp_item, 4);        good_msg = check_matched(msg, text);        good_mod = check_matched(mod, module);        is_subclass = PyObject_IsSubclass(category, cat);        ln = PyLong_AsSsize_t(ln_obj);        if (good_msg == -1 || good_mod == -1 || is_subclass == -1 ||            (ln == -1 && PyErr_Occurred()))            return NULL;        if (good_msg && is_subclass && good_mod && (ln == 0 || lineno == ln))            return _PyUnicode_AsString(action);    }    action = get_default_action();    if (action != NULL) {        return _PyUnicode_AsString(action);    }    PyErr_SetString(PyExc_ValueError,                    MODULE_NAME "".defaultaction not found"");    return NULL;}",2,"cwe469,cweother"
"44_set_rx_mode(struct net_device *netdev){tstruct b44_private *bp = netdev_priv(netdev);tunsigned char zero[6] = { 0, 0, 0, 0, 0, 0 };tu32 val;tint i;tval = br32(bp, B44_RXCONFIG);tval &= ~RXCONFIG_PROMISC;tval |= RXCONFIG_ALLMULTI;tb44_set_mac_addr(bp);tfor (i = 1; i < 64; i++)ttb44_cam_write(bp, zero, i);tbw32(bp, B44_RXCONFIG, val);tval = br32(bp, B44_CAM_CTRL);tbw32(bp, B44_CAM_CTRL, val | CAM_CTRL_ENABLE);}",2,"cwe119,cwe120"
"multiline_begin(char *p){tif (*p == '-') {ttif (*++p == ' ') {tttchar_to_strip = is_ws;tttp++;tt} elsetttchar_to_strip = is_tab;t} elsettchar_to_strip = NULL;tif (*p == '') {ttp++;ttmultiline_unescape = 0;t} else if (*p == '""') {ttchar *q; ttp++;ttmultiline_unescape = 0;ttq = strchr(p, '""');ttmultiline_delimiter_len = q - p;t} else {ttmultiline_delimiter_len = strcspn(p, "" t"");ttmultiline_unescape = 1;t}t tmultiline_delimiter_len--;tmultiline_delimiter = grecs_malloc(multiline_delimiter_len + 1);tmemcpy(multiline_delimiter, p, multiline_delimiter_len);tmultiline_delimiter[multiline_delimiter_len] = 0;tgrecs_line_begin();t tgrecs_locus_point_advance_line(grecs_current_locus_point);tgrecs_grecs_lloc.beg = grecs_current_locus_point;tgrecs_grecs_lloc.beg.col++;}",2,"cwe120,cwe469"
"ecs_mem_usage_pr_size(void){  size_t sys_mem_usage = 0;     {    if (_ecs_mem_usage_proc_file_init == 0)      _ecs_mem_usage_pr_size_init();    if (_ecs_mem_usage_proc_file_init == 1) {      char  buf[81];        const pid_t  pid = getpid();      FILE *fp;      unsigned long val;      char *s;      sprintf(buf, ""/proc/%lu/status"", (unsigned long) pid);      fp = fopen(buf, ""r"");      if (fp != NULL) {        int fields_read = 0;        while (fields_read < 2) {          s = fgets(buf, 80, fp);          if (s == NULL)            break;          if (strncmp(s, ""VmSize:"", 7) == 0) {            sscanf (s + 7, ""%lu"", &val);            sys_mem_usage = (size_t) val;            fields_read += 1;          }          else if (strncmp(s, ""VmPeak:"", 7) == 0) {            sscanf (s + 7, ""%lu"", &val);            if ((size_t) val > _ecs_mem_usage_global_max_pr)              _ecs_mem_usage_global_max_pr = (size_t) val;            fields_read += 1;          }        }        fclose(fp);      }    }    _ecs_mem_usage_pr_size_end();  }  if (sys_mem_usage > _ecs_mem_usage_global_max_pr)    _ecs_mem_usage_global_max_pr = sys_mem_usage;  return sys_mem_usage;}",3,"cwe119,cwe120,cweother"
"_Unpickler_ReadFromFile(UnpicklerObject *self, Py_ssize_t n){    PyObject *data;    Py_ssize_t read_size;    assert(self->read != NULL);    if (_Unpickler_SkipConsumed(self) < 0)        return -1;    if (n == READ_WHOLE_LINE) {        PyObject *empty_tuple = PyTuple_New(0);        data = PyObject_Call(self->readline, empty_tuple, NULL);        Py_DECREF(empty_tuple);    }    else {        PyObject *len;                 if (self->peek && n < PREFETCH) {            len = PyLong_FromSsize_t(PREFETCH);            if (len == NULL)                return -1;            data = _Pickle_FastCall(self->peek, len);            if (data == NULL) {                if (!PyErr_ExceptionMatches(PyExc_NotImplementedError))                    return -1;                                 PyErr_Clear();                Py_CLEAR(self->peek);            }            else {                read_size = _Unpickler_SetStringInput(self, data);                Py_DECREF(data);                self->prefetched_idx = 0;                if (n <= read_size)                    return n;            }        }        len = PyLong_FromSsize_t(n);        if (len == NULL)            return -1;        data = _Pickle_FastCall(self->read, len);    }    if (data == NULL)        return -1;    read_size = _Unpickler_SetStringInput(self, data);    Py_DECREF(data);    return read_size;}",2,"cwe120,cweother"
"ai_init(void){  bool failure = FALSE;#if !defined(AI_MODULES) || defined(AI_MOD_STATIC_CLASSIC) || defined(AI_MOD_STATIC_THREADED)     struct ai_type *ai;#endif#ifdef AI_MODULES  if (lt_dlinit()) {    failure = TRUE;  }  if (!failure) {#ifdef DEBUG         const char *moduledirs[] = { ""default"", ""threaded"", ""stub"", NULL };    int i;    for (i = 0; moduledirs[i] != NULL ; i++) {      char buf[2048];      fc_snprintf(buf, sizeof(buf), ""ai/%s"", moduledirs[i]);      lt_dladdsearchdir(buf);    }#endif           lt_dladdsearchdir(AI_MODULEDIR);  }#endif  #if defined(AI_MODULES) && !defined(AI_MOD_STATIC_CLASSIC)  if (!failure && !load_ai_module(""classic"")) {    failure = TRUE;  }#else     ai = ai_type_alloc();  init_ai(ai);  if (!fc_ai_classic_setup(ai)) {    failure = TRUE;  }#endif    if (failure) {    log_fatal(_(""Failed to setup default AI module, cannot continue.""));    exit(EXIT_FAILURE);  }  default_ai = ai;#ifdef AI_MOD_STATIC_THREADED  ai = ai_type_alloc();  if (ai != NULL) {    init_ai(ai);    if (!fc_ai_threaded_setup(ai)) {      log_error(_(""Failed to setup threaded AI module""));    }  }#endif  }",2,"cwe119,cwe120"
"get_city_dialog_production(struct city *pcity,ttttchar *buffer, size_t buffer_len){  char time_str[50], *cost_str;  int turns, stock;  if (pcity == NULL) {              fc_strlcpy(buffer, Q_(""?filler:XXX/XXX XXX turns""), buffer_len);    return;  }  if (city_production_has_flag(pcity, IF_GOLD)) {    int gold = MAX(0, pcity->surplus[O_SHIELD]);    fc_snprintf(buffer, buffer_len, PL_(""%3d gold per turn"",                                        ""%3d gold per turn"", gold), gold);    return;  }  turns = city_production_turns_to_build(pcity, TRUE);  stock = pcity->shield_stock;  cost_str = city_production_cost_str(pcity);  if (turns < FC_INFINITY) {    if (concise_city_production) {      fc_snprintf(time_str, sizeof(time_str), ""%3d"", turns);    } else {      fc_snprintf(time_str, sizeof(time_str),                  PL_(""%3d turn"", ""%3d turns"", turns), turns);    }  } else {    fc_snprintf(time_str, sizeof(time_str), ""%s"",                concise_city_production ? ""-"" : _(""never""));  }  if (concise_city_production) {    fc_snprintf(buffer, buffer_len, _(""%3d/%s:%s""), stock, cost_str,                time_str);  } else {    fc_snprintf(buffer, buffer_len, _(""%3d/%s %s""), stock, cost_str,                time_str);  }}",2,"cwe119,cwe120"
"MGD77_Set_Home (struct MGD77_CONTROL *F){tchar *this = NULL;tif (F->MGD77_HOME) return;t tif ((this = getenv (""MGD77_HOME"")) != CNULL) {t ttF->MGD77_HOME = (char *) GMT_memory (VNULL, (size_t)(strlen (this) + 1), (size_t)1, ""MGD77_Set_Home"");ttstrcpy (F->MGD77_HOME, this);t}telse {t ttF->MGD77_HOME = (char *) GMT_memory (VNULL, (size_t)(strlen (GMT_SHAREDIR) + 7), (size_t)1, ""MGD77_Set_Home"");ttsprintf (F->MGD77_HOME, ""%s/mgd77"", GMT_SHAREDIR);t}#ifdef WIN32tDOS_path_fix (F->MGD77_HOME);#endif}",2,"cwe120,cweother"
"gdpy_dirfile_getnativetypename(struct gdpy_dirfile_t* self,    PyObject* args, PyObject* keys){  dtrace(""%p, %p, %p"", self, args, keys);  char* keywords[] = { ""field_code"", NULL };  const char* field_code;  char tbuffer[11];  if (!PyArg_ParseTupleAndKeywords(args, keys,        ""s:pygetdata.dirfile.native_type_name"", keywords, &field_code))  {    dreturn (""%p"", NULL);    return NULL;  }  gd_type_t t = gd_native_type(self->D, field_code);  PYGD_CHECK_ERROR(self->D, NULL);  sprintf(tbuffer, ""%s%i"", ((t & GD_COMPLEX) ? ""COMPLEX"" :        (t & GD_IEEE754) ? ""FLOAT"" : (t & GD_SIGNED) ?  ""INT"" : ""UINT""),      (int)(8 * GD_SIZE(t)));  PyObject* pyobj = PyString_FromString(tbuffer);  dreturn(""%p"", pyobj);  return pyobj;}",2,"cwe119,cwe120"
"nfs3svc_link (rpcsvc_request_t *req){        char                    newpath[NFS_PATH_MAX];        struct nfs3_fh          dirfh = {{0}, };        struct nfs3_fh          targetfh = {{0}, };        link3args               args;        int                     ret = RPCSVC_ACTOR_ERROR;        if (!req)                return ret;        nfs3_prep_link3args (&args, &targetfh, &dirfh, newpath);        if (xdr_to_link3args (req->msg[0], &args) <= 0) {                gf_log (GF_NFS3, GF_LOG_ERROR, ""Error decoding args"");                rpcsvc_request_seterr (req, GARBAGE_ARGS);                goto rpcerr;        }        ret = nfs3_link (req, &targetfh, &dirfh, newpath);        if ((ret < 0) && (ret != RPCSVC_ACTOR_IGNORE)) {                gf_log (GF_NFS3, GF_LOG_ERROR, ""LINK procedure failed"");                rpcsvc_request_seterr (req, SYSTEM_ERR);                ret = RPCSVC_ACTOR_ERROR;        }rpcerr:        return ret;}",2,"cwe119,cwe120"
"_terminal_profile_clone (TerminalProfile *base_profile,                         const char      *visible_name){  TerminalApp *app = terminal_app_get ();  GObject *base_object = G_OBJECT (base_profile);  TerminalProfilePrivate *new_priv;  char profile_name[32];  GParameter *params;  GParamSpec **pspecs;  guint n_pspecs, i, n_params, profile_num;  TerminalProfile *new_profile;  g_object_ref (base_profile);  profile_num = 0;  do    {      g_snprintf (profile_name, sizeof (profile_name), ""Profile%u"", profile_num++);    }  while (terminal_app_get_profile_by_name (app, profile_name) != NULL);      pspecs = g_object_class_list_properties (G_OBJECT_CLASS (TERMINAL_PROFILE_GET_CLASS (base_profile)), &n_pspecs);    params = g_newa (GParameter, n_pspecs);  n_params = 0;  for (i = 0; i < n_pspecs; ++i)    {      GParamSpec *pspec = pspecs[i];      GValue *value;      if (pspec->owner_type != TERMINAL_TYPE_PROFILE ||          (pspec->flags & G_PARAM_WRITABLE) == 0)        continue;      params[n_params].name = pspec->name;      value = &params[n_params].value;      G_VALUE_TYPE (value) = 0;      g_value_init (value, G_PARAM_SPEC_VALUE_TYPE (pspec));      if (pspec->name == I_(TERMINAL_PROFILE_NAME))        g_value_set_static_string (value, profile_name);      else if (pspec->name == I_(TERMINAL_PROFILE_VISIBLE_NAME))        g_value_set_static_string (value, visible_name);      else        g_object_get_property (base_object, pspec->name, value);      ++n_params;    }  new_profile = g_object_newv (TERMINAL_TYPE_PROFILE, n_params, params);  g_object_unref (base_profile);  for (i = 0; i < n_params; ++i)    g_value_unset (&params[i].value);     new_priv = new_profile->priv;  g_slist_free (new_priv->dirty_pspecs);  new_priv->dirty_pspecs = NULL;  if (new_priv->save_idle_id != 0)    {      g_source_remove (new_priv->save_idle_id);      new_priv->save_idle_id = 0;    }  for (i = 0; i < n_pspecs; ++i)    {      GParamSpec *pspec = pspecs[i];      if (pspec->owner_type != TERMINAL_TYPE_PROFILE ||          (pspec->flags & G_PARAM_WRITABLE) == 0)        continue;      new_priv->dirty_pspecs = g_slist_prepend (new_priv->dirty_pspecs, pspec);    }  g_free (pspecs);  terminal_profile_save (new_profile);  return new_profile;}",2,"cwe119,cwe120"
"insert_utf8(JVM_CLASS *class, const void *value) {  CP_INFO *newnode;  if(!class || !value) {    BAD_ARG();    return -1;  }  newnode = (CP_INFO *)malloc(sizeof(CP_INFO));  if(!newnode) return -1;  newnode->tag = CONSTANT_Utf8;   newnode->cpnode.Utf8.length = strlen(value);  newnode->cpnode.Utf8.bytes = (u1 *) malloc(newnode->cpnode.Utf8.length);  if(!newnode->cpnode.Utf8.bytes) {    free(newnode);    return -1;  }  strncpy((char*)newnode->cpnode.Utf8.bytes,value,newnode->cpnode.Utf8.length);   return cp_insert(class, newnode);}",2,"cwe120,cweother"
"write_point_mesh(const char *filename, int ub, int npts, float *pts,                      int nvars, int *vardim, const char * const *varnames,                      float **vars){    int   i;    char  str[128];    int  *centering = NULL;    useBinary = ub;    open_file(filename);    write_header();    write_string(""DATASET UNSTRUCTURED_GRID"");    sprintf(str, ""POINTS %d float"", npts);    write_string(str);    for (i = 0 ; i < 3*npts ; i++)    {        write_float(pts[i]);    }    new_section();    sprintf(str, ""CELLS %d %d"", npts, 2*npts);    write_string(str);    for (i = 0 ; i < npts ; i++)    {        write_int(1);        write_int(i);        end_line();    }    new_section();    sprintf(str, ""CELL_TYPES %d"", npts);    write_string(str);    for (i = 0 ; i < npts ; i++)    {        write_int(VISIT_VERTEX);        end_line();    }    centering = (int *) malloc(nvars*sizeof(int));    for (i = 0 ; i < nvars ; i++)        centering[i] = 1;    write_variables(nvars, vardim, centering, varnames, vars, npts, npts);    free(centering);    close_file();}",2,"cwe120,cweother"
"FS_Dir_f( void ){tchart*path = NULL;tchartfindname[1024];tchartwildcard[1024] = ""*.*"";tchart**dirnames;tintttndirs;tif ( Cmd_Argc() != 1 )t{ttQ_strncpyz(wildcard, Cmd_Argv(1), sizeof(wildcard));t}twhile ( ( path = FS_NextPath( path ) ) != NULL )t{ttchar *tmp = findname;ttCom_sprintf( findname, sizeof(findname), ""%s/%s"", path, wildcard );ttwhile ( *tmp != 0 )tt{tttif ( *tmp == '' ) tttt*tmp = '/';ttttmp++;tt}ttCom_Printf( ""Directory of %s"", findname );ttCom_Printf( ""----"" );ttif ( ( dirnames = FS_ListFiles( findname, &ndirs, 0, 0 ) ) != 0 )tt{tttint i;tttfor ( i = 0; i < ndirs-1; i++ )ttt{ttttif ( strrchr( dirnames[i], '/' ) )tttttCom_Printf( ""%s"", strrchr( dirnames[i], '/' ) + 1 );ttttelsetttttCom_Printf( ""%s"", dirnames[i] );ttttZ_Free( dirnames[i] );ttt}tttZ_Free( dirnames );tt}ttCom_Printf( """" );t}}",2,"cwe119,cwe120"
"cmd_merge_file(int argc, const char **argv, const char *prefix){tconst char *names[3];tmmfile_t mmfs[3];tmmbuffer_t result = {NULL, 0};txpparam_t xpp = {XDF_NEED_MINIMAL};tint ret = 0, i = 0, to_stdout = 0;twhile (argc > 4) {ttif (!strcmp(argv[1], ""-L"") && i < 3) {tttnames[i++] = argv[2];tttargc--;tttargv++;tt} else if (!strcmp(argv[1], ""-p"") ||tttt!strcmp(argv[1], ""--stdout""))tttto_stdout = 1;ttelse if (!strcmp(argv[1], ""-q"") ||tttt!strcmp(argv[1], ""--quiet""))tttfreopen(""/dev/null"", ""w"", stderr);ttelsetttusage(merge_file_usage);ttargc--;ttargv++;t}tif (argc != 4)ttusage(merge_file_usage);tfor (; i < 3; i++)ttnames[i] = argv[i + 1];tfor (i = 0; i < 3; i++) {ttif (read_mmfile(mmfs + i, argv[i + 1]))tttreturn -1;ttif (buffer_is_binary(mmfs[i].ptr, mmfs[i].size))tttreturn error(""Cannot merge binary files: %s"",tttttargv[i + 1]);t}tret = xdl_merge(mmfs + 1, mmfs + 0, names[0], mmfs + 2, names[2],ttt&xpp, XDL_MERGE_ZEALOUS_ALNUM, &result);tfor (i = 0; i < 3; i++)ttfree(mmfs[i].ptr);tif (ret >= 0) {ttconst char *filename = argv[1];ttFILE *f = to_stdout ? stdout : fopen(filename, ""wb"");ttif (!f)tttret = error(""Could not open %s for writing"", filename);ttelse if (result.size &&ttt fwrite(result.ptr, result.size, 1, f) != 1)tttret = error(""Could not write to %s"", filename);ttelse if (fclose(f))tttret = error(""Could not close %s"", filename);ttfree(result.ptr);t}treturn ret;}",4,"cwe119,cwe120,cwe476,cweother"
"PCSp_PCSp(void *cntx, double *out, double *in) {tcallback *p = (callback *)cntx;tco pp;#ifdef DEBUG2tprintf(""Got Lab in %f %f %f"",in[0],in[1],in[2]);#endiftpp.p[0] = in[0];tpp.p[1] = in[1];tpp.p[2] = in[2];tp->r->interp(p->r, &pp);tttt tout[0] = pp.v[0];tout[1] = pp.v[1];tout[2] = pp.v[2];#ifdef COMPLOOKUPt tif (p->rd_luo != NULL) {ttp->rd_luo->lookup(p->rd_luo, out, out);ttt t}#endif#ifdef DEBUG2tprintf(""Got Lab out %f %f %f"",out[0],out[1],out[2]);tprintf("""");#endiftif (p->verb) {tt ttint pc;ttp->count++;ttpc = p->count * 100.0/p->total + 0.5;ttif (pc != p->last) {tttprintf(""%c%2d%%"",cr_char,pc), fflush(stdout);tttp->last = pc;tt}t}}",2,"cwe119,cwe120"
"__certificate_properties_dump_raw_data(const unsigned char *buffer, size_t buffer_size){tconst gint BYTES_PER_LINE = 16;tgchar *result = g_new0 (gchar, 4 * buffer_size);tsize_t i;tgchar *result_iterator = result;tif (!result)t{ttfprintf(stderr, ""Error: (%s,%d): %s"", __FILE__, __LINE__, ""Not enough memory"");ttreturn result;t}tfor (i = 0; i < buffer_size; i++)t{ttresult_iterator += sprintf(result_iterator, ""%02x:"", buffer[i]);ttif ((i % BYTES_PER_LINE) == BYTES_PER_LINE - 1)ttt*result_iterator++ = '';t}tif ((i % BYTES_PER_LINE) == 0)tt*(result_iterator - 1) = 0;treturn result;}",2,"cwe120,cweother"
"mca_btl_tcp_create(int if_kindex, const char* if_name){    struct mca_btl_tcp_module_t* btl;    char param[256];    int i;    for( i = 0; i < (int)mca_btl_tcp_component.tcp_num_links; i++ ) {        btl = (struct mca_btl_tcp_module_t *)malloc(sizeof(mca_btl_tcp_module_t));        if(NULL == btl)            return OMPI_ERR_OUT_OF_RESOURCE;        memcpy(btl, &mca_btl_tcp_module, sizeof(mca_btl_tcp_module));        OBJ_CONSTRUCT(&btl->tcp_endpoints, opal_list_t);        mca_btl_tcp_component.tcp_btls[mca_btl_tcp_component.tcp_num_btls++] = btl;                 btl->tcp_ifkindex = (uint16_t) if_kindex;#if MCA_BTL_TCP_STATISTICS        btl->tcp_bytes_recv = 0;        btl->tcp_bytes_sent = 0;        btl->tcp_send_handler = 0;#endif                 sprintf(param, ""bandwidth_%s"", if_name);        mca_btl_tcp_param_register_uint(param, NULL, btl->super.btl_bandwidth, OPAL_INFO_LVL_5, &btl->super.btl_bandwidth);                 sprintf(param, ""latency_%s"", if_name);        mca_btl_tcp_param_register_uint(param, NULL, btl->super.btl_latency, OPAL_INFO_LVL_5,  &btl->super.btl_latency);        if( i > 0 ) {            btl->super.btl_bandwidth >>= 1;            btl->super.btl_latency   <<= 1;        }                 sprintf(param, ""bandwidth_%s:%d"", if_name, i);        mca_btl_tcp_param_register_uint(param, NULL, btl->super.btl_bandwidth, OPAL_INFO_LVL_5, &btl->super.btl_bandwidth);                 sprintf(param, ""latency_%s:%d"", if_name, i);        mca_btl_tcp_param_register_uint(param, NULL, btl->super.btl_latency, OPAL_INFO_LVL_5, &btl->super.btl_latency);#if 0 && OPAL_ENABLE_DEBUG        BTL_OUTPUT((""interface %s instance %i: bandwidth %d latency %d"", if_name, i,                    btl->super.btl_bandwidth, btl->super.btl_latency));#endif    }    return OMPI_SUCCESS;}",3,"cwe119,cwe120,cweother"
"generate_opcode_handler(FILE* filep, body_struct* body, replace_struct* replace, opcode_struct* opinfo, int ea_mode)r{rtchar str[MAX_LINE_LENGTH+1];rtopcode_struct* op = malloc(sizeof(opcode_struct));rrt rtset_opcode_struct(opinfo, op, ea_mode);rtget_base_name(str, op);rtwrite_prototype(g_prototype_file, str);rtadd_opcode_output_table_entry(op, str);rtwrite_function_name(filep, str);rrt rtif(ea_mode != EA_MODE_NONE)rt{rttsprintf(str, ""EA_%s_8()"", g_ea_info_table[ea_mode].ea_add);rttadd_replace_string(replace, ID_OPHANDLER_EA_AY_8, str);rttsprintf(str, ""EA_%s_16()"", g_ea_info_table[ea_mode].ea_add);rttadd_replace_string(replace, ID_OPHANDLER_EA_AY_16, str);rttsprintf(str, ""EA_%s_32()"", g_ea_info_table[ea_mode].ea_add);rttadd_replace_string(replace, ID_OPHANDLER_EA_AY_32, str);rttsprintf(str, ""OPER_%s_8()"", g_ea_info_table[ea_mode].ea_add);rttadd_replace_string(replace, ID_OPHANDLER_OPER_AY_8, str);rttsprintf(str, ""OPER_%s_16()"", g_ea_info_table[ea_mode].ea_add);rttadd_replace_string(replace, ID_OPHANDLER_OPER_AY_16, str);rttsprintf(str, ""OPER_%s_32()"", g_ea_info_table[ea_mode].ea_add);rttadd_replace_string(replace, ID_OPHANDLER_OPER_AY_32, str);rt}rrt rtwrite_body(filep, body, replace);rtg_num_functions++;rtfree(op);r}",2,"cwe119,cwe120"
"GetTempPath (guint32 len, gunichar2 *buf){tgchar *tmpdir=g_strdup (g_get_tmp_dir ());tgunichar2 *tmpdir16=NULL;tglong dirlen;tgsize bytes;tguint32 ret;ttif(tmpdir[strlen (tmpdir)]!='/') {ttg_free (tmpdir);tttmpdir=g_strdup_printf (""%s/"", g_get_tmp_dir ());t}tttmpdir16=mono_unicode_from_external (tmpdir, &bytes);tif(tmpdir16==NULL) {ttg_free (tmpdir);ttreturn(0);t} else {ttdirlen=(bytes/2);ttttif(dirlen+1>len) {tttDEBUG (""%s: Size %d smaller than needed (%ld)"",tttt   __func__, len, dirlen+1);tttttret=dirlen+1;tt} else {ttt tttmemset (buf, '0', bytes+2);tttmemcpy (buf, tmpdir16, bytes);tttttret=dirlen;tt}t}tif(tmpdir16!=NULL) {ttg_free (tmpdir16);t}tg_free (tmpdir);ttreturn(ret);}",2,"cwe120,cweother"
"read_cb(evutil_socket_t fd, short event, void *arg){tchar buf[256];tint len;tif (EV_TIMEOUT & event) {ttprintf(""%s: Timeout!"", __func__);ttexit(1);t}tlen = recv(fd, buf, sizeof(buf), 0);tprintf(""%s: read %d%s"", __func__,t    len, len ? """" : "" - means EOF"");tif (len) {ttif (!called)tttevent_add(arg, &timeout);t} else if (called == 1)tttest_okay = 0;tcalled++;}",2,"cwe119,cwe120"
"print_file_info(const udf_dirent_t *p_udf_dirent, const char* psz_dirname){  time_t mod_time = udf_get_modification_time(p_udf_dirent);  char psz_mode[11]=""invalid"";  const char *psz_fname= psz_dirname     ? psz_dirname : udf_get_filename(p_udf_dirent);     printf(""%s "", udf_mode_string(udf_get_posix_filemode(p_udf_dirent),ttttpsz_mode));  printf(""%4d "", udf_get_link_count(p_udf_dirent));  printf(""%lu "", (long unsigned int) udf_get_file_length(p_udf_dirent));  printf(""%s %s"",  *psz_fname ? psz_fname : ""/"", ctime(&mod_time));}",2,"cwe119,cwe120"
"get_text_ellipsis_limit_for_zoom (char **strs,tttt  const char *zoom_level,tttt  int *limit){tchar **p;tchar *str;tgboolean success;tsuccess = FALSE;t t*limit = 3;tif (zoom_level != NULL) {ttstr = g_strdup_printf (""%s:%%d"", zoom_level);t} else {ttstr = g_strdup (""%d"");t}tif (strs != NULL) {ttfor (p = strs; *p != NULL; p++) {tttif (sscanf (*p, str, limit)) {ttttsuccess = TRUE;ttt}tt}t}tg_free (str);treturn success;}",2,"cwe120,cweother"
"cmd_marktrusted (assuan_context_t ctx, char *line){  ctrl_t ctrl = assuan_get_pointer (ctx);  int rc, n, i;  char *p;  char fpr[41];  int flag;     for (p=line,n=0; hexdigitp (p); p++, n++)    ;  if (!spacep (p) || !(n == 40 || n == 32))    return set_error (GPG_ERR_ASS_PARAMETER, ""invalid fingerprint"");  i = 0;  if (n==32)    {      strcpy (fpr, ""00000000"");      i += 8;    }  for (p=line; i < 40; p++, i++)    fpr[i] = *p >= 'a'? (*p & 0xdf): *p;  fpr[i] = 0;  while (spacep (p))    p++;  flag = *p++;  if ( (flag != 'S' && flag != 'P') || !spacep (p) )    return set_error (GPG_ERR_ASS_PARAMETER, ""invalid flag - must be P or S"");  while (spacep (p))    p++;  rc = agent_marktrusted (ctrl, p, fpr, flag);  if (rc)    log_error (""command marktrusted failed: %s"", gpg_strerror (rc));  return rc;}",2,"cwe119,cwe120"
"sanei_epson2_scsi_read(int fd, void *buf, size_t buf_size,tt      SANE_Status *status){tunsigned char cmd[6];tmemset(cmd, 0, 6);tcmd[0] = READ_6_COMMAND;tcmd[2] = buf_size >> 16;tcmd[3] = buf_size >> 8;tcmd[4] = buf_size;t*status = sanei_scsi_cmd2(fd, cmd, sizeof(cmd), NULL, 0, buf, &buf_size);tif (*status == SANE_STATUS_GOOD)ttreturn buf_size;treturn 0;}",2,"cwe119,cwe120"
"x509_crt_copy(gnutls_x509_crt_t src){    int ret;    size_t size;    gnutls_datum_t tmp;    gnutls_x509_crt_t dest;    size = 0;        if (gnutls_x509_crt_init(&dest) != 0) {    tg_warning(""couldn't gnutls_x509_crt_init"");        return NULL;    }    if (gnutls_x509_crt_export(src, GNUTLS_X509_FMT_DER, NULL, &size)         != GNUTLS_E_SHORT_MEMORY_BUFFER) {    tg_warning(""couldn't gnutls_x509_crt_export to get size"");        gnutls_x509_crt_deinit(dest);        return NULL;    }    tmp.data = malloc(size);    memset(tmp.data, 0, size);    ret = gnutls_x509_crt_export(src, GNUTLS_X509_FMT_DER, tmp.data, &size);    if (ret == 0) {        tmp.size = size;        ret = gnutls_x509_crt_import(dest, &tmp, GNUTLS_X509_FMT_DER);tif (ret) {ttg_warning(""couldn't gnutls_x509_crt_import for real (%d %s)"", ret, gnutls_strerror(ret));ttgnutls_x509_crt_deinit(dest);ttdest = NULL;t}    } else {    tg_warning(""couldn't gnutls_x509_crt_export for real (%d %s)"", ret, gnutls_strerror(ret));        gnutls_x509_crt_deinit(dest);        dest = NULL;    }    free(tmp.data);    return dest;}",2,"cwe119,cwe120"
"""tor_strstrip(char *s, const char *strip){  char *read = s;  while (*read) {    if (strchr(strip, *read)) {      ++read;    } else {      *s++ = *read++;    }  }  *s = '0';}""",3,"cwe119,cwe120,cweother"
"viafb_dvp0_proc_write(struct file *file,tconst char __user *buffer, size_t count, loff_t *pos){tchar buf[20], *value, *pbuf;tu8 reg_val = 0;tunsigned long length, i;tif (count < 1)ttreturn -EINVAL;tlength = count > 20 ? 20 : count;tif (copy_from_user(&buf[0], buffer, length))ttreturn -EFAULT;tbuf[length - 1] = '0';t tpbuf = &buf[0];tfor (i = 0; i < 3; i++) {ttvalue = strsep(&pbuf, "" "");ttif (value != NULL) {tttif (kstrtou8(value, 0, &reg_val) < 0)ttttreturn -EINVAL;tttDEBUG_MSG(KERN_INFO ""DVP0:reg_val[%l]=:%x"", i,tttt  reg_val);tttswitch (i) {tttcase 0:ttttviafb_write_reg_mask(CR96, VIACR,tttttreg_val, 0x0f);ttttbreak;tttcase 1:ttttviafb_write_reg_mask(SR2A, VIASR,tttttreg_val << 4, BIT5);ttttviafb_write_reg_mask(SR1B, VIASR,tttttreg_val << 1, BIT1);ttttbreak;tttcase 2:ttttviafb_write_reg_mask(SR2A, VIASR,tttttreg_val << 3, BIT4);ttttviafb_write_reg_mask(SR1E, VIASR,tttttreg_val << 2, BIT2);ttttbreak;tttdefault:ttttbreak;ttt}tt} else {tttbreak;tt}t}treturn count;}",2,"cwe119,cwe120"
"dispatch_attachment(ATTACH_S *a){    if(a->test_deferred){ta->test_deferred = 0;ta->can_display = mime_can_display(a->body->type, a->body->subtype, a->body);    }    return(a->can_display);}",2,"cwe119,cwe120"
"""set_stdio(void){    charttserver[LAM_PATH_MAX];t/* fd server socket name */    if (opt_taken('f')) return(0);#if LAM_HAVE_FD_PASSING/* * Pass stdin, stdout and stderr to filed. */    if (lam_mktmpid((int) lam_getpid(), server, sizeof(server))) {treturn(LAMERROR);    }    if (lam_lfopenfd(server)) {treturn(LAMERROR);    }/* * Set LAM file descriptors to the passed file descriptors.  The call to * lam_lfopenfd() takes care of the case when stdin is a tty. */    _kio.ki_stdin = _ufd[0].fu_tfd;    _kio.ki_stdout = _ufd[1].fu_tfd;    _kio.ki_stderr = _ufd[2].fu_tfd;#endif    return(0);}""",2,"cwe119,cwe120"
"tar_append_tree(TAR *t, char *realdir, char *savedir){  char realpath[TAR_MAXPATHLEN];  char savepath[TAR_MAXPATHLEN];  size_t plen;#if defined(HAVE_DIRENT_H)  struct dirent *dent;  DIR *dp;#else    kwDirEntry * dent;  kwDirectory *dp;#endif    struct stat s;  strncpy(realpath, realdir, sizeof(realpath));  realpath[sizeof(realpath)-1] = 0;  plen = strlen(realpath);  if ( realpath[plen-1] == '/' )    {    realpath[plen-1] = 0;    }  #ifdef DEBUG  printf(""==> tar_append_tree(0x%lx, ""%s"", ""%s"")"",         t, realdir, (savedir ? savedir : ""[NULL]""));#endif  if (tar_append_file(t, realdir, savedir) != 0)    return -1;#ifdef DEBUG  puts(""    tar_append_tree(): done with tar_append_file()..."");#endif  if ( stat(realpath, &s) != 0 )    {    return -1;       }  if ( #if defined(_WIN32) && !defined(__CYGWIN__)    (s.st_mode & _S_IFDIR) == 0#else    !S_ISDIR(s.st_mode)#endif  )    return 0;#if defined(HAVE_DIRENT_H)  dp = opendir(realdir);#else  dp = kwOpenDir(realdir);#endif  if (dp == NULL)  {    if (errno == ENOTDIR)      return 0;    return -1;  }#if defined(HAVE_DIRENT_H)  while ((dent = readdir(dp)) != NULL)#else  while ((dent = kwReadDir(dp)) != NULL)#endif  {    if (strcmp(dent->d_name, ""."") == 0 ||        strcmp(dent->d_name, "".."") == 0)      continue;    snprintf(realpath, TAR_MAXPATHLEN, ""%s/%s"", realdir,       dent->d_name);    if (savedir)      snprintf(savepath, TAR_MAXPATHLEN, ""%s/%s"", savedir,         dent->d_name);#ifndef WIN32    if (lstat(realpath, &s) != 0)      return -1;#else    if (stat(realpath, &s) != 0)      return -1;#endif    if (S_ISDIR(s.st_mode))    {      if (tar_append_tree(t, realpath,              (savedir ? savepath : NULL)) != 0)        return -1;      continue;    }    if (tar_append_file(t, realpath,            (savedir ? savepath : NULL)) != 0)      return -1;  }#if defined(HAVE_DIRENT_H)  closedir(dp);#else  kwCloseDir(dp);#endif  return 0;}",2,"cwe119,cwe120"
"sendFeedback(PGconn *conn, XLogRecPtr blockpos, int64 now, bool replyRequested){tcharttreplybuf[1 + 8 + 8 + 8 + 8 + 1];tinttttlen = 0;treplybuf[len] = 'r';tlen += 1;tfe_sendint64(blockpos, &replybuf[len]);tt tlen += 8;tif (reportFlushPosition)ttfe_sendint64(lastFlushPosition, &replybuf[len]);tt telsettfe_sendint64(InvalidXLogRecPtr, &replybuf[len]);tt tlen += 8;tfe_sendint64(InvalidXLogRecPtr, &replybuf[len]);t tlen += 8;tfe_sendint64(now, &replybuf[len]);t tlen += 8;treplybuf[len] = replyRequested ? 1 : 0;tt tlen += 1;tif (PQputCopyData(conn, replybuf, len) <= 0 || PQflush(conn))t{ttfprintf(stderr, _(""%s: could not send feedback packet: %s""),ttttprogname, PQerrorMessage(conn));ttreturn false;t}treturn true;}",2,"cwe119,cwe120"
"_slurm_set_addr_char (slurm_addr_t * addr, uint16_t port, char *host){tstruct hostent * he    = NULL;tintt   h_err = 0;tchar *t   h_buf[4096];t taddr->sin_family = AF_SLURM;taddr->sin_port   = htons(port);tif (host == NULL)ttreturn;the = get_host_by_name(host, (void *)&h_buf, sizeof(h_buf), &h_err);tif (he != NULL)ttmemcpy (&addr->sin_addr.s_addr, he->h_addr, he->h_length);telse {tterror(""Unable to resolve ""%s"": %s"", host, hstrerror(h_err));ttaddr->sin_family = 0;ttaddr->sin_port = 0;t}treturn;}",2,"cwe119,cwe120"
"""ParseComment(FILE *f, char *comment){  int current;  int pos_in_comment=0;  do {        current=fgetc(f);    if(current==EOF) {      comment[pos_in_comment]=(char)0;      return(EOF);    }    if(current!='') {      comment[pos_in_comment]=current;      pos_in_comment++;      if(pos_in_comment+1>=MAX_ENTRY_LENGTH) return(-1);    }  } while(current!='');  DbmParseLineNumber++;  comment[pos_in_comment]= (char) 0;    return(1);}""",2,"cwe120,cweother"
"__ecereMethod_NewProjectDialog_NotifyModifiedLocation(struct __ecereNameSpace__ecere__com__Instance * this, struct __ecereNameSpace__ecere__com__Instance * pathBox){struct NewProjectDialog * __ecerePointer_NewProjectDialog = (struct NewProjectDialog *)(this ? (((char *)this) + __ecereClass_NewProjectDialog->offset) : 0);char location[797];char lastPart[274];char * text;BasicValidatePathBoxPath(pathBox);text = __ecereProp___ecereNameSpace__ecere__gui__controls__PathBox_Get_slashPath(pathBox);__ecereProp___ecereNameSpace__ecere__gui__Window_Set_disabled(__ecerePointer_NewProjectDialog->okBtn, !(text[0] && __ecereProp___ecereNameSpace__ecere__gui__controls__EditBox_Get_contents(__ecerePointer_NewProjectDialog->projectName)[0]));__ecereFunction___ecereNameSpace__ecere__sys__GetWorkingDir(location, sizeof location - 1);__ecereFunction___ecereNameSpace__ecere__sys__PathCatSlash(location, text);__ecereFunction___ecereNameSpace__ecere__sys__GetLastDirectory(__ecerePointer_NewProjectDialog->path, lastPart);strcpy(__ecerePointer_NewProjectDialog->path, location);__ecereProp___ecereNameSpace__ecere__gui__controls__PathBox_Set_path(pathBox, __ecerePointer_NewProjectDialog->path);return 0x1;}",3,"cwe119,cwe120,cwe476"
"proxy_ajp_canon(request_rec *r, char *url){    char *host, *path, sport[7];    char *search = NULL;    const char *err;    apr_port_t port = AJP13_DEF_PORT;         if (strncasecmp(url, ""ajp:"", 4) == 0) {        url += 4;    }    else {        return DECLINED;    }    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, ""canonicalising URL %s"", url);         err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);    if (err) {        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00867) ""error parsing URL %s: %s"",                      url, err);        return HTTP_BAD_REQUEST;    }         if (apr_table_get(r->notes, ""proxy-nocanon"")) {        path = url;        }    else {        path = ap_proxy_canonenc(r->pool, url, strlen(url), enc_path, 0,                                 r->proxyreq);        search = r->args;    }    if (path == NULL)        return HTTP_BAD_REQUEST;    apr_snprintf(sport, sizeof(sport), "":%d"", port);    if (ap_strchr_c(host, ':')) {                 host = apr_pstrcat(r->pool, ""["", host, ""]"", NULL);    }    r->filename = apr_pstrcat(r->pool, ""proxy:ajp://"", host, sport,                              ""/"", path, (search) ? ""?"" : """",                              (search) ? search : """", NULL);    return OK;}",2,"cwe119,cwe120"
"tps65912_irq_sync_unlock(struct irq_data *data){tstruct tps65912 *tps65912 = irq_data_get_irq_chip_data(data);tu32 reg_mask;tu8 reg;ttps65912->read(tps65912, TPS65912_INT_MSK, 1, &reg);treg_mask = reg;ttps65912->read(tps65912, TPS65912_INT_MSK2, 1, &reg);treg_mask |= reg << 8;ttps65912->read(tps65912, TPS65912_INT_MSK3, 1, &reg);treg_mask |= reg << 16;ttps65912->read(tps65912, TPS65912_INT_MSK4, 1, &reg);treg_mask |= reg << 24;tif (tps65912->irq_mask != reg_mask) {ttreg = tps65912->irq_mask & 0xFF;tttps65912->write(tps65912, TPS65912_INT_MSK, 1, &reg);ttreg = tps65912->irq_mask >> 8 & 0xFF;tttps65912->write(tps65912, TPS65912_INT_MSK2, 1, &reg);ttreg = tps65912->irq_mask >> 16 & 0xFF;tttps65912->write(tps65912, TPS65912_INT_MSK3, 1, &reg);ttreg = tps65912->irq_mask >> 24 & 0xFF;tttps65912->write(tps65912, TPS65912_INT_MSK4, 1, &reg);t}tmutex_unlock(&tps65912->irq_lock);}",2,"cwe120,cweother"
"Parse_Date (void){    const gchar *year;    gchar *tmp, *tmp1;    gchar *current_year;    GDateTime *dt;         if (!DATE_AUTO_COMPLETION) return FALSE;         year = gtk_entry_get_text(GTK_ENTRY(YearEntry));    if ( strcmp(year,"""")!=0 && strlen(year)<4 )    {        dt = g_date_time_new_now_local ();        current_year = g_date_time_format (dt, ""%Y"");        g_date_time_unref (dt);        tmp = &current_year[4-strlen(year)];        if ( atoi(year) <= atoi(tmp) )        {            sprintf(current_year,""%d"",atoi(current_year)-atoi(tmp));            tmp1 = g_strdup_printf(""%d"",atoi(current_year)+atoi(year));            gtk_entry_set_text(GTK_ENTRY(YearEntry),tmp1);            g_free(tmp1);        }else        {            sprintf(current_year,""%d"",atoi(current_year)-atoi(tmp)                -(strlen(year)<=0 ? 1 : strlen(year)<=1 ? 10 :                            strlen(year)<=2 ? 100 : strlen(year)<=3 ? 1000 : 0));            tmp1 = g_strdup_printf(""%d"",atoi(current_year)+atoi(year));            gtk_entry_set_text(GTK_ENTRY(YearEntry),tmp1);            g_free(tmp1);        }        g_free (current_year);    }    return FALSE;}",2,"cwe120,cweother"
"convert_op_cmp(PyObject **vcmp, PyObject **wcmp, PyObject *v, PyObject *w,               int op, PyObject *context){    mpd_context_t *ctx = CTX(context);    *vcmp = v;    if (PyDec_Check(w)) {        Py_INCREF(w);        *wcmp = w;    }    else if (PyLong_Check(w)) {        *wcmp = PyDec_FromLongExact(w, context);    }    else if (PyFloat_Check(w)) {        if (op != Py_EQ && op != Py_NE &&            dec_addstatus(context, MPD_Float_operation)) {            *wcmp = NULL;        }        else {            ctx->status |= MPD_Float_operation;            *wcmp = PyDec_FromFloatExact(w, context);        }    }    else if (PyComplex_Check(w) && (op == Py_EQ || op == Py_NE)) {        Py_complex c = PyComplex_AsCComplex(w);        if (c.real == -1.0 && PyErr_Occurred()) {            *wcmp = NULL;        }        else if (c.imag == 0.0) {            PyObject *tmp = PyFloat_FromDouble(c.real);            if (tmp == NULL) {                *wcmp = NULL;            }            else {                ctx->status |= MPD_Float_operation;                *wcmp = PyDec_FromFloatExact(tmp, context);                Py_DECREF(tmp);            }        }        else {            Py_INCREF(Py_NotImplemented);            *wcmp = Py_NotImplemented;        }    }    else if (PyObject_IsInstance(w, Rational)) {        *wcmp = numerator_as_decimal(w, context);        if (*wcmp && !mpd_isspecial(MPD(v))) {            *vcmp = multiply_by_denominator(v, w, context);            if (*vcmp == NULL) {                Py_CLEAR(*wcmp);            }        }    }    else {        Py_INCREF(Py_NotImplemented);        *wcmp = Py_NotImplemented;    }    if (*wcmp == NULL || *wcmp == Py_NotImplemented) {        return 0;    }    if (*vcmp == v) {        Py_INCREF(v);    }    return 1;}",2,"cwe119,cwe120"
"command_setstat(char * token, Channel * c) {    char path[FILE_PATH_SIZE];    FileAttrs attrs;    int err = 0;    read_path(&c->inp, path, sizeof(path));    if (read_stream(&c->inp) != 0) exception(ERR_JSON_SYNTAX);    memset(&attrs, 0, sizeof(FileAttrs));    json_read_struct(&c->inp, read_file_attrs, &attrs);    if (read_stream(&c->inp) != 0) exception(ERR_JSON_SYNTAX);    if (read_stream(&c->inp) != MARKER_EOM) exception(ERR_JSON_SYNTAX);    if (attrs.flags & ATTR_SIZE) {        if (truncate(path, attrs.size) < 0) err = errno;    }#if !defined(WIN32) && !defined(_WRS_KERNEL)    if (attrs.flags & ATTR_UIDGID) {        if (chown(path, attrs.uid, attrs.gid) < 0) err = errno;    }#endif    if (attrs.flags & ATTR_PERMISSIONS) {        if (chmod(path, attrs.permissions) < 0) err = errno;    }    if (attrs.flags & ATTR_ACMODTIME) {        struct utimbuf buf;        buf.actime = (time_t)(attrs.atime / 1000);        buf.modtime = (time_t)(attrs.mtime / 1000);        if (utime(path, &buf) < 0) err = errno;    }    reply_setstat(token, &c->out, err);}",3,"cwe119,cwe120,cweother"
"xosdlib_drv_flush (Driver *drvthis){tPrivateData *p = drvthis->private_data;tint i;tchar buffer[LCD_MAX_WIDTH];tdebug(RPT_DEBUG, ""%s(%p)"", __FUNCTION__, drvthis);tfor (i = 0; i < p->height; i++) {ttmemcpy(buffer, p->framebuf + (i * p->width), p->width);ttbuffer[p->width] = '0';ttdebug(RPT_DEBUG, ""xosd: flushed string ""%s"" at (%d,%d)"", buffer, 0, i);ttxosd_display(p->osd, i, XOSD_string, buffer);t}}",2,"cwe119,cwe120"
"gl843_send_slope_table (Genesys_Device * dev, int table_nr,tttuint16_t * slope_table, int steps){  SANE_Status status;  uint8_t *table;  int i;  char msg[2048 * 4];  DBG (DBG_proc, ""%s (table_nr = %d, steps = %d)"", __FUNCTION__,       table_nr, steps);  table = (uint8_t *) malloc (steps * 2);  for (i = 0; i < steps; i++)    {      table[i * 2] = slope_table[i] & 0xff;      table[i * 2 + 1] = slope_table[i] >> 8;    }  if (DBG_LEVEL >= DBG_io)    {      sprintf (msg, ""write slope %d (%d)="", table_nr, steps);      for (i = 0; i < steps; i++)t{t  sprintf (msg, ""%s,%d"", msg, slope_table[i]);t}      DBG (DBG_io, ""%s: %s"", __FUNCTION__, msg);    }        status = write_data (dev, 0x4000 + 0x800 * table_nr, steps * 2, table);  if (status != SANE_STATUS_GOOD)    {      DBG (DBG_error,t   ""%s: write data failed writing slope table %d (%s)"",t   __FUNCTION__, table_nr, sane_strstatus (status));    }  free (table);  DBG (DBG_proc, ""%s: completed"", __FUNCTION__);  return status;}",2,"cwe119,cwe120"
"svis(char *mbdst, int c, int flags, int nextc, const char *mbextra){tchar cc[2];tint ret;tcc[0] = c;tcc[1] = nextc;tret = istrsenvisx(mbdst, NULL, cc, 1, flags, mbextra, NULL);tif (ret < 0)ttreturn NULL;treturn mbdst + ret;}",2,"cwe119,cwe120"
"AddBasicConstraint(void *extHandle){    CERTBasicConstraints basicConstraint;        SECStatus rv;    char buffer[10];    PRBool yesNoAns;    do {        basicConstraint.pathLenConstraint = CERT_UNLIMITED_PATH_CONSTRAINT;        basicConstraint.isCA = GetYesNo (""Is this a CA certificate [y/N]?"");        buffer[0] = '0';        if (PrintChoicesAndGetAnswer(""Enter the path length constraint, ""                                     ""enter to skip [<0 for unlimited path]:"",                                     buffer, sizeof(buffer)) == SECFailure) {            GEN_BREAK(SECFailure);        }        if (PORT_Strlen (buffer) > 0)            basicConstraint.pathLenConstraint = PORT_Atoi (buffer);        yesNoAns = GetYesNo (""Is this a critical extension [y/N]?"");        rv = SECU_EncodeAndAddExtensionValue(NULL, extHandle,tt &basicConstraint, yesNoAns, SEC_OID_X509_BASIC_CONSTRAINTS,tt (EXTEN_EXT_VALUE_ENCODER)CERT_EncodeBasicConstraintValue);    } while (0);    return (rv);}",2,"cwe119,cwe120"
"search_todo(const char *needle, GtkWidget *clist){   gchar *empty_line[] = { """","""" };   char str2[SEARCH_MAX_COLUMN_LEN+2];   ToDoList *todo_list;   ToDoList *temp_todo;   struct search_record *new_sr;   int found, count;   int case_sense;       todo_list = NULL;   get_todos2(&todo_list, SORT_DESCENDING, 2, 2, 2, 1, CATEGORY_ALL);   if (todo_list==NULL) {      return 0;   }   count = 0;   case_sense = GTK_TOGGLE_BUTTON(case_sense_checkbox)->active;   for (temp_todo = todo_list; temp_todo; temp_todo=temp_todo->next) {      found = 0;      if ( (temp_todo->mtodo.todo.description) &&           (temp_todo->mtodo.todo.description[0]) ) {         if ( jp_strstr(temp_todo->mtodo.todo.description, needle, case_sense) ) {            found = 1;         }      }      if ( !found &&           (temp_todo->mtodo.todo.note) &&           (temp_todo->mtodo.todo.note[0]) ) {         if ( jp_strstr(temp_todo->mtodo.todo.note, needle, case_sense) ) {            found = 2;         }      }      if (found) {         gtk_clist_prepend(GTK_CLIST(clist), empty_line);         gtk_clist_set_text(GTK_CLIST(clist), 0, 0, _(""todo""));         if (found == 1) {            lstrncpy_remove_cr_lfs(str2, temp_todo->mtodo.todo.description, SEARCH_MAX_COLUMN_LEN);         } else {            lstrncpy_remove_cr_lfs(str2, temp_todo->mtodo.todo.note, SEARCH_MAX_COLUMN_LEN);         }         gtk_clist_set_text(GTK_CLIST(clist), 0, 1, str2);                   new_sr = malloc(sizeof(struct search_record));         new_sr->app_type = TODO;         new_sr->plugin_flag = 0;         new_sr->unique_id = temp_todo->mtodo.unique_id;         new_sr->next = search_rl;         search_rl = new_sr;         gtk_clist_set_row_data(GTK_CLIST(clist), 0, new_sr);         count++;      }   }   jp_logf(JP_LOG_DEBUG, ""calling free_ToDoList"");   free_ToDoList(&todo_list);   return count;}",2,"cwe119,cwe120"
"uild_header(const char *article, size_t length, const char *header,             struct buffer *overview){    ptrdiff_t size;    size_t offset;    const char *data, *end, *p;    data = wire_findheader(article, length, header, false);    if (data == NULL)        return;    end = wire_endheader(data, article + length - 1);    if (end == NULL)        return;         if (strcasecmp(header, ""xref"") == 0) {        const char *next = end + 1;        while (next != NULL) {            next = wire_findheader(next, length - (next - article), header, false);            if (next != NULL) {                data = next;                end = wire_endheader(data, article + length - 1);                if (end == NULL)                    return;            }        }    }    size = end - data + 1;    offset = overview->used + overview->left;    buffer_resize(overview, offset + size);    for (p = data; p <= end; p++) {        if (*p == 'r' && p[1] == '') {            p++;            continue;        }        if (*p == '0' || *p == 't' || *p == '' || *p == 'r')            overview->data[offset++] = ' ';        else            overview->data[offset++] = *p;        overview->left++;    }}",2,"cwe119,cwe120"
"Consult_2(WamWord tmp_file_word, WamWord pl_file_word){  char *tmp_file = Rd_String_Check(tmp_file_word);  char *pl_file = Rd_String_Check(pl_file_word);  char *singl_warn = (Flag_Value(FLAG_SINGLETON_WARNING)) ? NULL    : ""--no-singl-warn"";  StmInf *pstm_o = stm_tbl[stm_top_level_output];  StmInf *pstm_i = stm_tbl[stm_top_level_input];  int pid;  FILE *f_out, *f_in;  FILE **pf_in;  long save;  unsigned char *p = NULL;  int status, c;  int save_use_le_prompt;  char *arg[] = { ""pl2wam"", ""-w"", ""--compile-msg"", ""--no-redef-error"",tt  ""--pl-state"", tmp_file, ""-o"", tmp_file, pl_file,tt  singl_warn, NULL };  save = SYS_VAR_SAY_GETC;#ifndef NO_USE_PIPED_STDIN_FOR_CONSULT  SYS_VAR_SAY_GETC = 1;  pf_in = &f_in;#else  f_in = NULL;  pf_in = NULL;#endif  Write_Pl_State_File(tmp_file_word);  SYS_VAR_SAY_GETC = save;  Flush_All_Streams();  pid = M_Spawn_Redirect(arg, 0, pf_in, &f_out, &f_out);  Os_Test_Error(pid == -1);  if (pid == -2)    {    error_pl2wam:      Pl_Err_System(Create_Atom(""error trying to execute pl2wam ""tttt""(maybe not found)""));      return FALSE;    }  save_use_le_prompt = use_le_prompt;  use_le_prompt = 0;  for (;;)    {#if 1      c = fgetc(f_out);#else      char c0;      c = (read(fileno(f_out), &c0, 1) == 1) ? c0 : EOF;#endif      if (c == EOF)tbreak;t  #ifndef NO_USE_PIPED_STDIN_FOR_CONSULT      if (c == CHAR_TO_EMIT_WHEN_CHAR)t{t  if (p == NULL)t    {t      c = Stream_Getc(pstm_i);t      if (c == EOF)tt{tteof_reached:tt  p = (unsigned char *) ""end_of_file."";tt  c = *p++;tt}t    }t  elset    {t      if (*p == '0')ttgoto eof_reached;t      elsettc = *p++;t    }t  fputc(c, f_in);t  fflush(f_in);t  continue;t}#endif      Stream_Putc(c, pstm_o);    }  use_le_prompt = save_use_le_prompt;  if (f_in)    fclose(f_in);  fclose(f_out);  status = M_Get_Status(pid);  if (status < 0)    goto error_pl2wam;  return status == 0;}",2,"cwe120,cweother"
"NewPersistentContext(char *name,unsigned int ttl_minutes,enum statepolicy policy){ int errno;  CF_DB *dbp;  struct CfState state;  time_t now = time(NULL);  char filename[CF_BUFSIZE];snprintf(filename,CF_BUFSIZE,""%s/state/%s"",CFWORKDIR,CF_STATEDB_FILE);MapName(filename);if (!OpenDB(filename,&dbp))   {   return;   }cf_chmod(filename,0644);        if (ReadDB(dbp,name,&state,sizeof(state)))   {   if (state.policy == cfpreserve)      {      if (now < state.expires)         {         CfOut(cf_verbose,"""","" -> Persisent state %s is already in a preserved state --  %d minutes to go"",name,(state.expires-now)/60);         CloseDB(dbp);         return;         }      }   }else   {   CfOut(cf_verbose,"""","" -> New persistent state %s"",name);   state.expires = now + ttl_minutes * 60;   state.policy = policy;   } WriteDB(dbp,name,&state,sizeof(state));CloseDB(dbp);}",2,"cwe119,cwe120"
"sge_add_double2load_report(lList **lpp, char *name, double value,                               const char *host, char *units){   char load_string[255];    DENTER(BASIS_LAYER, ""sge_add_double2load_report"");    sprintf(load_string, ""%f%s"", value, units?units:"""");   sge_add_str2load_report(lpp, name, load_string, host);   DRETURN(0); }",2,"cwe119,cwe120"
"""ecs_loc_pre_ens__lit_chaine(const ecs_file_t  *fic_geo,                            char   ligne[ECS_LOC_LNG_MAX_CHAINE_ENS],                            int   *num_ligne){  size_t ind;  if (ecs_file_get_type(fic_geo) != ECS_FILE_TYPE_TEXT) {    ecs_file_read(ligne, sizeof(char), 80, fic_geo);    ligne[80] = '0';  }  else {    ecs_file_gets(ligne, ECS_LOC_LNG_MAX_CHAINE_ENS, fic_geo, num_ligne);    for (ind = strlen(ligne) - 1;         ind > 0 && (ligne[ind] == '' || ligne[ind] == 'r');         ind--);    ligne[ind + 1] = '0';  }}""",3,"cwe119,cwe120,cweother"
"read_cache(struct lscpu_desc *desc, int num){tchar buf[256];tint i;tif (!desc->ncaches) {ttwhile(path_exist(_PATH_SYS_SYSTEM ""/cpu/cpu%d/cache/index%d"",tttttnum, desc->ncaches))tttdesc->ncaches++;ttif (!desc->ncaches)tttreturn;ttdesc->caches = xcalloc(desc->ncaches, sizeof(*desc->caches));t}tfor (i = 0; i < desc->ncaches; i++) {ttstruct cpu_cache *ca = &desc->caches[i];ttcpu_set_t *map;ttif (!path_exist(_PATH_SYS_SYSTEM ""/cpu/cpu%d/cache/index%d"",ttttnum, i))tttcontinue;ttif (!ca->name) {tttint type, level;ttt tttpath_getstr(buf, sizeof(buf),ttttt_PATH_SYS_CPU ""/cpu%d/cache/index%d/type"",tttttnum, i);tttif (!strcmp(buf, ""Data""))tttttype = 'd';tttelse if (!strcmp(buf, ""Instruction""))tttttype = 'i';tttelsetttttype = 0;ttt tttlevel = path_getnum(_PATH_SYS_CPU ""/cpu%d/cache/index%d/level"",tttttnum, i);tttif (type)ttttsnprintf(buf, sizeof(buf), ""L%d%c"", level, type);tttelsettttsnprintf(buf, sizeof(buf), ""L%d"", level);tttca->name = xstrdup(buf);ttt tttpath_getstr(buf, sizeof(buf),ttttt_PATH_SYS_CPU ""/cpu%d/cache/index%d/size"",tttttnum, i);tttca->size = xstrdup(buf);tt}tt ttmap = path_cpuset(_PATH_SYS_CPU ""/cpu%d/cache/index%d/shared_cpu_map"",ttttnum, i);ttif (!ca->sharedmaps)tttca->sharedmaps = xcalloc(desc->ncpus, sizeof(cpu_set_t *));ttadd_cpuset_to_array(ca->sharedmaps, &ca->nsharedmaps, map);t}}",3,"cwe119,cwe120,cwe469"
"uds_reader (assuan_context_t ctx, void *buf, size_t buflen){#ifndef HAVE_W32_SYSTEM  int len = 0;     while (!len)       {      struct msghdr msg;      struct iovec iovec;#ifdef USE_DESCRIPTOR_PASSING      union {        struct cmsghdr cm;        char control[CMSG_SPACE(sizeof (int))];      } control_u;      struct cmsghdr *cmptr;#endif        memset (&msg, 0, sizeof (msg));      msg.msg_name = NULL;      msg.msg_namelen = 0;      msg.msg_iov = &iovec;      msg.msg_iovlen = 1;      iovec.iov_base = buf;      iovec.iov_len = buflen;#ifdef USE_DESCRIPTOR_PASSING      msg.msg_control = control_u.control;      msg.msg_controllen = sizeof (control_u.control);#endif      len = _assuan_recvmsg (ctx, ctx->inbound.fd, &msg, 0);      if (len < 0)        return -1;      if (len == 0)treturn 0;#ifdef USE_DESCRIPTOR_PASSING      cmptr = CMSG_FIRSTHDR (&msg);      if (cmptr && cmptr->cmsg_len == CMSG_LEN (sizeof(int)))        {          if (cmptr->cmsg_level != SOL_SOCKET              || cmptr->cmsg_type != SCM_RIGHTS)            TRACE0 (ctx, ASSUAN_LOG_SYSIO, ""uds_reader"", ctx,tt    ""unexpected ancillary data received"");          else            {              int fd;t      memcpy (&fd, CMSG_DATA (cmptr), sizeof (fd));              if (ctx->uds.pendingfdscount >= DIM (ctx->uds.pendingfds))                {tt  TRACE1 (ctx, ASSUAN_LOG_SYSIO, ""uds_reader"", ctx,ttt  ""too many descriptors pending - ""ttt  ""closing received descriptor %d"", fd);                  _assuan_close (ctx, fd);                }              else                ctx->uds.pendingfds[ctx->uds.pendingfdscount++] = fd;            }t}#endif      }  return len;#else    int res = recvfrom (HANDLE2SOCKET(ctx->inbound.fd), buf, buflen, 0, NULL, NULL);  if (res < 0)    gpg_err_set_errno (_assuan_sock_wsa2errno (WSAGetLastError ()));  return res;#endif  }",2,"cwe119,cwe120"
"cuse_pack_info(int argc, const char **argv, char *buf){tsize_t size = 0;tint i;tfor (i = 0; i < argc; i++) {ttsize_t len;ttlen = strlen(argv[i]) + 1;ttsize += len;ttif (buf) {tttmemcpy(buf, argv[i], len);tttbuf += len;tt}t}treturn size;}",2,"cwe120,cweother"
"sky81452_bl_show_open_short(struct device *dev,ttstruct device_attribute *attr, char *buf){tstruct regmap *regmap = bl_get_data(to_backlight_device(dev));tunsigned int reg, value = 0;tchar tmp[3];tint i, ret;treg = !strcmp(attr->attr.name, ""open"") ? SKY81452_REG5 : SKY81452_REG4;tret = regmap_read(regmap, reg, &value);tif (ret < 0)ttreturn ret;tif (value & SKY81452_SHRT) {tt*buf = 0;ttfor (i = 0; i < 6; i++) {tttif (value & 0x01) {ttttsprintf(tmp, ""%d "", i + 1);ttttstrcat(buf, tmp);ttt}tttvalue >>= 1;tt}ttstrcat(buf, """");t} else {ttstrcpy(buf, ""none"");t}treturn strlen(buf);}",2,"cwe119,cwe120"
"Version (char *c, Object *in){    intttn;    intttm0, m1, m2;    chartbuf[256];    inttterr = TRUE;    chart*b;    if (c == NULL || *c == '000')    {tDXBeginLongMessage ();        DXMessage (""Executive version:        %d %d %d"", t            DXD_VERSION, DXD_RELEASE, DXD_MODIFICATION);        DXMessage (""Executive/UI interface:   %d %d %d"",t            UI_MAJOR, UI_MINOR, UI_MICRO);        DXMessage (""Creation date:            %s"", EX_COM_DATE);        DXMessage (""Creation host:            %s"", EX_COM_HOST);tDXEndLongMessage ();treturn (OK);    }#if DXD_PRINTF_RETURNS_COUNT    n = sprintf (buf,tt ""Executive/UI version mismatch:  %d %d %d vs "",tt UI_MAJOR, UI_MINOR, UI_MICRO);#else    {        sprintf (buf,tt ""Executive/UI version mismatch:  %d %d %d vs "",tt UI_MAJOR, UI_MINOR, UI_MICRO);        n = strlen(buf);    }#endif    b = buf + n;    n = sscanf (c, ""%d%d%d"", &m0, &m1, &m2);    if (n == 3 && m0 == UI_MAJOR && m1 == UI_MINOR && m2 == UI_MICRO)terr = FALSE;    elsetsprintf (b, ""%s"", *c ? c : ""<no version specified>"");    if (err)tDXUIMessage (""ERROR"", buf);    return (OK);}",2,"cwe119,cwe120"
"msg(char *text,...) {    char buff[140];    va_list p;    va_start(p,text);    vsnprintf(buff,139,text,p);    va_end(p);    if(!opt_silent) {tif(use_syslog)t    syslog(LOG_INFO, ""%s: %s"",curdev,buff);telset    fprintf(stderr,""%s (%s): %s"",progname,curdev,buff);    }   }",3,"cwe119,cwe120,cweother"
"""getbuf( void ) {tchar *p;tstatic char buf[1024];tif ( fgets( buf, sizeof(buf), stdin ) == NULL ) return NULL;tif ( (p = strchr( buf, '' )) != NULL ) *p = '0';treturn buf;}""",2,"cwe119,cwe120"
"encap_platform_compat(char *pkg_platform, char *host_platform,tt      encap_list_t *suffix_l){tchar base[MAXPATHLEN], suffix[MAXPATHLEN];tencap_listptr_t lp;tchar *cp;tif (encap_platform_split(pkg_platform, base, sizeof(base),tttt suffix, sizeof(suffix)) == -1)ttreturn -1;tif (strcmp(base, ""share"") == 0t    && suffix[0] == '0')ttreturn 1;t tif (strncmp(host_platform, ""pa-hpux"", 7) == 0)t{ttif (strncmp(base, ""pa1.1-hpux"", 10) == 0tt    || strncmp(base, ""pa2.0-hpux"", 10) == 0)tttmemmove(base + 2, base + 5, strlen(base + 5) + 1);t}tif (strcmp(base, host_platform) != 0)ttreturn 0;tif (suffix[0] == '0')ttreturn 1;tif (suffix_l != NULL)t{ttencap_listptr_reset(&lp);ttwhile (encap_list_next(suffix_l, &lp) != 0)tt{tttcp = (char *)encap_listptr_data(&lp);tttif (strcmp(cp, suffix) == 0)ttttreturn 1;tt}t}treturn 0;}",3,"cwe119,cwe120,cwe469"
"parq_upload_send_queue_conf(struct upload *u){tchar queue[MAX_LINE_SIZE];tstruct parq_ul_queued *puq;tstruct gnutella_socket *s;tsize_t rw;tssize_t sent;tupload_check(u);tg_assert(u->status == GTA_UL_QUEUE);tg_assert(u->name);tpuq = parq_upload_find(u);tg_return_unless(puq != NULL);t tpuq->flags &= ~PARQ_UL_QUEUE;trw = str_bprintf(queue, sizeof queue, ""QUEUE %s %sr"",tttguid_hex_str(&puq->id),ttthost_addr_port_to_string(listen_addr(), socket_listen_port()));ts = u->socket;tsent = bws_write(BSCHED_BWS_OUT, &s->wio, queue, rw);tif ((ssize_t) -1 == sent) {ttg_warning(""[PARQ UL] ""ttt""Unable to send back QUEUE for ""%s"" to %s: %m"",ttt  u->name, host_addr_port_to_string(s->addr, s->port));t} else if ((size_t) sent < rw) {ttg_warning(""[PARQ UL] ""ttt""Only sent %lu out of %lu bytes of QUEUE for ""%s"" to %s"",ttt  (ulong) sent, (ulong) rw, u->name,ttt  host_addr_port_to_string(s->addr, s->port));t} else if (GNET_PROPERTY(parq_debug) > 2) {ttg_debug(""PARQ UL: Sent #%d to %s: %s"",ttt  puq->queue_sent, host_addr_port_to_string(s->addr, s->port),ttt  queue);t}tif ((size_t) sent != rw) {ttupload_remove(u, ""Unable to send QUEUE #%d"", puq->queue_sent);ttreturn;t}t tpuq->flags |= PARQ_UL_QUEUE_SENT;tgnet_stats_inc_general(GNR_PARQ_QUEUE_SENT);texpect_http_header(u, GTA_UL_QUEUE_WAITING);}",2,"cwe119,cwe120"
"g_dbus_send_error_valist(DBusConnection *connection,tttttDBusMessage *message, const char *name,tttttconst char *format, va_list args){tDBusMessage *error;tchar str[1024];tvsnprintf(str, sizeof(str), format, args);terror = dbus_message_new_error(message, name, str);tif (error == NULL)ttreturn FALSE;treturn g_dbus_send_message(connection, error);}",3,"cwe119,cwe120,cweother"
"repo_init_structure(repo_init *results){tconst int mode = 0755;  tint error;tchar temp_path[GIT_PATH_MAX];tchar *git_dir = results->path_repository;tif (git_futils_mkdir_r(git_dir, mode))ttreturn git__throw(GIT_ERROR, ""Failed to initialize repository structure. Could not mkdir"");#ifdef GIT_WIN32t tif (!results->is_bare) {tterror = p_hide_directory__w32(git_dir);ttif (error < GIT_SUCCESS)tttreturn git__rethrow(error, ""Failed to initialize repository structure"");t}#endift tgit_path_join(temp_path, git_dir, GIT_OBJECTS_INFO_DIR);terror = git_futils_mkdir_r(temp_path, mode);tif (error < GIT_SUCCESS)ttreturn git__rethrow(error, ""Failed to initialize repository structure"");t tgit_path_join(temp_path, git_dir, GIT_OBJECTS_PACK_DIR);terror = p_mkdir(temp_path, mode);tif (error < GIT_SUCCESS)ttreturn git__throw(error, ""Unable to create `%s` folder"", temp_path);t tgit_path_join(temp_path, git_dir, GIT_REFS_HEADS_DIR);terror = git_futils_mkdir_r(temp_path, mode);tif (error < GIT_SUCCESS)ttreturn git__rethrow(error, ""Failed to initialize repository structure"");t tgit_path_join(temp_path, git_dir, GIT_REFS_TAGS_DIR);terror = p_mkdir(temp_path, mode);tif (error < GIT_SUCCESS)ttreturn git__throw(error, ""Unable to create `%s` folder"", temp_path);t treturn GIT_SUCCESS;}",2,"cwe119,cwe120"
"arb_start_server(const char *arb_tcp_env, GBDATA *gbmain, int do_sleep){    const char *tcp_id;    GB_ERROR error = 0;    if (!(tcp_id = GBS_read_arb_tcp(arb_tcp_env))) {        error = GB_export_errorf(""Entry '%s' in $(ARBHOME)/lib/arb_tcp.dat not found"", arb_tcp_env);    }    else {        const char *server       = strchr(tcp_id, 0) + 1;        char       *serverparams = 0;                 {            const char *param  = strchr(server, 0)+1;            size_t      plen   = strlen(param);            size_t      alllen = 0;            while (plen) {                param  += plen+1;                alllen += plen+1;                plen    = strlen(param);            }            serverparams = (char*)malloc(alllen+1);            {                char *sp = serverparams;                param = strchr(server, 0)+1;                plen  = strlen(param);                if (!plen) sp++;                else do {                    memcpy(sp, param, plen);                    sp[plen]  = ' ';                    sp       += plen+1;                    param    += plen+1;                    plen      = strlen(param);                } while (plen);                sp[-1] = 0;            }        }        {            char *command = 0;            int   delay   = 5;            if (*tcp_id == ':') {                  command = GBS_global_string_copy(""%s %s -T%s &"",server, serverparams, tcp_id);            }            else {                const char *port = strchr(tcp_id, ':');                if (!port) {                    error = GB_export_errorf(""Error: Missing ':' in line '%s' file $(ARBHOME)/lib/arb_tcp.dat"", arb_tcp_env);                }                else {                    char *remoteCommand = GBS_global_string_copy(""$ARBHOME/bin/%s %s -T%s"", server, serverparams, port);                    command = prefixSSH(tcp_id, remoteCommand, 1);                    free(remoteCommand);                }            }            if (!error) {#if defined(DEBUG)                printf(""Starting server (cmd='%s')"", command);#endif                  if (!gbmain || GBCMC_system(gbmain,command)) system(command);                if (do_sleep) sleep(delay);            }            free(command);        }        free(serverparams);    }    return error;}",3,"cwe120,cwe476,cweother"
"tracing_set_trace_write(struct file *filp, const char __user *ubuf,tttsize_t cnt, loff_t *ppos){tstruct trace_array *tr = filp->private_data;tchar buf[MAX_TRACER_SIZE+1];tint i;tsize_t ret;tint err;tret = cnt;tif (cnt > MAX_TRACER_SIZE)ttcnt = MAX_TRACER_SIZE;tif (copy_from_user(&buf, ubuf, cnt))ttreturn -EFAULT;tbuf[cnt] = 0;t tfor (i = cnt - 1; i > 0 && isspace(buf[i]); i--)ttbuf[i] = 0;terr = tracing_set_tracer(tr, buf);tif (err)ttreturn err;t*ppos += ret;treturn ret;}",2,"cwe119,cwe120"
"manager_parkinglot_list(struct mansession *s, const struct message *m){tconst char *id = astman_get_header(m, ""ActionID"");tchar idText[256] = """";tstruct ao2_iterator iter;tstruct ast_parkinglot *curlot;tif (!ast_strlen_zero(id))ttsnprintf(idText, sizeof(idText), ""ActionID: %sr"", id);tastman_send_ack(s, m, ""Parking lots will follow"");titer = ao2_iterator_init(parkinglots, 0);twhile ((curlot = ao2_iterator_next(&iter))) {ttastman_append(s, ""Event: Parkinglotr""ttt""Name: %sr""ttt""StartExten: %dr""ttt""StopExten: %dr""ttt""Timeout: %dr""ttt""r"",tttcurlot->name,tttcurlot->cfg.parking_start,tttcurlot->cfg.parking_stop,tttcurlot->cfg.parkingtime ? curlot->cfg.parkingtime / 1000 : curlot->cfg.parkingtime);ttao2_ref(curlot, -1);t}tastman_append(s,tt""Event: ParkinglotsCompleter""tt""%s""tt""r"",idText);treturn RESULT_SUCCESS;}",2,"cwe119,cwe120"
"authn_cache_dircfg_merge(apr_pool_t *pool, void *BASE, void *ADD){    authn_cache_dircfg *base = BASE;    authn_cache_dircfg *add = ADD;    authn_cache_dircfg *ret = apr_pmemdup(pool, add, sizeof(authn_cache_dircfg));         if (add->context == directory) {        ret->context = base->context;    }    if (add->timeout == apr_time_from_sec(300)) {        ret->timeout = base->timeout;    }    if (add->providers == NULL) {        ret->providers = base->providers;    }    return ret;}",2,"cwe120,cweother"
"les_connect(int lecs_method, struct sockaddr_atmsvc *manual_atm_addr,                  struct sockaddr_atmsvc *listen_addr){        struct sockaddr_atmsvc les_addr;        struct atm_sap sap;        struct atm_qos qos;        char buff[MAX_CTRL_FRAME];        int frame_size = 0;          diag(COMPONENT, DIAG_DEBUG, ""Entering Join phase"");        if (lecs_method == LECS_NONE) {                diag(COMPONENT, DIAG_DEBUG, ""Skipping LECS, connecting straight to LES"");                memcpy(les_addr.sas_addr.prv, manual_atm_addr->sas_addr.prv, ATM_ESA_LEN);        } else memcpy(les_addr.sas_addr.prv, lec_params.c9_les_atm_addr, ATM_ESA_LEN);t*les_addr.sas_addr.pub = 0;        init_conn_params(&sap, &qos, CONTROL_CONN);        lec_params.ctrl_direct = setup_svc(&les_addr, listen_addr, &sap, &qos);        if (lec_params.ctrl_direct == NULL) {                diag(COMPONENT, DIAG_ERROR, ""Control direct SVC failed"");                random_delay();                return -1;        }        lec_params.ctrl_listen = create_listensocket(listen_addr, &sap, &qos);        if (lec_params.ctrl_listen == NULL) {                diag(COMPONENT, DIAG_ERROR, ""Control distribute listen socket failed"");                random_delay();                return -1;        }        lec_params.c7c_current_timeout = lec_params.c7i_initial_ctrl_timeout;          while (lec_params.c7c_current_timeout <= lec_params.c7_ctrl_timeout) {                if (send_join_req(lec_params.ctrl_direct) < 0) {                        diag(COMPONENT, DIAG_ERROR, ""Sending LE_JOIN_REQUEST failed"");                        random_delay();                        return -1;                }                frame_size = read_join_rsp(buff, sizeof(buff));                if (frame_size < 0) {                        diag(COMPONENT, DIAG_ERROR, ""Receiving LE_JOIN_RESPONSE failed"");                        random_delay();                        return -1;                } else if (frame_size == 0)                          lec_params.c7c_current_timeout *= lec_params.c7x_timeout_multiplier;                else                        break;          }        lec_params.c7c_current_timeout = lec_params.c7i_initial_ctrl_timeout;          if (frame_size == 0) {                diag(COMPONENT, DIAG_ERROR, ""LE_JOIN_RESPONSE timed out"");                return -1;        }                if (parse_join_rsp(buff, frame_size) < 0) {                diag(COMPONENT, DIAG_ERROR, ""Parsing LE_JOIN_RESPONSE failed"");                return -1;        }        return 0;}",2,"cwe119,cwe120"
"Datadir_find_genomedir (char *user_genomedir) {  FILE *fp;  char *genomedir;  if (user_genomedir != NULL) {    genomedir = (char *) CALLOC(strlen(user_genomedir)+1,sizeof(char));    strcpy(genomedir,user_genomedir);  } else if (getenv(""GMAPDB"") != NULL) {         genomedir = (char *) CALLOC(strlen(getenv(""GMAPDB""))+1,sizeof(char));    strcpy(genomedir,getenv(""GMAPDB""));  } else if ((fp = FOPEN_READ_TEXT(""./.gmaprc"")) != NULL) {    genomedir = read_config_file(fp,""GMAPDB"");    fclose(fp);  } else if ((fp = find_homedir_config()) != NULL) {    genomedir = read_config_file(fp,""GMAPDB"");    fclose(fp);  } else {    genomedir = (char *) CALLOC(strlen(GMAPDB)+1,sizeof(char));    strcpy(genomedir,GMAPDB);  }  return genomedir;}",2,"cwe120,cweother"
"register_background(char *pixels, char pal[768]){tif (background) {ttfree(background);ttbackground = NULL;t}tbackground_drawn = 0;tif (!pixels)ttreturn;tassert(pal);tif (scale_up) {ttbackground = malloc(screen_pitch*screen_height);ttassert(background);ttdo_scale2x((unsigned char *)pixels, JNB_WIDTH, JNB_HEIGHT, (unsigned char *)background);t} else {ttbackground = malloc(JNB_WIDTH*JNB_HEIGHT);ttassert(background);ttmemcpy(background, pixels, JNB_WIDTH*JNB_HEIGHT);t}}",2,"cwe119,cwe120"
"replica_execute_ldif2cl_task (Object *r, char *returntext){    int rc, imprc = 0;    Object *rlist [2];    Replica *replica;    char fName [MAXPATHLEN];    char *clDir = NULL;    changelog5Config config;    if (cl5GetState () != CL5_STATE_OPEN)    {        PR_snprintf (returntext, SLAPI_DSE_RETURNTEXT_SIZE, ""changelog is not open"");        slapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name,                        ""replica_execute_ldif2cl_task: %s"", returntext);        rc = LDAP_OPERATIONS_ERROR;        goto bail;    }    rlist[0] = r;    rlist[1] = NULL;         clDir = cl5GetDir ();    if (NULL == clDir) {        rc = LDAP_OPERATIONS_ERROR;        goto bail;    }    replica = (Replica*)object_get_data (r);    if (NULL == replica) {        rc = LDAP_OPERATIONS_ERROR;        goto bail;    }    PR_snprintf (fName, MAXPATHLEN, ""%s/%s.ldif"", clDir, replica_get_name (replica));    rc = cl5Close();    if (rc != CL5_SUCCESS)    {        PR_snprintf (returntext, SLAPI_DSE_RETURNTEXT_SIZE,                     ""failed to close changelog to import changelog data; ""                     ""changelog error - %d"", rc);        slapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name,                        ""replica_execute_ldif2cl_task: %s"", returntext);        rc = LDAP_OPERATIONS_ERROR;        goto bail;    }    slapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name,                    ""Beginning changelog import of replica ""%s"""",                    replica_get_name(replica));    imprc = cl5ImportLDIF (clDir, fName, rlist);    slapi_ch_free_string (&clDir);    if (CL5_SUCCESS == imprc)    {        slapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name,                        ""Finished changelog import of replica ""%s"""",                        replica_get_name(replica));    }    else    {        PR_snprintf (returntext, SLAPI_DSE_RETURNTEXT_SIZE,                     ""Failed changelog import replica %s; ""                     ""changelog error - %d"", replica_get_name(replica), rc);        slapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name,                        ""replica_execute_ldif2cl_task: %s"", returntext);        imprc = LDAP_OPERATIONS_ERROR;    }    changelog5_read_config (&config);         rc = cl5Open (config.dir, &config.dbconfig);    if (CL5_SUCCESS == rc)    {        rc = LDAP_SUCCESS;    }    else    {        slapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name,            ""replica_execute_ldif2cl_task: failed to start changelog at %s"",            config.dir?config.dir:""null config dir"");        rc = LDAP_OPERATIONS_ERROR;    }bail:    changelog5_config_done(&config);         return imprc?imprc:rc;}",2,"cwe119,cwe120"
"complete_test_error (GeditDocument *document,                     GError        *error,                     SaverTestData *data){tg_assert_no_error (error);}",2,"cwe120,cweother"
"dns_default_realm(krb5_context context, krb5_hostrealm_moddata data,                  char ***realms_out){    krb5_error_code ret;    char localhost[MAXDNAME + 1], *realm;    *realms_out = NULL;    if (!_krb5_use_dns_realm(context))        return KRB5_PLUGIN_NO_HANDLE;    ret = krb5int_get_fq_local_hostname(localhost, sizeof(localhost));    if (ret)        return ret;         realm = txt_lookup(context, localhost);    if (realm == NULL)        (void)k5_try_realm_txt_rr(context, ""_kerberos"", NULL, &realm);    if (realm == NULL)        return KRB5_PLUGIN_NO_HANDLE;    ret = k5_make_realmlist(realm, realms_out);    free(realm);    return ret;}",2,"cwe119,cwe120"
"print_cpu (int announce, char* format){tchar model[bsize];tchar vendor[bsize];tchar cache[bsize];tchar buffer[bsize];tunsigned int count;tdouble freq;tint giga = 0;tif (xs_parse_cpu (model, vendor, &freq, cache, &count) != 0)t{tthexchat_printf (ph, ""%stERROR in parse_cpu()"", name);ttreturn HEXCHAT_EAT_ALL;t}tif (freq > 1000)t{ttfreq /= 1000;ttgiga = 1;t}tif (giga)t{ttsnprintf (buffer, bsize, ""%d x %s (%s) @ %.2fGHz w/ %s L2 Cache"", count, model, vendor, freq, cache);t}telset{ttsnprintf (buffer, bsize, ""%d x %s (%s) @ %.0fMHz w/ %s L2 Cache"", count, model, vendor, freq, cache);t}tformat_output (""CPU"", buffer, format);tif (announce)t{tthexchat_commandf (ph, ""SAY %s"", buffer);t}telset{tthexchat_printf (ph, ""%s"", buffer);t}treturn HEXCHAT_EAT_ALL;}",2,"cwe119,cwe120"
"_check_noident (cl_t *cl){tchar p[ID_BUF_SIZE+1];ttp[ID_BUF_SIZE] = 0;ttsnprintf (p, ID_BUF_SIZE-1, ""%s/%s"", cl->pw->pw_dir, NOIDENT_FILE);ttif (access (p, F_OK) == 0) {tt_clreply (cl, ""ERROR"", ""HIDDEN-USER"");ttsyslog (LOG_INFO, ""no reply to %s (query %d, %d) due to %s"",ttttinet_ntoa (cl->raddr.sin_addr),ttttcl->lp, cl->rp, p);ttreturn 0; t}treturn -1;}",3,"cwe119,cwe120,cweother"
"dblayer_delete_database_ex(struct ldbminfo *li, char *instance, char *cldir){    dblayer_private *priv = NULL;    Object *inst_obj;    PRDir *dirhandle = NULL;    PRDirEntry *direntry = NULL;    PRFileInfo64 fileinfo;    char filename[MAXPATHLEN];    char *log_dir;    int ret;    PR_ASSERT(NULL != li);    priv = (dblayer_private *)li->li_dblayer_private;    PR_ASSERT(NULL != priv);         for (inst_obj = objset_first_obj(li->li_instance_set); inst_obj;        inst_obj = objset_next_obj(li->li_instance_set, inst_obj)) {        ldbm_instance *inst = (ldbm_instance *)object_get_data(inst_obj);        if (inst->inst_be->be_instance_info != NULL) {tttif ((NULL != instance) && (strcasecmp(inst->inst_name,instance) != 0)) ttt{ttttLDAPDebug(LDAP_DEBUG_ANY,ttttt""dblayer_delete_database: skipping instance %s"",inst->inst_name , 0, 0);tttt} else ttt{ttttif (NULL == instance)tttt{tttttret = _dblayer_delete_instance_dir(inst, 0  );tttt} else {tttttret = _dblayer_delete_instance_dir(inst, 1  );tttt}ttttif (ret != 0)tttt{tttttLDAPDebug(LDAP_DEBUG_ANY,ttttt""dblayer_delete_database: WARNING _dblayer_delete_instance_dir failed (%d)"", ret, 0, 0);tttttreturn ret;tttt}tttt}        }    }         if (cldir) {        ret = _dblayer_delete_aux_dir(li, cldir);        if (ret) {            LDAPDebug1Arg(LDAP_DEBUG_ANY,                          ""dblayer_delete_database: failed to deelete ""%s"""",                          chdir);            return ret;        }    }         dirhandle = PR_OpenDir(priv->dblayer_home_directory);    if (! dirhandle)    {        LDAPDebug(LDAP_DEBUG_ANY, ""PR_OpenDir (%s) failed (%d): %s"",         priv->dblayer_home_directory,        PR_GetError(),slapd_pr_strerror(PR_GetError()));        return -1;    }    while (NULL != (direntry = PR_ReadDir(dirhandle, PR_SKIP_DOT |                                          PR_SKIP_DOT_DOT))) {ttint rval_tmp = 0;        if (! direntry->name)            break;ttPR_snprintf(filename, MAXPATHLEN, ""%s/%s"", priv->dblayer_home_directory, tttdirentry->name);tt         rval_tmp = PR_GetFileInfo64(filename, &fileinfo);        if (rval_tmp == PR_SUCCESS && fileinfo.type != PR_FILE_DIRECTORY)tt{ttt tttif (!dblayer_is_logfilename(direntry->name))ttt{       ttttPR_Delete(filename);ttt}tt}    }    PR_CloseDir(dirhandle);         if ((NULL != priv->dblayer_log_directory) &&        (0 != strlen(priv->dblayer_log_directory) ))     {        log_dir = priv->dblayer_log_directory;    }    else    {        log_dir = dblayer_get_home_dir(li, NULL);    }tif (instance == NULL && log_dir && *log_dir)t{ttret = dblayer_delete_transaction_logs(log_dir);ttif(ret) {tt  LDAPDebug(LDAP_DEBUG_ANY,tt  ""dblayer_delete_database: dblayer_delete_transaction_logs failed (%d)"",tt  ret, 0, 0);tt  return -1;tt}t}    return 0;}",2,"cwe119,cwe120"
"SwitchBackgroundMusicTo(char *filename_raw_parameter){tstatic char PreviousFileParameter[5000] = ""NONE_AT_ALL"";tif (!sound_on)ttreturn;t t t t t tif (!strcmp(PreviousFileParameter, filename_raw_parameter)) {ttreturn;t} else {ttstrcpy(PreviousFileParameter, filename_raw_parameter);t}tstrcpy(NewMusicTargetFileName, filename_raw_parameter);t t t t tif (BackgroundMusicStateMachineState == NOTHING_PLAYING_AT_ALL) {ttLoadAndFadeInBackgroundMusic();ttBackgroundMusicStateMachineState = FADING_IN;t} else {ttMix_FadeOutMusic(2000);ttBackgroundMusicStateMachineState = FADING_OUT;tt tt tt tt ttMix_HookMusicFinished(LoadAndFadeInBackgroundMusic);t}}",2,"cwe119,cwe120"
"eina_log_print_prefix_threads_color_file_NOfunc(FILE *fp,                                                const Eina_Log_Domain *d,                                                Eina_Log_Level level,                                                const char *file,                                                const char *fnc __UNUSED__,                                                int line){   Thread cur;   DECLARE_LEVEL_NAME_COLOR(level);   cur = SELF();   if (IS_OTHER(cur))     {# ifdef _WIN32        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),                                color);        fprintf(fp, ""%s"", name);        SetConsoleTextAttribute(GetStdHandle(                                   STD_OUTPUT_HANDLE),                                FOREGROUND_RED | FOREGROUND_GREEN |                                FOREGROUND_BLUE);        fprintf(fp, "":"");        SetConsoleTextAttribute(GetStdHandle(                                   STD_OUTPUT_HANDLE),                                eina_log_win32_color_get(d->domain_str));        fprintf(fp, ""%s[T:"", d->name);        SetConsoleTextAttribute(GetStdHandle(                                   STD_OUTPUT_HANDLE),                                FOREGROUND_RED | FOREGROUND_GREEN |                                FOREGROUND_BLUE);        fprintf(fp, ""[T:"");        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),                                FOREGROUND_GREEN | FOREGROUND_BLUE);        fprintf(fp, ""%lu"", (unsigned long)cur);        SetConsoleTextAttribute(GetStdHandle(                                   STD_OUTPUT_HANDLE),                                FOREGROUND_RED | FOREGROUND_GREEN |                                FOREGROUND_BLUE);        fprintf(fp, ""] %s:%d "", file, line);# else        fprintf(fp, ""%s%s<%u>"" EINA_COLOR_RESET "":%s[T:""                EINA_COLOR_ORANGE ""%lu"" EINA_COLOR_RESET ""] %s:%d "",                color, name, eina_log_pid_get(), d->domain_str,                 (unsigned long)cur, file, line);# endif        return;     }# ifdef _WIN32   eina_log_print_prefix_NOthreads_color_file_NOfunc(fp,                                                     d,                                                     level,                                                     file,                                                     fnc,                                                     line);# else        fprintf(fp, ""%s%s"" EINA_COLOR_RESET "":%s %s:%d "",           color, name, d->domain_str, file, line);# endif}",2,"cwe119,cwe120"
"_read_offset(struct sst *sst, const char *key){tint fd;tint blk_sizes;tint b_count;tuint64_t off = 0UL;tchar file[SST_FLEN];tstruct sst_block *blks;tmemset(file, 0, SST_FLEN);tsnprintf(file, SST_FLEN, ""%s/%s"", sst->basedir, sst->name);tfd = open(file, O_RDWR, 0644);tblk_sizes = lseek(fd, 0, SEEK_END);tb_count = blk_sizes / sizeof(struct sst_block);t tblks= mmap(0, blk_sizes, PROT_READ, MAP_SHARED, fd, 0);tif (blks == MAP_FAILED) {t    perror(""Error:read_offset, mmapping the file"");ttgoto out;t}tsize_t left = 0, right = b_count, i = 0;twhile (left < right) {tti = (right -left) / 2 +left;ttint cmp = strcmp(key, blks[i].key);ttif (cmp == 0) {tttif (blks[i].opt == ADD)ttttoff = blks[i].offset;ttttbreak ;tt}ttif (cmp < 0)tttright = i;ttelsetttleft = i + 1;t}ttif (munmap(blks, blk_sizes) == -1)ttperror(""Error:read_offset, un-mmapping the file"");out:tclose(fd);treturn off;}",3,"cwe119,cwe120,cweother"
"igb_validate_nvm_checksum(struct e1000_hw *hw){ts32 ret_val = 0;tu16 checksum = 0;tu16 i, nvm_data;tfor (i = 0; i < (NVM_CHECKSUM_REG + 1); i++) {ttret_val = hw->nvm.ops.read(hw, i, 1, &nvm_data);ttif (ret_val) {ttthw_dbg(""NVM Read Error"");tttgoto out;tt}ttchecksum += nvm_data;t}tif (checksum != (u16) NVM_SUM) {tthw_dbg(""NVM Checksum Invalid"");ttret_val = -E1000_ERR_NVM;ttgoto out;t}out:treturn ret_val;}",2,"cwe120,cweother"
"username_checkout (const char *section_name,                   struct config_keyvalue *kv,                   void *arg){  bmc_config_state_data_t *state_data;  fiid_obj_t obj_cmd_rs = NULL;  config_err_t rv = CONFIG_ERR_FATAL_ERROR;  uint8_t userid;     char username[IPMI_MAX_USER_NAME_LENGTH*2+1];  assert (section_name);  assert (kv);  assert (arg);    state_data = (bmc_config_state_data_t *)arg;  userid = atoi (section_name + strlen (""User""));  if (!(obj_cmd_rs = fiid_obj_create (tmpl_cmd_get_user_name_rs)))    {      pstdout_fprintf (state_data->pstate,                       stderr,                       ""fiid_obj_create: %s"",                       strerror (errno));      goto cleanup;    }     memset (username, '0', IPMI_MAX_USER_NAME_LENGTH*2+1);  if (ipmi_cmd_get_user_name (state_data->ipmi_ctx,                              userid,                              obj_cmd_rs) < 0)    {      config_err_t ret;      if (state_data->prog_data->args->config_args.common.debug)        pstdout_fprintf (state_data->pstate,                         stderr,                         ""ipmi_cmd_get_user_name: %s"",                         ipmi_ctx_errormsg (state_data->ipmi_ctx));             if (ipmi_ctx_errnum (state_data->ipmi_ctx) == IPMI_ERR_BAD_COMPLETION_CODE          && (ipmi_check_completion_code (obj_cmd_rs,                                          IPMI_COMP_CODE_INVALID_DATA_FIELD_IN_REQUEST) == 1))        {          strcpy (username, CONFIG_USERNAME_NOT_SET_YET_STR);          goto got_data;        }      if (config_is_non_fatal_error (state_data->ipmi_ctx,                                     obj_cmd_rs,                                     &ret))        rv = ret;      goto cleanup;    }     if (userid == 1)    strcpy (username, ""NULL"");  else    {      if (fiid_obj_get_data (obj_cmd_rs,                             ""user_name"",                             username,                             IPMI_MAX_USER_NAME_LENGTH) < 0)        {          pstdout_fprintf (state_data->pstate,                           stderr,                           ""fiid_obj_get_data: 'user_name': %s"",                           fiid_obj_errormsg (obj_cmd_rs));          goto cleanup;        }    } got_data:     if (state_data->prog_data->args->config_args.action == CONFIG_ACTION_DIFF      && userid == 1      && same (kv->value_input, ""anonymous""))    {      if (config_section_update_keyvalue_output (state_data->pstate,                                                 kv,                                                 ""anonymous"") < 0)        return (CONFIG_ERR_FATAL_ERROR);    }  else    {      if (config_section_update_keyvalue_output (state_data->pstate,                                                 kv,                                                 username) < 0)        return (CONFIG_ERR_FATAL_ERROR);    }  rv = CONFIG_ERR_SUCCESS; cleanup:  fiid_obj_destroy (obj_cmd_rs);  return (rv);}",3,"cwe119,cwe120,cweother"
"configerrfile(void *opt, char *cmd, char *arg1, char *arg2, int rc) {     FILE **err = (FILE **)opt;  FILE *tmp;  if (rc == 0) {    shortwarn(cmd, arg1, rc);    return;  }  if (rc > 1)    longwarn(cmd, arg1, arg2, rc);  if (strcaseeq(arg1, ""stderr"")) {    if (*err != stderr) {      debug('F', ""Opening stderr as new ERRFILE"");      warn('E', TRUE, ""Redirecting future diagnostic messages to stderr"");      fclose(*err);      *err = stderr;    }  }  else {    arg1 = buildfilename(ERRDIR, """", arg1);    if ((tmp = FOPENW(arg1)) == NULL)      warn('F', TRUE, ""Failed to open ERRFILE %s: ignoring it"", arg1);    else {      debug('F', ""Opening %s as new ERRFILE"", arg1);      warn('E', TRUE, ""Redirecting future diagnostic messages to %s"", arg1);      if (*err != stderr)tfclose(*err);      *err = tmp;      setvbuf(*err, NULL, ERRBUFMODE, BUFSIZ);    }  }}",3,"cwe119,cwe120,cweother"
"andb_add(bandb_type type, struct Client *source_p, const char *mask1,t  const char *mask2, const char *reason, const char *oper_reason, int perm){tstatic char buf[BUFSIZE];trb_snprintf(buf, sizeof(buf), ""%c %s "", bandb_add_letter[type], mask1);tif(!EmptyString(mask2))ttrb_snprintf_append(buf, sizeof(buf), ""%s "", mask2);trb_snprintf_append(buf, sizeof(buf), ""%s %ld %d :%s"",ttt   get_oper_name(source_p), (long int)rb_current_time(), perm, reason);tif(!EmptyString(oper_reason))ttrb_snprintf_append(buf, sizeof(buf), ""|%s"", oper_reason);trb_helper_write(bandb_helper, ""%s"", buf);}",2,"cwe119,cwe120"
"compile_int_case_units (NODE_T * p, FILE_T out, NODE_T * sym, int k, int * count, int compose_fun){  if (p == NO_NODE) {    return (A68_FALSE);  } else {    if (IS (p, UNIT)) {      if (k == * count) {        if (compose_fun == A68_MAKE_FUNCTION) {          indentf (out, snprintf (line, SNPRINTF_SIZE, ""case %d: {"", k));          indentation ++;          indentf (out, snprintf (line, SNPRINTF_SIZE, ""OPEN_STATIC_FRAME (_N_ (%d));"", NUMBER (sym)));          CODE_EXECUTE (p);          inline_comment_source (p, out);          undent (out, NEWLINE_STRING);          indent (out, ""CLOSE_FRAME;"");          indent (out, ""break;"");          indentation --;          indent (out, ""}"");        } else if (compose_fun == A68_MAKE_OTHERS) {          if (compile_unit (p, out, A68_MAKE_FUNCTION) == NO_TEXT) {            if (IS (p, UNIT) && IS (SUB (p), TERTIARY)) {              compile_units (SUB_SUB (p), out);            } else {              compile_units (SUB (p), out);            }          } else if (SUB (p) != NO_NODE && GINFO (SUB (p)) != NO_GINFO && COMPILE_NODE (GINFO (SUB (p))) > 0) {            COMPILE_NODE (GINFO (p)) = COMPILE_NODE (GINFO (SUB (p)));            COMPILE_NAME (GINFO (p)) = COMPILE_NAME (GINFO (SUB (p)));          }        }        return (A68_TRUE);      } else {        (* count)++;        return (A68_FALSE);      }    } else {      if (compile_int_case_units (SUB (p), out, sym, k, count, compose_fun)) {        return (A68_TRUE);      } else {        return (compile_int_case_units (NEXT (p), out, sym, k, count, compose_fun));      }    }  }}",2,"cwe119,cwe120"
"write_update(RLI *rli){  globus_size_tttnb;  BUFFERttb;  charttterrbuf[MAXERRMSG];  charttterrbuf2[MAXERRMSG];  inttttrc;  globus_result_ttr;  inttttimmediateretry = 1;  if (loglevel > 1)    logit(LOG_DEBUG, ""write_update: %s %d pending"", rli->url, rli->idx);  if (rli->idx) {    rli->iov[rli->idx].iov_base = """";    rli->iov[rli->idx++].iov_len = 1;   retry:    if (!(rli->flags & FR_OPEN)) {      if (rli->flags & FR_EXITING) {tflush_pending(rli, 0);treturn;      }      rli->h = NULL;      if ((r = globus_rls_client_connect(rli->url,&rli->h)) != GLOBUS_SUCCESS){tglobus_rls_client_error_info(r, NULL, errbuf, MAXERRMSG, GLOBUS_FALSE);tlogit(LOG_WARNING, ""write_update(%s): %s"", rli->url, errbuf);tif (rli->flags & FR_EXITING)t t  flush_pending(rli, 0);        else {t  rli->idx--;t  rli->retrytime = time(0) + update_retry;t}treturn;      }      globus_mutex_lock(&rli->mtx);      rli->flags |= FR_OPEN;      globus_mutex_unlock(&rli->mtx);      immediateretry = 0;    }    if ((rc = rrpc_writev(&rli->h->handle, rli->iov, rli->idx,ttt  &nb, errbuf)) == GLOBUS_RLS_SUCCESS) {      rc = rrpc_getresult(rli->h, &b, errbuf);#ifdef COUNTUPDATE      updatebytes += nb;#endif    }         if (rc == GLOBUS_RLS_DBERROR || rc == GLOBUS_RLS_GLOBUSERR ||        rc == GLOBUS_RLS_TIMEOUT || rc == GLOBUS_RLS_INVHANDLE) {      globus_rls_client_close(rli->h);      globus_mutex_lock(&rli->mtx);      rli->flags &= ~FR_OPEN;      globus_mutex_unlock(&rli->mtx);      logit(LOG_DEBUG, ""write_update(%s): %s: retrying"", rli->url,t    globus_rls_errmsg(rc, errbuf, errbuf2, MAXERRMSG));      if (immediateretry)tgoto retry;      if (rli->flags & FR_EXITING)t tflush_pending(rli, 0);      else {trli->idx--;trli->retrytime = time(0) + update_retry;      }      return;    }    if (rc != GLOBUS_RLS_SUCCESS) {      logit(LOG_WARNING, ""write_update(%s): %s"", rli->url,t    globus_rls_errmsg(rc, errbuf, errbuf2, MAXERRMSG));      if (rli->flags & FR_SYNCED) {tglobus_mutex_lock(&rli->mtx);trli->flags &= ~FR_SYNCED;tglobus_mutex_unlock(&rli->mtx);      }          }  }  flush_pending(rli, 0);}",2,"cwe119,cwe120"
"cram_write_container(cram_fd *fd, cram_container *c) {    char buf_a[1024], *buf = buf_a, *cp;    int i;    if (50 + c->num_landmarks * 5 >= 1024)tbuf = malloc(50 + c->num_landmarks * 5);    cp = buf;    if (fd->version == CRAM_1_VERS) {tcp += itf8_put(cp, c->length);    } else {t*(int32_t *)cp = le_int4(c->length);tcp += 4;    }    if (c->multi_seq) {tcp += itf8_put(cp, -2);tcp += itf8_put(cp, 0);tcp += itf8_put(cp, 0);    } else {tcp += itf8_put(cp, c->ref_seq_id);tcp += itf8_put(cp, c->ref_seq_start);tcp += itf8_put(cp, c->ref_seq_span);    }    cp += itf8_put(cp, c->num_records);    if (fd->version != CRAM_1_VERS) {tcp += itf8_put(cp, c->record_counter);tcp += ltf8_put(cp, c->num_bases);    }    cp += itf8_put(cp, c->num_blocks);    cp += itf8_put(cp, c->num_landmarks);    for (i = 0; i < c->num_landmarks; i++)tcp += itf8_put(cp, c->landmark[i]);    if (cp-buf != hwrite(fd->fp, buf, cp-buf)) {tif (buf != buf_a)t    free(buf);treturn -1;    }    if (buf != buf_a)tfree(buf);    return 0;}",2,"cwe119,cwe120"
"config_lookup(ares_channel channel, const char *str,                         const char *bindch, const char *filech){  char lookups[3], *l;  const char *vqualifier p;     l = lookups;  p = str;  while (*p)    {      if ((*p == *bindch || *p == *filech) && l < lookups + 2) {        if (*p == *bindch) *l++ = 'b';        else *l++ = 'f';      }      while (*p && !ISSPACE(*p) && (*p != ','))        p++;      while (*p && (ISSPACE(*p) || (*p == ',')))        p++;    }  *l = '0';  channel->lookups = strdup(lookups);  return (channel->lookups) ? ARES_SUCCESS : ARES_ENOMEM;}",2,"cwe119,cwe120"
"logfiles_open(void){#ifdef LOG_SERVER_CHANNELStintti;tSChant*shptr;tchartfname[BUFSIZE];tfor (i = SCH_MAX - 1, shptr = svchans + i; i >= 0; i--, shptr--)t{ttif (shptr->fd == -2)tt{ttt tttcontinue;tt}ttsprintf(fname, ""%s.%s"", FNAME_SCH_PREFIX, shptr->svc_chname+1);ttshptr->fd = open(fname, O_WRONLY|O_APPEND|O_NDELAY#ifdef LOGFILES_ALWAYS_CREATEttt|O_CREAT, S_IRUSR|S_IWUSR#endifttt);tt ttif (shptr->fd >= 0)tt{tttlocal[shptr->fd] = NULL;tt}t}#endif#ifdef  FNAME_USERLOGtuserlog = open(FNAME_USERLOG, O_WRONLY|O_APPEND|O_NDELAY# ifdeftLOGFILES_ALWAYS_CREATEttt|O_CREAT, S_IRUSR|S_IWUSR# endifttt);t tif (userlog >= 0)t{ttlocal[userlog] = NULL;t}#elsetuserlog = -1;#endif#ifdef  FNAME_CONNLOGtconnlog = open(FNAME_CONNLOG, O_WRONLY|O_APPEND|O_NDELAY# ifdeftLOGFILES_ALWAYS_CREATEtt|O_CREAT, S_IRUSR|S_IWUSR# endifttt);tif (connlog >= 0)t{ttlocal[connlog] = NULL;t}#elsetconnlog = -1;#endif}",3,"cwe119,cwe120,cweother"
"amdlibLoadRawFrames(const char      *filename,                                     amdlibRAW_DATA  *rawData,                                     int             firstFrame,                                     int             nbFrames,                                     amdlibERROR_MSG errMsg){    char            fitsioMsg[256];    fitsfile        *filePtr;    int             status = 0;    int i;    amdlibLogTrace(""amdlibLoadRawFrames()"");             if (amdlibLoadRawDataHdr(filename, rawData, errMsg) != amdlibSUCCESS)    {        return amdlibFAILURE;    }         if (fits_open_file(&filePtr, filename, READONLY, &status) != 0)    {        amdlibReturnFitsError(filename);    }         if (nbFrames == amdlibALL_FRAMES)    {        nbFrames = rawData->nbFrames - firstFrame + 1;    }         if (amdlibReadRegionData(filePtr, rawData->region,                            rawData->nbRegions,                            firstFrame, nbFrames,                            errMsg) != amdlibSUCCESS)    {        fits_close_file(filePtr, &status);        return amdlibFAILURE;    }         rawData->nbFrames = nbFrames;         if (amdlibReadArrayGeometry(filePtr, &rawData->arrayGeometry,                                errMsg) != amdlibSUCCESS)    {        fits_close_file(filePtr, &status);        return amdlibFAILURE;    }             if (amdlibReadTimeTag(filePtr, rawData,                          firstFrame, nbFrames,                          errMsg) != amdlibSUCCESS)    {        fits_close_file(filePtr, &status);        return amdlibFAILURE;    }             rawData->dataLoaded = amdlibTRUE;    rawData->dataCalibrated = amdlibFALSE;         if (fits_close_file(filePtr, &status) != 0)    {        amdlibReturnFitsError(filename);    }    if (amdlibAllocateRegions(&rawData->variance,                               rawData->nbRegions) != amdlibSUCCESS)    {        amdlibSetErrMsg(""Could not allocate memory for variance map"");        return amdlibFAILURE;    }         for (i = 0; i < rawData->nbRegions; i++)    {        int regionSize;                 memcpy(&rawData->variance[i], &rawData->region[i],                sizeof(amdlibREGION));                 regionSize = rawData->region[i].dimAxis[0] *             rawData->region[i].dimAxis[1] *             rawData->region[i].dimAxis[2];        rawData->variance[i].data  = calloc(regionSize, sizeof(*(rawData->variance[i].data)));        if (rawData->variance[i].data == NULL)        {            amdlibSetErrMsg(""Could not allocate memory for data of variance #%d"",                            i);            return amdlibFAILURE;        }    }        return amdlibSUCCESS;}",2,"cwe119,cwe120"
"get_pka_info (const char *address, unsigned char *fpr){  union    {      signed char p[PACKETSZ];      HEADER h;    } answer;  int anslen;  int qdcount, ancount;  int rc;  unsigned char *p, *pend;  const char *domain;  char *name;  domain = strrchr (address, '@');  if (!domain || domain == address || !domain[1])    return NULL;    name = malloc (strlen (address) + 5 + 1);  memcpy (name, address, domain - address);  strcpy (stpcpy (name + (domain-address), ""._pka.""), domain+1);  anslen = res_query (name, C_IN, T_TXT, answer.p, PACKETSZ);  xfree (name);  if (anslen < sizeof(HEADER))    return NULL;    if ( (rc=answer.h.rcode) != NOERROR )    return NULL;       if (anslen > PACKETSZ)    return NULL;    qdcount = ntohs (answer.h.qdcount);  ancount = ntohs (answer.h.ancount);  if (!ancount)    return NULL;    p = answer.p + sizeof (HEADER);  pend = answer.p + anslen;    while (qdcount-- && p < pend)    {      rc = dn_skipname (p, pend);      if (rc == -1)        return NULL;      p += rc + QFIXEDSZ;    }  if (ancount > 1)    return NULL;    while (ancount-- && p <= pend)    {      unsigned int type, class, txtlen, n;      char *buffer, *bufp;      rc = dn_skipname (p, pend);      if (rc == -1)        return NULL;      p += rc;      if (p >= pend - 10)        return NULL;        type = *p++ << 8;      type |= *p++;      class = *p++ << 8;      class |= *p++;      p += 4;      txtlen = *p++ << 8;      txtlen |= *p++;      if (type != T_TXT || class != C_IN)        return NULL;        buffer = bufp = xmalloc (txtlen + 1);      while (txtlen && p < pend)        {          for (n = *p++, txtlen--; txtlen && n && p < pend; txtlen--, n--)            *bufp++ = *p++;        }      *bufp = 0;      if (parse_txt_record (buffer, fpr))        {          xfree (buffer);          return NULL;          }      return buffer;    }  return NULL;}",2,"cwe119,cwe120"
"do_debug (const char *subcmd, char *const *argv){  size_t argc, i;  for (i = argc = 0; argv[i] != NULL; ++i)    argc++;  for (i = 0; cmds[i].cmd != NULL; ++i) {    if (STRCASEEQ (subcmd, cmds[i].cmd))      return cmds[i].f (subcmd, argc, argv);  }  reply_with_error (""use 'debug help 0' to list the supported commands"");  return NULL;}",3,"cwe119,cwe120,cweother"
"g_stat(Char *fn, struct stat *sb, glob_t *pglob){tchar buf[MaxPathLen];tg_Ctoc(fn, buf);tif (pglob->gl_flags & GLOB_ALTDIRFUNC)ttreturn((*pglob->gl_stat)(buf, sb));treturn(stat(buf, sb));}",2,"cwe119,cwe120"
"update_city_activities(struct player *pplayer){  char buf[4 * MAX_LEN_NAME];  int n, gold;  fc_assert(NULL != pplayer);  fc_assert(NULL != pplayer->cities);  n = city_list_size(pplayer->cities);  gold = pplayer->economic.gold;  pplayer->bulbs_last_turn = 0;  if (n > 0) {    struct city *cities[n];    int i = 0, r;    city_list_iterate(pplayer->cities, pcity) {      cities[i++] = pcity;    } city_list_iterate_end;              while (i > 0) {      r = fc_rand(i);             city_units_upkeep(cities[r]);      update_city_activity(cities[r]);      cities[r] = cities[--i];    }    if (pplayer->economic.gold < 0 && game.info.gold_upkeep_style > 0) {      switch (game.info.gold_upkeep_style) {        case 2:                     player_balance_treasury_units_and_buildings(pplayer);          break;        case 1:                     player_balance_treasury_units(pplayer);          break;        default:                     break;      }    }         fc_assert(pplayer->economic.gold >= 0);  }     if (gold - (gold - pplayer->economic.gold) * 3 < 0) {    notify_player(pplayer, NULL, E_LOW_ON_FUNDS, ftc_server,                  _(""WARNING, we're LOW on FUNDS %s.""),                  ruler_title_for_player(pplayer, buf, sizeof(buf)));  }#if 0     if (pplayer->got_tech && pplayer->research->researched > 0) {    pplayer->research->researched = 0;  }#endif  city_refresh_queue_processing();}",2,"cwe119,cwe120"
"csr_write_varid_valueless(int dd, uint16_t seqnum, uint16_t varid){tunsigned char cmd[] = { 0x02, 0x00, 0x09, 0x00,ttttseqnum & 0xff, seqnum >> 8, varid & 0xff, varid >> 8, 0x00, 0x00,tttt0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };tunsigned char cp[254], rp[254];tstruct hci_request rq;tmemset(&cp, 0, sizeof(cp));tcp[0] = 0xc2;tmemcpy(cp + 1, cmd, sizeof(cmd));tswitch (varid) {tcase CSR_VARID_COLD_RESET:tcase CSR_VARID_WARM_RESET:tcase CSR_VARID_COLD_HALT:tcase CSR_VARID_WARM_HALT:ttreturn hci_send_cmd(dd, OGF_VENDOR_CMD, 0x00, sizeof(cmd) + 1, cp);t}tmemset(&rq, 0, sizeof(rq));trq.ogf    = OGF_VENDOR_CMD;trq.ocf    = 0x00;trq.event  = EVT_VENDOR;trq.cparam = cp;trq.clen   = sizeof(cmd) + 1;trq.rparam = rp;trq.rlen   = sizeof(rp);tif (hci_send_req(dd, &rq, 2000) < 0)ttreturn -1;tif (rp[0] != 0xc2) {tterrno = EIO;ttreturn -1;t}tif ((rp[9] + (rp[10] << 8)) != 0) {tterrno = ENXIO;ttreturn -1;t}treturn 0;}",2,"cwe119,cwe120"
"send_to_dataplane(char *buff, int length, int shortcut_fd){        char tmp[MAX_PACKET_LENGTH + sizeof(struct llc_snap_hdr)];tint bytes_written;        char *pos = tmp;tmemcpy(pos, &llc_snap_mpoa_ctrl, sizeof(struct llc_snap_hdr));tpos += sizeof(struct llc_snap_hdr);tmemcpy(pos, buff, length);tlength += sizeof(struct llc_snap_hdr);         bytes_written = write(shortcut_fd, tmp, length);twhile(bytes_written != 0){ttbytes_written = write(shortcut_fd, tmp+bytes_written, length-bytes_written);ttif( bytes_written < 0 ){tttprintf(""mpcd: io.c: write to dataplane failed"");tttreturn -1;tt}t}treturn 1;}",2,"cwe119,cwe120"
"playout_moggy_permit(struct playout_policy *p, struct board *b, struct move *m){tstruct moggy_policy *pp = p->data;t tif (fast_random(100) >= pp->selfatarirate) {ttif (PLDEBUGL(5))tttfprintf(stderr, ""skipping sar test"");ttreturn true;t}tbool selfatari = is_bad_selfatari(b, m->color, m->coord);tif (selfatari) {ttif (PLDEBUGL(5))tttfprintf(stderr, ""__ Prohibiting self-atari %s %s"",ttttstone2str(m->color), coord2sstr(m->coord, b));ttif (pp->selfatari_other) {ttt tttcoord_t c = selfatari_cousin(b, m->color, m->coord, NULL);tttif (is_pass(c)) return false;tttif (PLDEBUGL(5))ttttfprintf(stderr, ""___ Redirecting to other lib %s"",tttttcoord2sstr(c, b));tttm->coord = c;tttreturn true;tt}ttreturn false;t}treturn true;}",2,"cwe120,cweother"
"final(const char *final_pack_name, const char *curr_pack_name,tt  const char *final_index_name, const char *curr_index_name,tt  const char *keep_name, const char *keep_msg,tt  unsigned char *sha1){tconst char *report = ""pack"";tchar name[PATH_MAX];tint err;tif (!from_stdin) {ttclose(input_fd);t} else {ttfsync_or_die(output_fd, curr_pack_name);tterr = close(output_fd);ttif (err)tttdie(""error while closing pack file: %s"", strerror(errno));t}tif (keep_msg) {ttint keep_fd, keep_msg_len = strlen(keep_msg);ttif (!keep_name) {tttsnprintf(name, sizeof(name), ""%s/pack/pack-%s.keep"",tttt get_object_directory(), sha1_to_hex(sha1));tttkeep_name = name;tt}ttkeep_fd = open(keep_name, O_RDWR|O_CREAT|O_EXCL, 0600);ttif (keep_fd < 0) {tttif (errno != EEXIST)ttttdie(""cannot write keep file"");tt} else {tttif (keep_msg_len > 0) {ttttwrite_or_die(keep_fd, keep_msg, keep_msg_len);ttttwrite_or_die(keep_fd, """", 1);ttt}tttif (close(keep_fd) != 0)ttttdie(""cannot write keep file"");tttreport = ""keep"";tt}t}tif (final_pack_name != curr_pack_name) {ttif (!final_pack_name) {tttsnprintf(name, sizeof(name), ""%s/pack/pack-%s.pack"",tttt get_object_directory(), sha1_to_hex(sha1));tttfinal_pack_name = name;tt}ttif (move_temp_to_file(curr_pack_name, final_pack_name))tttdie(""cannot store pack file"");t}tif (from_stdin)ttchmod(final_pack_name, 0444);tif (final_index_name != curr_index_name) {ttif (!final_index_name) {tttsnprintf(name, sizeof(name), ""%s/pack/pack-%s.idx"",tttt get_object_directory(), sha1_to_hex(sha1));tttfinal_index_name = name;tt}ttif (move_temp_to_file(curr_index_name, final_index_name))tttdie(""cannot store index file"");t}tchmod(final_index_name, 0444);tif (!from_stdin) {ttprintf(""%s"", sha1_to_hex(sha1));t} else {ttchar buf[48];ttint len = snprintf(buf, sizeof(buf), ""%st%s"",tttt   report, sha1_to_hex(sha1));ttwrite_or_die(1, buf, len);tt ttwhile (input_len) {ttterr = xwrite(1, input_buffer + input_offset, input_len);tttif (err <= 0)ttttbreak;tttinput_len -= err;tttinput_offset += err;tt}t}}",3,"cwe119,cwe120,cweother"
"time_parse_monthdays(const char *arg){tchar day[3], *err = NULL;tuint32_t ret = 0;tunsigned int i;twhile (my_strseg(day, sizeof(day), &arg, ',') != NULL) {tti = strtoul(day, &err, 0);ttif ((*err != ',' && *err != '0') || i > 31)tttxtables_error(PARAMETER_PROBLEM,ttt           ""%s is not a valid day for --monthdays"", day);ttret |= 1 << i;t}treturn ret;}",2,"cwe119,cwe120"
"encap_check_target(char *encap_source, char *tgt_path,tt   encap_target_info_t *tgtinfo){tstruct stat s1, s2;tint i, j;tchar buf[MAXPATHLEN];tmemset(tgtinfo, 0, sizeof(encap_target_info_t));t tif (lstat(tgt_path, &s1) == 0)ttBIT_SET(tgtinfo->tgt_flags, TGT_EXISTS);telse if (errno == ENOENT)ttreturn 0;telsettreturn -1;t tif (!S_ISLNK(s1.st_mode))t{tt ttif (S_ISDIR(s1.st_mode))tttBIT_SET(tgtinfo->tgt_flags, TGT_ISDIR);ttreturn 0;t}tBIT_SET(tgtinfo->tgt_flags, TGT_ISLNK);t tif (stat(tgt_path, &s2) == 0)t{ttBIT_SET(tgtinfo->tgt_flags, TGT_DEST_EXISTS);tt ttif (S_ISDIR(s2.st_mode))tttBIT_SET(tgtinfo->tgt_flags, TGT_DEST_ISDIR);t}telse if (errno != ENOENT)ttreturn -1;t tget_link_dest(tgt_path, tgtinfo->tgt_link_existing,tt      sizeof(tgtinfo->tgt_link_existing));ti = strlen(encap_source);tif (strncmp(encap_source, tgtinfo->tgt_link_existing, i) != 0 ||t    tgtinfo->tgt_link_existing[i] != '/')ttreturn 0;tBIT_SET(tgtinfo->tgt_flags, TGT_DEST_ENCAP_SRC);t tj = strcspn(tgtinfo->tgt_link_existing + i + 1, ""/"");tstrlcpy(buf, tgtinfo->tgt_link_existing,tt(size_t)(j + i + 2) < sizeof(buf) ? (j + i + 2) : sizeof(buf));tstrlcpy(tgtinfo->tgt_link_existing_pkg, basename(buf),ttsizeof(tgtinfo->tgt_link_existing_pkg));tstrlcpy(tgtinfo->tgt_link_existing_pkgdir_relative,tttgtinfo->tgt_link_existing + j + i + 2,ttsizeof(tgtinfo->tgt_link_existing_pkgdir_relative));t tif (stat(buf, &s1) == 0)ttBIT_SET(tgtinfo->tgt_flags, TGT_DEST_PKGDIR_EXISTS);telse if (errno != ENOENT)ttreturn -1;treturn 0;}",2,"cwe119,cwe120"
"change_runlevel(const char *level){tchar *argv[3];tint pid;tpid = fork();tif (pid < 0) {ttsyslog(LOG_ALERT, tt       ""audisp-remote failed to fork switching runlevels"");ttreturn;t}tif (pid)t ttreturn;t targv[0] = (char *)INIT_PGM;targv[1] = (char *)level;targv[2] = NULL;texecve(INIT_PGM, argv, NULL);tsyslog(LOG_ALERT, ""audisp-remote failed to exec %s"", INIT_PGM);texit(1);}",2,"cwe119,cwe120"
"zRead(int *bzerr, BZStream* stream, unsigned char* out, size_t len) {tsize_t toRead;tsize_t haveRead;tsize_t total;tttotal = len;tt*bzerr = BZ_OK;ttwhile(total > 0) {ttif(!stream->ended) {tttmemmove(stream->inBuffer, stream->bz2.next_in, stream->bz2.avail_in);tttstream->file->seek(stream->file, stream->offset);ttthaveRead = stream->file->read(stream->file, stream->inBuffer + stream->bz2.avail_in, stream->bufferLen - stream->bz2.avail_in);tttstream->offset += haveRead;tttstream->bz2.avail_in += haveRead;tttstream->bz2.next_in = (char*) stream->inBuffer;tttttt*bzerr = BZ2_bzDecompress(&(stream->bz2));ttttttif(*bzerr == BZ_STREAM_END) {ttttstream->ended = TRUE;ttt} else {ttttif(*bzerr != BZ_OK) {tttttreturn 0;tttt}ttt}tt}ttttif(total > (stream->bufferLen - stream->bz2.avail_out)) {ttttoRead = stream->bufferLen - stream->bz2.avail_out;tt} else {ttttoRead = total;tt}ttttmemcpy(out, stream->outBuffer, toRead);ttmemmove(stream->outBuffer, stream->outBuffer + toRead, stream->bufferLen - toRead);ttstream->bz2.next_out -= toRead;ttstream->bz2.avail_out += toRead;ttout += toRead;tttotal -= toRead;ttttif(total > 0 && stream->ended) {tttreturn (len - total);tt}t}ttreturn len;}",2,"cwe120,cweother"
cgroup_walk_tree_end(void **handle){tstruct cgroup_tree_handle *entry;tif (!cgroup_initialized)ttreturn ECGROUPNOTINITIALIZED;tif (!handle)ttreturn ECGINVAL;tentry = (struct cgroup_tree_handle *) *handle;tfts_close(entry->fts);tfree(entry);t*handle = NULL;treturn 0;},2,"cwe476,cweother"
"_SCI_REALLOC(void *ptr, size_t size, const char *file, int line, const char *funct){tvoid *res;#ifdef MALLOC_DEBUGtINFO_MEMORY(""_SCI_REALLOC()"", size, file, line, funct);#endiftALLOC_MEM((res = realloc(ptr, size)), size, file, line, funct)treturn res;}",2,"cwe476,cweother"
"af_parse_url(const char *url,char **protocol,char **hostname,char **username,char **password,tt int *port,char **path){    const char *p1 = strstr(url,""://"");    if(!p1){tif(protocol) *protocol = strdup(""file"");tif(path)     *path     = strdup(url);treturn;    }    if(protocol){tint len = p1-url;t*protocol = (char *)malloc(len+1);tstrncpy(*protocol,url,len);    }    url = p1+3;tt     const char *at = strchr(url,'@');    if(at){ttttt tchar *scratch = (char *)malloc(at-url+1);tstrncpy(scratch,url,at-url);tscratch[at-url]='000';tchar *colon = strchr(scratch,':');tif(colon){t    *colon = '000';t}tif(username) *username = strdup(scratch);tif(colon){t    if(password) *password = strdup(colon+1);t}tfree(scratch);turl = at+1;    }         const char *slash = strchr(url,'/');    if(slash){tchar *scratch = (char *)malloc(slash-url+1);tstrncpy(scratch,url,slash-url);tscratch[slash-url]='000';tchar *colon = strchr(scratch,':');tif(colon){t    *colon = '000';t}tif(hostname) *hostname = strdup(scratch);tif(colon){t    if(port) *port = atoi(colon+1);t}tfree(scratch);turl = slash+1;    }    if(path) *path = strdup(url);t                 }",2,"cwe120,cweother"
"ng_waypt_rd(const waypoint* wpt){  char* s = NULL;  char z[50];  double lat, lon;  static int current_wp_ix=0;  memset(z, 0, 50);  current_wp_ix++;  ng_fill_waypoint_default();  if (!GPS_Math_WGS84_To_ICS_EN(wpt->latitude, wpt->longitude, &lon, &lat)) {    fatal(MYNAME "": Waypoint %d is out of the israeli grid area"", current_wp_ix);  }  WPNC.wp_data.North = (gbuint32)lat;  WPNC.wp_data.East = (gbuint32)lon;  if (reorder_wp) {    sprintf(temp_short_name, ""A%03d"", current_wp_ix);    s = temp_short_name;  }  else {    s = wpt->shortname;  }  ng_fwrite_wp_data(s, wpt->description, &WPNC.wp_data, file_out);     if (nof_wp > current_wp_ix) {    ng_next_wp.next_wp = current_wp_ix + 1;    ng_fwrite_next_wp(&ng_next_wp, file_out);  }}",2,"cwe119,cwe120"
"jack_cleanup_files (const char *server_name){tDIR *dir;tstruct dirent *dirent;tchar dir_name[PATH_MAX+1] = """";        jack_server_dir (server_name, dir_name);t t tif ((dir = opendir (dir_name)) == NULL) {ttreturn;t}t twhile ((dirent = readdir (dir)) != NULL) {ttchar fullpath[PATH_MAX+1];ttif ((strcmp (dirent->d_name, ""."") == 0)tt    || (strcmp (dirent->d_name, "".."") == 0)) {tttcontinue;tt}ttsnprintf (fullpath, sizeof (fullpath), ""%s/%s"",ttt  dir_name, dirent->d_name);ttif (unlink (fullpath)) {tttjack_error (""cannot unlink `%s' (%s)"", fullpath,tttt    strerror (errno));tt}t} tclosedir (dir);t tif (rmdir (dir_name)) { ttjack_error (""cannot remove `%s' (%s)"", dir_name,ttt    strerror (errno));t}t tif (rmdir (jack_user_dir ())) {ttif (errno != ENOTEMPTY) {tttjack_error (""cannot remove `%s' (%s)"",tttt    jack_user_dir (), strerror (errno));tt}t}}",3,"cwe119,cwe120,cwe469"
"map_code_to_default(char *code){tchar event[21];tunsigned int dummy, repeat = 0;tinttkey = 0;ttif (sscanf(code,""%x %x %20s"", &dummy, &repeat, event) != 3)t{ttprintf(""lirc: oops, parse error: %s"", code);ttreturn NULL;t}ttif (!repeat && !strcasecmp(""KEY_KPPLUS"", event))ttreturn (char*)strdup(""tune up"");telse if (!repeat && !strcasecmp(""KEY_KPMINUS"", event))ttreturn (char*)strdup(""tune down"");telse if (!strcasecmp(""KEY_VOLUMEUP"", event))ttreturn (char*)strdup(""volume up"");telse if (!strcasecmp(""KEY_VOLUMEDOWN"", event))ttreturn (char*)strdup(""volume down"");telse if (!repeat && !strcasecmp(""KEY_MUTE"", event))ttreturn (char*)strdup(""mute"");telse if (!repeat && !strcasecmp(""KEY_TUNER"", event))ttreturn (char*)strdup(""tv"");telse if (!repeat && !strcasecmp(""KEY_POWER"", event))ttreturn (char*)strdup(""quit"");telse if (!repeat && !strcasecmp(""KEY_CHANNELUP"", event))ttreturn (char*)strdup(""preset up"");telse if (!repeat && !strcasecmp(""KEY_CHANNELDOWN"", event))ttreturn (char*)strdup(""preset down"");telse if (!repeat && !strcasecmp(""KEY_TEXT"", event))ttreturn (char*)strdup(""toggle visible"");ttif (sscanf(event, ""KEY_%d"", &key) == 1)t{ttchar *ret;ttif (repeat || (key < 0) || (key > 9))tttreturn NULL;ttret = malloc(strlen(""preset xx""));ttsprintf(ret, ""preset %1.1d"", key);ttreturn ret;t}ttreturn NULL;}",2,"cwe119,cwe120"
"_get_suffixed_integer_arguments(tchar *action, char **ret_action, int *retvals, int num,tchar *suffixlist, int *ret_suffixnum, char *parsestring){tint i;tint j;tint n;tchar *token;tint suffixes;t tsuffixes = 0;tif (suffixlist != 0)t{tt ttsuffixes = strlen(suffixlist);t}tfor (i = 0; i < num && action; i++)t{tttoken = PeekToken(action, &action);ttif (token == NULL)tt{tttbreak;tt}ttif (sscanf(token, parsestring, &(retvals[i]), &n) < 1)tt{tttbreak;tt}ttif (suffixes != 0 && ret_suffixnum != NULL)tt{tttint len;tttchar c;tttlen = strlen(token) - 1;tttc = token[len];tttif (isupper(c))ttt{ttttc = tolower(c);ttt}tttfor (j = 0; j < suffixes; j++)ttt{ttttchar c2 = suffixlist[j];ttttif (isupper(c2))tttt{tttttc2 = tolower(c2);tttt}ttttif (c == c2)tttt{tttttret_suffixnum[i] = j+1;tttttbreak;tttt}ttt}tttif (j == suffixes)ttt{ttttret_suffixnum[i] = 0;ttt}tt}ttelse if (token[n] != 0 && !isspace(token[n]))tt{ttt tttbreak;tt}t}tif (ret_action != NULL)t{tt*ret_action = action;t}treturn i;}",2,"cwe120,cweother"
"ipset_parse_name_compat(struct ipset_session *session,tttenum ipset_opt opt, const char *str){tchar *saved;tchar *a = NULL, *b = NULL, *tmp;tint err, before = 0;tconst char *sep = IPSET_ELEM_SEPARATOR;tstruct ipset_data *data;tassert(session);tassert(opt == IPSET_OPT_NAME);tassert(str);tdata = ipset_session_data(session);tif (ipset_data_flags_test(data, IPSET_FLAG(IPSET_OPT_NAMEREF)))ttsyntax_err(""mixed syntax, before|after option already used"");ttmp = saved = ipset_strdup(session, str);tif (saved == NULL)ttreturn -1;tif ((a = elem_separator(tmp)) != NULL) {tt tt*a++ = '0';ttif ((b = elem_separator(a)) != NULL)ttt*b++ = '0';ttif (b == NULL ||tt    !(STREQ(a, ""before"") || STREQ(a, ""after""))) {ttterr = ipset_err(session, ""you must specify elements ""ttttt""as setname%s[before|after]%ssetname"",tttttsep, sep);tttgoto out;tt}ttbefore = STREQ(a, ""before"");t}tcheck_setname(tmp, saved);tif ((err = ipset_data_set(data, opt, tmp)) != 0 || b == NULL)ttgoto out;tcheck_setname(b, saved);tif ((err = ipset_data_set(data,tttt  IPSET_OPT_NAMEREF, b)) != 0)ttgoto out;tif (before)tterr = ipset_data_set(data, IPSET_OPT_BEFORE, &before);out:tfree(saved);treturn err;}",2,"cwe469,cweother"
__ecereMethod_ThreadsView_GetThreadId(struct __ecereNameSpace__ecere__com__Instance * this){struct ThreadsView * __ecerePointer_ThreadsView = (struct ThreadsView *)(this ? (((char *)this) + __ecereClass_ThreadsView->offset) : 0);return atoi(__ecereProp___ecereNameSpace__ecere__gui__controls__EditLine_Get_text(__ecereProp___ecereNameSpace__ecere__gui__controls__EditBox_Get_line(__ecerePointer_ThreadsView->editBox)));},2,"cwe476,cweother"
"_fill_table(raw_wave *this){       FILE *in;  int i;  short *tmp;  int block_size = 8192;  int current_block = 0;  int count         = 0;    in = fopen(this->filename,""r"");     if( in==NULL )    {      fprintf(stderr, ""Couldn't open sample: %s"", this->filename);      this->length=0;      return;    }  if( this->table != NULL)    {      free(this->table);    }  this->length = 0;    this->current_index = 0;  tmp = (short *)malloc(sizeof(short) * block_size);  while((count = fread(tmp + (block_size * current_block),tt       sizeof(short),tt       block_size,tt       in))t== block_size) {    this->length += count;    tmp  = realloc(tmp, sizeof(short) * tt   block_size * (current_block + 2));    current_block++;  }  this->length += count;#if __BYTE_ORDER == __BIG_ENDIAN  swap_endian(tmp, this->length);#endif  this->table = (sample *)malloc(sizeof(sample) * this->length);  for(i = 0; i < this->length;i++) {    this->table[i] = (sample)tmp[i];  }  fclose(in);  free(tmp);}",2,"cwe120,cweother"
"_crywrap_setup_pidfile(const crywrap_config_t * config){tchar mypid[128];tint pidfilefd;tif (!config->pidfile || !*(config->pidfile))ttreturn;tif (!access(config->pidfile, F_OK)) {ttcry_error(""Pidfile (%s) already exists. Exiting."",ttt  config->pidfile);ttexit(1);t}tif ((pidfilefd = open(config->pidfile,ttt      O_WRONLY | O_CREAT | O_TRUNC, 0644)) == -1) {ttcry_error(""Cannot create pidfile (%s): %s."",ttt  config->pidfile, strerror(errno));ttexit(1);t}tfchown(pidfilefd, config->uid, (gid_t) - 1);tmain_pid = getpid();tsnprintf(mypid, sizeof(mypid), ""%d"", main_pid);twrite(pidfilefd, mypid, strlen(mypid));tclose(pidfilefd);tpidfile = config->pidfile;}",3,"cwe119,cwe120,cweother"
"chirp_client_putfile_buffer(struct chirp_client * c, const char *path, const char *buffer, INT64_T mode, INT64_T length, time_t stoptime){tINT64_T result;tchar safepath[CHIRP_LINE_MAX];turl_encode(path, safepath, sizeof(safepath));tresult = simple_command(c, stoptime, ""putfile %s %lld %lld"", safepath, mode, length);tif(result < 0)ttreturn result;tresult = link_putlstring(c->link, buffer, length, stoptime);tif(result != length) {ttc->broken = 1;tterrno = ECONNRESET;ttreturn -1;t}treturn get_result(c, stoptime);}",2,"cwe119,cwe120"
"find_gretlpre (const char *path, const char *localname){    char test[MAXLEN];    int err, gotit = 0;    if (*localname != '0') {t tsprintf(test, ""%s%s"", path, localname);terr = gretl_test_fopen(test, ""r"");tif (!err) {t    strcpy(tex_preamble_file, test);t    gotit = 1;t}    }    if (!gotit) {t tsprintf(test, ""%sgretlpre.tex"", path);terr = gretl_test_fopen(test, ""r"");tif (!err) {t    strcpy(tex_preamble_file, test);t    gotit = 1;t}    }    return gotit;}",2,"cwe119,cwe120"
"_ldapfull_chk_hashed(moddata_t data, const char *scheme, int salted, const char *hash, const char *passwd) {    char *bhash;      EVP_MD_CTX mdctx;    const EVP_MD *md;    unsigned char digest[EVP_MAX_MD_SIZE];    int bhlen, rc;    md = EVP_get_digestbyname(scheme);    if (!md) {        return 0;    }    if( ! _ldapfull_base64_decode(hash, &bhash, &bhlen) ) {        return 0;    }    EVP_DigestInit(&mdctx, md);    EVP_DigestUpdate(&mdctx, passwd, strlen(passwd));    if (salted) {        EVP_DigestUpdate(&mdctx, &bhash[EVP_MD_size(md)],                bhlen - EVP_MD_size(md));    }    EVP_DigestFinal(&mdctx, digest, NULL);    rc = memcmp((char *)bhash, (char *)digest, EVP_MD_size(md));    free(bhash);    return !rc;}",2,"cwe119,cwe120"
"cdrom_read_tocentry(ide_drive_t *drive, int trackno, int msf_flag,ttttint format, char *buf, int buflen,ttttstruct request_sense *sense){tunsigned char cmd[BLK_MAX_CDB];tide_debug_log(IDE_DBG_FUNC, ""enter"");tmemset(cmd, 0, BLK_MAX_CDB);tcmd[0] = GPCMD_READ_TOC_PMA_ATIP;tcmd[6] = trackno;tcmd[7] = (buflen >> 8);tcmd[8] = (buflen & 0xff);tcmd[9] = (format << 6);tif (msf_flag)ttcmd[1] = 2;treturn ide_cd_queue_pc(drive, cmd, 0, buf, &buflen, sense, 0, REQ_QUIET);}",2,"cwe119,cwe120"
"get_utf8_line_from_file ( FILE *fichier,                        gchar **string,                        const gchar *coding_system ){    gchar c = 0;    gint i = 0;    gint j = 0;    gchar *pointeur_char = NULL;    gchar *tmp_string;    if ( !fichier )treturn 0;t             pointeur_char = (gchar*)g_realloc(pointeur_char,30*sizeof(gchar));    if ( !pointeur_char )    {t tdialogue_error ( _(""Memory allocation error"" ));treturn 0;    }         c =(gchar)fgetc(fichier);    while ( ( c != '' ) && (c != 'r') && !feof (fichier))    {tpointeur_char[j++] = c;tif ( ++i == 29 )t{t    pointeur_char = (gchar*)g_realloc(pointeur_char, j + 1 + 30*sizeof(gchar));t    if ( !pointeur_char )t    {tt ttdialogue_error ( _(""Memory allocation error"" ));ttreturn 0;t    }t    i = 0;t}tc =(gchar)fgetc(fichier);    }    pointeur_char[j] = 0;         if ( c == 'r' )    {tc =(gchar)fgetc(fichier);tif ( c != '' )t{t    ungetc ( c, fichier );t}    }    tmp_string = g_convert ( pointeur_char, -1, ""UTF-8"", ttt     coding_system, NULL, NULL,ttt     NULL );    if (!tmp_string)    {        devel_debug (""convert to utf8 failed, will use latin2utf8"");        tmp_string = latin2utf8 (pointeur_char);        if ( tmp_string == NULL )        {            dialogue_special ( GTK_MESSAGE_ERROR, make_hint (                            _(""Convert to utf8 failed.""),                            _(""If the result is not correct, try again by selecting the ""                            ""correct character set in the window for selecting files."") ) );            return 0;        }    }    *string = tmp_string;    g_free (pointeur_char);    if ( feof(fichier))        return EOF;    else        return 1;}",2,"cwe120,cweother"
"fluid_midi_file_read_tracklen(fluid_midi_file *mf){tunsigned char length[5];tif (fluid_midi_file_read(mf, length, 4) != FLUID_OK) {ttreturn FLUID_FAILED;t}tmf->tracklen = fluid_getlength(length);tmf->trackpos = 0;tmf->eot = 0;treturn FLUID_OK;}",2,"cwe119,cwe120"
"zReadTransition (FILE *stream, zTransition *t, int iso_groups) {tchar          from[17], to[17];tfloat         *prob;tint i;tprob = zCalloc(iso_groups, sizeof(float), ""zReadTransition Isochores prob"");tif (fscanf(stream, ""%16s %16s %f"", from, to, prob) != 3) {ttzWarn(""fscanf error in zReadTransition"");ttreturn 0;t}tfor (i = 1; i < iso_groups; i++){ttif(fscanf(stream, ""%f"", &prob[i]) != 1) {tttzWarn(""fscanf error in zReadTransition Isochores"");tttreturn 0;tt}t}tt->prob = prob;tt->score = zCalloc(iso_groups, sizeof(score_t), ""zReadTransition Isochores score"");tfor (i = 0; i < iso_groups; i++){ttt->score[i] = zFloat2Score(prob[i]);t}t tif (!zStrIdxExists(from)) {ttzWarn(""zReadTransition from unrecognized state (%s)"", from);ttreturn 0;t}tt->from = zChar2StrIdx(from);t tif (!zStrIdxExists(to)) {ttzWarn(""zReadTransition from unrecognized state (%s)"", to);ttreturn 0;t}tt->to = zChar2StrIdx(to);treturn 1;}",2,"cwe119,cwe120"
"log__enough_freespace(char  *path){#ifdef _WIN32DWORDtsectorsPerCluster, bytesPerSector, freeClusters, totalClusters;char rootpath[4];#else#ifdef LINUXtstruct  statfsttbuf;#elsetstructtstatvfsttbuf;#endif    #endiftPRInt64tttfreeBytes;tPRInt64 tmpval;#ifdef _WIN32    strncpy(rootpath, path, 3);    rootpath[3] = '0';     tif ( !GetDiskFreeSpace(rootpath, &sectorsPerCluster, &bytesPerSector,tttt&freeClusters, &totalClusters)) {ttLDAPDebug(LDAP_DEBUG_ANY, ttt  ""log__enough_freespace: Unable to get the free space"",0,0,0);ttreturn 1;t} else {t    LL_UI2L(freeBytes, freeClusters);t    LL_UI2L(tmpval, sectorsPerCluster);        LL_MUL(freeBytes, freeBytes, tmpval);t    LL_UI2L(tmpval, bytesPerSector);        LL_MUL(freeBytes, freeBytes, tmpval); t}tt#else#ifdef LINUXtif (statfs(path, &buf) == -1)#elsetif (statvfs(path, &buf) == -1)#endift{ttchar buffer[BUFSIZ];ttPR_snprintf(buffer, sizeof(buffer),ttt  tt""log__enough_freespace: Unable to get the free space (errno:%d)"",ttttterrno);ttlog__error_emergency(buffer, 0, 1);ttreturn 1;t} else {t    LL_UI2L(freeBytes, buf.f_bavail);t    LL_UI2L(tmpval, buf.f_bsize);t    LL_MUL(freeBytes, freeBytes, tmpval);t   t}#endiftLL_UI2L(tmpval, loginfo.log_access_minfreespace);tif (LL_UCMP(freeBytes, <, tmpval)) {t t  return 0;t}treturn 1;}",2,"cwe119,cwe120"
"trash_item_delete (TrashItem  *item,                   GError    **error){  gboolean success;  GFile *expunged;  guint unique;  guint i;  expunged = g_file_resolve_relative_path (item->file,                                           ""../../expunged"");  g_file_make_directory_with_parents (expunged, NULL, NULL);  unique = g_random_int ();  for (success = FALSE, i = 0; !success && i < 1000; i++)    {      GFile *temp_name;      char buffer[16];      g_sprintf (buffer, ""%u"", unique + i);      temp_name = g_file_get_child (expunged, buffer);             if (trash_item_restore (item, temp_name,ttt      G_FILE_COPY_OVERWRITE | G_FILE_COPY_NOFOLLOW_SYMLINKS,ttt      NULL))        {          trash_expunge (expunged);          success = TRUE;        }      g_object_unref (temp_name);    }  g_object_unref (expunged);  if (!success)    g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,                         ""Failed to delete the item from the trash"");  return success;}",3,"cwe119,cwe120,cweother"
"check_menu_dir(const char *dir, Eina_List **menus){   char buf[PATH_MAX], *file;   Eina_List *files;      snprintf(buf, sizeof(buf), ""%s/menus"", dir);   files = ecore_file_ls(buf);   EINA_LIST_FREE(files, file)     {        if (e_util_glob_match(file, ""*.menu""))          {             snprintf(buf, sizeof(buf), ""%s/menus/%s"", dir, file);             *menus = eina_list_append(*menus, strdup(buf));          }        free(file);     }}",2,"cwe119,cwe120"
"detect_keyboard_layout_from_locale(){tint i;tint j;tint k;tint dot;tint underscore;tchar language[4];tchar country[10];t tchar* envLang = getenv(""LANG"");  tif(envLang == NULL)ttreturn 0;  tunderscore = strcspn(envLang, ""_"");tif(underscore > 3)ttreturn 0;  telset{tt ttstrncpy(language, envLang, underscore);ttlanguage[underscore] = '0';t}t tif((strcmp(language, ""C"") == 0) || (strcmp(language, ""POSIX"") == 0))ttreturn ENGLISH_UNITED_STATES;  tdot = strcspn(envLang, ""."");t tif(dot > underscore)t{ttstrncpy(country, &envLang[underscore + 1], dot - underscore - 1);ttcountry[dot - underscore - 1] = '0';t}telsettreturn 0;  tfor(i = 0; i < sizeof(locales) / sizeof(locale); i++)t{ttif((strcmp(language, locales[i].language) == 0) && (strcmp(country, locales[i].country) == 0))tttbreak;t}tDEBUG_KBD(""Found locale : %s_%s"", locales[i].language, locales[i].country);tfor(j = 0; j < sizeof(defaultKeyboardLayouts) / sizeof(localeAndKeyboardLayout); j++)t{ttif(defaultKeyboardLayouts[j].locale == locales[i].code)tt{ttt tttfor(k = 0; k < 5; k++)ttt{ttttif(defaultKeyboardLayouts[j].keyboardLayouts[k] == ENGLISH_UNITED_STATES)tttt{tttttcontinue;  tttt}ttttelse if(defaultKeyboardLayouts[j].keyboardLayouts[k] == 0)tttt{tttttbreak;  tttt}ttttelsetttt{tttttreturn defaultKeyboardLayouts[j].keyboardLayouts[k];tttt}ttt}ttt tttif(k >= 1)ttttreturn ENGLISH_UNITED_STATES;tttelsettttreturn 0;tt}t}treturn 0;  }",4,"cwe119,cwe120,cwe476,cweother"
"mboxlist_createmailbox_full(const char *name, int mbtype,ttttconst char *partition,ttttint isadmin, const char *userid,ttttstruct auth_state *auth_state,ttttint options, unsigned uidvalidity,ttttconst char *copyacl, const char *uniqueid,ttttint localonly, int forceuser, int dbonly,ttttstruct mailbox **mboxptr){    int r;    char *newpartition = NULL;    mupdate_handle *mupdate_h = NULL;    char *mboxent = NULL;    char *acl = NULL;    struct mailbox *newmailbox = NULL;    int isremote = mbtype & MBTYPE_REMOTE;         char buf[MAX_PARTITION_LEN + HOSTNAME_SIZE + 2];    if (copyacl) {tnewpartition = xstrdup(partition);tacl = xstrdup(copyacl);    }    else {t tr = mboxlist_mycreatemailboxcheck(name, mbtype, partition, isadmin, ttttt  userid, auth_state, ttttt  &acl, &newpartition, 0, localonly,ttttt  forceuser, NULL);tif (r) goto done;    }    if (!newpartition) {tr = IMAP_IOERROR;tgoto done;    }    if (!dbonly && !isremote) {t tr = mailbox_create(name, newpartition, acl, uniqueid,ttt   options, uidvalidity, &newmailbox);    }    if (r) goto done;            mboxent = mboxlist_makeentry(mbtype, newpartition, acl);    r = DB->store(mbdb, name, strlen(name), mboxent, strlen(mboxent), NULL);    if (r) {tsyslog(LOG_ERR, ""DBERROR: failed to insert to mailboxes list %s: %s"", t       name, cyrusdb_strerror(r));tr = IMAP_IOERROR;    }         if (!r && config_mupdate_server && !localonly) {t tsnprintf(buf, sizeof(buf), ""%s!%s"", config_servername, newpartition);tr = mupdate_connect(config_mupdate_server, NULL, &mupdate_h, NULL);tif (!r) r = mupdate_reserve(mupdate_h, name, buf);tif (!r) r = mupdate_activate(mupdate_h, name, buf, acl);tif (r) {t    syslog(LOG_ERR,tt   ""MUPDATE: can't commit mailbox entry for '%s'"", name);t    DB->delete(mbdb, name, strlen(name), NULL, 0);t}tif (mupdate_h) mupdate_disconnect(&mupdate_h);    }done:    if (newmailbox) {tif (r) mailbox_delete(&newmailbox);telse if (mboxptr) *mboxptr = newmailbox;telse mailbox_close(&newmailbox);    }    if (acl) free(acl);    if (newpartition) free(newpartition);    if (mboxent) free(mboxent);       return r;}",3,"cwe119,cwe120,cweother"
"hypermaze_get_pixmap (int idx, int color){tint fg, bg, i;tchar *colors = hypermaze_colors;tstatic char pixbuf[HYPERMAZE_CELL_SIZE * (HYPERMAZE_CELL_SIZE+1)];tfor(i=0, bg=0;i<3;i++) t{ int col = colors[i]; if (col<0) col += 256; bg += col * (1 << (16-8*i));}tif (idx == HYPERMAZE_WALL)ttreturn hypermaze_pixmap_square_gen(idx, ""#443333"");tif (idx == HYPERMAZE_CUR)ttreturn pixmap_ball_gen (HYPERMAZE_CELL_SIZE, pixbuf,ttt0xffffff, bg, 6, 20);t tswitch (idx)t{ttcase HYPERMAZE_N: return arrow_blue_n_xpm;ttcase HYPERMAZE_S: return arrow_blue_s_xpm;ttcase HYPERMAZE_E: return arrow_blue_e_xpm;ttcase HYPERMAZE_W: return arrow_blue_w_xpm;ttcase HYPERMAZE_NE: return arrow_blue_ne_xpm;ttcase HYPERMAZE_NW: return arrow_blue_nw_xpm;ttcase HYPERMAZE_SW: return arrow_blue_sw_xpm;ttcase HYPERMAZE_SE: return arrow_blue_se_xpm;ttdefault: assert (0);t}}",2,"cwe119,cwe120"
"number_process(int first_digit){tunsigned i;tint num;tint keypress;tchar num_input[sizeof(int)*4];  tnum_input[0] = first_digit;t tclear_line();tprintf("":%c"", first_digit);t ti = 1;twhile (i < sizeof(num_input)-1) {ttkeypress = less_getch(i + 1);ttif ((unsigned)keypress > 255 || !isdigit(num_input[i]))tttbreak;ttnum_input[i] = keypress;ttbb_putchar(keypress);tti++;t}tnum_input[i] = '0';tnum = bb_strtou(num_input, NULL, 10);t tif (num < 1 || num > MAXLINES) {ttbuffer_print();ttreturn;t}t tswitch (keypress) {tcase KEYCODE_DOWN: case 'z': case 'd': case 'e': case ' ': case '015':ttbuffer_down(num);ttbreak;tcase KEYCODE_UP: case 'b': case 'w': case 'y': case 'u':ttbuffer_up(num);ttbreak;tcase 'g': case '<': case 'G': case '>':ttcur_fline = num + max_displayed_line;ttread_lines();ttbuffer_line(num - 1);ttbreak;tcase 'p': case '%':ttnum = num * (max_fline / 100);  ttcur_fline = num + max_displayed_line;ttread_lines();ttbuffer_line(num);ttbreak;#if ENABLE_FEATURE_LESS_REGEXPtcase 'n':ttgoto_match(match_pos + num);ttbreak;tcase '/':ttoption_mask32 &= ~LESS_STATE_MATCH_BACKWARDS;ttregex_process();ttbreak;tcase '?':ttoption_mask32 |= LESS_STATE_MATCH_BACKWARDS;ttregex_process();ttbreak;#endift}}",2,"cwe119,cwe120"
"waiting_socket(int family,int port){    int sock;    int ret;    char portstr[8];    struct addrinfo hints,*result = NULL;        if(port < 0 || 0xffff < port) {tdisplay(MSDL_ERR,""internal: invalid port number"");tgoto failed;    }        memset(portstr,0,8);    snprintf(portstr,7,""%d"",port);        memset(&hints,0,sizeof(hints));    hints.ai_family = family;    hints.ai_socktype = SOCK_STREAM;    hints.ai_flags = AI_PASSIVE;        ret = getaddrinfo(NULL,portstr,&hints,&result);    if(ret != 0) {tperror(""getaddrinfo() failed"");tgoto failed;    }    sock = socket(result->ai_family,result->ai_socktype,result->ai_protocol);    if(sock < 0) {tperror(""socket() failed"");tgoto failed;    }        ret = bind(sock,(struct sockaddr *)result->ai_addr,result->ai_addrlen);    if(ret < 0) {tperror(""bind() failed"");tgoto failed;    }        ret = listen(sock,1);    if(ret < 0) {tperror(""listen() failed"");tgoto failed;    }    freeaddrinfo(result);    return sock;      failed:    if(result) freeaddrinfo(result);    return -1;}",2,"cwe119,cwe120"
"sil_dev_config(struct ata_device *dev){tstruct ata_port *ap = dev->link->ap;tint print_info = ap->link.eh_context.i.flags & ATA_EHI_PRINTINFO;tunsigned int n, quirks = 0;tunsigned char model_num[ATA_ID_PROD_LEN + 1];t tdev->horkage |= ATA_HORKAGE_NOTRIM;tata_id_c_string(dev->id, model_num, ATA_ID_PROD, sizeof(model_num));tfor (n = 0; sil_blacklist[n].product; n++)ttif (!strcmp(sil_blacklist[n].product, model_num)) {tttquirks = sil_blacklist[n].quirk;tttbreak;tt}t tif (slow_down ||t    ((ap->flags & SIL_FLAG_MOD15WRITE) &&t     (quirks & SIL_QUIRK_MOD15WRITE))) {ttif (print_info)tttata_dev_info(dev,tt""applying Seagate errata fix (mod15write workaround)"");ttdev->max_sectors = 15;ttreturn;t}t tif (quirks & SIL_QUIRK_UDMA5MAX) {ttif (print_info)tttata_dev_info(dev, ""applying Maxtor errata fix %s"",tttt     model_num);ttdev->udma_mask &= ATA_UDMA5;ttreturn;t}}",2,"cwe119,cwe120"
"cmd_users(){tuserrect*u;tinttnum_cols = 4;tinttcol, row, num_rows, tot, index, have_flags = 0, byacct = 0;tu_longtflags;tchartline[160], levels[FLAGSHORTLEN];tcontext;tline[0] = 0;tif(cmdinfo.istok1)t{ttif(isequal(cmdinfo.tok1,""-a""))tt{tttbyacct = 1;tttif(cmdinfo.istok2)ttt{tttthave_flags = 1;ttttUser_str2flags(cmdinfo.tok2,&flags);ttt}tt}ttelsett{ttthave_flags = 1;tttUser_str2flags(cmdinfo.tok1,&flags);tt}t}tif(byacct)t{ttif(have_flags)ttttot = User_orderbyacctname_plusflags(flags);ttelsettttot = User_orderbyacctname();t}telset{ttif(have_flags)ttttot = User_orderbyreg_plusflags(flags);ttelsettttot = User_orderbyreg();t}tif(tot == 0)t{ttif(have_flags)tt{tttUser_flags2str(flags,levels);tttsay(""No users match levels ""%s"""",levels);tt}ttelsetttsay(""No users."");ttreturn;t}tif(have_flags)t{ttUser_flags2str(flags,levels);ttsay(""%d user%s match%s levels ""%s""."",tot,tot==1?"""":""s"",tot==1?""es"":"""",levels);t}telsettsay(""%d user%s."",tot,tot==1?"""":""s"");tsay("""");t tif(tot <= ENTRIES_FOR_ONE_COL)t{ttsay(""   # Username"");ttsay(""---- ---------"");ttnum_cols = 1;t}telset{ttsay(""   # Username       # Username       # Username       # Username"");ttsay(""---- ---------   ---- ---------   ---- ---------   ---- ---------"");t}tnum_rows = tot / num_cols;tif(tot % num_cols)ttnum_rows++;tfor(row=1; row<=num_rows; row++)t{ttfor(col=1; col<=num_cols; col++)tt{tttindex = (num_rows * (col-1)) +row;tttu = User_userbyorder(index);tttif(u)ttttsprintf(line,""%s%4d %-9s   "",line,u->registered,u->acctname);tt}ttline[strlen(line) - 3] = 0;ttsay(""%s"",line);ttline[0] = 0;t}tif(tot <= ENTRIES_FOR_ONE_COL)ttsay(""---- ---------"");telsettsay(""---- ---------   ---- ---------   ---- ---------   ---- ---------"");}",2,"cwe119,cwe120"
"add_locate(void *ctx, int type, struct sockaddr *addr){    struct krb5_krbhst_data *kd = ctx;    char host[NI_MAXHOST], port[NI_MAXSERV];    socklen_t socklen;    krb5_error_code ret;    int proto, portnum;    socklen = socket_sockaddr_size(addr);    portnum = socket_get_port(addr);    ret = getnameinfo(addr, socklen, host, sizeof(host), port, sizeof(port),tt      NI_NUMERICHOST|NI_NUMERICSERV);    if (ret != 0)treturn 0;    if (kd->port)tsnprintf(port, sizeof(port), ""%d"", kd->port);    else if (atoi(port) == 0)tsnprintf(port, sizeof(port), ""%d"", krbhst_get_default_port(kd));    proto = krbhst_get_default_proto(kd);    ret = add_plugin_host(kd, host, port, portnum, proto);    if (ret)treturn ret;         if (proto == KRB5_KRBHST_UDP) {tret = add_plugin_host(kd, host, port, portnum, KRB5_KRBHST_TCP);tif (ret)t    return ret;    }    return 0;}",3,"cwe119,cwe120,cweother"
"_e_startup(void){   Efreet_Desktop *desktop;   char buf[8192];   if (!startup_apps)     {        e_init_done();        return;     }   desktop = eina_list_nth(startup_apps->desktops, start_app_pos);   start_app_pos++;   if (!desktop)     {        e_object_del(E_OBJECT(startup_apps));        startup_apps = NULL;        start_app_pos = -1;        e_init_done();        return;     }   e_exec(NULL, desktop, NULL, NULL, NULL);   snprintf(buf, sizeof(buf), _(""Starting %s""), desktop->name);   e_init_status_set(buf);   ecore_job_add(_e_startup_next_cb, NULL);}",2,"cwe119,cwe120"
"x86_64_xendump_panic_task(struct xendump_data *xd){tint i;tulong rsp;toff_t offset;tulong task;tif (INVALID_MEMBER(vcpu_guest_context_user_regs) ||t    INVALID_MEMBER(cpu_user_regs_esp))ttreturn NO_TASK;        offset = (off_t)xd->xc_core.header.xch_ctxt_offset +                (off_t)OFFSET(vcpu_guest_context_user_regs) +tt(off_t)OFFSET(cpu_user_regs_rsp);        if (lseek(xd->xfd, offset, SEEK_SET) == -1)ttreturn NO_TASK;        if (read(xd->xfd, &rsp, sizeof(ulong)) != sizeof(ulong))ttreturn NO_TASK;        if (IS_KVADDR(rsp) && (task = stkptr_to_task(rsp))) {                for (i = 0; i < NR_CPUS; i++) {                tif (task == tt->active_set[i]) {                        tif (CRASHDEBUG(0))                                terror(INFO,                            ""x86_64_xendump_panic_task: rsp: %lx -> task: %lx"",                                        trsp, task);                        treturn task;ttt}tt}                              terror(WARNING,tt    ""x86_64_xendump_panic_task: rsp: %lx -> task: %lx (not active)"",tttrsp);        }treturn NO_TASK;}",2,"cwe120,cweother"
"E(r   const unsigned char *input,r   const unsigned char *key,r   unsigned char *outputr )r {rtint i, r;rtunsigned char subkey[32 * 4];rtunsigned char left[4], right[4];rtunsigned char temp[4], nibble[8];rrtkey_sched_LBlocks(key, subkey);tt rtfor(i = 0; i < 4; i++)rt{rttleft[i] = input[i];rttright[i] = input[i + 4];rt}rrt tfor(r = 0; r < 32; r++)rt{rtt ttfor(i = 0; i < 4; i++)rtt{rttttemp[i] = right[(i + 1) % 4];rtt}rttfor(i = 0; i < 4; i++)rtt{rtttright[i] = temp[i];rtt}rrtt ttfor(i = 0; i < 4; i++)rtt{rttttemp[i] = left[i] ^ subkey[r * 4 + i];rtt}rrtt ttfor(i = 0; i < 4; i++)rtt{rtttnibble[2 * i] = S[temp[i] >> 4];rtttnibble[2 * i + 1] = S[temp[i] & 0xf];rtt}rttrtt tttemp[0] = (nibble[1] << 4) ^ nibble[3];rtttemp[1] = (nibble[0] << 4) ^ nibble[2];rtttemp[2] = (nibble[5] << 4) ^ nibble[7];rtttemp[3] = (nibble[4] << 4) ^ nibble[6];rrttfor(i = 0; i < 4; i++)rtt{rttttemp[i] ^= right[i];rtt}rttfor(i = 0; i < 4; i++)rtt{rtttright[i] = left[i];rtttleft[i] = temp[i];rtt}rt}rrt tfor(i = 0; i < 4; i++)rt{rttoutput[i] = left[i];rttoutput[i + 4] = right[i];rt}r }",2,"cwe119,cwe120"
"spoil_mon_info(const char *fname){tchar buf[1024];tint i, n;tu16b *who;tint count = 0;t tpath_build(buf, sizeof(buf), ANGBAND_DIR_USER, fname);tfh = file_open(buf, MODE_WRITE, FTYPE_TEXT);t tif (!fh)t{ttmsg(""Cannot create spoiler file."");ttreturn;t}t ttext_out_hook = text_out_to_file;ttext_out_file = fh;t ttext_out(""Monster Spoilers for %s"", buildid);ttext_out(""------------------------------------------"");t twho = C_ZNEW(z_info->r_max, u16b);t tfor (i = 1; i < z_info->r_max; i++)t{ttmonster_race *r_ptr = &r_info[i];tt ttif (r_ptr->name) who[count++] = (u16b)i;t}tsort(who, count, sizeof(*who), cmp_monsters);t tfor (n = 0; n < count; n++)t{ttint r_idx = who[n];ttmonster_race *r_ptr = &r_info[r_idx];tt ttif (rf_has(r_ptr->flags, RF_QUESTOR))tt{ttttext_out(""[Q] "");tt}ttelse if (rf_has(r_ptr->flags, RF_UNIQUE))tt{ttttext_out(""[U] "");tt}ttelsett{ttttext_out(""The "");tt}tt tttext_out(""%s  ("",  r_ptr->name);t tt tttext_out(attr_to_text(r_ptr->d_attr));tt tttext_out("" '%c')"", r_ptr->d_char);tt tttext_out(""=== "");tt tttext_out(""Num:%d  "", r_idx);tt tttext_out(""Lev:%d  "", r_ptr->level);tt tttext_out(""Rar:%d  "", r_ptr->rarity);tt ttif (r_ptr->speed >= 110)tt{ttttext_out(""Spd:+%d  "", (r_ptr->speed - 110));tt}ttelsett{ttttext_out(""Spd:-%d  "", (110 - r_ptr->speed));tt}tt tttext_out(""Hp:%d  "", r_ptr->avg_hp);tt tttext_out(""Ac:%d  "", r_ptr->ac);tt tttext_out(""Exp:%ld"", (long)(r_ptr->mexp));tt ttdescribe_monster(r_idx, TRUE);tt tttext_out("""");t}t tFREE(who);t tif (!file_close(fh))t{ttmsg(""Cannot close spoiler file."");ttreturn;t}tmsg(""Successfully created a spoiler file."");}",2,"cwe119,cwe120"
"m_Categorize( Object *in, Object *out ){    catinfo c;    int i;#define MAX_NUM_COMPS 200    char *s_list[ MAX_NUM_COMPS ];         memset( ( char * ) & c, '0', sizeof( c ) );    c.maxparallel = DXProcessors( 0 );    c.sort = 1;      if ( c.maxparallel > 1 )        c.maxparallel = ( c.maxparallel - 1 ) * PFACTOR;         if ( !in[ 0 ] ) {        DXSetError( ERROR_BAD_PARAMETER, ""#10000"", ""input"" );        return ERROR;    } else        c.o = in[ 0 ];    c.comp_list = s_list;    c.comp_list[ 0 ] = DEFAULTCOMP;    if ( in[ 1 ] && ! DXExtractNthString( in[ 1 ], 0, &c.comp_list[ 0 ] ) ) {        DXSetError( ERROR_BAD_PARAMETER, ""#10200"", ""component name"" );        goto error;    }    for ( i = 1; i < MAX_NUM_COMPS; i++ ) {        if ( !DXExtractNthString( in[ 1 ], i, &c.comp_list[ i ] ) )            break;    }    c.comp_list[ i ] = NULL;        if (in [ 2 ]) {    tif (!DXExtractInteger(in[2], &c.sort) ||t    t(c.sort != 0 && c.sort != 1)) {t    tDXSetError(ERROR_BAD_PARAMETER, ""#10070"", ""sort flag"");t    tgoto error;tt}t}         out[ 0 ] = Object_Categorize( &c );    return ( out[ 0 ] ? OK : ERROR );error:    out[ 0 ] = out[ 1 ] = NULL;    return ( ERROR );}",2,"cwe119,cwe120"
"netlink_if_link_filter(struct sockaddr_nl *snl, struct nlmsghdr *h){tstruct ifinfomsg *ifi;tstruct rtattr *tb[IFLA_MAX + 1];tinterface_t *ifp;tint i, len;tchar *name;tifi = NLMSG_DATA(h);tif (h->nlmsg_type != RTM_NEWLINK)ttreturn 0;tlen = h->nlmsg_len - NLMSG_LENGTH(sizeof (struct ifinfomsg));tif (len < 0)ttreturn -1;t tmemset(tb, 0, sizeof (tb));tparse_rtattr(tb, IFLA_MAX, IFLA_RTA(ifi), len);tif (tb[IFLA_IFNAME] == NULL)ttreturn -1;tname = (char *) RTA_DATA(tb[IFLA_IFNAME]);t tif (ifi->ifi_type == ARPHRD_LOOPBACK)ttreturn 0;t tifp = if_get_by_ifname(name);tif (ifp) {ttif (!ifp->vmac) {tttvmac_reflect_flags(ifi);tttifp->flags = ifi->ifi_flags;tt}ttreturn 0;t}t tifp = (interface_t *) MALLOC(sizeof(interface_t));tmemcpy(ifp->ifname, name, strlen(name));tifp->ifindex = ifi->ifi_index;tifp->mtu = *(int *) RTA_DATA(tb[IFLA_MTU]);tifp->hw_type = ifi->ifi_type;tif (!ifp->vmac) {ttvmac_reflect_flags(ifi);ttifp->flags = ifi->ifi_flags;ttifp->base_ifindex = ifi->ifi_index;t}tif (tb[IFLA_ADDRESS]) {ttint hw_addr_len = RTA_PAYLOAD(tb[IFLA_ADDRESS]);ttif (hw_addr_len > IF_HWADDR_MAX)tttlog_message(LOG_ERR, ""MAC address for %s is too large: %d"",ttt       name, hw_addr_len);ttelse {tttifp->hw_addr_len = hw_addr_len;tttmemcpy(ifp->hw_addr, RTA_DATA(tb[IFLA_ADDRESS]),ttt       hw_addr_len);tttfor (i = 0; i < hw_addr_len; i++)ttttif (ifp->hw_addr[i] != 0)tttttbreak;tttif (i == hw_addr_len)ttttifp->hw_addr_len = 0;tttelsettttifp->hw_addr_len = hw_addr_len;tt}t}t tif_add_queue(ifp);treturn 0;}",2,"cwe119,cwe120"
"dump_hrtimer_clock_base(const void *hrtimer_bases, const int num){tvoid *base;tulonglong current_time, now;tulonglong offset;tulong get_time;tchar buf[BUFSIZE];tbase = (void *)hrtimer_bases + OFFSET(hrtimer_cpu_base_clock_base) +ttSIZE(hrtimer_clock_base) * num;treadmem((ulong)(base + OFFSET(hrtimer_clock_base_get_time)), KVADDR,tt&get_time, sizeof(get_time), ""hrtimer_clock_base get_time"",ttFAULT_ON_ERROR);tfprintf(fp, ""  CLOCK: %d  HRTIMER_CLOCK_BASE: %lx  [%s]"", num, tt(ulong)base, value_to_symstr(get_time, buf, 0));t tget_uptime(NULL, &current_time);toffset = 0;tif (VALID_MEMBER(hrtimer_clock_base_offset))ttoffset = ktime_to_ns(base + OFFSET(hrtimer_clock_base_offset));tnow = current_time * 1000000000LL / machdep->hz + offset;tdump_active_timers(base, now);}",2,"cwe119,cwe120"
"check_provisioning(struct sockaddr_in *sin, int sockfd, char *si, unsigned int ver){tunsigned int ourver;tchar rsi[80];tsnprintf(rsi, sizeof(rsi), ""si-%s"", si);tif (iax_provision_version(&ourver, rsi, 1))ttreturn 0;tast_debug(1, ""Service identifier '%s', we think '%08x', they think '%08x'"", si, ourver, ver);tif (ourver != ver)ttiax2_provision(sin, sockfd, NULL, rsi, 1);treturn 0;}",2,"cwe119,cwe120"
"stlc2500_init(int dd, bdaddr_t *bdaddr){tunsigned char cmd[16];tunsigned char buf[254];tuint16_t version;tint len;tint err;t tlen = do_command(dd, 0xff, 0x000f, NULL, 0, buf, sizeof(buf));tif (len < 0)ttreturn -1;tprintf(""%s"", buf);t tlen = do_command(dd, 0x04, 0x0001, NULL, 0, buf, sizeof(buf));tif (len < 0)ttreturn -1;tversion = buf[2] << 8 | buf[1];terr = load_file(dd, version, "".ptc"");tif (err < 0) {ttif (err == -ENOENT)tttfprintf(stderr, ""No ROM patch file loaded."");ttelsetttreturn -1;t}terr = load_file(dd, buf[2] << 8 | buf[1], "".ssf"");tif (err < 0) {ttif (err == -ENOENT)tttfprintf(stderr, ""No static settings file loaded."");ttelsetttreturn -1;t}tcmd[0] = 0xfe;tcmd[1] = 0x06;tbacpy((bdaddr_t *) (cmd + 2), bdaddr);t tlen = do_command(dd, 0xff, 0x0022, cmd, 8, buf, sizeof(buf));tif (len < 0)ttreturn -1;t tlen = do_command(dd, 0x03, 0x0003, NULL, 0, buf, sizeof(buf));tif (len < 0)ttreturn -1;treturn 0;}",2,"cwe119,cwe120"
"fetch_files(ssh_session session){  int size;  char buffer[16384];  int mode;  char *filename;  int r;  ssh_scp scp=ssh_scp_new(session, SSH_SCP_READ | SSH_SCP_RECURSIVE, ""/tmp/libssh_tests/*"");  if(ssh_scp_init(scp) != SSH_OK){t  fprintf(stderr,""error initializing scp: %s"",ssh_get_error(session));t  ssh_scp_free(scp);t  return -1;  }  printf(""Trying to download 3 files (a,b,d) and 1 directory (c)"");  do {t  r=ssh_scp_pull_request(scp);t  switch(r){t  case SSH_SCP_REQUEST_NEWFILE:tt  size=ssh_scp_request_get_size(scp);tt  filename=strdup(ssh_scp_request_get_filename(scp));tt  mode=ssh_scp_request_get_permissions(scp);tt  printf(""downloading file %s, size %d, perms 0%o"",filename,size,mode);tt  free(filename);tt  ssh_scp_accept_request(scp);tt  r=ssh_scp_read(scp,buffer,sizeof(buffer));tt  if(r==SSH_ERROR){ttt  fprintf(stderr,""Error reading scp: %s"",ssh_get_error(session));ttt  ssh_scp_close(scp);ttt  ssh_scp_free(scp);ttt  return -1;tt  }tt  printf(""done"");tt  break;t  case SSH_ERROR:tt  fprintf(stderr,""Error: %s"",ssh_get_error(session));tt  ssh_scp_close(scp);tt  ssh_scp_free(scp);tt  return -1;t  case SSH_SCP_REQUEST_WARNING:tt  fprintf(stderr,""Warning: %s"",ssh_scp_request_get_warning(scp));tt  break;t  case SSH_SCP_REQUEST_NEWDIR:tt  filename=strdup(ssh_scp_request_get_filename(scp));tt  mode=ssh_scp_request_get_permissions(scp);tt  printf(""downloading directory %s, perms 0%o"",filename,mode);tt  free(filename);tt  ssh_scp_accept_request(scp);tt  break;t  case SSH_SCP_REQUEST_ENDDIR:tt  printf(""End of directory"");tt  break;t  case SSH_SCP_REQUEST_EOF:tt  printf(""End of requests"");tt  goto end;t  }  } while (1);  end:  ssh_scp_close(scp);  ssh_scp_free(scp);  return 0;}",2,"cwe119,cwe120"
"gui_save_object(struct gui_object *cur){tchar tmp[256];tDBT key, data;tint res;tif (db && cur) {ttif (strlen(cur->ident)) {tttsnprintf(tmp, sizeof(tmp), ""%d:%d"", cur->widget->allocation.x, cur->widget->allocation.y);tttmemset(&key, 0, sizeof(key));tttmemset(&data, 0, sizeof(data));tttkey.data = cur->ident;tttkey.size = strlen(cur->ident) + 1;tttdata.data = tmp;tttdata.size = strlen(tmp) + 1;#ifdef __FreeBSD__tttif ((res = db->put(db, &key, &data, 0)))#elsetttif ((res = db->put(db, NULL, &key, &data, 0)))#endifttttfprintf(stderr, ""Unable to save '%s' location"", cur->ident);ttttt}t}treturn 0;}",2,"cwe119,cwe120"
"gip_changed(const char *filename, void *idx_ptr){tFILE *f;tchar buf[80];tuint count;tunsigned idx = pointer_to_uint(idx_ptr);tf = file_fopen(filename, ""r"");tif (f == NULL)ttreturn;tcount = gip_load(f, idx);tfclose(f);tstr_bprintf(buf, sizeof buf, ""Reloaded %u geographic IPv%c ranges."",ttcount, GIP_IPV4 == idx ? '4' : '6');tgcu_statusbar_message(buf);}",2,"cwe119,cwe120"
"lua_cwd(lua_State *L){#ifdef LUA_WIN  char drv[2];  int l;  SB sb;  sbinit(&sb);  drv[0] = '.'; drv[1] = 0;  l = GetFullPathNameA(drv, sb.maxlen, sb.buffer, 0);  if (l > sb.maxlen) {    sbgrow(&sb, l+1);    l = GetFullPathNameA(drv, sb.maxlen, sb.buffer, 0);  }  if (l <= 0)    return sbsetpush(L, &sb, ""."");  sb.len += l;  return sbpush(L, &sb);#elif HAVE_GETCWD    const char *s;  SB sb;  sbinit(&sb);  s = getcwd(sb.buffer, sb.maxlen);  while (!s && errno==ERANGE)    {      sbgrow(&sb, sb.maxlen + SBINCREMENT);      s = getcwd(sb.buffer, sb.maxlen);    }  if (! s)    return sbsetpush(L, &sb, ""."");  sb.len += strlen(s);  return sbpush(L, &sb);#else    const char *s;  SB sb;  sbinit(&sb);  sbgrow(&sb, PATH_MAX);   s = getwd(sb.buffer);  if (! s)    return sbsetpush(L, &sb, ""."");  sb.len += strlen(s);  return sbpush(L, &sb);#endif}",3,"cwe119,cwe120,cweother"
"_apply_cfdata(E_Config_Dialog *cfd __UNUSED__, E_Config_Dialog_Data *cfdata){   const char *cur_profile;   E_Action *a;   cur_profile = e_config_profile_get();   if (strcmp(cur_profile, cfdata->sel_profile) == 0)     return 1;   e_config_save_flush();   e_config_profile_set(cfdata->sel_profile);   e_config_profile_save();   e_config_save_block_set(1);   a = e_action_find(""restart"");   if ((a) && (a->func.go)) a->func.go(NULL, NULL);   return 1;}",2,"cwe119,cwe120"
"nmc_ip6_address_as_string (const struct in6_addr *ip, GError **error){tchar buf[INET6_ADDRSTRLEN];tg_return_val_if_fail (error == NULL || *error == NULL, NULL);tmemset (&buf, '0', sizeof (buf));tif (inet_ntop (AF_INET6, ip, buf, INET6_ADDRSTRLEN)) {ttreturn g_strdup (buf);t} else {ttif (error) {tttint j;tttGString *ip6_str = g_string_new (NULL);tttg_string_append_printf (ip6_str, ""%02X"", ip->s6_addr[0]);tttfor (j = 1; j < 16; j++)ttttg_string_append_printf (ip6_str, "" %02X"", ip->s6_addr[j]);tttg_set_error (error, NMCLI_ERROR, 0, _(""Error converting IP6 address '%s' to text form""),ttt             ip6_str->str);tttg_string_free (ip6_str, TRUE);tt}ttreturn NULL;t}}",2,"cwe119,cwe120"
"utest_viterbi(ESL_GETOPTS *go, ESL_RANDOMNESS *r, ESL_ALPHABET *abc, P7_BG *bg, P7_PROFILE *gm, int nseq, int L){  float     avg_sc = 0.;  char      errbuf[eslERRBUFSIZE];  ESL_DSQ  *dsq = NULL;  P7_GMX   *gx  = NULL;  P7_TRACE *tr  = NULL;  int       idx;  float     sc1, sc2;  if ((dsq    = malloc(sizeof(ESL_DSQ) *(L+2))) == NULL)  esl_fatal(""malloc failed"");  if ((tr     = p7_trace_Create())              == NULL)  esl_fatal(""trace creation failed"");  if ((gx     = p7_gmx_Create(gm->M, L))        == NULL)  esl_fatal(""matrix creation failed"");  for (idx = 0; idx < nseq; idx++)    {      if (esl_rsq_xfIID(r, bg->f, abc->K, L, dsq) != eslOK) esl_fatal(""seq generation failed"");      if (p7_GViterbi(dsq, L, gm, gx, &sc1)       != eslOK) esl_fatal(""viterbi failed"");      if (p7_GTrace  (dsq, L, gm, gx, tr)         != eslOK) esl_fatal(""trace failed"");      if (p7_trace_Validate(tr, abc, dsq, errbuf) != eslOK) esl_fatal(""trace invalid:%s"", errbuf);      if (p7_trace_Score(tr, dsq, gm, &sc2)       != eslOK) esl_fatal(""trace score failed"");      if (esl_FCompare(sc1, sc2, 1e-6)            != eslOK) esl_fatal(""Trace score != Viterbi score"");       if (p7_bg_NullOne(bg, dsq, L, &sc2)         != eslOK) esl_fatal(""null score failed"");      avg_sc += (sc1 - sc2);      if (esl_opt_GetBoolean(go, ""--vv""))       tprintf(""utest_viterbi: Viterbi score: %.4f (null %.4f) (total so far: %.4f)"", sc1, sc2, avg_sc);      p7_trace_Reuse(tr);    }  avg_sc /= (float) nseq;  if (avg_sc > 0.) esl_fatal(""Viterbi scores have positive expectation (%f nats)"", avg_sc);  p7_gmx_Destroy(gx);  p7_trace_Destroy(tr);  free(dsq);  return;}",2,"cwe119,cwe120"
"create_simage(void){    simage_t *s;    s = (simage_t *) MALLOC(sizeof(simage_t));    MEMSET(s, 0, sizeof(simage_t));    s->pmap = (pixmap_t *) MALLOC(sizeof(pixmap_t));    s->iml = (imlib_t *) MALLOC(sizeof(imlib_t));    MEMSET(s->pmap, 0, sizeof(pixmap_t));    MEMSET(s->iml, 0, sizeof(imlib_t));    return s;}",2,"cwe476,cweother"
"ReleaseChiSymbolBuf( ChewingData *pgdata, ChewingOutput *pgo ){tint throwEnd;tuint16_t bufPhoneSeq[ MAX_PHONE_SEQ_LEN + 1 ];tchar bufWordSeq[ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ];tthrowEnd = CountReleaseNum( pgdata );tpgo->nCommitStr = throwEnd;tif ( throwEnd ) {tt ttWriteChiSymbolToBuf( pgo->commitStr, throwEnd, pgdata );tt ttmemcpy( bufPhoneSeq, pgdata->phoneSeq, sizeof( uint16_t ) * throwEnd );ttbufPhoneSeq[ throwEnd ] = (uint16_t) 0;ttueStrNCpy( bufWordSeq, pgdata->phrOut.chiBuf, throwEnd, 1 );ttUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );ttKillFromLeft( pgdata, throwEnd );t}treturn throwEnd;}",3,"cwe119,cwe120,cweother"
"SDLVid_SetCaption(){tchar szName[100];tif (SDL_VideoDriverName(szName, 100)) {ttchar szCap[1024];ttsprintf(szCap, ""SDL Video Output (%s)"", szName);ttSDL_WM_SetCaption(szCap, NULL);t} else {ttSDL_WM_SetCaption(""SDL Video Output"", NULL);t}}",2,"cwe119,cwe120"
"ios_get_entry(FILE *handle, UINT32 pcr_index, UINT32 *num, TSS_PCR_EVENT **ppEvent){tchar page[BIOS_READ_SIZE];tUINT32 seen_indices = 0;tTSS_RESULT result = TSS_E_INTERNAL_ERROR;tTSS_PCR_EVENT *e = NULL;tTCG_PCClientPCREventStruc *event = NULL;twhile (1) {tt ttif ((fread(page, 32, 1, handle)) == 0) {tttgoto done;tt}ttevent = (TCG_PCClientPCREventStruc *)page;ttif (pcr_index == event->pcrIndex) {tttif (ppEvent && !*ppEvent && seen_indices == *num) {tttt*ppEvent = calloc(1, sizeof(TSS_PCR_EVENT));ttttif (*ppEvent == NULL) {tttttLogError(""malloc of %zd bytes failed."",tttttt sizeof(TSS_PCR_EVENT));tttttreturn TSS_E_INTERNAL_ERROR;tttt}tttte = *ppEvent;tttte->rgbPcrValue = malloc(20);ttttif (e->rgbPcrValue == NULL) {tttttLogError(""malloc of %d bytes failed."", 20);tttttfree(e);ttttte = NULL;tttttbreak;tttt}tttte->ulPcrIndex = pcr_index;tttte->eventType = event->eventType;tttte->ulPcrValueLength = 20;tttt ttttmemcpy(e->rgbPcrValue, event->digest, 20);tttte->ulEventLength = event->eventDataSize;ttttif (event->eventDataSize>0) {ttttte->rgbEvent = malloc(e->ulEventLength);tttttif (e->rgbEvent == NULL) {ttttttLogError(""malloc of %d bytes failed."",ttttttt e->ulEventLength);ttttttfree(e->rgbPcrValue);ttttttfree(e);tttttte = NULL;ttttttbreak;ttttt}tttttif ((fread(e->rgbEvent,tttttt   event->eventDataSize,tttttt   1, handle)) <= 0) {ttttttLogError(""read from event source failed: %s"",ttttttt strerror(errno));ttttttreturn result;ttttt}tttt} else {ttttte->rgbEvent = NULL;tttt}ttttresult = TSS_SUCCESS;ttttbreak;ttt} else {tttt ttttif (event->eventDataSize > 0) {tttttfseek(handle,event->eventDataSize,SEEK_CUR);tttt}ttt}tttseen_indices++;tt} else {ttt tttif (event->eventDataSize > 0) {ttttfseek(handle,event->eventDataSize,SEEK_CUR);ttt}tt}t}done:tif (!ppEvent) {tt*num = seen_indices;ttresult = TSS_SUCCESS;t} else if (e == NULL)tt*ppEvent = NULL;treturn result;}",2,"cwe119,cwe120"
"DisplaySize(TwmWindow *tmp_win, int width, int height){    char str[100];    int dwidth;    int dheight;        if (last_width == width && last_height == height)        return;    last_width = width;    last_height = height;    dheight = height - tmp_win->title_height - 2 * tmp_win->frame_bw3D;    dwidth = width - 2 * tmp_win->frame_bw3D;         if (tmp_win->hints.flags&(PMinSize|PBaseSize) && tmp_win->hints.flags & PResizeInc)    {tif (tmp_win->hints.flags & PBaseSize) {t    dwidth -= tmp_win->hints.base_width;t    dheight -= tmp_win->hints.base_height;t} else {t    dwidth -= tmp_win->hints.min_width;t    dheight -= tmp_win->hints.min_height;t}    }    if (tmp_win->hints.flags & PResizeInc)    {        dwidth /= tmp_win->hints.width_inc;        dheight /= tmp_win->hints.height_inc;    }    (void) sprintf (str, "" %4d x %-4d "", dwidth, dheight);    XRaiseWindow(dpy, Scr->SizeWindow);    Draw3DBorder (Scr->SizeWindow, 0, 0,ttScr->SizeStringOffset + Scr->SizeStringWidth + SIZE_HINDENT,ttScr->SizeFont.height + SIZE_VINDENT * 2,tt2, Scr->DefaultC, off, False, False);#ifdef I18N    FB(Scr->DefaultC.fore, Scr->DefaultC.back);    XmbDrawImageString (dpy, Scr->SizeWindow, Scr->SizeFont.font_set,tt      Scr->NormalGC, Scr->SizeStringOffset,tt      Scr->SizeFont.ascent + SIZE_VINDENT, str, 13);#else        FBF(Scr->DefaultC.fore, Scr->DefaultC.back, Scr->SizeFont.font->fid);    XDrawImageString (dpy, Scr->SizeWindow, Scr->NormalGC,tt      Scr->SizeStringOffset,tt      Scr->SizeFont.font->ascent + SIZE_VINDENT,tt      str, 13);#endif}",2,"cwe119,cwe120"
"update_hosts(char* host, char* addr){  char buf[BUFSIZ+1], *name = HOSTS_PATH "".asp"";  FILE *fp1, *fp2;  int c, m;  if((fp1 = fopen(HOSTS_PATH, ""r+"")) == NULL) asp_perror(""fopen"");     if((fp2 = fopen(name, ""w"")) == NULL) asp_perror(""fopen"");  do{     fgets(buf, BUFSIZ, fp1);    if((m = match(buf, host))) break;    fputs(buf, fp2);  }while(!feof(fp1));  if(m){    if(addr != NULL) fprintf(fp2, ""%st%s"", addr, host);    while((c = fgetc(fp1)) != EOF)      fputc(c, fp2);                                            if(rename(name, HOSTS_PATH) == -1) asp_perror(""rename"");  }else{    if(addr != NULL){      if(strchr(buf, '')) fprintf(fp1, ""%st%s"", addr, host);      else fprintf(fp1, ""%st%s"", addr, host);t }    if(remove(name) == -1) asp_perror(""remove"");  }  fclose(fp1);  fclose(fp2);}",3,"cwe119,cwe120,cweother"
"validatedev(const char *devname){tconst   chart*name;tstructtstattsbuf;tchartfullpath[PATH_MAX];tif  (devname[0] == '/')ttname = devname;telse  {ttsprintf(fullpath, ""/dev/%s"", devname);ttname = fullpath;t}tif  (stat(name, &sbuf) < 0)ttreturn  86;t tdisp_arg[8] = sbuf.st_uid;tif  (sbuf.st_uid != Daemuid)  {ttif  ((sbuf.st_mode & 022) != 022)tttreturnt91;t ttreturnt90;t t}tif  ((sbuf.st_mode & 0600) != 0600)ttreturnt92;t tswitch  (sbuf.st_mode & S_IFMT)  {tcase  S_IFBLK:ttreturn  87;t tcase  S_IFREG:ttreturn  88;t tcase  S_IFIFO:ttreturnt89;t t}treturn  0;}",2,"cwe119,cwe120"
"add_header_color_line(struct pine *ps, CONF_S **ctmp, char *val, int which){    struct variable *vtmp;    SPEC_COLOR_S     *hc;    chart     tmp[100+1];    int              l;    vtmp = &ps->vars[V_VIEW_HDR_COLORS];    l = strlen(HEADER_WORD);         new_confline(ctmp);    (*ctmp)->flagstt|= CF_NOSELECT | CF_B_LINE;    new_confline(ctmp)->vart = vtmp;    (*ctmp)->varnameptt = *ctmp;    (*ctmp)->keymenutt = &custom_color_setting_keymenu;    (*ctmp)->helptt = config_help(vtmp - ps->vars, 0);    (*ctmp)->tooltt = color_setting_tool;    (*ctmp)->flags |= (CF_STARTITEM | CF_COLORSAMPLE | CF_POT_SLCTBL);    if(!pico_usingcolor())      (*ctmp)->flags |= CF_NOSELECT;         (*ctmp)->varmemtt = CFC_SET_COLOR(which, 0);    hc = spec_color_from_var(val, 0);    if(hc && hc->inherit)      (*ctmp)->flags = (CF_NOSELECT | CF_INHERIT);    else{t tutf8_snprintf(tmp, sizeof(tmp), ""%s%c%.*w Color%*w %s%s"",ttHEADER_WORD,tt(hc && hc->spec) ? (islower((unsigned char)hc->spec[0])ttttt    ? toupper((unsigned char)hc->spec[0])ttttt    : hc->spec[0]) : '?',ttMIN(utf8_width((hc && hc->spec && hc->spec[0]) ? hc->spec+1 : """"),30-l),tt(hc && hc->spec && hc->spec[0]) ? hc->spec+1 : """",ttMAX(EQ_COL - COLOR_INDENT -1 -tt   MIN(utf8_width((hc && hc->spec && hc->spec[0]) ? hc->spec+1 : """"),30-l)ttt    - l - 6 - 1, 0), """",ttsample_text(ps,vtmp),ttcolor_parenthetical(vtmp));ttmp[sizeof(tmp)-1] = '0';t(*ctmp)->valuett = cpystr(tmp);    }    (*ctmp)->valoffsettt = COLOR_INDENT;    if(hc)      free_spec_colors(&hc);}",2,"cwe119,cwe120"
"amdlibLogPrint(amdlibLOG_LEVEL level, amdlibBOOLEAN isDetail, const char *fileLine,                  const char *format, ...){    va_list  argPtr;         if ((amdlibLogConfig.enabled == amdlibTRUE) &&         (level <= amdlibLogConfig.level))    {                 if (amdlibLogConfig.printDate == amdlibTRUE)        {            char infoTime[32];                         amdlibGetTimeStamp(infoTime, 6);                         printf(""%s - "", infoTime);        }                 if ((fileLine != NULL ) &&            (amdlibLogConfig.printFileLine == amdlibTRUE))        {                         fprintf(stdout, ""%s - "", fileLine);        }                 if (isDetail == amdlibFALSE)        {                         switch (level)            {                case amdlibLOG_ERROR:                    fprintf(stdout, "" ERROR : "");                    break;                case amdlibLOG_WARNING:                    fprintf(stdout, "" WARNING : "");                    break;                default:                    fprintf(stdout, "" "");                    break;            }        }        else        {                         fprintf(stdout, ""    "");        }                         va_start(argPtr, format);        vfprintf(stdout, format, argPtr);        fprintf(stdout, """");        fflush(stdout);        va_end(argPtr);    }}",3,"cwe119,cwe120,cweother"
initialize(int n) {tthis->nVertices  = n;tthis->vertices = (Vertex * *) malloc( n * sizeof(Vertex*));tfor(int i=0; i<n; i++)ttvertices[i] = new Vertex(i);},2,"cwe120,cweother"
"mastermind_get_pixmap (int idx, int color){tint fg = 0, bg = 0, i;tchar *colors;tstatic char pixbuf[MASTERMIND_CELL_SIZE*(MASTERMIND_CELL_SIZE)+1];tstatic char dice_pixbuf[MASTERMIND_CELL_SIZE*(MASTERMIND_CELL_SIZE)+1];tstatic gboolean first = TRUE;tcolors = mastermind_colors;tif (idx == MASTERMIND_ARROW)ttreturn arrow_blue_left_40_xpm;telse if (idx == MASTERMIND_RETURN)ttreturn arrow_blue_return_40_xpm;tif (idx < 16)t{ttfg += (idx & 1);ttfg += (idx & 2 ? 256 : 0);ttfg += (idx & 4 ? 65536 : 0);ttfg *= 255;ttif (idx >= 9 && idx <= 14) fg = 100 * 0x10101;ttif (color == BLACK) colors += 3;ttfor(i=0, bg=0;i<3;i++) tt{ int col = colors[i]; if (col<0) col += 256; bg += col * (1 << (16-8*i));}ttif (first)tt{tttfirst = FALSE;tttreturn pixmap_ball_gentttt(MASTERMIND_CELL_SIZE, pixbuf, fg, bg, 10.0, 30.0);tt}ttreturn  pixmap_header_gen ttt(MASTERMIND_CELL_SIZE, pixbuf, fg, bg);t}telse if (idx < 25)t{ttint num = (idx <= 20 ? idx - 16 : idx - 20);ttfor(i=0, bg=0;i<3;i++) tt{ int col = colors[i]; if (col<0) col += 256; bg += col * (1 << (16-8*i));}ttfg = (idx <= 20 ? 0 : 0xffffff);ttreturn pixmap_die_gen(MASTERMIND_CELL_SIZE, dice_pixbuf, fg, bg, 3.0, 30.0, num);t}telse return red_X_40_xpm;treturn NULL;}",2,"cwe119,cwe120"
"parser_read_file_full( FILE *file, PData *top ){    PData *sub = 0;    char token[1024];         while ( !feof( file ) ) {        if ( ( sub = parser_parse_file( file ) ) != 0 )            list_add( top->entries, sub );        else            return 0;                  if ( !file_read_token( file, PARSER_SYMBOLS, PARSER_SKIP_SYMBOLS, token ) ) {            if ( token[0] != 0 )                return 0;            break;        }        else            fseek( file, -strlen( token ), SEEK_CUR );    }    return 1;}",2,"cwe119,cwe120"
"archive_read_format_iso9660_cleanup(struct archive_read *a){    struct iso9660 *iso9660;    struct file_info *file;    int r = ARCHIVE_OK;    iso9660 = (struct iso9660 *)(a->format->data);    while ((file = next_entry(iso9660)) != NULL)        release_file(iso9660, file);    archive_string_free(&iso9660->pathname);    archive_string_free(&iso9660->previous_pathname);    if (iso9660->pending_files)        free(iso9660->pending_files);#ifdef HAVE_ZLIB_H    free(iso9660->entry_zisofs.uncompressed_buffer);    free(iso9660->entry_zisofs.block_pointers);    if (iso9660->entry_zisofs.stream_valid) {        if (inflateEnd(&iso9660->entry_zisofs.stream) != Z_OK) {            archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,                ""Failed to clean up zlib decompressor"");            r = ARCHIVE_FATAL;        }    }#endif    free(iso9660);    (a->format->data) = NULL;    return (r);}",2,"cwe119,cwe120"
"SaveRAW(const char *name, void *data, Uint32 size,ttint format, int rate, int loop){tunsigned char header[8] = ""RAW0rate"";tint result;tFILE *f = fopen(name, ""wb"");tif(!f)ttreturn -1;theader[3] = (char)format;tif(loop)ttheader[3] |= 0x80;theader[4] = rate & 0xff;theader[5] = (rate >> 8) & 0xff;theader[6] = (rate >> 16) & 0xff;theader[7] = (rate >> 24) & 0xff;tif(fwrite(header, sizeof(header), 1, f) != 1)ttreturn -2;tflip_endian(data, size, format);tresult = fwrite(data, size, 1, f);tflip_endian(data, size, format);tif(result != 1)ttreturn -3;tfclose(f);treturn 0;}",3,"cwe119,cwe120,cweother"
"ay_buddy_quit(const char *message, irc_message_prefix *prefix,tirc_account *ia){tConversation *ecr;tLList *node = chat_window_list;tchar buddy_name[BUF_LEN];teb_account *ea;teb_local_account *ela = (eb_local_account *)ia->data;tay_irc_account *eia;tfor (; node; node = node->next) {ttchat_window *cw = (chat_window *)node->data;ttecr = cw->conv;ttif (ecr &&tttecr->local_user->service_id ==tttSERVICE_INFO.protocol_id) {tttif (ay_conversation_buddy_connected(ecr, prefix->nick)) {ttttsnprintf(buddy_name, sizeof(buddy_name),ttttt""%s@%s"", prefix->nick,tttttia->connect_address);tttt ttttif ((ea = find_account_with_ela(buddy_name,tttttttela))) {ttttteb_debug(DBG_IRC,tttttt""Logged off QUITed user: %s"",ttttttbuddy_name);ttttteia = (ay_irc_account *)ea->ttttttprotocol_account_data;tttttif (eia->status == !IRC_OFFLINE) {ttttttif (eia->dummy) {tttttttea->account_contact->ttttttttonline--;tttttttea->online = FALSE;tttttttif (!ea->ttttttttaccount_contact->ttttttttonline)ttttttttea->account_contact->group->contacts_online--;ttttttteb_debug(DBG_IRC,tttttttt""Dummy logoff: %s"",ttttttttea->handle);tttttt} else {ttttttteb_debug(DBG_IRC,tttttttt""Buddy logoff: %s"",ttttttttea->handle);tttttttbuddy_logoff(ea);tttttt}ttttt}tttttbuddy_update_status(ea);ttttteia->status = IRC_OFFLINE;tttt}ttttif (message && *message) {tttttchar *buf;tttttbuf = g_strdup_printf(_tttttt(""Quit reason: %s""), message);tttttay_conversation_buddy_leave_ex(ecr,ttttttprefix->nick, buf);tttttg_free(buf);tttt} elsetttttay_conversation_buddy_leave(ecr,ttttttprefix->nick);ttt}tt}t}}",2,"cwe119,cwe120"
"check_lab_desc(uint16 tag, uint16 ref, char *label, char *desc){    int32       inlablen, indesclen, ret;    char        inlabel[MAXLEN_LAB], *indesc;    inlablen = ret = DFANgetlablen(TESTFILE, tag, ref);    RESULT(""DFANgetlablen"");    if (inlablen != (int32) HDstrlen(label))      {          printf(""t>>>BAD LABEL LENGTH.t       IS: %dtSHOULD BE: %d<<<"",                 (int) inlablen, (int) HDstrlen(label));          num_errs++;      }    ret = DFANgetlabel(TESTFILE, tag, ref, inlabel, MAXLEN_LAB);    RESULT(""DFANgetlabel"");    if (HDstrcmp(inlabel, label) != 0)      {          printf(""t>>>BAD LABEL. t       IS: %s; tSHOULD BE: %s<<<"",                 inlabel, label);          num_errs++;      }    indesclen = ret = DFANgetdesclen(TESTFILE, tag, ref);    RESULT(""DFANgetdesclen"");    if (indesclen != (int32) HDstrlen(desc))      {          printf(""t>>>BAD DESCRIPTION LENGTH. t       IS: %d"", (int) indesclen);          printf(""tSHOULD BE: %d<<<"", (int) HDstrlen(desc));          num_errs++;      }    else      {          indesc = (char *) HDmalloc(indesclen + 1);          ret = DFANgetdesc(TESTFILE, tag, ref, indesc, MAXLEN_DESC);          RESULT(""DFANgetdesc"");          indesc[indesclen] = '0';          if (HDstrcmp(indesc, desc) != 0)            {                printf(""t>>>BAD DESCRIPTION.t      IS: %s"", indesc);                printf(""tSHOULD BE: %s<<<"", desc);                num_errs++;            }          HDfree((VOIDP) indesc);      }}",2,"cwe119,cwe120"
"""PaOssStreamComponent_Read( PaOssStreamComponent *component, unsigned long *frames ){    PaError result = paNoError;    size_t len = *frames * PaOssStreamComponent_FrameSize( component );    ssize_t bytesRead;    ENSURE_( bytesRead = read( component->fd, component->buffer, len ), paUnanticipatedHostError );    *frames = bytesRead / PaOssStreamComponent_FrameSize( component );    /* TODO: Handle condition where number of frames read doesn't equal number of frames requested */error:    return result;}""",2,"cwe120,cweother"
"asn1_print_info(BIO *bp, int tag, int xclass, int constructed,t     int indent)t{tstatic const char fmt[]=""%-18s"";tstatic const char fmt2[]=""%2d %-15s"";tchar str[128];tconst char *p,*p2=NULL;tif (constructed & V_ASN1_CONSTRUCTED)ttp=""cons: "";telsettp=""prim: "";tif (BIO_write(bp,p,6) < 6) goto err;#if OPENSSL_VERSION_NUMBER >= 0x0090701fLtBIO_indent(bp,indent,128);#endiftp=str;tif ((xclass & V_ASN1_PRIVATE) == V_ASN1_PRIVATE)tttsprintf(str,""priv [ %d ] "",tag);telse if ((xclass & V_ASN1_CONTEXT_SPECIFIC) == V_ASN1_CONTEXT_SPECIFIC)ttsprintf(str,""cont [ %d ]"",tag);telse if ((xclass & V_ASN1_APPLICATION) == V_ASN1_APPLICATION)ttsprintf(str,""appl [ %d ]"",tag);telse p = ASN1_tag2str(tag);tif (p2 != NULL)tt{ttif (BIO_printf(bp,fmt2,tag,p2) <= 0) goto err;tt}telsett{ttif (BIO_printf(bp,fmt,p) <= 0) goto err;tt}treturn(1);err:treturn(0);t}",2,"cwe119,cwe120"
"_echo_header(const char   *name,             size_t        n_values,             const char   *datatype_name){  char name_pad[33] = """";  char type_pad[3] = """";  if (strlen(name) < 32) {    memset(name_pad, ' ', sizeof(name_pad));    name_pad[32 - strlen(name)] = '0';  }  if (strlen(datatype_name) < 2) {    type_pad[0] = ' '; type_pad[1] = ' ';    type_pad[2 - strlen(datatype_name)] = '0';  }  if (n_values > 0)    printf(_(""  Wrote: ""%s""%s; Type: ""%s""%s; Size: %lu""),           name, name_pad, datatype_name, type_pad,           (unsigned long)n_values);  else    printf(_(""  Wrote: ""%s""""),           name);  fflush(stdout);}",2,"cwe119,cwe120"
"_iodbcdm_pool_set_retry_wait (HDBC hdbc){  CONN (pdbc, hdbc);  int retry_wait = 0;  char buf[1024];     SQLSetConfigMode (ODBC_BOTH_DSN);  if (SQLGetPrivateProfileString (""ODBC Connection Pooling"", ""Retry Wait"", """",         buf, sizeof (buf), ""odbcinst.ini"") != 0 &&         buf[0] != '0')    retry_wait = atoi(buf);  DPRINTF ((stderr, ""DEBUG: setting RetryWait %d (conn %p)"",      retry_wait, hdbc));  pdbc->cp_retry_wait = time(NULL) + retry_wait;}",3,"cwe119,cwe120,cweother"
"ReadALConfig(void){    const char *str;    FILE *f;    cfgBlocks = calloc(1, sizeof(ConfigBlock));    cfgBlocks->name = strdup(""general"");    cfgCount = 1;#ifdef _WIN32    if(SHGetSpecialFolderPathA(NULL, buffer, CSIDL_APPDATA, FALSE) != FALSE)    {        size_t p = strlen(buffer);        snprintf(buffer+p, sizeof(buffer)-p, ""alsoft.ini"");        f = fopen(buffer, ""rt"");        if(f)        {            LoadConfigFromFile(f);            fclose(f);        }    }#else    f = fopen(""/etc/openal/alsoft.conf"", ""r"");    if(f)    {        LoadConfigFromFile(f);        fclose(f);    }    if((str=getenv(""HOME"")) != NULL && *str)    {        snprintf(buffer, sizeof(buffer), ""%s/.alsoftrc"", str);        f = fopen(buffer, ""r"");        if(f)        {            LoadConfigFromFile(f);            fclose(f);        }    }#endif    if((str=getenv(""ALSOFT_CONF"")) != NULL && *str)    {        f = fopen(str, ""r"");        if(f)        {            LoadConfigFromFile(f);            fclose(f);        }    }}",2,"cwe469,cweother"
"get_efi_runtime_map(struct efi_mem_descriptor **map){tDIR *dirp;tstruct dirent *entry;tchar filename[1024];tstruct efi_mem_descriptor md, *p = NULL;tint nr_maps = 0;tdirp = opendir(""/sys/firmware/efi/runtime-map"");tif (!dirp)ttreturn 0;twhile ((entry = readdir(dirp)) != NULL) {ttsprintf(filename,ttt""/sys/firmware/efi/runtime-map/%s"",ttt(char *)entry->d_name);ttif (*entry->d_name == '.')tttcontinue;ttfile_scanf(filename, ""type"", ""0x%x"", (unsigned int *)&md.type);ttfile_scanf(filename, ""phys_addr"", ""0x%llx"",ttt   (unsigned long long *)&md.phys_addr);ttfile_scanf(filename, ""virt_addr"", ""0x%llx"",ttt   (unsigned long long *)&md.virt_addr);ttfile_scanf(filename, ""num_pages"", ""0x%llx"",ttt   (unsigned long long *)&md.num_pages);ttfile_scanf(filename, ""attribute"", ""0x%llx"",ttt   (unsigned long long *)&md.attribute);ttp = realloc(p, (nr_maps + 1) * sizeof(md));ttif (!p)tttgoto err_out;tt*(p + nr_maps) = md;tt*map = p;ttnr_maps++;t}tclosedir(dirp);treturn nr_maps;err_out:tif (map)ttfree(map);tclosedir(dirp);treturn 0;}",3,"cwe119,cwe120,cweother"
"handle_extent (struct file_extent ext, unsigned int sectors_per_block, __u64 start_lba){tchar lba_info[64], len_info[32];t__u64 begin_lba, end_lba;t__u64 nsectors = ext.block_count * sectors_per_block;tif (ext.first_block) {ttbegin_lba = start_lba + ( ext.first_block     * sectors_per_block);ttend_lba   = start_lba + ((ext.last_block + 1) * sectors_per_block) - 1;t} else {ttbegin_lba = end_lba = 0;t}tif (ext.first_block)ttsprintf(lba_info, ""%10llu %10llu"", begin_lba, end_lba);telsettstrcpy(lba_info, ""      -          -   "");tif (!ext.first_block && !nsectors)ttstrcpy(len_info, ""      -   "");telsettsprintf(len_info, ""%10llu"", nsectors);tprintf(""%12llu %s %s"", ext.byte_offset, lba_info, len_info);}",2,"cwe119,cwe120"
"CheckParseString(char *lval,char *s,char *range){ char output[CF_BUFSIZE];  Debug(""CheckParseString(%s => %s/%s)"",lval,s,range);if (s == NULL)   {   return true;   }if (strlen(range) == 0)   {   return true;   }if (IsNakedVar(s,'@')||IsNakedVar(s,'$'))   {   Debug(""Validation: Unable to verify variable expansion of %s at this stage"",s);   return false;   } if (strcmp(lval,""mode"") == 0 || strcmp(lval,""search_mode"") == 0)   {   mode_t plus,minus;      if (!ParseModeString(s,&plus,&minus))      {      snprintf(output,CF_BUFSIZE,""Error parsing Unix permission string %s)"",s);      ReportError(output);      return false;      }   }if (FullTextMatch(range,s))   {   return true;   }if (IsCf3VarString(s))   {   Debug(""Validation: Unable to verify syntax of %s due to variable expansion at this stage"",s);   }else   {   snprintf(output,CF_BUFSIZE,""Scalar item in %s => { %s } in rvalue is out of bounds (value should match pattern %s)"",lval,s,range);   ReportError(output);   return false;   }return true;}",2,"cwe119,cwe120"
"main (void){  char buf[BUFSIZ];  char *p;  int rc;  size_t i;  setlocale (LC_ALL, """");  printf (""Input domain encoded as `%s': "", stringprep_locale_charset ());  fflush (stdout);  if (!fgets (buf, BUFSIZ, stdin))    perror (""fgets"");  buf[strlen (buf) - 1] = '0';  printf (""Read string (length %ld): "", (long int) strlen (buf));  for (i = 0; i < strlen (buf); i++)    printf (""%02x "", buf[i] & 0xFF);  printf ("""");  rc = idna_to_unicode_lzlz (buf, &p, 0);  if (rc != IDNA_SUCCESS)    {      printf (""ToUnicode() failed (%d): %s"", rc, idna_strerror (rc));      return EXIT_FAILURE;    }  printf (""ACE label (length %ld): '%s'"", (long int) strlen (p), p);  for (i = 0; i < strlen (p); i++)    printf (""%02x "", p[i] & 0xFF);  printf ("""");  free (p);  return 0;}",2,"cwe119,cwe120"
"nuke(const char *src){tstruct stat sb;tDIR *dir;tstruct dirent *d;tchar path[PATH_MAX];tint len;tmemset(&sb, 0, sizeof(struct stat));t tif (stat(src, &sb) < 0)ttreturn 0;tif (!S_ISDIR(sb.st_mode)) {ttif (unlink(src) == 0)tttreturn 0;ttelsetttreturn 1;t}tdir = opendir(src);tif (!dir) {tt ttif (errno != EACCES)tttreturn -1;t}twhile ((d = readdir(dir))) {tt ttif (d->d_name[0] == '.' && (d->d_name[1] == '0'tt    || (d->d_name[1] == '.' && d->d_name[2] == '0')))tttcontinue;tt ttif (strlen(src) + 1 + strlen(d->d_name) >= PATH_MAX  - 1)tttcontinue;ttlen = snprintf(path, sizeof path, ""%s/%s"", src, d->d_name);ttif (len  >= sizeof path)tttreturn -1;ttmemset(&sb, 0, sizeof(struct stat));ttif (stat(path, &sb) < 0) {tttclosedir(dir);tttreturn -1;tt}ttif (nuke(path) < 0)tttreturn -1;t}tclosedir(dir);trmdir(src);treturn 0;}",2,"cwe119,cwe120"
"update_one_catalog(void *catalog_host, const void *text){tchar addr[DATAGRAM_ADDRESS_MAX];tif(domain_name_cache_lookup(catalog_host, addr)) {ttdebug(D_DEBUG, ""sending update to %s:%d"", catalog_host, CATALOG_PORT);ttdatagram_send(catalog_port, text, strlen(text), addr, CATALOG_PORT);t}treturn 1;}",2,"cwe119,cwe120"
"rb_str_match_m(int argc, VALUE *argv, VALUE str){    VALUE re, result;    if (argc < 1)       rb_raise(rb_eArgError, ""wrong number of arguments (%d for 1..2)"", argc);    re = argv[0];    argv[0] = str;    result = rb_funcall2(get_pat(re, 0), rb_intern(""match""), argc, argv);    if (!NIL_P(result) && rb_block_given_p()) {treturn rb_yield(result);    }    return result;}",2,"cwe119,cwe120"
"sco_get(int sock, GError **err, BtIOOption opt1, va_list args){tBtIOOption opt = opt1;tstruct sockaddr_sco src, dst;tstruct sco_options sco_opt;tsocklen_t len;tuint8_t dev_class[3];tuint16_t handle;tlen = sizeof(sco_opt);tmemset(&sco_opt, 0, len);tif (getsockopt(sock, SOL_SCO, SCO_OPTIONS, &sco_opt, &len) < 0) {ttERROR_FAILED(err, ""getsockopt(SCO_OPTIONS)"", errno);ttreturn FALSE;t}tif (!get_peers(sock, (struct sockaddr *) &src,tttt(struct sockaddr *) &dst, sizeof(src), err))ttreturn FALSE;twhile (opt != BT_IO_OPT_INVALID) {ttswitch (opt) {ttcase BT_IO_OPT_SOURCE:tttba2str(&src.sco_bdaddr, va_arg(args, char *));tttbreak;ttcase BT_IO_OPT_SOURCE_BDADDR:tttbacpy(va_arg(args, bdaddr_t *), &src.sco_bdaddr);tttbreak;ttcase BT_IO_OPT_DEST:tttba2str(&dst.sco_bdaddr, va_arg(args, char *));tttbreak;ttcase BT_IO_OPT_DEST_BDADDR:tttbacpy(va_arg(args, bdaddr_t *), &dst.sco_bdaddr);tttbreak;ttcase BT_IO_OPT_MTU:ttcase BT_IO_OPT_IMTU:ttcase BT_IO_OPT_OMTU:ttt*(va_arg(args, uint16_t *)) = sco_opt.mtu;tttbreak;ttcase BT_IO_OPT_HANDLE:tttif (sco_get_info(sock, &handle, dev_class) < 0) {ttttERROR_FAILED(err, ""SCO_CONNINFO"", errno);ttttreturn FALSE;ttt}ttt*(va_arg(args, uint16_t *)) = handle;tttbreak;ttcase BT_IO_OPT_CLASS:tttif (sco_get_info(sock, &handle, dev_class) < 0) {ttttERROR_FAILED(err, ""SCO_CONNINFO"", errno);ttttreturn FALSE;ttt}tttmemcpy(va_arg(args, uint8_t *), dev_class, 3);tttbreak;ttdefault:tttg_set_error(err, BT_IO_ERROR, BT_IO_ERROR_INVALID_ARGS,ttttt""Unknown option %d"", opt);tttreturn FALSE;tt}ttopt = va_arg(args, int);t}treturn TRUE;}",2,"cwe120,cweother"
"perfTestUInt64(uint32_t arraySize, uint32_t iterations){tdouble radix8Total_s = 0, radix11Total_s = 0;tdouble invIter = 1.0 / (double)iterations;tuint64_t * keysOrig = (uint64_t *)malloc(sizeof(uint64_t) * arraySize);tuint64_t * keys0 = (uint64_t *)malloc(sizeof(uint64_t) * arraySize);tuint64_t * keys1 = (uint64_t *)malloc(sizeof(uint64_t) * arraySize);tuint32_t * valuesOrig = (uint32_t *)malloc(sizeof(uint32_t) * arraySize);tuint32_t * values0 = (uint32_t *)malloc(sizeof(uint32_t) * arraySize);tuint32_t * values1 = (uint32_t *)malloc(sizeof(uint32_t) * arraySize);tfor (uint32_t i = 0; i < iterations; ++i)t{ttRAND_UINT64_KEYS(keysOrig, valuesOrig, keysOrig, arraySize);ttmemcpy(keys0, keysOrig, sizeof(uint64_t) * arraySize);ttmemcpy(values0, valuesOrig, sizeof(uint32_t) * arraySize);ttPRINT_UINT64_ARRAY(keys0, arraySize);ttBITS_TIMER_START(radixSort8UInt64);ttradixSort8UInt64(keys0, keys1, values0, values1, arraySize);ttradix8Total_s += BITS_TIMER_END(radixSort8UInt64);ttPRINT_UINT64_ARRAY(keys0, arraySize);ttCHECK_SORTED(keys0, values0, keysOrig, arraySize);ttmemcpy(keys0, keysOrig, sizeof(uint64_t) * arraySize);ttmemcpy(values0, valuesOrig, sizeof(uint32_t) * arraySize);ttPRINT_UINT32_ARRAY(keys0, arraySize);ttBITS_TIMER_START(radixSort11UInt64);ttradixSort11UInt64(keys0, keys1, values0, values1, arraySize);ttradix11Total_s += BITS_TIMER_END(radixSort11UInt64);ttPRINT_UINT32_ARRAY(keys0, arraySize);ttCHECK_SORTED(keys0, values0, keysOrig, arraySize);t}tfree(keysOrig);tfree(keys0);tfree(keys1);tfree(valuesOrig);tfree(values0);tfree(values1);tprintf(""%6"" PRIu32 ""  %5f  %5f"", arraySize, radix8Total_s * invIter,ttradix11Total_s * invIter);}",2,"cwe120,cweother"
"Parse_ReplyGetBattery(gn_data *data, struct gn_statemachine *state){tat_driver_instance *drvinst = AT_DRVINST(state);tconst char *line, *pos;tchar key[4];tsnprintf(key, 4, ""CBC"");tline = map_get(&drvinst->cached_capabilities, key, 1);tif (data->battery_level) {ttif (data->battery_unit)ttt*(data->battery_unit) = GN_BU_Percentage;ttpos = strchr(line, ',');ttif (pos) {tttpos++;ttt*(data->battery_level) = atoi(pos);tt} else {ttt*(data->battery_level) = 1;tt}t}tif (data->power_source) {ttpos = line + strlen(""+CBC: "");ttswitch (*pos) {ttcase '0':ttt*(data->power_source) = GN_PS_BATTERY;tttbreak;ttcase '1':ttt*(data->power_source) = GN_PS_ACDC;tttbreak;ttcase '2':ttt*(data->power_source) = GN_PS_NOBATTERY;tttbreak;ttcase '3':ttt*(data->power_source) = GN_PS_FAULT;tttbreak;ttdefault:tttdprintf(""Unknown power status '%c'"", *pos);ttt*(data->power_source) = GN_PS_UNKNOWN;tt}t}treturn GN_ERR_NONE;}",3,"cwe119,cwe120,cweother"
"adb_auth_confirm_key(unsigned char *key, size_t len, atransport *t){    char msg[MAX_PAYLOAD];    int ret;    if (framework_fd < 0) {        D(""Client not connected"");        return;    }    if (key[len - 1] != '0') {        D(""Key must be a null-terminated string"");        return;    }    ret = snprintf(msg, sizeof(msg), ""PK%s"", key);    if (ret >= (signed)sizeof(msg)) {        D(""Key too long. ret=%d"", ret);        return;    }    D(""Sending '%s'"", msg);    ret = unix_write(framework_fd, msg, ret);    if (ret < 0) {        D(""Failed to write PK, errno=%d"", errno);        return;    }    fdevent_install(&t->auth_fde, framework_fd, adb_auth_event, t);    fdevent_add(&t->auth_fde, FDE_READ);}",2,"cwe119,cwe120"
"createTanMethodString(const AH_TAN_METHOD *tm, GWEN_BUFFER *tbuf) {  const char *s;  char numbuf[32];  snprintf(numbuf, sizeof(numbuf)-1, ""%d"", AH_TanMethod_GetFunction(tm));  numbuf[sizeof(numbuf)-1]=0;  GWEN_Buffer_AppendString(tbuf, numbuf);  s=AH_TanMethod_GetMethodName(tm);  if (!(s && *s))    s=AH_TanMethod_GetMethodId(tm);  if (s && *s) {    GWEN_Buffer_AppendString(tbuf, "" - "");    GWEN_Buffer_AppendString(tbuf, s);  }     GWEN_Buffer_AppendString(tbuf, "" (Version "");  snprintf(numbuf, sizeof(numbuf)-1, ""%d"", AH_TanMethod_GetGvVersion(tm));  numbuf[sizeof(numbuf)-1]=0;  GWEN_Buffer_AppendString(tbuf, numbuf);  GWEN_Buffer_AppendString(tbuf, "")"");  return 0;}",2,"cwe119,cwe120"
"snd_card_set_id_no_lock(struct snd_card *card, const char *src,tttt    const char *nid){tint len, loops;tbool is_default = false;tchar *id;ttcopy_valid_id_string(card, src, nid);tid = card->id; again:t tif (!*id || !strncmp(id, ""card"", 4)) {ttstrcpy(id, ""Default"");ttis_default = true;t}tlen = strlen(id);tfor (loops = 0; loops < SNDRV_CARDS; loops++) {ttchar *spos;ttchar sfxstr[5];  ttint sfxlen;ttif (card_id_ok(card, id))tttreturn;  tt ttsprintf(sfxstr, ""_%X"", loops + 1);ttsfxlen = strlen(sfxstr);ttif (len + sfxlen >= sizeof(card->id))tttspos = id + sizeof(card->id) - sfxlen - 1;ttelsetttspos = id + len;ttstrcpy(spos, sfxstr);t}t tif (!is_default) {tt*id = 0;ttgoto again;t}t tdev_err(card->dev, ""unable to set card id (%s)"", id);tif (card->proc_root->name)ttstrlcpy(card->id, card->proc_root->name, sizeof(card->id));}",2,"cwe119,cwe120"
"handle_kill(sourceinfo_t *si, const char *victim, const char *reason){tconst char *source, *source1, *origreason;tchar qreason[512];tuser_t *u;tstatic time_t lastkill = 0;tstatic unsigned int killcount = 0;tsource = get_oper_name(si);tif (si->su)ttsource1 = si->su->nick;telse if (si->s)ttsource1 = si->s->name;telsettsource1 = me.name;torigreason = reason;treason = skip_kill_path(reason);tif (reason[0] == '[' || !strncmp(reason, ""Killed"", 6))ttsnprintf(qreason, sizeof qreason, ""%s"", reason);telse if (origreason == reason)ttsnprintf(qreason, sizeof qreason, ""Killed (%s (%s))"",ttttsource1, reason);telsettsnprintf(qreason, sizeof qreason, ""Killed (%s %s)"",ttttsource1, reason);tu = user_find(victim);tif (u == NULL)ttslog(LG_DEBUG, ""handle_kill(): %s killed unknown user %s (%s)"", source, victim, reason);telse if (u->flags & UF_ENFORCER)t{ttslog(LG_INFO, ""handle_kill(): %s killed enforcer %s (%s)"", source, u->nick, reason);ttuser_delete(u, qreason);t}telse if (u->server == me.me)t{ttslog(LG_INFO, ""handle_kill(): %s killed service %s (%s)"", source, u->nick, reason);ttif (lastkill != CURRTIME && killcount < 5 + me.me->users)tttkillcount = 0, lastkill = CURRTIME;ttkillcount++;ttif (killcount < 5 + me.me->users)tttreintroduce_user(u);ttelsett{tttslog(LG_ERROR, ""handle_kill(): services kill fight (2%s2 -> 2%s2), shutting down"", source, u->nick);tttwallops(_(""Services kill fight (%s -> %s), shutting down!""), source, u->nick);tttrunflags |= RF_SHUTDOWN;tt}t}telset{ttslog(LG_DEBUG, ""handle_kill(): %s killed user %s (%s)"", source, u->nick, reason);ttuser_delete(u, qreason);t}}",2,"cwe119,cwe120"
"add_player(struct game * g, int fd, char* nick){        char joined_msg[1000];        int i;        if (g->players_number < MAX_PLAYERS_PER_GAME) {                                 snprintf(joined_msg, sizeof(joined_msg), ok_player_joined, nick);                for (i = 0; i < g->players_number; i++)                        send_line_log_push(g->players_conn[i], joined_msg);                g->players_conn[g->players_number] = fd;                g->players_nick[g->players_number] = nick;                g->players_number++;                open_players = g_list_remove(open_players, GINT_TO_POINTER(fd));                calculate_list_games();                return 1;        } else {                free(nick);                return 0;        }}",3,"cwe119,cwe120,cweother"
"sanei_magicolor_net_write(struct Magicolor_Scanner *s,ttt  const unsigned char *buf, size_t buf_size,ttt  SANE_Status *status){tsize_t len = 64;tunsigned char *new_buf = malloc(len);tif (!new_buf) {tt*status = SANE_STATUS_NO_MEM;ttreturn 0;t}tmemset(new_buf, 0x00, len);tif (buf_size > len)ttbuf_size = len;tif (buf_size)ttmemcpy(new_buf, buf, buf_size);treturn sanei_magicolor_net_write_raw (s, new_buf, len, status);}",2,"cwe120,cweother"
"set_key(dns_client_t *client, char *keynamestr, char *keystr,tisc_boolean_t is_sep, isc_mem_t **mctxp){tisc_result_t result;tdns_fixedname_t fkeyname;tsize_t namelen;tdns_name_t *keyname;tdns_rdata_dnskey_t keystruct;tunsigned char keydata[4096];tisc_buffer_t keydatabuf;tunsigned char rrdata[4096];tisc_buffer_t rrdatabuf;tisc_buffer_t b;tisc_textregion_t tr;tisc_region_t r;tdns_secalg_t alg;tresult = isc_mem_create(0, 0, mctxp);tif (result != ISC_R_SUCCESS) {ttfprintf(stderr, ""failed to crate mctx"");ttexit(1);t}tif (algname != NULL) {tttr.base = algname;tttr.length = strlen(algname);ttresult = dns_secalg_fromtext(&alg, &tr);ttif (result != ISC_R_SUCCESS) {tttfprintf(stderr, ""failed to identify the algorithm"");tttexit(1);tt}t} elsettalg = DNS_KEYALG_RSASHA1;tkeystruct.common.rdclass = dns_rdataclass_in;tkeystruct.common.rdtype = dns_rdatatype_dnskey;tkeystruct.flags = DNS_KEYOWNER_ZONE;  tif (is_sep)ttkeystruct.flags |= DNS_KEYFLAG_KSK;tkeystruct.protocol = DNS_KEYPROTO_DNSSEC;  tkeystruct.algorithm = alg;tisc_buffer_init(&keydatabuf, keydata, sizeof(keydata));tisc_buffer_init(&rrdatabuf, rrdata, sizeof(rrdata));tresult = isc_base64_decodestring(keystr, &keydatabuf);tif (result != ISC_R_SUCCESS) {ttfprintf(stderr, ""base64 decode failed"");ttexit(1);t}tisc_buffer_usedregion(&keydatabuf, &r);tkeystruct.datalen = r.length;tkeystruct.data = r.base;tresult = dns_rdata_fromstruct(NULL, keystruct.common.rdclass,tttt      keystruct.common.rdtype,tttt      &keystruct, &rrdatabuf);tif (result != ISC_R_SUCCESS) {ttfprintf(stderr, ""failed to construct key rdata"");ttexit(1);t}tnamelen = strlen(keynamestr);tisc_buffer_init(&b, keynamestr, namelen);tisc_buffer_add(&b, namelen);tdns_fixedname_init(&fkeyname);tkeyname = dns_fixedname_name(&fkeyname);tresult = dns_name_fromtext(keyname, &b, dns_rootname, 0, NULL);tif (result != ISC_R_SUCCESS) {ttfprintf(stderr, ""failed to construct key name"");ttexit(1);t}tresult = dns_client_addtrustedkey(client, dns_rdataclass_in,ttttt  keyname, &rrdatabuf);tif (result != ISC_R_SUCCESS) {ttfprintf(stderr, ""failed to add key for %s"",tttkeynamestr);ttexit(1);t}}",3,"cwe119,cwe120,cweother"
"wt_status_print(struct wt_status *s){tunsigned char sha1[20];tconst char *branch_color = color(WT_STATUS_HEADER);ts->is_initial = get_sha1(s->reference, sha1) ? 1 : 0;tif (s->branch) {ttconst char *on_what = ""On branch "";ttconst char *branch_name = s->branch;ttif (!prefixcmp(branch_name, ""refs/heads/""))tttbranch_name += 11;ttelse if (!strcmp(branch_name, ""HEAD"")) {tttbranch_name = """";tttbranch_color = color(WT_STATUS_NOBRANCH);ttton_what = ""Not currently on any branch."";tt}ttcolor_fprintf(s->fp, color(WT_STATUS_HEADER), ""# "");ttcolor_fprintf_ln(s->fp, branch_color, ""%s%s"", on_what, branch_name);ttif (!s->is_initial)tttwt_status_print_tracking(s);t}tif (s->is_initial) {ttcolor_fprintf_ln(s->fp, color(WT_STATUS_HEADER), ""#"");ttcolor_fprintf_ln(s->fp, color(WT_STATUS_HEADER), ""# Initial commit"");ttcolor_fprintf_ln(s->fp, color(WT_STATUS_HEADER), ""#"");ttwt_status_print_initial(s);t}telse {ttwt_status_print_updated(s);t}twt_status_print_changed(s);tif (wt_status_submodule_summary)ttwt_status_print_submodule_summary(s);tif (show_untracked_files)ttwt_status_print_untracked(s);telse if (s->commitable)tt fprintf(s->fp, ""# Untracked files not listed (use -u option to show untracked files)"");tif (s->verbose && !s->is_initial)ttwt_status_print_verbose(s);tif (!s->commitable) {ttif (s->amend)tttfprintf(s->fp, ""# No changes"");ttelse if (s->nowarn)ttt;  ttelse if (s->workdir_dirty)tttprintf(""no changes added to commit (use ""git add"" and/or ""git commit -a"")"");ttelse if (s->workdir_untracked)tttprintf(""nothing added to commit but untracked files present (use ""git add"" to track)"");ttelse if (s->is_initial)tttprintf(""nothing to commit (create/copy files and use ""git add"" to track)"");ttelse if (!show_untracked_files)tttprintf(""nothing to commit (use -u to show untracked files)"");ttelsetttprintf(""nothing to commit (working directory clean)"");t}}",3,"cwe119,cwe120,cwe469"
"gfarm_hash_table_free(struct gfarm_hash_table *hashtab){tint i;tstruct gfarm_hash_entry *p, *np;tfor (i = 0; i < hashtab->table_size; i++) {ttfor (p = hashtab->buckets[i]; p != NULL; p = np) {tttnp = p->next;tttfree(p);tt}t}tfree(hashtab);}",2,"cwe120,cweother"
"count_objects(DIR *d, char *path, int len, int verbose,ttt  unsigned long *loose,ttt  unsigned long *loose_size,ttt  unsigned long *packed_loose,ttt  unsigned long *garbage){tstruct dirent *ent;twhile ((ent = readdir(d)) != NULL) {ttchar hex[41];ttunsigned char sha1[20];ttconst char *cp;ttint bad = 0;ttif ((ent->d_name[0] == '.') &&tt    (ent->d_name[1] == 0 ||tt     ((ent->d_name[1] == '.') && (ent->d_name[2] == 0))))tttcontinue;ttfor (cp = ent->d_name; *cp; cp++) {tttint ch = *cp;tttif (('0' <= ch && ch <= '9') ||ttt    ('a' <= ch && ch <= 'f'))ttttcontinue;tttbad = 1;tttbreak;tt}ttif (cp - ent->d_name != 38)tttbad = 1;ttelse {tttstruct stat st;tttmemcpy(path + len + 3, ent->d_name, 38);tttpath[len + 2] = '/';tttpath[len + 41] = 0;tttif (lstat(path, &st) || !S_ISREG(st.st_mode))ttttbad = 1;tttelsetttt(*loose_size) += xsize_t(st.st_blocks);tt}ttif (bad) {tttif (verbose) {tttterror(""garbage found: %.*s/%s"",tttt      len + 2, path, ent->d_name);tttt(*garbage)++;ttt}tttcontinue;tt}tt(*loose)++;ttif (!verbose)tttcontinue;ttmemcpy(hex, path+len, 2);ttmemcpy(hex+2, ent->d_name, 38);tthex[40] = 0;ttif (get_sha1_hex(hex, sha1))tttdie(""internal error"");ttif (has_sha1_pack(sha1, NULL))ttt(*packed_loose)++;t}}",2,"cwe119,cwe120"
"read_net_nfs(struct stats_net_nfs *st_net_nfs){tFILE *fp;tchar line[256];tunsigned int getattcnt = 0, accesscnt = 0, readcnt = 0, writecnt = 0;tif ((fp = fopen(NET_RPC_NFS, ""r"")) == NULL)ttreturn;tmemset(st_net_nfs, 0, STATS_NET_NFS_SIZE);ttwhile (fgets(line, 256, fp) != NULL) {ttif (!strncmp(line, ""rpc "", 4)) {tttsscanf(line + 4, ""%u %u"",ttt       &st_net_nfs->nfs_rpccnt, &st_net_nfs->nfs_rpcretrans);tt}ttelse if (!strncmp(line, ""proc3 "", 6)) {tttsscanf(line + 6, ""%*u %*u %u %*u %*u %u %*u %u %u"",ttt       &getattcnt, &accesscnt, &readcnt, &writecnt);ttttttst_net_nfs->nfs_getattcnt += getattcnt;tttst_net_nfs->nfs_accesscnt += accesscnt;tttst_net_nfs->nfs_readcnt   += readcnt;tttst_net_nfs->nfs_writecnt  += writecnt;tt}ttelse if (!strncmp(line, ""proc4 "", 6)) {tttsscanf(line + 6, ""%*u %*u %u %u ""ttt       ""%*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %*u %u %u"",ttt       &readcnt, &writecnt, &accesscnt, &getattcnt);ttttttst_net_nfs->nfs_getattcnt += getattcnt;tttst_net_nfs->nfs_accesscnt += accesscnt;tttst_net_nfs->nfs_readcnt   += readcnt;tttst_net_nfs->nfs_writecnt  += writecnt;tt}t}tfclose(fp);}",3,"cwe119,cwe120,cweother"
"""uv__fs_sendfile_emul(uv_fs_t* req) {  struct pollfd pfd;  int use_pread;  off_t offset;  ssize_t nsent;  ssize_t nread;  ssize_t nwritten;  size_t buflen;  size_t len;  ssize_t n;  int in_fd;  int out_fd;  char buf[8192];  len = req->len;  in_fd = req->flags;  out_fd = req->file;  offset = req->off;  use_pread = 1;  /* Here are the rules regarding errors:   *   * 1. Read errors are reported only if nsent==0, otherwise we return nsent.   *    The user needs to know that some data has already been sent, to stop   *    him from sending it twice.   *   * 2. Write errors are always reported. Write errors are bad because they   *    mean data loss: we've read data but now we can't write it out.   *   * We try to use pread() and fall back to regular read() if the source fd   * doesn't support positional reads, for example when it's a pipe fd.   *   * If we get EAGAIN when writing to the target fd, we poll() on it until   * it becomes writable again.   *   * FIXME: If we get a write error when use_pread==1, it should be safe to   *        return the number of sent bytes instead of an error because pread()   *        is, in theory, idempotent. However, special files in /dev or /proc   *        may support pread() but not necessarily return the same data on   *        successive reads.   *   * FIXME: There is no way now to signal that we managed to send *some* data   *        before a write error.   */  for (nsent = 0; (size_t) nsent < len; ) {    buflen = len - nsent;    if (buflen > sizeof(buf))      buflen = sizeof(buf);    do      if (use_pread)        nread = pread(in_fd, buf, buflen, offset);      else        nread = read(in_fd, buf, buflen);    while (nread == -1 && errno == EINTR);    if (nread == 0)      goto out;    if (nread == -1) {      if (use_pread && nsent == 0 && (errno == EIO || errno == ESPIPE)) {        use_pread = 0;        continue;      }      if (nsent == 0)        nsent = -1;      goto out;    }    for (nwritten = 0; nwritten < nread; ) {      do        n = write(out_fd, buf + nwritten, nread - nwritten);      while (n == -1 && errno == EINTR);      if (n != -1) {        nwritten += n;        continue;      }      if (errno != EAGAIN && errno != EWOULDBLOCK) {        nsent = -1;        goto out;      }      pfd.fd = out_fd;      pfd.events = POLLOUT;      pfd.revents = 0;      do        n = poll(&pfd, 1, -1);      while (n == -1 && errno == EINTR);      if (n == -1 || (pfd.revents & ~POLLOUT) != 0) {        errno = EIO;        nsent = -1;        goto out;      }    }    offset += nread;    nsent += nread;  }out:  if (nsent != -1)    req->off = offset;  return nsent;}""",3,"cwe119,cwe120,cweother"
"guess_dns_domain(char *domain){tchar line[DOMAIN_NAME_MAX];tFILE *file;tfile = fopen(""/etc/resolv.conf"", ""r"");tif(!file)ttreturn 0;twhile(fgets(line, sizeof(line), file)) {ttif(sscanf(line, ""search %[^ t]"", domain) == 1) {tttfclose(file);tttreturn 1;tt}ttif(sscanf(line, ""domain %[^ t]"", domain) == 1) {tttfclose(file);tttreturn 1;tt}t}tfclose(file);treturn 0;}",3,"cwe119,cwe120,cweother"
"client3_1_opendir (call_frame_t *frame, xlator_t *this,                   void *data){        clnt_local_t     *local    = NULL;        clnt_conf_t      *conf     = NULL;        clnt_args_t      *args     = NULL;        gfs3_opendir_req  req      = {{0,},};        int               ret      = 0;        int               op_errno = ESTALE;        if (!frame || !this || !data)                goto unwind;        args = data;        local = mem_get0 (this->local_pool);        if (!local) {                op_errno = ENOMEM;                goto unwind;        }        if (!(args->loc && args->loc->inode))                goto unwind;        local->fd = fd_ref (args->fd);        loc_copy (&local->loc, args->loc);        frame->local = local;        if (!uuid_is_null (args->loc->inode->gfid))                memcpy (req.gfid,  args->loc->inode->gfid, 16);        else                memcpy (req.gfid, args->loc->gfid, 16);        GF_ASSERT_AND_GOTO_WITH_ERROR (this->name,                                       !uuid_is_null (*((uuid_t*)req.gfid)),                                       unwind, op_errno, EINVAL);        conf = this->private;        ret = client_submit_request (this, &req, frame, conf->fops,                                     GFS3_OP_OPENDIR, client3_1_opendir_cbk,                                     NULL, NULL, 0, NULL, 0, NULL,                                     (xdrproc_t)xdr_gfs3_opendir_req);        if (ret) {                gf_log (this->name, GF_LOG_WARNING, ""failed to send the fop"");        }        if (req.xdata.xdata_val)                GF_FREE (req.xdata.xdata_val);        return 0;unwind:        CLIENT_STACK_UNWIND (opendir, frame, -1, op_errno, NULL, NULL);        if (req.xdata.xdata_val)                GF_FREE (req.xdata.xdata_val);        return 0;}",2,"cwe120,cwe476"
"""skipline(FILE *fp){tint c;tfor (c = getc(fp); c != EOF && c != '' && c != 'r'; c = getc(fp))tt;treturn c;}""",2,"cwe120,cweother"
"_init_slurmd_nodehash(void){tslurm_conf_node_t **ptr_array;tslurm_conf_frontend_t **ptr_front_end;tint count, i;tif (nodehash_initialized)ttreturn;telsettnodehash_initialized = true;tif (!conf_initialized) {ttif (_init_slurm_conf(NULL) != SLURM_SUCCESS)tttfatal(""Unable to process slurm.conf file"");ttconf_initialized = true;t}tcount = slurm_conf_nodename_array(&ptr_array);tfor (i = 0; i < count; i++)tt_register_conf_node_aliases(ptr_array[i]);tcount = slurm_conf_frontend_array(&ptr_front_end);tfor (i = 0; i < count; i++)tt_register_front_ends(ptr_front_end[i]);}",2,"cwe119,cwe120"
"parse_command_line(Config *c, int argc, char *argv[]) {    int o;    static const struct option long_options[] = {        { ""help"",           no_argument,       NULL, 'h' },        { ""ssh"",            no_argument,       NULL, 's' },        { ""vnc"",            no_argument,       NULL, 'v' },        { ""shell"",          no_argument,       NULL, 'S' },        { ""domain"",         required_argument, NULL, 'd' },        { NULL, 0, NULL, 0 }    };    while ((o = getopt_long(argc, argv, ""hVd:svS"", long_options, NULL)) >= 0) {        switch(o) {            case 'h':                c->command = COMMAND_HELP;                break;            case 's':                c->command = COMMAND_SSH;                break;            case 'v':                c->command = COMMAND_VNC;                break;            case 'S':                c->command = COMMAND_SHELL;                break;            case 'd':                avahi_free(c->domain);                c->domain = avahi_strdup(optarg);                break;            default:                return -1;        }    }    if (optind < argc) {        fprintf(stderr, _(""Too many arguments""));        return -1;    }    return 0;}",2,"cwe120,cweother"
"OS_LibInit(int stdioFds[3]){    if(libInitialized)        return 0;    char *libfcgiOsClosePollTimeoutStr = getenv( ""LIBFCGI_OS_CLOSE_POLL_TIMEOUT"" );    if(libfcgiOsClosePollTimeoutStr) {        libfcgiOsClosePollTimeout = atoi(libfcgiOsClosePollTimeoutStr);    }    char *libfcgiIsAfUnixKeeperPollTimeoutStr = getenv( ""LIBFCGI_IS_AF_UNIX_KEEPER_POLL_TIMEOUT"" );    if(libfcgiIsAfUnixKeeperPollTimeoutStr) {        libfcgiIsAfUnixKeeperPollTimeout = atoi(libfcgiIsAfUnixKeeperPollTimeoutStr);    }    asyncIoTable = (AioInfo *)malloc(asyncIoTableSize * sizeof(AioInfo));    if(asyncIoTable == NULL) {        errno = ENOMEM;        return -1;    }    memset((char *) asyncIoTable, 0,           asyncIoTableSize * sizeof(AioInfo));    FD_ZERO(&readFdSet);    FD_ZERO(&writeFdSet);    FD_ZERO(&readFdSetPost);    FD_ZERO(&writeFdSetPost);    OS_InstallSignalHandlers(FALSE);    libInitialized = TRUE;    return 0;}",2,"cwe120,cweother"
"send_read_command(char command) {tint retry, sent;tunsigned char buf[4];tretry = 0;tsent = 0;twhile ((sent != 4) && (retry < 5)) {ttbuf[0]=0x02; ttt ttbuf[1]=0x02;ttt ttbuf[2]=command;ttt ttbuf[3]=buf[1] + buf[2];t ttif (retry == 4) send_zeros();t ttsent = ser_send_buf(upsfd, buf, 4);ttretry += 1;t}}",2,"cwe119,cwe120"
"network_client_recv_file(struct network_client *client, int fd, size_t size){tssize_t rdlen;tchar buff[2048];tif (size == 0)t{ttwhile (1)tt{tttrdlen = client->recv(client, buff, sizeof(buff));tttif (rdlen <= 0)ttt{ttttif (rdlen < 0)tttt{tttttreturn rdlen;tttt}ttttreturn size;ttt}tttif (ffile_write(fd, buff, rdlen) < rdlen)ttt{ttttreturn -EIO;ttt}tttsize += rdlen;tt}t}telset{ttsize_t size_bak = size;ttstruct progress_bar bar;ttprogress_bar_init(&bar, size);ttwhile (size)tt{tttrdlen = client->recv(client, buff, sizeof(buff));tttif (rdlen <= 0 || ffile_write(fd, buff, rdlen) < rdlen)ttt{ttttreturn -EIO;ttt}tttsize -= rdlen;tttprogress_bar_add(&bar, rdlen);tt}ttprogress_bar_finish(&bar);ttreturn size_bak;t}}",2,"cwe119,cwe120"
"getauthc(int fd){fd_settfds;structttimevalttv;tif (readleft--)ttreturn ( (int)(unsigned char)*readptr++ );treadleft=0;tFD_ZERO(&fds);tFD_SET(fd, &fds);ttv.tv_sec=10;ttv.tv_usec=0;tif (select(fd+1, &fds, 0, 0, &tv) <= 0 ||tt!FD_ISSET(fd, &fds))ttreturn (EOF);treadleft=read(fd, buf, sizeof(buf));treadptr=buf;tif (readleft <= 0)t{ttreadleft=0;ttreturn (EOF);t}t--readleft;treturn ( (int)(unsigned char)*readptr++ );}",3,"cwe120,cwe476,cweother"
"set_digest_authorization(SERVICE service, DIGEST_CHLG **challenge, DIGEST_CRED **credentials, unsigned int *randseed, char *realm, char *str) {  char buf[64];  struct LOGIN *li     = (service==WWW)?my.auth.head:my.proxy.head;  while(li != NULL){    if(!strncasecmp(li->realm, realm, strlen(realm))){       snprintf( t  buf, sizeof(buf), t  ""%s:%s"", t  (li->username!=NULL)?li->username:"""", (li->password!=NULL)?li->password:"""" t  );              *challenge = digest_challenge_make(str);      *credentials = digest_credential_make(li->username, li->password, randseed);      if(*credentials == NULL || *challenge == NULL)treturn -1;      return 0;    }    li = li->next;  }     li = (service==WWW)?my.auth.head:my.proxy.head;   if(li == NULL)    return -1;  snprintf(      buf, sizeof( buf ),      ""%s:%s"",      (li->username!=NULL)?li->username:"""", (li->password!=NULL)?li->password:""""      );   *challenge = digest_challenge_make(str);  *credentials = digest_credential_make(li->username, li->password, randseed);  if(*credentials == NULL || *challenge == NULL)    return -1;  return 0;}",2,"cwe119,cwe120"
"diff_print_one_raw(tconst git_diff_delta *delta, float progress, void *data){tdiff_print_info *pi = data;tgit_buf *out = pi->buf;tchar code = git_diff_status_char(delta->status);tchar start_oid[GIT_OID_HEXSZ+1], end_oid[GIT_OID_HEXSZ+1];tGIT_UNUSED(progress);tif ((pi->flags & GIT_DIFF_SHOW_UNMODIFIED) == 0 && code == ' ')ttreturn 0;tgit_buf_clear(out);tgit_oid_tostr(start_oid, pi->oid_strlen, &delta->old_file.id);tgit_oid_tostr(end_oid, pi->oid_strlen, &delta->new_file.id);tgit_buf_printf(ttout, (pi->oid_strlen <= GIT_OID_HEXSZ) ?ttt"":%06o %06o %s... %s... %c"" : "":%06o %06o %s %s %c"",ttdelta->old_file.mode, delta->new_file.mode, start_oid, end_oid, code);tif (delta->similarity > 0)ttgit_buf_printf(out, ""%03u"", delta->similarity);tif (delta->old_file.path != delta->new_file.path)ttgit_buf_printf(tttout, ""t%s %s"", delta->old_file.path, delta->new_file.path);telsettgit_buf_printf(tttout, ""t%s"", delta->old_file.path ?tttdelta->old_file.path : delta->new_file.path);tif (git_buf_oom(out))ttreturn -1;tpi->line.origin      = GIT_DIFF_LINE_FILE_HDR;tpi->line.content     = git_buf_cstr(out);tpi->line.content_len = git_buf_len(out);treturn pi->print_cb(delta, NULL, &pi->line, pi->payload);}",2,"cwe119,cwe120"
"snd_hdspm_midi_output_write (struct hdspm_midi *hmidi){tunsigned long flags;tint n_pending;tint to_write;tint i;tunsigned char buf[128];t tspin_lock_irqsave (&hmidi->lock, flags);tif (hmidi->output &&t    !snd_rawmidi_transmit_empty (hmidi->output)) {ttn_pending = snd_hdspm_midi_output_possible (hmidi->hdspm,ttttttt    hmidi->id);ttif (n_pending > 0) {tttif (n_pending > (int)sizeof (buf))ttttn_pending = sizeof (buf);tttto_write = snd_rawmidi_transmit (hmidi->output, buf,ttttttt n_pending);tttif (to_write > 0) {ttttfor (i = 0; i < to_write; ++i)tttttsnd_hdspm_midi_write_byte (hmidi->hdspm,tttttttt   hmidi->id,tttttttt   buf[i]);ttt}tt}t}tspin_unlock_irqrestore (&hmidi->lock, flags);treturn 0;}",2,"cwe119,cwe120"
"client3_1_fsync (call_frame_t *frame, xlator_t *this,                 void *data){        clnt_args_t    *args      = NULL;        gfs3_fsync_req  req       = {{0,},};        int64_t         remote_fd = -1;        clnt_conf_t    *conf      = NULL;        int             op_errno  = 0;        int             ret       = 0;        if (!frame || !this || !data)                goto unwind;        args = data;        conf = this->private;        CLIENT_GET_REMOTE_FD(conf, args->fd, remote_fd, op_errno, unwind);        req.fd   = remote_fd;        req.data = args->flags;        memcpy (req.gfid, args->fd->inode->gfid, 16);        ret = client_submit_request (this, &req, frame, conf->fops,                                     GFS3_OP_FSYNC, client3_1_fsync_cbk, NULL,                                     NULL, 0, NULL, 0,                                     NULL, (xdrproc_t)xdr_gfs3_fsync_req);        if (ret) {                gf_log (this->name, GF_LOG_WARNING, ""failed to send the fop"");        }        if (req.xdata.xdata_val)                GF_FREE (req.xdata.xdata_val);        return 0;unwind:        CLIENT_STACK_UNWIND (fsync, frame, -1, op_errno, NULL, NULL, NULL);        if (req.xdata.xdata_val)                GF_FREE (req.xdata.xdata_val);        return 0;}",2,"cwe120,cwe476"
"widget_options_print_label( int left_edge, int width, int number, const char *string ){  char buffer[128];  size_t l, w;  int colour = WIDGET_COLOUR_BACKGROUND;  if( number == highlight_line ) colour = WIDGET_COLOUR_HIGHLIGHT;  widget_rectangle( left_edge*8+1, number*8+24, width*8-2, 1*8, colour );  snprintf( buffer, sizeof( buffer ), ""%s"", string );  l = strlen( buffer );  if( l >= sizeof( buffer ) )    l = sizeof( buffer ) - 1;  while( ( w = widget_substringwidth( string, l ) ) >= (left_edge+width-2)*8 )    --l;  buffer[l] = '0';  w = widget_printstring( left_edge*8+8, number*8+24, WIDGET_COLOUR_FOREGROUND, buffer )      - 1;  while ((w += 3) < (left_edge+width-1)*8-2)    widget_putpixel (w, number*8+31, 0);  return 0;}",2,"cwe119,cwe120"
"html_escfprintf(FILE *outf, char *name) {#ifdef EBCDIC  extern unsigned char os_toascii[];#endif  char w1[64];  char *w = w1;  int len = 0;  for ( ; *name != '0'; name++) {    if (ISALNUM(*name) || *name == '/' || *name == '.' || *name == ':' ||t*name == '-' || *name == '~' || *name == '_' || *name == '?' ||t*name == '%' || *name == '=' || *name == '+' ||t*name == ';' ||t*name == '@' || *name == '$' || *name == ',') {                    PUTc(w, *name);      len += 1;    }    else if (*name == '&') {      PUTs(w, ""&amp;"", 0);      len += 5;    }    else {#ifdef EBCDIC      sprintf(w, ""%%%.2X"", os_toascii[*name]);#else      sprintf(w, ""%%%.2X"", (unsigned char)(*name));#endif      w += 3;      len += 3;    }    if (len > 58) {      *w = '0';      fputs(w1, outf);      w = w1;      len = 0;    }  }  *w = '0';  fputs(w1, outf);}",2,"cwe119,cwe120"
"do_set(const char *varname, const char *newval){tchartbuf[SMALLBUF], enc[SMALLBUF];tsnprintf(buf, sizeof(buf), ""SET VAR %s %s ""%s"""", upsname, varname, pconf_encode(newval, enc, sizeof(enc)));tif (upscli_sendline(ups, buf, strlen(buf)) < 0) {ttfatalx(EXIT_FAILURE, ""Can't set variable: %s"", upscli_strerror(ups));t}tif (upscli_readline(ups, buf, sizeof(buf)) < 0) {ttfatalx(EXIT_FAILURE, ""Set variable failed: %s"", upscli_strerror(ups));t}t tif (strncmp(buf, ""OK"", 2) != 0) {ttfatalx(EXIT_FAILURE, ""Unexpected response from upsd: %s"", buf);t}tfprintf(stderr, ""%s"", buf);}",2,"cwe119,cwe120"
"read_input(void){  unsigned rd;  unsigned long timeout_left;  if ((conn = socket_acceptu(sock)) == -1) return CVME_IO;  if (!nonblock_on(conn)) {    close(conn);    return CVME_IO;  }  for (cvm_module_inbuflen = 0, timeout_left = timeout;       cvm_module_inbuflen < BUFSIZE;       cvm_module_inbuflen += rd) {    switch (poll_timeout(conn, IOPOLL_READ, &timeout_left)) {    case 0:    case -1:      close(conn);      return CVME_IO;    }    if ((rd = read(conn, cvm_module_inbuffer+cvm_module_inbuflen,tt   BUFSIZE-cvm_module_inbuflen)) == 0)      break;    if (rd == (unsigned)-1) {      close(conn);      return CVME_IO;    }  }  return 0;}",2,"cwe120,cweother"
"lvl_load_body_file (int fd, a_level *out){  size_t length = out->tile_count * LVL_RECORD_SIZE;  a_u8 *data = xmalloc (length);  ssize_t rlength = read (fd, data, length);  if (rlength < 0 || (size_t) rlength != length) {    free (data);    return -1;  }  lvl_load_body_mem (data, out);  free (data);  return 0;}",2,"cwe120,cweother"
"sdf_getsel_indices(int32 *i1, int32 *i2, char *s){ register char *chp, *chp2; char s1[RECLEN], s2[RECLEN]; *i1 = *i2 = -1;    if ((chp = strrchr(s, ']')) == NULL) __arg_terr(__FILE__, __LINE__); chp++; if (*chp != '0' || chp[-1] == '') return(FALSE); chp--; strncpy(s1, s, chp - s); s1[chp - s] = '0';   if (__id_partsel)  {   if ((chp = strchr(s1, ':')) == NULL) __arg_terr(__FILE__, __LINE__);   chp++;   strcpy(s2, chp);   chp--;   chp--;   *chp = '0';       for (chp2 = s2; *chp2 != '0'; chp2++)    {     if (!isdigit(*chp2)) return(FALSE);    }   if (sscanf(s2, ""%d"", i2) != 1) return(FALSE);  }     for (chp2 = s1; *chp2 != '0'; chp2++)  {   if (!isdigit(*chp2)) return(FALSE);  } if (sscanf(s1, ""%d"", i1) != 1) return(FALSE); if (!__id_partsel) *i2 = *i1; return(TRUE);}",2,"cwe119,cwe120"
"load_core_modules(int warn){tchar module_name[PATH_MAX + 1];tchar dir_name[PATH_MAX + 1];tDIR *core_dir;tint i;tcore_dir = opendir(MODPATH);tif(core_dir == NULL)t{ttrb_snprintf(dir_name, sizeof(dir_name), ""%s/modules"", ConfigFileEntry.dpath);ttcore_dir = opendir(dir_name);t}telset{ttrb_strlcpy(dir_name, MODPATH, sizeof(dir_name));t}tif(core_dir == NULL)t{ttilog(L_MAIN,tt     ""Cannot find where core modules are located(tried %s and %s): terminating ircd"",tt     MODPATH, dir_name);ttexit(0);t}tfor(i = 0; core_module_table[i]; i++)t{ttrb_snprintf(module_name, sizeof(module_name), ""%s/%s%s"", dir_name,ttt    core_module_table[i], SHLIBEXT);ttif(load_a_module(module_name, warn, 1) == -1)tt{tttilog(L_MAIN,ttt     ""Error loading core module %s%s: terminating ircd"",ttt     core_module_table[i], SHLIBEXT);tttexit(0);tt}t}tclosedir(core_dir);}",2,"cwe119,cwe120"
"cli_cmd_volume_statedump_options_parse (const char **words, int wordcount,                                        dict_t **options){        int     ret = 0;        int     i = 0;        dict_t  *dict = NULL;        int     option_cnt = 0;        char    option_str[100] = {0,};        for (i = 3; i < wordcount; i++, option_cnt++) {                if (!cli_cmd_validate_dumpoption (words[i])) {                        ret = -1;                        goto out;                }                strncat (option_str, words[i], sizeof (words [i]));                strncat (option_str, "" "", 1);        }        dict = dict_new ();        if (!dict)                goto out;        ret = dict_set_str (dict, ""options"", gf_strdup (option_str));        if (ret)                goto out;        ret = dict_set_int32 (dict, ""option_cnt"", option_cnt);        if (ret)                goto out;        *options = dict;out:        if (ret && dict)                dict_destroy (dict);        if (ret)                gf_log (""cli"", GF_LOG_ERROR, ""Error parsing dumpoptions"");        return ret;}",2,"cwe119,cwe120"
"""hash_data_has_checksum(const char* data, unsigned int function)r{rthash_function_desc* info = hash_get_function_desc(function);rtchar str[3];rtconst char* res;rrtstr[0] = info->code; rtstr[1] = ':'; rtstr[2] = '0';rrt// Check if the specified hash function is used within this datartres = strstr(data, str);rrtif (!res)rttreturn 0;rrt// Return the offset within the string where the checksum beginsrtreturn (res - data + 2);r}""",2,"cwe119,cwe120"
"telnet_gets (char *prompt, char *result, int length, int echo){# if !HAVE_DECL_GETPASS  extern char *getpass ();# endif  extern int globalmode;  int om = globalmode;  char *res;  TerminalNewMode (-1);  if (echo)    {      printf (""%s"", prompt);      res = fgets (result, length, stdin);    }  else    {      res = getpass (prompt);      if (res)t{t  strncpy (result, res, length);t  memset (res, 0, strlen (res));t  res = result;t}    }  TerminalNewMode (om);  return (res);}",2,"cwe120,cweother"
"GRSTasn1GetField(int index, char *coords, char *asn1string,tt   struct GRSTasn1TagList taglist[], int lasttag,tt   ASN1_OBJECT **field_obj, int *field_index){    char coordstmp[81];    const unsigned char *q;    ASN1_OBJECT *obj = NULL;    int iobj, ival;    snprintf(coordstmp, sizeof(coordstmp), coords, index, 1);    iobj = GRSTasn1SearchTaglist(taglist, lasttag, coordstmp);    if (iobj < 0)treturn GRST_RET_FAILED;    snprintf(coordstmp, sizeof(coordstmp), coords, index, 2);    ival = GRSTasn1SearchTaglist(taglist, lasttag, coordstmp);    if (ival < 0)treturn GRST_RET_FAILED;    q = (unsigned char *) &asn1string[taglist[iobj].start];    obj = d2i_ASN1_OBJECT(NULL, &q,tt    taglist[iobj].length + taglist[iobj].headerlength);    if (obj == NULL)treturn GRST_RET_FAILED;    *field_obj = obj;    *field_index = ival;    return GRST_RET_OK;}",3,"cwe119,cwe120,cweother"
"ibmasm_heartbeat_exit(struct service_processor *sp){tchar tsbuf[32];tdbg(""%s:%d at %s"", __func__, __LINE__, get_timestamp(tsbuf));tibmasm_wait_for_response(sp->heartbeat, IBMASM_CMD_TIMEOUT_NORMAL);tdbg(""%s:%d at %s"", __func__, __LINE__, get_timestamp(tsbuf));tsuspend_heartbeats = 1;tcommand_put(sp->heartbeat);}",2,"cwe119,cwe120"
"""gfp_xdr_vsend_size_add(size_t *sizep, const char **formatp, va_list *app){tconst char *format = *formatp;tsize_t size = *sizep;tgfarm_uint8_t c;tgfarm_int16_t h;tgfarm_int32_t i, n;tgfarm_int64_t o;tgfarm_uint32_t lv[2];#if INT64T_IS_FLOATtint minus;#endiftdouble d;#ifndef WORDS_BIGENDIANtstruct { char c[8]; } nd;#else#tdefine nd d#endiftconst char *s;tfor (; *format; format++) {ttswitch (*format) {ttcase 'c':tttc = va_arg(*app, int);tttsize += sizeof(c);tttcontinue;ttcase 'h':ttth = va_arg(*app, int);tttsize += sizeof(h);tttcontinue;ttcase 'i':ttti = va_arg(*app, gfarm_int32_t);tttsize += sizeof(i);tttcontinue;ttcase 'l':ttt/*ttt * note that because actual type of gfarm_int64_tttt * may be diffenent (int64_t or double), we use lv herettt */ttto = va_arg(*app, gfarm_int64_t);tttsize += sizeof(lv);tttcontinue;ttcase 's':ttts = va_arg(*app, const char *);tttn = strlen(s);tttsize += sizeof(i);tttsize += n;tttcontinue;ttcase 'S':ttts = va_arg(*app, const char *);tttn = va_arg(*app, size_t);tttsize += sizeof(i);tttsize += n;tttcontinue;ttcase 'b':ttt/*ttt * note that because actual type of size_t may bettt * diffenent ([u]int32_t or [u]int64_t), we must notttt * pass this as is via network.ttt */tttn = va_arg(*app, size_t);ttts = va_arg(*app, const char *);tttsize += sizeof(i);tttsize += n;tttcontinue;ttcase 'f':tttd = va_arg(*app, double);tttsize += sizeof(nd);tttcontinue;ttdefault:tttbreak;tt}ttbreak;t}t*sizep = size;t*formatp = format;treturn (GFARM_ERR_NO_ERROR);}""",2,"cwe119,cwe120"
"readlines(FILE *file, readlines_cb fun){tchar buf[1024*1024];tint lineno = 0;twhile (fgets(buf, sizeof(buf), file)) {ttlineno ++;ttchar *saveptr;ttchar *line = strip(buf);ttchar *action = strtok_r(line, "" t"", &saveptr);ttif (action == NULL) {tttcontinue;tt}ttint tokc;ttchar *tokv[32];ttfor (tokc = 0; tokc < 32; tokc++) {ttttokv[tokc] = strtok_r(NULL, "" t"", &saveptr);tttif (tokv[tokc] == NULL) {ttttbreak;ttt}tt}ttint r = fun(action, tokc, tokv);ttif (r) {tttfprintf(stderr, ""Error %i on line %i"", r, lineno);tttreturn r;tt}t}treturn 0;}",4,"cwe119,cwe120,cwe476,cweother"
"printPointGNU(FILE * pf, const char *szImageDir, const char *szExtension,              int iPoint0, int iPoint1, const int fColor, const int fUp, const htmlexportcss hecss){    char sz[100];    char szAlt[100];    if (iPoint0) {                 sprintf(sz, ""b-%c%c-x%d"", fColor ? 'g' : 'r', fUp ? 'd' : 'u', iPoint0);        sprintf(szAlt, ""%1xX"", iPoint0);    } else if (iPoint1) {                 sprintf(sz, ""b-%c%c-o%d"", fColor ? 'g' : 'r', fUp ? 'd' : 'u', iPoint1);        sprintf(szAlt, ""%1xO"", iPoint1);    } else {                 sprintf(sz, ""b-%c%c"", fColor ? 'g' : 'r', fUp ? 'd' : 'u');        sprintf(szAlt, ""&nbsp;'"");    }    printImage(pf, szImageDir, sz, szExtension, szAlt, hecss, HTML_EXPORT_TYPE_GNU);}",2,"cwe119,cwe120"
"rcms_c_set_nmode(struct brcms_c_info *wlc){tuint i;ts32 nmode = AUTO;tif (wlc->stf->txstreams == WL_11N_3x3)ttnmode = WL_11N_3x3;telsettnmode = WL_11N_2x2;t tbrcms_c_set_gmode(wlc, GMODE_AUTO, true);tif (nmode == WL_11N_3x3)ttwlc->pub->_n_enab = SUPPORT_HT;telsettwlc->pub->_n_enab = SUPPORT_11N;twlc->default_bss->flags |= BRCMS_BSS_HT;t tbrcms_c_rateset_mcs_build(&wlc->default_bss->rateset,ttt      wlc->stf->txstreams);tfor (i = 0; i < wlc->pub->_nbands; i++)ttmemcpy(wlc->bandstate[i]->hw_rateset.mcs,tt       wlc->default_bss->rateset.mcs, MCSSET_LEN);treturn 0;}",2,"cwe120,cweother"
"parse_log_for_any (const GString *str,                   CkLogEvent    *event){        gboolean ret;        int      res;        gulong   sec;        guint    frac;        char     buf[32];        ret = FALSE;        res = sscanf (str->str, ""%lu.%u type=%30s :"",                      &sec,                      &frac,                      buf);        if (res == 3) {                res = event_name_to_type (buf, &event->type);                if (! res) {                        goto out;                }                event->timestamp.tv_sec = sec;                event->timestamp.tv_usec = 1000 * frac;                ret = TRUE;        } out:        return ret;}",2,"cwe119,cwe120"
"pcd_detect(void){tchar id[18];tint k, unit;tstruct pcd_unit *cd;tprintk(""%s: %s version %s, major %d, nice %d"",t       name, name, PCD_VERSION, major, nice);tpar_drv = pi_register_driver(name);tif (!par_drv) {ttpr_err(""failed to register %s driver"", name);ttreturn -1;t}tk = 0;tif (pcd_drive_count == 0) {  ttcd = pcd;ttif (pi_init(cd->pi, 1, -1, -1, -1, -1, -1, pcd_buffer,ttt    PI_PCD, verbose, cd->name)) {tttif (!pcd_probe(cd, -1, id) && cd->disk) {ttttcd->present = 1;ttttk++;ttt} elsettttpi_release(cd->pi);tt}t} else {ttfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {tttint *conf = *drives[unit];tttif (!conf[D_PRT])ttttcontinue;tttif (!pi_init(cd->pi, 0, conf[D_PRT], conf[D_MOD],tttt     conf[D_UNI], conf[D_PRO], conf[D_DLY],tttt     pcd_buffer, PI_PCD, verbose, cd->name)) ttttcontinue;tttif (!pcd_probe(cd, conf[D_SLV], id) && cd->disk) {ttttcd->present = 1;ttttk++;ttt} elsettttpi_release(cd->pi);tt}t}tif (k)ttreturn 0;tprintk(""%s: No CD-ROM drive found"", name);tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)ttput_disk(cd->disk);tpi_unregister_driver(par_drv);treturn -1;}",2,"cwe119,cwe120"
"pick_path (char *dir, char *stem, char *path, char *ext[]){tint k;tfor (k = 0; k < 2; k++) {t ttsprintf (path, ""%s/%s%s"", dir, stem, ext[k]);ttif (!access (path, R_OK)) {t tttreturn (TRUE);tt}t}treturn (FALSE);}",3,"cwe119,cwe120,cweother"
"drmParsePciBusInfo(int maj, int min, drmPciBusInfoPtr info){#ifdef __linux__    char path[PATH_MAX + 1];    char data[128 + 1];    char *str;    int domain, bus, dev, func;    int fd, ret;    snprintf(path, PATH_MAX, ""/sys/dev/char/%d:%d/device/uevent"", maj, min);    fd = open(path, O_RDONLY);    if (fd < 0)        return -errno;    ret = read(fd, data, sizeof(data));    data[128] = '0';    close(fd);    if (ret < 0)        return -errno;#define TAG ""PCI_SLOT_NAME=""    str = strstr(data, TAG);    if (str == NULL)        return -EINVAL;    if (sscanf(str, TAG ""%04x:%02x:%02x.%1u"",               &domain, &bus, &dev, &func) != 4)        return -EINVAL;#undef TAG    info->domain = domain;    info->bus = bus;    info->dev = dev;    info->func = func;    return 0;#else#warning ""Missing implementation of drmParsePciBusInfo""    return -EINVAL;#endif}",3,"cwe119,cwe120,cweother"
"fnic_reset_stats_write(struct file *file,tttttconst char __user *ubuf,tttttsize_t cnt, loff_t *ppos){tstruct stats_debug_info *debug = file->private_data;tstruct fnic *fnic = (struct fnic *)debug->i_private;tstruct fnic_stats *stats = &fnic->fnic_stats;tu64 *io_stats_p = (u64 *)&stats->io_stats;tu64 *fw_stats_p = (u64 *)&stats->fw_stats;tchar buf[64];tunsigned long val;tint ret;tif (cnt >= sizeof(buf))ttreturn -EINVAL;tif (copy_from_user(&buf, ubuf, cnt))ttreturn -EFAULT;tbuf[cnt] = 0;tret = kstrtoul(buf, 10, &val);tif (ret < 0)ttreturn ret;tfnic->reset_stats = val;tif (fnic->reset_stats) {tt ttatomic64_set(&fnic->io_cmpl_skip,tttatomic64_read(&stats->io_stats.active_ios));ttmemset(&stats->abts_stats, 0, sizeof(struct abort_stats));ttmemset(&stats->term_stats, 0,tttsizeof(struct terminate_stats));ttmemset(&stats->reset_stats, 0, sizeof(struct reset_stats));ttmemset(&stats->misc_stats, 0, sizeof(struct misc_stats));ttmemset(&stats->vlan_stats, 0, sizeof(struct vlan_stats));ttmemset(io_stats_p+1, 0,tttsizeof(struct io_path_stats) - sizeof(u64));ttmemset(fw_stats_p+1, 0,tttsizeof(struct fw_stats) - sizeof(u64));t}t(*ppos)++;treturn cnt;}",2,"cwe119,cwe120"
"cavan_mtd_write_partition1(struct mtd_partition_descriptor *desc, int fd){tssize_t readlen, writelen;tstruct mtd_partition_info *info = desc->part_info;tchar buff[info->erase_size];twhile (1)t{ttreadlen = read(fd, buff, sizeof(buff));ttif (readlen < 0)tt{tttprint_error(""read"");tttreturn readlen;tt}ttif (readlen == 0)tt{tttreturn 0;tt}ttwritelen = cavan_mtd_write_block(desc, buff);ttif (writelen < 0)tt{ttterror_msg(""cavan_mtd_write_block"");tttreturn writelen;tt}t}treturn 0;}",3,"cwe119,cwe120,cweother"
"knowledge_write_player_data(const knowledge_player *kp) {    FILE *file;    char write[MAX_BUF], final[MAX_BUF];    const knowledge_item *item;    int i;    snprintf(final, sizeof(final), ""%s/%s/%s/%s.knowledge"", settings.localdir, settings.playerdir, kp->player_name, kp->player_name);    snprintf(write, sizeof(write), ""%s.new"", final);    file = fopen(write, ""w+"");    if (!file) {        LOG(llevError, ""knowledge: couldn't open player knowledge file %s!"", write);        draw_ext_info(NDI_UNIQUE | NDI_ALL_DMS, 0, NULL, MSG_TYPE_ADMIN, MSG_TYPE_ADMIN_LOADSAVE, ""File write error on server!"");        return;    }    for (i = 0; i < kp->item_count; i++) {        item = kp->items[i];        fprintf(file, ""%s:%s"", item->handler->type, item->item);    }    fclose(file);         unlink(final);    rename(write, final);}",3,"cwe119,cwe120,cweother"
"telnet_vprintf(telnet_t *telnet, const char *fmt, va_list va) {    static const char CRLF[] = { 'r', '' };    static const char CRNUL[] = { 'r', '0' };tchar buffer[1024];tchar *output = buffer;tint rs, i, l;t trs = vsnprintf(buffer, sizeof(buffer), fmt, va);tif ((size_t)rs >= sizeof(buffer)) {ttoutput = (char*)malloc(rs + 1);ttif (output == 0) {ttt_error(telnet, __LINE__, __func__, TELNET_ENOMEM, 0,ttttt""malloc() failed: %s"", strerror(errno));tttreturn -1;tt}ttrs = vsnprintf(output, rs + 1, fmt, va);t}t tfor (l = i = 0; i != rs; ++i) {tt ttif (output[i] == (char)TELNET_IAC || output[i] == 'r' ||ttttoutput[i] == '') {ttt tttif (i != l)tttt_send(telnet, output + l, i - l);tttl = i + 1;ttt tttif (output[i] == (char)TELNET_IAC)tttttelnet_iac(telnet, TELNET_IAC);ttt tttelse if (output[i] == 'r')tttt_send(telnet, CRNUL, 2);ttt tttelse if (output[i] == '')tttt_send(telnet, CRLF, 2);tt}t}t tif (i != l) {tt_send(telnet, output + l, i - l);t}t tif (output != buffer) {ttfree(output);t}treturn rs;}",3,"cwe119,cwe120,cweother"
"get_string_array (void **array, int count, gboolean is_process){tint i;tMonoDomain *domain = mono_domain_get ();tMonoArray * res = mono_array_new (mono_domain_get (), mono_get_string_class (), count);tfor (i = 0; i < count; ++i) {ttchar buf [128];ttchar *p;ttif (is_process) {tttchar *pname = mono_process_get_name (array [i], buf, sizeof (buf));tttp = g_strdup_printf (""%d/%s"", GPOINTER_TO_INT (array [i]), pname);tt} else {tttsprintf (buf, ""%d"", GPOINTER_TO_INT (array [i]));tttp = buf;tt}ttmono_array_setref (res, i, mono_string_new (domain, p));ttif (p != buf)tttg_free (p);t}treturn res;}",2,"cwe119,cwe120"
"OFF_start(){  char file_name[200];  for (;;)  {    prompt(""Enter file name: "",file_name,sizeof(file_name));    if ( file_name[0] == 0 )    { kb_error(4005,""File aborted."",RECOVERABLE);    }    fd = fopen(file_name,""w"");    if ( fd == NULL )    { perror(file_name);      kb_error(1034,"""",RECOVERABLE);    }    else break;  }  OFF_vertex_count = 0;  OFF_edge_count = 0;  OFF_facet_count = 0;  OFF_verts_alloc = 2*web.skel[EDGE].count + 3*web.skel[FACET].count;  OFF_verts = (struct OFF_vertex_t *)temp_calloc(OFF_verts_alloc,                  sizeof(struct OFF_vertex_t));  OFF_facets_alloc = 3*web.skel[FACET].count;  OFF_facets = (struct OFF_facet_t *)temp_calloc(OFF_facets_alloc,                  sizeof(struct OFF_facet_t));}",3,"cwe119,cwe120,cweother"
"dbg_meas(const char *name){tconst struct obj *obj;tconst struct inst *inst;tstruct coord a1, b1;tchar *s;tobj = find_obj(frames, name);tif (!obj) {ttyyerrorf(""unknown object ""%s"""", name);ttreturn 0;t}t tif (!pkg_name)                pkg_name = stralloc(""_"");        reporter = report_to_stderr;tif (!instantiate())ttreturn 0;tinst = find_meas_hint(obj);tif (!inst) {ttyyerrorf(""measurement ""%s"" was not instantiated"", name);ttreturn 0;t}tproject_meas(inst, &a1, &b1);ts = format_len(obj->u.meas.label ? obj->u.meas.label : """",t    dist_point(a1, b1), curr_unit);tprintf(""%s"", s);tfree(s);treturn 1;}",2,"cwe469,cweother"
"get_smp_uptime(void){tFILE *fp;tchar buf[sizeof(long)*3 * 2 + 4];tunsigned long sec, dec;tfp = xfopen_for_read(""/proc/uptime"");tif (fgets(buf, sizeof(buf), fp))ttif (sscanf(buf, ""%lu.%lu"", &sec, &dec) != 2)tttbb_error_msg_and_die(""can't read /proc/uptime"");tfclose(fp);treturn (cputime_t)sec * G.clk_tck + dec * G.clk_tck / 100;}",2,"cwe119,cwe120"
"generate_id_list(void){tstatic unsigned char sha1[20];tstatic char line[1000];tSHA_CTX ctx;tint patchlen = 0;tSHA1_Init(&ctx);twhile (fgets(line, sizeof(line), stdin) != NULL) {ttunsigned char n[20];ttchar *p = line;ttint len;ttif (!memcmp(line, ""diff-tree "", 10))tttp += 10;ttelse if (!memcmp(line, ""commit "", 7))tttp += 7;ttif (!get_sha1_hex(p, n)) {tttflush_current_id(patchlen, sha1, &ctx);ttthashcpy(sha1, n);tttpatchlen = 0;tttcontinue;tt}tt ttif (!patchlen && memcmp(line, ""diff "", 5))tttcontinue;tt ttif (!memcmp(line, ""index "", 6))tttcontinue;tt ttif (!memcmp(line, ""@@ -"", 4))tttcontinue;tt ttlen = remove_space(line);ttpatchlen += len;ttSHA1_Update(&ctx, line, len);t}tflush_current_id(patchlen, sha1, &ctx);}",2,"cwe119,cwe120"
"MP3_ConnectService(GF_InputService *plug, GF_ClientService *serv, const char *url){tchar szURL[2048];tu32 minSizeToRead = 0;tchar *ext;tGF_Err reply;tMP3Reader *read = plug->priv;tread->service = serv;tif (read->dnload) gf_term_download_del(read->dnload);tread->dnload = NULL;tstrcpy(szURL, url);text = strrchr(szURL, '#');tif (ext) ext[0] = 0;t tread->is_remote = !mp3_is_local(szURL);tif (read->is_remote) {ttmp3_download_file(plug, (char *) szURL);ttreturn GF_OK;t}treply = GF_OK;tread->stream = gf_f64_open(szURL, ""rb"");tif (!read->stream) {ttreply = GF_URL_ERROR;t} else if (!MP3_ConfigureFromFile(read, &minSizeToRead)) {ttfclose(read->stream);ttread->stream = NULL;ttreply = GF_NOT_SUPPORTED;t}tgf_term_on_connect(serv, NULL, reply);tif (!reply) mp3_setup_object(read);treturn GF_OK;}",3,"cwe119,cwe120,cweother"
"mywc(void){tinttfd, dh, nr = 0;tchartline[512];tstruct wordcount *listtmp;#ifdef M4_PREPROCtchar *inc;#endift tfiles = listtmp = (struct wordcount *)malloc(sizeof(struct wordcount));tlisttmp->min = 0;#ifdeftM4_PREPROCtlisttmp->filename = strdup(IRCDM4_PATH);tinc = configfile;tconfigfile = 0;  #elsetlisttmp->filename = strdup(""ircd.conf"");#endiftif ((fd = openconf()) == -1)t{tt(void)wait(0);ttreturn;t}t(void)dgets(-1, NULL, 0);t twhile ((dh = dgets(fd, line, sizeof(line) - 1)) > 0)ttif (dh != sizeof(line) - 1)tttnr++;tlisttmp->max = nr;t(void)close(fd);#ifdeftM4_PREPROCt(void)wait(0);tconfigfile = inc;tnr = simulateM4Include(listtmp, nr, configfile, 0);#endif}",2,"cwe119,cwe120"
"act120(){ ttNLA = 52;    {      static char buf[100];      if ( strlen(zzbegexpr)>(size_t)85 )      fatal(""#i AST ref too big"");      if ( GenCC ) sprintf(buf,""_ast%d%s"",BlkLevel-1,zzbegexpr+1);      else sprintf(buf,""zzastArg(%s)"",zzbegexpr+1);      zzreplstr(buf);      zzmore();      set_orel(atoi(zzbegexpr+1), &AST_nodes_refd_in_actions);      chkGTFlag();    }t}",3,"cwe119,cwe120,cweother"
"s2b_insert_symbol(SWFReader *read, GF_Node *n){tGF_Command *com;tGF_CommandField *f;tif (read->flags & GF_SM_SWF_STATIC_DICT) {ttM_Switch *par = (M_Switch *)gf_sg_find_node_by_name(read->load->scene_graph, ""DICTIONARY"");ttgf_node_list_add_child(&par->choice, n);ttgf_node_register((GF_Node *)n, (GF_Node *)par);t} else {ttcom = gf_sg_command_new(read->load->scene_graph, GF_SG_INDEXED_INSERT);ttcom->node = gf_sg_find_node_by_name(read->load->scene_graph, ""DICTIONARY"");ttgf_node_register(com->node, NULL);ttf = gf_sg_command_field_new(com);ttf->field_ptr = &f->new_node;ttf->fieldType = GF_SG_VRML_SFNODE;ttf->fieldIndex = 0;t ttf->pos = -1;ttf->new_node = n;ttgf_node_register(f->new_node, NULL);ttif (read->bifs_dict_au)tttgf_list_add(read->bifs_dict_au->commands, com);ttelsetttgf_list_add(read->bifs_au->commands, com);t}treturn GF_OK;}",3,"cwe119,cwe120,cweother"
"findfile(char *superfile, char *file){  static char *path = NULL;  char **dirp;  char pbuf[1024];  if (path) {    free(path);    path = NULL;  }  if (file == NULL) return NULL;  if (file[0] == '/' || file[0] == '$') {    strcpy(pbuf, file);    envexpand(pbuf);    if (access(pbuf,R_OK)==0)      return (path = strdup(pbuf));    else      return NULL;  }  if (superfile) {    dirprefix(superfile, pbuf);    strcat(pbuf, file);    envexpand(pbuf);    if (access(pbuf,R_OK)==0)      return (path = strdup(pbuf));  }  if(dirlist == NULL) {    if(access(file, R_OK) == 0)treturn (path = strdup(file));  } else {      for (dirp = dirlist; *dirp != NULL; dirp++) {tsprintf(pbuf,""%s/%s"", *dirp, file);tenvexpand(pbuf);tif (access(pbuf,R_OK)==0)t  return (path = strdup(pbuf));      }  }  return (path = NULL);}",3,"cwe119,cwe120,cweother"
"aes_setkey_dec( aes_context *ctx, const unsigned char *key, int keysize ){tint i, j;taes_context cty;tunsigned long *RK;tunsigned long *SK;tswitch( keysize )t{tcase 128: ctx->nr = 10; break;tcase 192: ctx->nr = 12; break;tcase 256: ctx->nr = 14; break;tdefault : return;t}#if defined(PADLOCK_ALIGN16)tctx->rk = RK = PADLOCK_ALIGN16( ctx->buf );#elsetctx->rk = RK = ctx->buf;#endiftaes_setkey_enc( &cty, key, keysize );tSK = cty.rk + cty.nr * 4;t*RK++ = *SK++;t*RK++ = *SK++;t*RK++ = *SK++;t*RK++ = *SK++;tfor( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )t{ttfor( j = 0; j < 4; j++, SK++ )tt{ttt*RK++ = RT0[ FSb[ ( *SK ) & 0xFF ] ] ^ttttRT1[ FSb[ ( *SK >> 8 ) & 0xFF ] ] ^ttttRT2[ FSb[ ( *SK >> 16 ) & 0xFF ] ] ^ttttRT3[ FSb[ ( *SK >> 24 ) & 0xFF ] ];tt}t}t*RK++ = *SK++;t*RK++ = *SK++;t*RK++ = *SK++;t*RK++ = *SK++;tmemset( &cty, 0, sizeof( aes_context ) );}",2,"cwe119,cwe120"
"read_config_read_memory(int type, char *readfrom,                        char *dataptr, size_t * len){    int            *intp;    unsigned int   *uintp;    char            buf[SPRINT_MAX_LEN];    if (!dataptr || !readfrom)        return NULL;    switch (type) {    case ASN_INTEGER:        if (*len < sizeof(int))            return NULL;        intp = (int *) dataptr;        readfrom = copy_nword(readfrom, buf, sizeof(buf));        *intp = atoi(buf);        *len = sizeof(int);        return readfrom;    case ASN_COUNTER:    case ASN_TIMETICKS:    case ASN_UNSIGNED:        if (*len < sizeof(unsigned int))            return NULL;        uintp = (unsigned int *) dataptr;        readfrom = copy_nword(readfrom, buf, sizeof(buf));        *uintp = strtoul(buf, NULL, 0);        *len = sizeof(unsigned int);        return readfrom;    case ASN_IPADDRESS:        if (*len < sizeof(int))            return NULL;        intp = (int *) dataptr;        readfrom = copy_nword(readfrom, buf, sizeof(buf));        *intp = inet_addr(buf);        if ((*intp == -1) && (strcmp(buf, ""255.255.255.255"") != 0))            return NULL;        *len = sizeof(int);        return readfrom;    case ASN_OCTET_STR:    case ASN_BIT_STR:    case ASN_PRIV_IMPLIED_OCTET_STR:        return read_config_read_octet_string(readfrom,                                             (u_char **) & dataptr, len);    case ASN_PRIV_IMPLIED_OBJECT_ID:    case ASN_OBJECT_ID:        readfrom =            read_config_read_objid(readfrom, (oid **) & dataptr, len);        *len *= sizeof(oid);        return readfrom;    case ASN_COUNTER64:        if (*len < sizeof(U64))            return NULL;        *len = sizeof(U64);        read64((U64 *) dataptr, readfrom);        readfrom = skip_token(readfrom);        return readfrom;    }    DEBUGMSGTL((""read_config_read_memory"", ""Fail: Unknown type: %d"", type));    return NULL;}",4,"cwe119,cwe120,cwe476,cweother"
"main(int argc,char **argv){    int bflag, ch;#ifdef SIGINFO    signal(SIGINFO,sig_info);#endif    bflag = 0;    while ((ch = getopt(argc, argv, ""s:S:p:lLh?dqnvr:"")) != -1) {tswitch (ch) {tcase 's':t    opt_segname = optarg;t    break;tcase 'S':t    opt_sector = atoi64(optarg);t    break;tcase 'p':t    opt_pagenum = atoi64(optarg);t    break;tcase 'q':t    opt_quiet = 1;t    break;tcase 'n':t    opt_quiet = 0;t    break;tcase 'l':t    opt_list = 1;t    break;tcase 'r':t    opt_r.push_back(optarg);t    break;tcase 'L':t    opt_list = 1;t    opt_list_long = 1;t    break;tcase 'b':t    opt_badflag = 1;t    break;tcase 'd':t    opt_debug++;t    break;tcase 'h':tcase '?':tdefault:t    usage();t    break;tcase 'v':t    printf(""%s version %s"",progname,PACKAGE_VERSION);t    exit(0);t}    }    argc -= optind;    argv += optind;    if(argc<1){tusage();    }    while(*argv){tAFFILE *af = af_open(*argv,O_RDONLY,0);tif(!af) af_err(1,""afcat(%s)"",*argv);tif(afcat(af)) err(1,""afcat"");taf_close(af);targv++;targc--;    }}",2,"cwe120,cweother"
"main( int argc, char **argv, char **envp )r{rtchar buf[ 1024 ];rtFILE *fin;rtFILE *fout;rtchar *p;rtint doDotC = 0;rrtif( argc < 3 )rt{rt    fprintf( stderr, ""usage: %s jambase.c Jambase ..."", argv[0] );rt    return -1;rt}rrtif( !( fout = fopen( argv[1], ""w"" ) ) )rt{rt    perror( argv[1] );rt    return -1;rt}rrt rrtif( ( p = strrchr( argv[1], '.' ) ) && !strcmp( p, "".c"" ) )rt    doDotC++;rrt rrtargc -= 2, argv += 2;rrtif( doDotC )rt{rt    fprintf( fout, ""/* Generated by mkjambase from Jambase */"" );rt    fprintf( fout, ""const char *jambase[] = {"" );rt}rrtfor( ; argc--; argv++ )rt{rt    if( !( fin = fopen( *argv, ""r"" ) ) )rt    {rttperror( *argv );rttreturn -1;rt    }rrt    if( doDotC )rt    {rttfprintf( fout, ""/* %s */"", *argv );rt    }rt    elsert    {rttfprintf( fout, ""### %s ###"", *argv );rt    }rrt    while( fgets( buf, sizeof( buf ), fin ) )rt    {rttif( doDotC )rtt{rtt    char *p = buf;rrtt     rrtt    while( *p == ' ' || *p == 't' || *p == '' )rtttp++;rrtt     rrtt    if( *p == '#' || !*p )rtttcontinue;rrtt     rrtt    putc( '""', fout );rrtt    for( ; *p && *p != '' && *p != 'r'; p++ )rtttswitch( *p )rtt    {rtt    case '': putc( '', fout ); putc( '', fout ); break;rtt    case '""': putc( '', fout ); putc( '""', fout ); break;rtt    default: putc( *p, fout ); break;rtt    }rrtt    fprintf( fout, """","" );rtt}rttelsertt{rtt    fprintf( fout, ""%s"", buf );rtt}rrt    }rrt    fclose( fin );rt}rt    rtif( doDotC )rt    fprintf( fout, ""0 };"" );rrtfclose( fout );rrtreturn 0;r}",2,"cwe469,cweother"
"PrintColorantTable(cmsHPROFILE hInput, cmsTagSignature Sig, const char* Title){    cmsNAMEDCOLORLIST* list;    int i, n;    if (cmsIsTag(hInput, Sig)) {                printf(""%s:"", Title);                list = cmsReadTag(hInput, Sig);        if (list == NULL) {            printf(""(Unavailable)"");            return;        }        n = cmsNamedColorCount(list);        for (i=0; i < n; i++) {            char Name[cmsMAX_PATH];            cmsNamedColorInfo(list, i, Name, NULL, NULL, NULL, NULL);            printf(""t%s"", Name);        }                    printf("""");    }    }",2,"cwe119,cwe120"
"ipmi_sdr_get_unit_string(uint8_t type, uint8_t base, uint8_t modifier){tstatic char unitstr[16];tmemset(unitstr, 0, sizeof (unitstr));tswitch (type) {tcase 2:ttsnprintf(unitstr, sizeof (unitstr), ""%s * %s"",ttt unit_desc[base], unit_desc[modifier]);ttbreak;tcase 1:ttsnprintf(unitstr, sizeof (unitstr), ""%s/%s"",ttt unit_desc[base], unit_desc[modifier]);ttbreak;tcase 0:tdefault:ttsnprintf(unitstr, sizeof (unitstr), ""%s"", unit_desc[base]);ttbreak;t}treturn unitstr;}",2,"cwe119,cwe120"
"gretl_matrix_data_subset_special (const int *list, tttt  const DATASET *dset,tttt  const gretl_matrix *mmask,tttt  int *err){    int n = gretl_vector_get_length(mmask);    gretl_matrix *X = NULL;    if (list == NULL || n != dset->n) {t*err = E_DATA;    } else if (list[0] == 0) {tX = gretl_null_matrix_new();    } else {tint T = mmask_row_count(mmask, dset);tint k = list[0];tif (T == 0) {t    X = gretl_null_matrix_new();t} else {t    X = gretl_matrix_alloc(T, k);t}ttif (X != NULL && T > 0) {t    const double *xi;t    double xti;t    int i, s, t;t    for (i=0; i<k; i++) {ttxi = dset->Z[list[i+1]];tts = 0;ttfor (t=dset->t1; t<=dset->t2; t++) {tt    if (mmask->val[t] != 0) {tttxti = xi[t];tttif (na(xti)) {ttt    xti = M_NA;ttt}tttif (s == 0) {ttt    gretl_matrix_set_t1(X, t);ttt} else if (s == T - 1) {ttt    gretl_matrix_set_t2(X, t);ttt}tttgretl_matrix_set(X, s++, i, xti);tt    }tt}t    }t}    }    if (X == NULL && *err == 0) {t*err = E_ALLOC;    }    return X;}",2,"cwe120,cwe476"
"HEIPV6TB_update_entry(void){  char buf[BUFFER_SIZE+1];  char *bp = buf;  int bytes;  int btot;  int ret;  buf[BUFFER_SIZE] = '0';  if(do_connect((int*)&client_sockfd, server, port) != 0)  {    if(!(options & OPT_QUIET))    {      show_message(""error connecting to %s:%s"", server, port);    }    return(UPDATERES_ERROR);  }  snprintf(buf, BUFFER_SIZE, ""GET %s?menu=%s&"", request, ""edit_tunnel_address"");  output(buf);  snprintf(buf, BUFFER_SIZE, ""aname=%s&"", user_name);  output(buf);  snprintf(buf, BUFFER_SIZE, ""auth=%s&"", password);  output(buf);  snprintf(buf, BUFFER_SIZE, ""ipv4b=%s"", address);  output(buf);  snprintf(buf, BUFFER_SIZE, "" HTTP/1.0015012"");  output(buf);  snprintf(buf, BUFFER_SIZE, ""User-Agent: %s-%s %s [%s] (%s)015012"",       ""ez-update"", VERSION, OS, (options & OPT_DAEMON) ? ""daemon"" : """", ""by Angus Mackay"");  output(buf);  snprintf(buf, BUFFER_SIZE, ""Host: %s015012"", server);  output(buf);  snprintf(buf, BUFFER_SIZE, ""015012"");  output(buf);  bp = buf;  bytes = 0;  btot = 0;  while((bytes=read_input(bp, BUFFER_SIZE-btot)) > 0)  {    bp += bytes;    btot += bytes;    dprintf((stderr, ""btot: %d"", btot));  }  close(client_sockfd);  buf[btot] = '0';  dprintf((stderr, ""server output: %s"", buf));  if(sscanf(buf, "" HTTP/1.%*c %3d"", &ret) != 1)  {    ret = -1;  }  switch(ret)  {    case -1:      if(!(options & OPT_QUIET))      {        show_message(""strange server response, are you connecting to the right server?"");      }      return(UPDATERES_ERROR);      break;    case 200:      if(!(options & OPT_QUIET))      {        printf(""request successful"");      }      break;    default:      if(!(options & OPT_QUIET))      {                 *auth = '0';        sscanf(buf, "" HTTP/1.%*c %*3d %255[^r]"", auth);        show_message(""unknown return code: %d"", ret);        fprintf(stderr, ""server response: %s"", auth);      }      return(UPDATERES_ERROR);      break;  }  return(UPDATERES_OK);}",2,"cwe119,cwe120"
"output_vcall_table (void){  unsigned i;  unsigned long vcall_length = size_of_vcall_table ();  vcall_entry *p;  char poc_label[MAX_ARTIFICIAL_LABEL_BYTES];  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)    dw2_asm_output_data (4, 0xffffffff,      ""Initial length escape value indicating 64-bit DWARF extension"");  dw2_asm_output_data (DWARF_OFFSET_SIZE, vcall_length,tt       ""Length of Virtual Call Table"");  dw2_asm_output_data (2, 4, ""Version number"");  dw2_asm_output_data (1, DWARF2_ADDR_SIZE, ""Pointer Size (in bytes)"");  FOR_EACH_VEC_ELT (vcall_entry, vcall_table, i, p)    {      ASM_GENERATE_INTERNAL_LABEL (poc_label, ""LPOC"", p->poc_label_num);      dw2_asm_output_addr (DWARF_OFFSET_SIZE, poc_label, ""Point of call"");      dw2_asm_output_data_uleb128 (p->vtable_slot, ""Vtable slot"");    }}",2,"cwe119,cwe120"
"search(FILE *file,char *buffer,int length,  const struct sockaddr *addr,int flags){    struct sockaddr_atmsvc temp;    char line[MAX_ATM_NAME_LEN+1];    const char *here;     while (fgets(line,MAX_ATM_NAME_LEN,file)) {        if (!(here = strtok(line,""t ""))) continue;tif (text2atm(here,(struct sockaddr *) &temp,sizeof(temp),flags) < 0)t    continue;tif (temp.sas_family != addr->sa_family) continue;tif (temp.sas_family == AF_ATMPVC) {t    if (((const struct sockaddr_atmpvc *) addr)->sap_addr.itf !=t      ((struct sockaddr_atmpvc *) &temp)->sap_addr.itf ||t      ((const struct sockaddr_atmpvc *) addr)->sap_addr.vpi !=t      ((struct sockaddr_atmpvc *) &temp)->sap_addr.vpi ||t      ((const struct sockaddr_atmpvc *) addr)->sap_addr.vci !=t      ((struct sockaddr_atmpvc *) &temp)->sap_addr.vci) continue;t}telse if (!atm_equal(addr,(struct sockaddr *) &temp,0,0)) continue;        while ((here = strtok(NULL,""t "")))t    if (strlen(here) < length) {ttstrcpy(buffer,here);ttreturn 0;t    }treturn FATAL;    }    return TRY_OTHER;}",2,"cwe119,cwe120"
"main(int argc, char *argv[]) {  char *me, *err;  int enc, form;  me = argv[0];  if (2 == argc) {    if (!strcmp(argv[1], ""--version"")) {      char vbuff[AIR_STRLEN_LARGE];      airTeemVersionSprint(vbuff);      printf(""%s"", vbuff);      exit(0);    } else if (!strcmp(argv[1], ""--help"")) {      char par1[] = "" Usage: nrrdSanity "";      char par2[] = ""tttt""        ""nrrdSanity calls the nrrdSanity() check to verify the correctness ""        ""of all the information (set at compile-time) about the architecture, ""        ""such as endianness, 32/64-bit, and the size of various types, as ""        ""well as running sanity checks on the global default (nrrdDefault*) ""        ""and state (nrrdState*) variables. "";      char par3[] = ""tttt""        ""As a convenience, nrrdSanity also list the availability of the ""        ""different formats and data encodings (for Nrrd files) supported ""        ""by this build. "";      _hestPrintStr(stdout, 1, 0, 78, par1, AIR_FALSE);      _hestPrintStr(stdout, 1, 0, 78, par2, AIR_FALSE);      _hestPrintStr(stdout, 1, 0, 78, par3, AIR_FALSE);      exit(0);    } else {      fprintf(stderr, ""%s: unexpected arguments; ""              """"%s --help"" for more information"", me, me);      exit(1);    }  }     if (!nrrdSanity()) {    printf(""%s: nrrd sanity check FAILED:%s"", me, err = biffGet(NRRD));    free(err);    return 1;  }  else {    printf(""%s: nrrd sanity check passed."", me);    printf("""");    printf(""%s: encodings supported in this build:"", me);    for (enc=nrrdEncodingTypeUnknown+1; enc<nrrdEncodingTypeLast; enc++) {      printf(""%s: %s"", airEnumStr(nrrdEncodingType, enc),             nrrdEncodingArray[enc]->available() ? ""yes"" : ""not available"");    }    printf(""%s: formats supported in this build:"", me);    for (form=nrrdFormatTypeUnknown+1; form<nrrdFormatTypeLast; form++) {      printf(""%s: %s"", airEnumStr(nrrdFormatType, form),             nrrdFormatArray[form]->available() ? ""yes"" : ""not available"");    }  }  return 0;}",2,"cwe119,cwe120"
"cgi_formdata(unsigned long contentlength){chartpidbuf[MAXLONGSIZE];charttimebuf[MAXLONGSIZE];chartcntbuf[MAXLONGSIZE];time_ttt;unsigned long cnt;inttn;chart*filename, *p;static const char fakeheader[]=""MIME-Version: 1.0Content-Type: "";chartbuf[BUFSIZ];tsprintf(pidbuf, ""%lu"", (unsigned long)getpid());ttime(&t);tsprintf(timebuf, ""%lu"", (unsigned long)t);tcnt=0;tbuf[sizeof(buf)-1]=0;tif (gethostname(buf, sizeof(buf)-1) != 0)ttbuf[0]='0';tdot{ttsprintf(cntbuf, ""%lu"", (unsigned long)cnt);ttfilename=malloc(strlen(pidbuf)+strlen(timebuf)+strlen(cntbuf)tttt+strlen(cgitempdir)+strlen(buf)+10);ttif (!filename)tenomem();ttsprintf(filename, ""%s/%s.%s_%s.%s"", cgitempdir,tttttimebuf, pidbuf, cntbuf, buf);ttcgiformfd=open(filename, O_RDWR | O_CREAT | O_EXCL, 0644);t} while (cgiformfd < 0);tunlink(filename);t thascgiformfd=1;tp=getenv(""CONTENT_TYPE"");tfree(filename);tcgiformfdw(fakeheader, strlen(fakeheader));tcgiformfdw(p, strlen(p));tcgiformfdw("""", 2);tclearerr(stdin);twhile (contentlength)t{ttn=sizeof(buf);ttif (n > contentlength)tn=contentlength;ttn=fread(buf, 1, n, stdin);ttif (n <= 0)tttenomem();ttcgiformfdw(buf, n);ttcontentlength -= n;t}trfc2045p=rfc2045_alloc();tlseek(cgiformfd, 0L, SEEK_SET);twhile ((n=read(cgiformfd, buf, sizeof(buf))) > 0)ttrfc2045_parse(rfc2045p, buf, n);trfc2045_parse_partial(rfc2045p);trfc2045_decode(rfc2045p, &cgiformdecode, 0);}",3,"cwe119,cwe120,cweother"
"handshake_set_fragsize(int dns_fd, int fragsize){tchar in[4096];tint i;tint read;tfprintf(stderr, ""Setting downstream fragment size to max %d..."", fragsize);tfor (i=0; running && i<5 ;i++) {ttsend_set_downstream_fragsize(dns_fd, fragsize);ttread = handshake_waitdns(dns_fd, in, sizeof(in), 'n', 'N', i+1);tt ttttttif (read > 0) {ttttint accepted_fragsize;ttttif (strncmp(""BADFRAG"", in, 7) == 0) {tttttfprintf(stderr, ""Server rejected fragsize. Keeping default."");tttttreturn;tttt} else if (strncmp(""BADIP"", in, 5) == 0) {tttttfprintf(stderr, ""Server rejected sender IP address."");tttttreturn;tttt}ttttaccepted_fragsize = ((in[0] & 0xff) << 8) | (in[1] & 0xff);ttttreturn;ttt}tt ttfprintf(stderr, ""Retrying set fragsize..."");t}tif (!running)ttreturn;tfprintf(stderr, ""No reply from server when setting fragsize. Keeping default."");}",3,"cwe119,cwe120,cweother"
"process_file(char *filename){tif (filename != NULL && strcmp(filename, ""-"") != 0) {ttif ((yyin = fopen(filename, ""r"")) == NULL)ttterr(1, ""%s"", filename);t} elsettyyin = stdin;tstrcpy(table[0].ident, """");tlineno = 1;tnline(lineno);tyyparse();tif (yyin != stdin)ttfclose(yyin);tprint_refs();}",3,"cwe120,cwe476,cweother"
"get_ctl_value_v1(struct usb_mixer_elem_info *cval, int request,ttt    int validx, int *value_ret){tstruct snd_usb_audio *chip = cval->head.mixer->chip;tunsigned char buf[2];tint val_len = cval->val_type >= USB_MIXER_S16 ? 2 : 1;tint timeout = 10;tint idx = 0, err;terr = snd_usb_lock_shutdown(chip);tif (err < 0)ttreturn -EIO;twhile (timeout-- > 0) {ttidx = snd_usb_ctrl_intf(chip) | (cval->head.id << 8);ttif (snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), request,tttt    USB_RECIP_INTERFACE | USB_TYPE_CLASS | USB_DIR_IN,tttt    validx, idx, buf, val_len) >= val_len) {ttt*value_ret = convert_signed_value(cval, snd_usb_combine_bytes(buf, val_len));ttterr = 0;tttgoto out;tt}t}tusb_audio_dbg(chip,tt""cannot get ctl value: req = %#x, wValue = %#x, wIndex = %#x, type = %d"",ttrequest, validx, idx, cval->val_type);terr = -EINVAL; out:tsnd_usb_unlock_shutdown(chip);treturn err;}",2,"cwe119,cwe120"
"iwl_dbgfs_interrupt_write(struct file *file,ttttt const char __user *user_buf,ttttt size_t count, loff_t *ppos){tstruct iwl_trans *trans = file->private_data;tstruct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);tstruct isr_statistics *isr_stats = &trans_pcie->isr_stats;tchar buf[8];tint buf_size;tu32 reset_flag;tmemset(buf, 0, sizeof(buf));tbuf_size = min(count, sizeof(buf) -  1);tif (copy_from_user(buf, user_buf, buf_size))ttreturn -EFAULT;tif (sscanf(buf, ""%x"", &reset_flag) != 1)ttreturn -EFAULT;tif (reset_flag == 0)ttmemset(isr_stats, 0, sizeof(*isr_stats));treturn count;}",2,"cwe119,cwe120"
"show_default(void){tconst char *s = def;tif (s) {ttunsigned char sha1[20];ttdef = NULL;ttif (!get_sha1(s, sha1)) {tttshow_rev(NORMAL, sha1, s);tttreturn 1;tt}t}treturn 0;}",3,"cwe119,cwe120,cwe469"
"netbeans_send_disconnect(){    char buf[128];    if (NETBEANS_OPEN)    {tsprintf(buf, ""0:disconnect=%d"", r_cmdno);tnbdebug((""EVT: %s"", buf));tnb_send(buf, ""netbeans_disconnect"");    }}",2,"cwe119,cwe120"
"handle_F(int rid, int mode){  struct user_F *f;  char s[200];  struct keyval *v;  unsigned short acb;  int b;  if (H_SAM < 0) return(0);     snprintf(s,180,""SAMDomainsAccountUsers%08XF"",rid);  v = get_val2buf(hive[H_SAM], NULL, 0, s, REG_BINARY, TPF_VK_EXACT);  if (!v) {    printf(""Cannot find value <%s>"",s);    return(0);  }  if (v->len < 0x48) {    printf(""handle_F: F value is 0x%x bytes, need >= 0x48, unable to check account flags!"",v->len);    FREE(v);    return(0);  }  f = (struct user_F *)&v->data;  acb = f->ACB_bits;  if (mode == 1) {    printf(""Account bits: 0x%04x ="",acb);    for (b=0; b < 15; b++) {      printf(""[%s] %-15.15s | "",t     (acb & (1<<b)) ? ""X"" : "" "", acb_fields[b] );      if (b%3 == 2) printf("""");    }    printf(""Failed login count: %u, while max tries is: %u"",f->failedcnt,max_sam_lock);    printf(""Total  login count: %u"",f->logins);  }      if (mode == 2) {    acb |= ACB_PWNOEXP;    acb &= ~ACB_DISABLED;    acb &= ~ACB_AUTOLOCK;    f->ACB_bits = acb;    f->failedcnt = 0;    put_buf2val(hive[H_SAM], v, 0, s, REG_BINARY,TPF_VK_EXACT);    printf(""Unlocked!"");  }  return (acb | ( (f->failedcnt > 0 && f->failedcnt >= max_sam_lock)<<15 ) | (acb & ACB_AUTOLOCK)<<15 | (acb & ACB_DISABLED)<<15);}",2,"cwe119,cwe120"
"parse_coord_string(const char *cstring, uint32_t *ret_start, uint32_t *ret_end){  ESL_REGEXP *re = esl_regexp_Create();  char        tok1[32];  char        tok2[32];  uint32_t    start, end;          if (esl_regexp_Match(re, ""^(d+)D+(d*)$"", cstring) != eslOK) esl_fatal(""with -t, 2nd cmdline arg must be coords <from>..<to>; %s not recognized"", cstring);  if (esl_regexp_SubmatchCopy(re, 1, tok1, 32)            != eslOK) esl_fatal(""Failed to find <from> coord in %s"", cstring);  if (esl_regexp_SubmatchCopy(re, 2, tok2, 32)            != eslOK) esl_fatal(""Failed to find <to> coord in %s"",   cstring);     start = atol(tok1);  if(start == 0) esl_fatal(""with -t, coordinates must be positive integers <from>..<to>, <from> coordinate read as '0'"");  if(tok2[0] == '0') {      end = 0;  }  else {     end = atol(tok2);    if(end <= 0) esl_fatal(""with -t, coordinates must be positive integers <from>..<to>, <to> coordinate read as '0'"");    if(start > end) esl_fatal(""with -t, 2nd cmdline arg <coords> must equal <from>..<to>, with <from> <= <to>"");  }  *ret_start = start;  *ret_end   = end;  esl_regexp_Destroy(re);  return eslOK;}",3,"cwe119,cwe120,cweother"
"goutfile(void){tFILEt*res;tinttfid;tfor  (;;)  {ttsprintf(tmpfl, ""%s%s%.8lu"", P_tmpdir, SPNAM, (unsigned long) (jobn%100000000));ttif  ((fid = open(tmpfl, O_RDWR|O_CREAT|O_EXCL, 0400)) >= 0)tttbreak;ttjobn += JN_INC;t}tcatchsigs();tif  ((res = fdopen(fid, ""w+"")) == (FILE *) 0)  {ttunlink(tmpfl);ttnomem();t}treturn  res;}",2,"cwe120,cweother"
"cdash_current_time(char *strtime) {ttime_t t1;tstruct tm d1;tchar s[20];tsize_t i;tt1 = time(0);tgmtime_r(&t1, &d1);tif(strtime == NULL)ttreturn t1;ti = strftime(s, 20, ""%b %d %H:%M EDT"", &d1);tstrncpy(strtime, s, i+1);treturn t1;}",2,"cwe119,cwe120"
"sdr_cache_flush_cache (ipmi_sdr_cache_ctx_t ctx,                       pstdout_state_t pstate,                       int quiet_cache,                       const char *hostname,                       const char *cache_dir,tt       const char *cache_file){  char cachefilenamebuf[MAXPATHLEN+1];  int rv = -1;  assert (ctx);  memset (cachefilenamebuf, '0', MAXPATHLEN+1);  if (_sdr_cache_get_cache_filename (pstate,tttt     hostname,tttt     cache_dir,tttt     cache_file,tttt     cachefilenamebuf,tttt     MAXPATHLEN) < 0)    goto cleanup;  if (!quiet_cache)    PSTDOUT_PRINTF (pstate, ""Flushing cache: %s"", cachefilenamebuf);    if (ipmi_sdr_cache_delete (ctx, cachefilenamebuf) < 0)    {      PSTDOUT_FPRINTF (pstate,                       stderr,                       ""ipmi_sdr_cache_delete: %s"",                       ipmi_sdr_cache_ctx_errormsg (ctx));      goto cleanup;    }    rv = 0; cleanup:  return (rv);}",2,"cwe119,cwe120"
"sanitize_xml(unsigned char * text, int length){tint i;tsize_t len;tunsigned char * pos;tchar * newpos;tchar * newtext = NULL;tif (text != NULL && length > 0) {ttlen = 5 * length;ttnewtext = (char *)calloc(1, (len + 1) * sizeof(char));  ttpos = text;ttfor (i = 0; i < length; ++i, ++pos) {tttswitch (*pos) {ttttcase '&':tttttstrncat(newtext, ""&amp;"", len);tttttbreak;ttttcase '<':tttttstrncat(newtext, ""&lt;"", len);tttttbreak;ttttcase '>':tttttstrncat(newtext, ""&gt;"", len);tttttbreak;ttttdefault:tttttif ( isprint((int)(*pos)) || (*pos)>127 ) {ttttttnewtext[strlen(newtext)] = *pos;ttttt} else {ttttttnewtext[strlen(newtext)] = '';ttttttnewpos = newtext + strlen(newtext);ttttttsnprintf(newpos, strlen(newpos) + 1, ""%3u"", *pos);ttttt}tttttbreak;ttt}tt}ttnewtext = (char *) realloc(newtext, strlen(newtext) + 1);t}treturn newtext;}",3,"cwe119,cwe120,cweother"
"addrgb(unsigned char rgb[3], int sr, int sg, int sb) { int add[3], i;    add[0]=2*sr; add[1]=2*sg; add[2]=2*sb; if (((int)rgb[0])+((int)rgb[1])+((int)rgb[2])>=3*160)    { add[0]=(-sg-sb); add[1]=(-sr-sb); add[2]=(-sr-sg); }     for (i=0;i<3;i++)   if (add[i]<0) rgb[i]-=((    rgb[i]<-add[i])?    rgb[i]:-add[i]);   else          rgb[i]+=((255-rgb[i]< add[i])?255-rgb[i]: add[i]);}",2,"cwe119,cwe120"
"FcCacheInsert (FcCache *cache, struct stat *cache_stat){    FcCacheSkip    **update[FC_CACHE_MAX_LEVEL];    FcCacheSkip    *s, **next;    inttt    i, level;         next = fcCacheChains;    for (i = fcCacheMaxLevel; --i >= 0; )    {tfor (; (s = next[i]); next = s->next)t    if (s->cache > cache)ttbreak;        update[i] = &next[i];    }         level = random_level ();    if (level > fcCacheMaxLevel)    {tlevel = fcCacheMaxLevel + 1;tupdate[fcCacheMaxLevel] = &fcCacheChains[fcCacheMaxLevel];tfcCacheMaxLevel = level;    }    s = malloc (sizeof (FcCacheSkip) + (level - 1) * sizeof (FcCacheSkip *));    if (!s)treturn FcFalse;    s->cache = cache;    s->size = cache->size;    s->ref = 1;    if (cache_stat)    {ts->cache_dev = cache_stat->st_dev;ts->cache_ino = cache_stat->st_ino;ts->cache_mtime = cache_stat->st_mtime;    }    else    {ts->cache_dev = 0;ts->cache_ino = 0;ts->cache_mtime = 0;    }         for (i = 0; i < level; i++)    {ts->next[i] = *update[i];t*update[i] = s;    }    return FcTrue;}",3,"cwe119,cwe120,cweother"
"ChooseConstraintName(const char *name1, const char *name2,ttttt const char *label, Oid namespace,ttttt List *others){tinttttpass = 0;tchart   *conname = NULL;tcharttmodlabel[NAMEDATALEN];tRelationtconDesc;tSysScanDesc conscan;tScanKeyData skey[2];tboolttfound;tListCell   *l;tconDesc = heap_open(ConstraintRelationId, AccessShareLock);t tStrNCpy(modlabel, label, sizeof(modlabel));tfor (;;)t{ttconname = makeObjectName(name1, name2, modlabel);ttfound = false;ttforeach(l, others)tt{tttif (strcmp((char *) lfirst(l), conname) == 0)ttt{ttttfound = true;ttttbreak;ttt}tt}ttif (!found)tt{tttScanKeyInit(&skey[0],ttttttAnum_pg_constraint_conname,ttttttBTEqualStrategyNumber, F_NAMEEQ,ttttttCStringGetDatum(conname));tttScanKeyInit(&skey[1],ttttttAnum_pg_constraint_connamespace,ttttttBTEqualStrategyNumber, F_OIDEQ,ttttttObjectIdGetDatum(namespace));tttconscan = systable_beginscan(conDesc, ConstraintNameNspIndexId, true,tttttttttt SnapshotNow, 2, skey);tttfound = (HeapTupleIsValid(systable_getnext(conscan)));tttsystable_endscan(conscan);tt}ttif (!found)tttbreak;tt ttpfree(conname);ttsnprintf(modlabel, sizeof(modlabel), ""%s%d"", label, ++pass);t}theap_close(conDesc, AccessShareLock);treturn conname;}",2,"cwe119,cwe120"
"main(int argc, char ** argv){  dxml_element * tmp ;  int c;  const char * papersize=""letter"";  const char * articletype=""report"";  while ((c = getopt(argc, argv, ""p"")) != -1)    {      switch (c)t{tcase 'p':t  articletype=""jreport"";t  papersize=""a4j"";t  break;tcase '?':t  return 1;tdefault:t  fprintf(stderr, ""Unknown option -%c used"", c);t  return 1;t}    }  printf (t  ""%s%s"",t  ""%%Generated by dxml-db2latex"",t  VERSION);  tmp = dxml_read_xml(stdin);  if (tmp)    {      char * title = NULL;      dxml_element * authorlink;            printf (t      ""documentclass[%s]{%s}""t      ""usepackage{moreverb}""t      ""date{}""t      ""author{"",t      papersize, articletype);            {tint notfirst = 0;tfor (authorlink = dxml_get_element_bysimplepath(tmp,""book/bookinfo/authorgroup/author"");t     authorlink; t     authorlink = dxml_get_element_byname(authorlink->next, ""author""))t  {t    if (notfirst) t      printf("", "");t    elset      notfirst = 1;t    t    convert_print(dxml_get_PCDATA_bysimplepath(authorlink, ""author/firstname""),0);t    printf("" "");t    t    convert_print(dxml_get_PCDATA_bysimplepath(authorlink, ""author/surname""),0);t  }      }            printf (""}"");         printf (t      ""title{"");      title=dxml_get_PCDATA_bysimplepath(tmp,""book/title"");      if (!title)ttitle=dxml_get_PCDATA_bysimplepath(tmp,""book/bookinfo/title"");      if (title)tconvert_print(title,0);            printf (t      ""}""t      ""begin{document}""t      ""maketitle""t      ""tableofcontents""t      );            recursebook(dxml_get_element_byname(tmp, ""book"")->child);      printf (t      ""end{document}"");    }  else    {      printf (""Something wicked happened!"");      return 1;    }  return 0;  }",2,"cwe120,cweother"
"main(int argc, char** argv) {  const char *Interp = getenv(""LLVMINTERP"");  const char **Args;  if (Interp == 0) Interp = ""lli"";     Args = (const char**)malloc(sizeof(char*) * (argc+2));     Args[0] = Interp;#ifdef LLVM_ON_WIN32  {    int len = strlen(argv[0]);    if (len < 4 || strcmp(argv[0] + len - 4, "".exe"") != 0) {             argv[0] = strcat(strcpy((char*)malloc(len + 5), argv[0]), "".exe"");    }  }#endif     Args[1] = strcat(strcpy((char*)malloc(strlen(argv[0])+4), argv[0]), "".bc"");     memcpy((char **)Args+2, argv+1, sizeof(char*)*argc);   #if !defined(_WIN32) || defined(__MINGW64__)  execvp(Interp, (char **)Args);  #else  execvp(Interp, Args);  #endif     fprintf(stderr, ""Could not execute the LLVM JIT.  Either add 'lli' to your""          "" path, or set theinterpreter you want to use in the LLVMINTERP ""          ""environment variable."");  return 1;}",2,"cwe120,cweother"
"do_epilog(int timeout, int ckpt_type){   char *epilog;   char command[10000];   int exit_status;   shepherd_state = SSTATE_BEFORE_EPILOG;   epilog = get_conf_val(""epilog"");   if (strcasecmp(""none"", epilog)) {      int i, n_exit_status = count_exit_status();             replace_params(epilog, command, sizeof(command)-1,                      prolog_epilog_variables);      exit_status = start_child(""epilog"", command, NULL, timeout, ckpt_type);      if (n_exit_status<(i=count_exit_status())) {         shepherd_trace(""exit states increased from %d to %d"",                                 n_exit_status, i);                   shepherd_trace(""failed starting epilog"");         return SSTATE_BEFORE_EPILOG;      }      if (exit_status) {         switch( exit_status ) {            case RESCHEDULE_EXIT_STATUS:               shepherd_state = SSTATE_AGAIN;               break;            case APPERROR_EXIT_STATUS:               shepherd_state = SSTATE_APPERROR;               break;            default:               shepherd_state = SSTATE_EPILOG_FAILED;         }         shepherd_error(0, ""exit_status of epilog = %d"", exit_status);         return SSTATE_EPILOG_FAILED;      }   }   else      shepherd_trace(""no epilog script to start"");      return 0;}",2,"cwe119,cwe120"
"xsh_rectify( cpl_frame *sci_frame,t     cpl_frame * orderlist_frame, t     cpl_frame *wavesol_frame,t     cpl_frame * model_frame, t     xsh_instrument *instrument,t     xsh_rectify_param *rectify_par,t     cpl_frame *spectralformat_frame,t     cpl_frame *disp_tab_frame, t     const char * res_name,t     cpl_frame** res_frame_ext, t     cpl_frame** res_frame_tab,t     const char* rec_prefix){  cpl_frame *result = NULL;  xsh_order_list *orderlist = NULL ;  int nslit;  double slit_min;  char tag[256];  XSH_ASSURE_NOT_NULL( orderlist_frame);  check( orderlist = xsh_order_list_load ( orderlist_frame, instrument));  sprintf(tag,""%s_%s"",rec_prefix,t  XSH_GET_TAG_FROM_ARM( XSH_ORDER2D, instrument));  xsh_rec_slit_size( rectify_par, &slit_min, &nslit, XSH_MODE_SLIT);  check( result = xsh_rectify_orders( sci_frame, orderlist,     wavesol_frame, model_frame, instrument, rectify_par, spectralformat_frame,                                      disp_tab_frame, res_name, tag,                                       res_frame_ext, res_frame_tab,                                      0, 100, slit_min, nslit,0, NULL));  cleanup:    xsh_order_list_free( &orderlist);    return result;}",3,"cwe119,cwe120,cweother"
"on_togglebutton_queue_freeze_toggled(GtkToggleButton *togglebutton,tvoid *unused_udata){t(void) unused_udata;    if (gtk_toggle_button_get_active(togglebutton)) {        guc_download_freeze_queue();    } else {        guc_download_thaw_queue();    }}",2,"cwe119,cwe120"
"s48_inet_ntop(s48_call_t call, s48_ref_t sch_af, s48_ref_t sch_src){  sa_family_t af = s48_extract_af(call, sch_af);  switch (af)    {    case AF_INET:      {tchar dest[INET_ADDRSTRLEN+1];  tstruct in_addr addr;textract_in_addr(call, sch_src, &addr);#ifdef _WIN32t{t  DWORD destlen;t  if (WSAAddressToString((struct sockaddr *)&addr, sizeof(struct in_addr),tttt NULL, dest, &destlen) != 0)t    s48_os_error_2(call, ""s48_inet_ntop"", WSAGetLastError(), 2, sch_af, sch_src);t}t    #elsetif (inet_ntop(AF_INET, &addr, dest, sizeof(dest)) == NULL)t  s48_os_error_2(call, ""s48_inet_ntop"", errno, 2, sch_af, sch_src);#endiftreturn s48_enter_string_latin_1_2(call, dest);      }    case AF_INET6:      {tchar dest[INET6_ADDRSTRLEN+1];  tstruct in6_addr addr;ts48_extract_in6_addr(call, sch_src, &addr);#ifdef _WIN32t{t  DWORD destlen;t  if (WSAAddressToString((struct sockaddr *)&addr, sizeof(struct in6_addr),tttt NULL, dest, &destlen) != 0)t    s48_os_error_2(call, ""s48_inet_ntop"", WSAGetLastError(), 2, sch_af, sch_src);t}#elsetif (inet_ntop(AF_INET6, &addr, dest, sizeof(dest)) == NULL)t  s48_os_error_2(call, ""s48_inet_ntop"", errno, 2, sch_af, sch_src);#endiftreturn s48_enter_string_latin_1_2(call, dest);      }    default:      s48_assertion_violation_2(call, ""s48_inet_ntop"", ""invalid adddress family"", 1, sch_af);    }}",2,"cwe119,cwe120"
"GMT_grd_get_format (char *file, struct GRD_HEADER *header, GMT_LONG magic){t ttGMT_LONG i = 0, val, j;tchar code[GMT_TEXT_LEN], tmp[BUFSIZ];tGMT_expand_filename (file, header->name);t t theader->z_scale_factor = GMT_d_NaN, header->z_add_offset = 0.0, header->nan_value = GMT_d_NaN;twhile (header->name[i] && header->name[i] != '=') i++;tif (header->name[i]) {t tti++;ttsscanf (&header->name[i], ""%[^/]/%lf/%lf/%lf"", code, &header->z_scale_factor, &header->z_add_offset, &header->nan_value);ttval = GMT_grd_format_decoder (code);ttif (val < 0) return (val);ttheader->type = val;ttj = (i == 1) ? i : i - 1;ttheader->name[j] = 0;ttsscanf (header->name, ""%[^?]?%s"", tmp, header->varname);     ttif (magic) {t tttif (!GMT_getdatapath (tmp, header->name)) return (GMT_GRDIO_FILE_NOT_FOUND);t tt}ttelsett tttstrcpy (header->name, tmp);t}telse if (magic) {t ttsscanf (header->name, ""%[^?]?%s"", tmp, header->varname);     ttif (!GMT_getdatapath (tmp, header->name)) return (GMT_GRDIO_FILE_NOT_FOUND);t tt ttif ((val = GMT_is_nc_grid (header)) >= 0) return (GMT_NOERROR);tt ttif (val != GMT_GRDIO_NC_NO_PIPE && val != GMT_GRDIO_OPEN_FAILED) return (val);tt ttif (GMT_is_native_grid (header) >= 0) return (GMT_NOERROR);tt ttif (GMT_is_ras_grid (header) >= 0) return (GMT_NOERROR);tt ttif (GMT_is_srf_grid (header) >= 0) return (GMT_NOERROR);tt ttif (GMT_is_mgg2_grid (header) >= 0) return (GMT_NOERROR);tt ttif (GMT_is_agc_grid (header) >= 0) return (GMT_NOERROR);ttreturn (GMT_GRDIO_UNKNOWN_FORMAT);t t}telse {ttt ttif (sscanf (header->name, ""%[^?]?%s"", tmp, header->varname) > 1) strcpy (header->name, tmp);     ttsscanf (gmtdefs.gridfile_format, ""%[^/]/%lf/%lf/%lf"", code, &header->z_scale_factor, &header->z_add_offset, &header->nan_value);ttval = GMT_grd_format_decoder (code);ttif (val < 0) return (val);ttheader->type = val;t}tif (header->type == GMT_grd_format_decoder (""af"")) header->nan_value = 0.0;t treturn (GMT_NOERROR);}",3,"cwe119,cwe120,cweother"
"uds_sendfd (assuan_context_t ctx, assuan_fd_t fd){#ifdef USE_DESCRIPTOR_PASSING  struct msghdr msg;  struct iovec iovec;  union {    struct cmsghdr cm;    char control[CMSG_SPACE(sizeof (int))];  } control_u;  struct cmsghdr *cmptr;  int len;  char buffer[80];      snprintf (buffer, sizeof(buffer)-1, ""# descriptor %d is in flight"", fd);  buffer[sizeof(buffer)-1] = 0;  memset (&msg, 0, sizeof (msg));  msg.msg_name = NULL;  msg.msg_namelen = 0;  msg.msg_iovlen = 1;  msg.msg_iov = &iovec;  iovec.iov_base = buffer;  iovec.iov_len = strlen (buffer);  msg.msg_control = control_u.control;  msg.msg_controllen = sizeof (control_u.control);  cmptr = CMSG_FIRSTHDR (&msg);  cmptr->cmsg_len = CMSG_LEN(sizeof(int));  cmptr->cmsg_level = SOL_SOCKET;  cmptr->cmsg_type = SCM_RIGHTS;  memcpy (CMSG_DATA (cmptr), &fd, sizeof (fd));  len = _assuan_sendmsg (ctx, ctx->outbound.fd, &msg, 0);  if (len < 0)    {      int saved_errno = errno;      TRACE1 (ctx, ASSUAN_LOG_SYSIO, ""uds_sendfd"", ctx,t      ""uds_sendfd: %s"", strerror (errno));      errno = saved_errno;      return _assuan_error (ctx, gpg_err_code_from_syserror ());    }  else    return 0;#else  return _assuan_error (ctx, GPG_ERR_NOT_IMPLEMENTED);#endif}",2,"cwe119,cwe120"
"console_read(gpointer handle, gpointer buffer,ttt     guint32 numbytes, guint32 *bytesread,ttt     WapiOverlapped *overlapped G_GNUC_UNUSED){tstruct _WapiHandle_file *console_handle;tgboolean ok;tint ret, fd;tok=_wapi_lookup_handle (handle, WAPI_HANDLE_CONSOLE,tttt(gpointer *)&console_handle);tif(ok==FALSE) {ttg_warning (""%s: error looking up console handle %p"", __func__,ttt   handle);ttSetLastError (ERROR_INVALID_HANDLE);ttreturn(FALSE);t}tfd = console_handle->fd;ttif(bytesread!=NULL) {tt*bytesread=0;t}ttif(!(console_handle->fileaccess & GENERIC_READ) &&t   !(console_handle->fileaccess & GENERIC_ALL)) {ttDEBUG (""%s: handle %p doesn't have GENERIC_READ access: %u"",ttt   __func__, handle, console_handle->fileaccess);ttSetLastError (ERROR_ACCESS_DENIED);ttreturn(FALSE);t}ttdo {ttret=read(fd, buffer, numbytes);t} while (ret==-1 && errno==EINTR && !_wapi_thread_cur_apc_pending());tif(ret==-1) {ttDEBUG(""%s: read of handle %p error: %s"", __func__, handle,ttt  strerror(errno));tt_wapi_set_last_error_from_errno ();ttreturn(FALSE);t}ttif(bytesread!=NULL) {tt*bytesread=ret;t}ttreturn(TRUE);}",2,"cwe120,cweother"
"""append_option(struct data_string *dst, struct universe *universe,t      struct option *option, struct data_string *src){tstruct data_string tmp;tif (src->len == 0 && option->format[0] != 'Z')ttreturn 0;tmemset(&tmp, 0, sizeof(tmp));t/* Allocate a buffer to hold existing data, the current option'st * tag and length, and the option's content.t */tif (!buffer_allocate(&tmp.buffer,ttt     (dst->len + universe->length_size +ttt      universe->tag_size + src->len), MDL)) {tt/* XXX: This kills all options presently stored in thett * destination buffer.  This is the way the original codett * worked, and assumes an 'all or nothing' approach tott * eg encapsulated option spaces.  It may or may not bett * desirable.tt */ttdata_string_forget(dst, MDL);ttreturn 0;t}ttmp.data = tmp.buffer->data;t/* Copy the existing data off the destination. */tif (dst->len != 0)ttmemcpy(tmp.buffer->data, dst->data, dst->len);ttmp.len = dst->len;t/* Place the new option tag and length. */t(*universe->store_tag)(tmp.buffer->data + tmp.len, option->code);ttmp.len += universe->tag_size;t(*universe->store_length)(tmp.buffer->data + tmp.len, src->len);ttmp.len += universe->length_size;t/* Copy the option contents onto the end. */tmemcpy(tmp.buffer->data + tmp.len, src->data, src->len);ttmp.len += src->len;t/* Play the shell game. */tdata_string_forget(dst, MDL);tdata_string_copy(dst, &tmp, MDL);tdata_string_forget(&tmp, MDL);treturn 1;}""",2,"cwe120,cwe476"
"lockerpid(const char *rootdir){  char path[URIBUFSIZ], *vbuf;  int pid;  pid = -1;  sprintf(path, ""%s%c%s"", rootdir, ESTPATHCHR, PIDFILE);  if((vbuf = cbreadfile(path, NULL)) != NULL){    pid = atoi(vbuf);    free(vbuf);  }  return pid;}",3,"cwe119,cwe120,cweother"
"hflip(struct fp_img *img){tint width = img->width;tunsigned char rowbuf[width];tint i, j;tfor (i = 0; i < img->height; i++) {ttint offset = i * width;ttmemcpy(rowbuf, img->data + offset, width);ttfor (j = 0; j < width; j++)tttimg->data[offset + j] = rowbuf[width - j - 1];t}}",2,"cwe119,cwe120"
"kwsysProcessFork(kwsysProcess* cp,                              kwsysProcessCreateInformation* si){     if(cp->OptionDetach)    {         pid_t middle_pid = fork();    if(middle_pid < 0)      {             return middle_pid;      }    else if(middle_pid == 0)      {             pid_t child_pid = fork();      if(child_pid == 0)        {                 return 0;        }      else        {                 while((write(si->ErrorPipe[1], &child_pid, sizeof(child_pid)) < 0) &&              (errno == EINTR));                 kwsysProcessExit();        return 0;          }      }    else      {             pid_t child_pid;      int status;      while((read(si->ErrorPipe[0], &child_pid, sizeof(child_pid)) < 0) &&            (errno == EINTR));             while((waitpid(middle_pid, &status, 0) < 0) && (errno == EINTR));      return child_pid;      }    }  else    {         return fork();    }}",2,"cwe120,cweother"
"ide_proc_port_register_devices(ide_hwif_t *hwif){tstruct proc_dir_entry *ent;tstruct proc_dir_entry *parent = hwif->proc;tide_drive_t *drive;tchar name[64];tint i;tide_port_for_each_dev(i, drive, hwif) {ttif ((drive->dev_flags & IDE_DFLAG_PRESENT) == 0)tttcontinue;ttdrive->proc = proc_mkdir(drive->name, parent);ttif (drive->proc)tttide_add_proc_entries(drive->proc, generic_drive_entries, drive);ttsprintf(name, ""ide%d/%s"", (drive->name[2]-'a')/2, drive->name);ttent = proc_symlink(drive->name, proc_ide_root, name);ttif (!ent) return;t}}",2,"cwe476,cweother"
"cb_edit_cats(GtkWidget *widget, gpointer data){   struct ExpenseAppInfo ai;   char full_name[256];   char buffer[65536];   int num;   size_t size;   void *buf;   struct pi_file *pf;   jp_logf(JP_LOG_DEBUG, ""cb_edit_cats"");   jp_get_home_file_name(""ExpenseDB.pdb"", full_name, 250);   buf=NULL;   memset(&ai, 0, sizeof(ai));   pf = pi_file_open(full_name);   pi_file_get_app_info(pf, &buf, &size);   num = unpack_ExpenseAppInfo(&ai, buf, size);   if (num <= 0) {      jp_logf(JP_LOG_WARN, _(""Error reading file: %s""), ""ExpenseDB.pdb"");      return;   }   pi_file_close(pf);   jp_edit_cats(widget, ""ExpenseDB"", &(ai.category));   size = pack_ExpenseAppInfo(&ai, (unsigned char *)buffer, 65535);   jp_pdb_file_write_app_block(""ExpenseDB"", buffer, size);          plugin_gui_refresh(-1);}",2,"cwe119,cwe120"
"printDeckInfo(DeckInfo *info){  char name[30] = ""NoName"";  char rev[10] = ""NoRev"";  if (deckTlvHasElement(&info->tlv, DECK_INFO_NAME)) {    deckTlvGetString(&info->tlv, DECK_INFO_NAME, name, 30);  }  if (deckTlvHasElement(&info->tlv, DECK_INFO_REVISION)) {    deckTlvGetString(&info->tlv, DECK_INFO_REVISION, rev, 10);  }  DECK_INFO_DBG_PRINT(""Deck %02x:%02x %s (Rev. %s)"", info->vid, info->pid, name, rev);  DECK_INFO_DBG_PRINT(""Used pin: %08x"", (unsigned int)info->usedPins);  if (info->driver == &dummyDriver) {    DEBUG_PRINT(""Warning! No driver found for deck."");  } else {    DECK_INFO_DBG_PRINT(""Driver implements: [ %s%s]"",                        info->driver->init?""init "":"""", info->driver->test?""test "":"""");  }}",2,"cwe119,cwe120"
"mtd_dev_present(libmtd_t desc, int mtd_num) {tstruct stat st;tstruct libmtd *lib = (struct libmtd *)desc;tif (!lib->sysfs_supported) {ttreturn legacy_dev_present(mtd_num) == 1;t} else {ttchar file[strlen(lib->mtd) + 10];ttsprintf(file, lib->mtd, mtd_num);ttreturn !stat(file, &st);t}}",3,"cwe119,cwe120,cweother"
"notify_mods (unsigned int level, const char *fmt, ...){    int     len;    va_list ap;    LIST   *list;    CONNECTION *con;    va_start (ap, fmt);    vsnprintf (Buf + 4, sizeof (Buf) - 4, fmt, ap);    va_end (ap);    set_tag (Buf, MSG_SERVER_NOSUCH);    len = strlen (Buf + 4);    set_len (Buf, len);    for (list = Mods; list; list = list->next)    {tcon = list->data;tif (con->uopt->usermode & level)t    queue_data (con, Buf, len + 4);    }}",3,"cwe119,cwe120,cweother"
"synaptics_capability(struct psmouse *psmouse){tstruct synaptics_data *priv = psmouse->private;tunsigned char cap[3];tif (synaptics_send_cmd(psmouse, SYN_QUE_CAPABILITIES, cap))ttreturn -1;tpriv->capabilities = (cap[0] << 16) | (cap[1] << 8) | cap[2];tpriv->ext_cap = priv->ext_cap_0c = 0;t tif (SYN_ID_FULL(priv->identity) < 0x705 &&t    SYN_CAP_SUBMODEL_ID(priv->capabilities) != 0x47) {ttreturn -1;t}t tif (!SYN_CAP_EXTENDED(priv->capabilities))ttpriv->capabilities = 0;tif (SYN_EXT_CAP_REQUESTS(priv->capabilities) >= 1) {ttif (synaptics_send_cmd(psmouse, SYN_QUE_EXT_CAPAB, cap)) {tttpsmouse_warn(psmouse,tttt     ""device claims to have extended capabilities, but I'm not able to read them."");tt} else {tttpriv->ext_cap = (cap[0] << 16) | (cap[1] << 8) | cap[2];ttt tttif (SYN_CAP_MULTI_BUTTON_NO(priv->ext_cap) > 8)ttttpriv->ext_cap &= 0xff0fff;tt}t}tif (SYN_EXT_CAP_REQUESTS(priv->capabilities) >= 4) {ttif (synaptics_send_cmd(psmouse, SYN_QUE_EXT_CAPAB_0C, cap)) {tttpsmouse_warn(psmouse,tttt     ""device claims to have extended capability 0x0c, but I'm not able to read it."");tt} else {tttpriv->ext_cap_0c = (cap[0] << 16) | (cap[1] << 8) | cap[2];tt}t}treturn 0;}",2,"cwe119,cwe120"
"GetTemplateString(struct __ecereNameSpace__ecere__com__Class * c, char * templateString){struct __ecereNameSpace__ecere__com__Instance * m = ((struct __ecereNameSpace__ecere__com__Module *)(((char *)c->module + 24)))->application;char * n = c->name;char * lt = strchr(n, '<');char * s;char ch;char curName[256];int len = 0;memcpy(templateString, n, lt - n);templateString[lt - n] = (char)0;strcat(templateString, ""</a>"");for(s = lt; (ch = *s); s++){if(ch == '<' || ch == '>' || ch == ','){if(len){struct __ecereNameSpace__ecere__com__Class * pc;char * d = templateString + strlen(templateString);curName[len] = (char)0;pc = __ecereNameSpace__ecere__com__eSystem_FindClass(m, curName);if(pc)sprintf(d, ""<a href=""api: elsestrcat(d, curName);}if(ch == '<')strcat(templateString, ""&lt;"");else if(ch == '>')strcat(templateString, ""&gt;"");elsestrcat(templateString, "", "");len = 0;}else if(ch == '='){curName[len++] = ' ';curName[len++] = ch;curName[len++] = ' ';curName[0] = (char)0;strcat(templateString, curName);len = 0;}else if(ch != ' ')curName[len++] = ch;}}",3,"cwe119,cwe120,cweother"
"salsa20_wordtobyte(unsigned char output[64],const uint32_t input[16]){  uint32_t i, x[16];  for (i = 0;i < 16;++i) x[i] = input[i];  for (i = HS1_SIV_CHACHA_RNDS;i != 0;i -= 2) {    QUARTERROUND( 0, 4, 8,12)    QUARTERROUND( 1, 5, 9,13)    QUARTERROUND( 2, 6,10,14)    QUARTERROUND( 3, 7,11,15)    QUARTERROUND( 0, 5,10,15)    QUARTERROUND( 1, 6,11,12)    QUARTERROUND( 2, 7, 8,13)    QUARTERROUND( 3, 4, 9,14)  }  for (i = 0;i < 16;++i) x[i] += input[i];  for (i = 0;i < 16;++i) write32le((uint32_t *)(output + 4 * i),x[i]);}",2,"cwe119,cwe120"
"_get_config_directory (pstdout_state_t pstate,                       const char *cache_dir,                       char *buf,                       unsigned int buflen){  char tbuf[MAXPATHLEN+1];  int ret;  assert (buf);  assert (buflen);  memset (tbuf, '0', MAXPATHLEN+1);  if (!cache_dir)    {      if (_get_home_directory (pstate,                               tbuf,                               MAXPATHLEN) < 0)        return (-1);    }  else    {      if (strlen (cache_dir) > (MAXPATHLEN - 1))        {          PSTDOUT_FPRINTF (pstate,                           stderr,                           ""internal overflow error"");          return (-1);        }      strcpy (tbuf, cache_dir);      if (access (tbuf, R_OK|W_OK|X_OK) < 0)        {          if (errno == ENOENT)            {              if (mkdir (tbuf, FREEIPMI_CONFIG_DIRECTORY_MODE) < 0)                {                  PSTDOUT_FPRINTF (pstate,                                   stderr,                                   ""Cannot make cache directory: %s: %s"",                                   tbuf,                                   strerror (errno));                  return (-1);                }            }          else            {              PSTDOUT_FPRINTF (pstate,                               stderr,                               ""Cannot access cache directory: %s"",                               tbuf);              return (-1);            }        }    }  if ((ret = snprintf (buf,                       buflen,                       ""%s/.%s"",                       tbuf,                       PACKAGE_NAME)) < 0)    {      PSTDOUT_PERROR (pstate, ""snprintf"");      return (-1);    }  if (ret >= buflen)    {      PSTDOUT_FPRINTF (pstate,                       stderr,                       ""snprintf invalid bytes written"");      return (-1);    }  return (0);}",3,"cwe119,cwe120,cweother"
"generateFixFixOnly ( HANDLE_SBR_FRAME_INFO hSbrFrameInfo,                                 HANDLE_SBR_GRID hSbrGrid,                                 int tranPosInternal,                                 int numberTimeSlots                               ){  int nEnv, i, k=0, tranIdx;  const int *pTable = NULL;  const FREQ_RES *freqResTable = NULL;  switch (numberTimeSlots) {      case 8:          pTable = envelopeTable_8[tranPosInternal];          freqResTable = freqRes_table_8;          break;      case 15:          pTable = envelopeTable_15[tranPosInternal];          freqResTable = freqRes_table_16;          break;      case 16:          pTable = envelopeTable_16[tranPosInternal];          freqResTable = freqRes_table_16;          break;  }     nEnv = pTable[0];     for (i=1; i<nEnv; i++)    hSbrFrameInfo->borders[i] = pTable[i+2];     hSbrFrameInfo->borders[0]    = 0;  hSbrFrameInfo->borders[nEnv] = numberTimeSlots;     for (i=0; i<nEnv; i++){    k = hSbrFrameInfo->borders[i+1] - hSbrFrameInfo->borders[i];    hSbrFrameInfo->freqRes[i] = freqResTable[k];    hSbrGrid->v_f[i] = freqResTable[k];  }  hSbrFrameInfo->nEnvelopes = nEnv;  hSbrFrameInfo->shortEnv   = pTable[2];     tranIdx = pTable[1];     hSbrFrameInfo->bordersNoise[0] = 0;  hSbrFrameInfo->bordersNoise[1] = hSbrFrameInfo->borders[tranIdx?tranIdx:1];  hSbrFrameInfo->bordersNoise[2] = numberTimeSlots;  hSbrFrameInfo->nNoiseEnvelopes = 2;  hSbrGrid->frameClass = FIXFIXonly;  hSbrGrid->bs_abs_bord = tranPosInternal;  hSbrGrid->bs_num_env = nEnv;}",2,"cwe476,cweother"
"_fix_user_default_edj(void){   char buff[PATH_MAX];       e_user_dir_concat_static(buff, ""themes/default.edj"");   if (ecore_file_exists(buff)) ecore_file_unlink(buff);}",2,"cwe119,cwe120"
"covered_cb_error_handler( p_cb_data cb ) { PROFILE(COVERED_CB_ERROR_HANDLER);  struct t_vpi_error_info einfotab;  struct t_vpi_error_info *einfop;  char   s1[128];  einfop = &einfotab;  vpi_chk_error( einfop );  if( einfop->state == vpiCompile ) {    strcpy( s1, ""vpiCompile"" );  } else if( einfop->state == vpiPLI ) {    strcpy( s1, ""vpiPLI"" );  } else if( einfop->state == vpiRun ) {    strcpy( s1, ""vpiRun"" );  } else {    strcpy( s1, ""**unknown**"" );  }  vpi_printf( ""covered VPI: ERR(%s) %s (level %d) at **%s(%d):  %s"",    einfop->code, s1, einfop->level, obf_file( einfop->file ), einfop->line, einfop->message );     if( (einfop->level == vpiError) || (einfop->level == vpiSystem) || (einfop->level == vpiInternal) ) {    vpi_printf( ""covered VPI: FATAL: encountered error - giving up"" );    vpi_control( vpiFinish, 0 );  }  PROFILE_END;  return( 0 );}",2,"cwe119,cwe120"
"toplevel_update_title_bar(toplevel_t * top){tconst apol_policy_path_t *paths[SEDIFFX_POLICY_NUM];tchar *types[SEDIFFX_POLICY_NUM] = { ""Policy"", ""Policy"" }, *s;tconst char *primaries[SEDIFFX_POLICY_NUM] = { NULL, NULL };tsediffx_policy_e i;tpaths[SEDIFFX_POLICY_ORIG] = sediffx_get_policy_path(top->s, SEDIFFX_POLICY_ORIG);tpaths[SEDIFFX_POLICY_MOD] = sediffx_get_policy_path(top->s, SEDIFFX_POLICY_MOD);tfor (i = SEDIFFX_POLICY_ORIG; i < SEDIFFX_POLICY_NUM; i++) {ttif (paths[i] == NULL) {tttprimaries[i] = ""No Policy"";tt} else {tttif (apol_policy_path_get_type(paths[i]) == APOL_POLICY_PATH_TYPE_MODULAR) {tttttypes[i] = ""Base"";ttt}tttprimaries[i] = apol_policy_path_get_primary(paths[i]);tt}t}tif (asprintf(&s, ""sediffx - [%s file: %s] [%s file: %s]"",tt     types[SEDIFFX_POLICY_ORIG], primaries[SEDIFFX_POLICY_ORIG],tt     types[SEDIFFX_POLICY_MOD], primaries[SEDIFFX_POLICY_MOD]) < 0) {tttoplevel_ERR(top, ""%s"", strerror(errno));ttreturn;t}tgtk_window_set_title(top->w, s);tfree(s);}",2,"cwe119,cwe120"
"ask_for_number(int n1,int n2){  char s[50];  int n;  if (n1!=n2)    sprintf(s,""Enter a number from %d to %d: "",n1,n2);  else    sprintf(s,""Enter a number: "");  for(;;) {    writestr(s);    n=read_number();    if (n1==n2 || ( n>=n1 && n<=n2)) return n;    writeln("""");  }   }",2,"cwe119,cwe120"
"keyword_scan(char *filename){  char *mem_start, *mem_end, *path;  pid_t pid;  Ds *ds;  Dsvec *keywords;  FILE *fp;  ds = NULL;  mem_start = mem_end = NULL;  if (filename == NULL) {tpid = getpid();#if defined(DACS_OS_LINUX)tpath = ds_xprintf(""/proc/%d/exe"", pid);#elif defined(DACS_OS_CYGWIN)t t{t  char *winexename;t  winexename = ds_xprintf(""/proc/%d/winexename"", pid);t  ds = ds_init(NULL);t  ds->delnl_flag = 1;t  if (ds_load_file(ds, winexename) == NULL) {ttlog_msg((LOG_NOTICE_LEVEL, ""Can't load %s"", winexename));ttreturn(NULL);t  }t  path = ds_buf(ds);t}#elif defined(DACS_OS_SOLARIS)tpath = ds_xprintf(""/proc/%d/object/a.out"", pid);#elif defined(DACS_OS_MACOSX)t tchar abuf[MAXPATHLEN * 10];tuint32_t abufsize;tabufsize = sizeof(abuf);tif (_NSGetExecutablePath(abuf, &abufsize) == -1) {t   t  log_msg((LOG_NOTICE_LEVEL, ""Cannot get executable path""));t  return(NULL);t}tpath = ds_xprintf(""%s"", abuf);#elsetpath = ds_xprintf(""/proc/%d/file"", pid);#endif  }  elsetpath = filename;#ifdef NOTDEF  if ((fp = fopen(path, ""r"")) == NULL) {tlog_msg((LOG_NOTICE_LEVEL, ""Can't open %s"", path));treturn(NULL);  }#else  if (path != NULL) {tif ((ds = ds_load_file(NULL, path)) == NULL) {t  log_msg((LOG_NOTICE_LEVEL, ""Can't open %s"", path));t  return(NULL);t}tmem_start = ds_buf(ds);tmem_end = ds_buf(ds) + ds_len(ds);  }#endif#ifdef NOTDEF  keywords = NULL;  keyword_scan_file(fp, &keywords);  fclose(fp);#else  keywords = keyword_scan_mem(mem_start, mem_end);  if (ds != NULL)tds_free(ds);#endif  dsvec_sort(keywords, keyword_compar);  return(keywords);}",3,"cwe119,cwe120,cweother"
"drbd_pr_state_change(struct drbd_device *device, union drbd_state os, union drbd_state ns,tttt enum chg_state_flags flags){tchar pb[300];tchar *pbp = pb;tpbp += print_state_change(pbp, os, ns, flags ^ CS_DC_MASK);tif (ns.aftr_isp != os.aftr_isp)ttpbp += sprintf(pbp, ""aftr_isp( %d -> %d ) "",ttt       os.aftr_isp,ttt       ns.aftr_isp);tif (ns.peer_isp != os.peer_isp)ttpbp += sprintf(pbp, ""peer_isp( %d -> %d ) "",ttt       os.peer_isp,ttt       ns.peer_isp);tif (ns.user_isp != os.user_isp)ttpbp += sprintf(pbp, ""user_isp( %d -> %d ) "",ttt       os.user_isp,ttt       ns.user_isp);tif (pbp != pb)ttdrbd_info(device, ""%s"", pb);}",2,"cwe119,cwe120"
"gfarm_pgsql_group_add(struct gfarm_group_info *info){tconst char *paramValues[1];tgfarm_error_t e;tstatic const char diag[] = ""pgsql_group_add"";tif ((e = gfarm_pgsql_start_with_retry(diag))t    == GFARM_ERR_NO_ERROR) {ttparamValues[0] = info->groupname;tte = gfarm_pgsql_insert_and_log(ttt""INSERT INTO GfarmGroup (groupname) VALUES ($1)"",ttt1,  tttNULL,  tttparamValues,tttNULL,  tttNULL,  ttt0,  tttdiag);ttif (e == GFARM_ERR_NO_ERROR)ttte = grpassign_set(info);ttif (e == GFARM_ERR_NO_ERROR)ttte = gfarm_pgsql_commit(diag);ttelsetttgfarm_pgsql_rollback(diag);t}tfree(info);treturn (e);}",2,"cwe119,cwe120"
"isl_map_coalesce(struct isl_map *map){tint i;tunsigned n;tstruct isl_tab **tabs = NULL;tmap = isl_map_remove_empty_parts(map);tif (!map)ttreturn NULL;tif (map->n <= 1)ttreturn map;tmap = isl_map_sort_divs(map);tmap = isl_map_cow(map);ttabs = isl_calloc_array(map->ctx, struct isl_tab *, map->n);tif (!tabs)ttgoto error;tn = map->n;tfor (i = 0; i < map->n; ++i) {tttabs[i] = isl_tab_from_basic_map(map->p[i], 0);ttif (!tabs[i])tttgoto error;ttif (!ISL_F_ISSET(map->p[i], ISL_BASIC_MAP_NO_IMPLICIT))tttif (isl_tab_detect_implicit_equalities(tabs[i]) < 0)ttttgoto error;ttmap->p[i] = isl_tab_make_equalities_explicit(tabs[i],ttttttttmap->p[i]);ttif (!map->p[i])tttgoto error;ttif (!ISL_F_ISSET(map->p[i], ISL_BASIC_MAP_NO_REDUNDANT))tttif (isl_tab_detect_redundant(tabs[i]) < 0)ttttgoto error;t}tfor (i = map->n - 1; i >= 0; --i)ttif (tabs[i]->empty)tttdrop(map, i, tabs);tmap = coalesce(map, tabs);tif (map)ttfor (i = 0; i < map->n; ++i) {tttmap->p[i] = isl_basic_map_update_from_tab(map->p[i],tttttttt    tabs[i]);tttmap->p[i] = isl_basic_map_gauss(map->p[i], NULL);tttmap->p[i] = isl_basic_map_finalize(map->p[i]);tttif (!map->p[i])ttttgoto error;tttISL_F_SET(map->p[i], ISL_BASIC_MAP_NO_IMPLICIT);tttISL_F_SET(map->p[i], ISL_BASIC_MAP_NO_REDUNDANT);tt}tfor (i = 0; i < n; ++i)ttisl_tab_free(tabs[i]);tfree(tabs);treturn map;error:tif (tabs)ttfor (i = 0; i < n; ++i)tttisl_tab_free(tabs[i]);tfree(tabs);tisl_map_free(map);treturn NULL;}",2,"cwe476,cweother"
"clicap_generate(struct Client *source_p, const char *subcmd, int flags, int clear){tchar buf[BUFSIZE];tchar capbuf[BUFSIZE];tchar *p;tint buflen = 0;tint curlen, mlen;tsize_t i;tmlen = rb_sprintf(buf, "":%s CAP %s %s"",tttme.name, tttEmptyString(source_p->name) ? ""*"" : source_p->name, tttsubcmd);tp = capbuf;tbuflen = mlen;t tif(flags == -1)t{ttsendto_one(source_p, ""%s :"", buf);ttreturn;t}tfor(i = 0; i < CLICAP_LIST_LEN; i++)t{ttif(flags)tt{tttif(!IsCapable(source_p, clicap_list[i].cap_serv))ttttcontinue;ttt tttelse if(clear && clicap_list[i].flags & CLICAP_FLAGS_STICKY)ttttcontinue;tt}tt ttif(buflen + clicap_list[i].namelen >= BUFSIZE - 10)tt{ttt tttif(buflen != mlen)tttt*(p - 1) = '0';tttelsetttt*p = '0';tttsendto_one(source_p, ""%s * :%s"", buf, capbuf);tttp = capbuf;tttbuflen = mlen;tt}ttif(clear)tt{ttt*p++ = '-';tttbuflen++;ttt tttif(clicap_list[i].cap_cli && ttt   IsCapable(source_p, clicap_list[i].cap_cli))ttt{tttt*p++ = '~';ttttbuflen++;ttt}tt}ttelsett{tttif(clicap_list[i].flags & CLICAP_FLAGS_STICKY)ttt{tttt*p++ = '=';ttttbuflen++;ttt}ttt tttif(clicap_list[i].cap_cli &&ttt   (!flags || !IsCapable(source_p, clicap_list[i].cap_cli)))ttt{tttt*p++ = '~';ttttbuflen++;ttt}tt}ttcurlen = rb_sprintf(p, ""%s "", clicap_list[i].name);ttp += curlen;ttbuflen += curlen;t}t tif(buflen != mlen)tt*(p - 1) = '0';telsett*p = '0';tsendto_one(source_p, ""%s :%s"", buf, capbuf);}",2,"cwe119,cwe120"
"md5_digest(char *md5str, unsigned char *digest){    int i;    for (i = 0; i < 16; i++) {        sprintf(md5str, ""%02x"", digest[i]);        md5str += 2;    }    *md5str = '0';}",2,"cwe119,cwe120"
"c_list (state_t * s){tif (_lists_need_sorting)ttcon_sort_all();tif (cmd_paramlength == 0)tt{tttsciprintf (""usage: list [type]where type is one of the following:""tttt   ""cmds       - lists all commands""tttt   ""vars       - lists all variables""tttt   ""docs       - lists all misc. documentation""tttt   """"tttt   ""restypes   - lists all resource types""tttt   ""selectors  - lists all selectors""tttt   ""syscalls   - lists all kernel functions""tttt   ""words      - lists all kernel words""tttt   ""suffixes   - lists all suffix replacements""tttt   ""[resource] - lists all [resource]s"");tt}telse if (cmd_paramlength == 1) {ttconst char *mm_subsects[3] = {""cmds"", ""vars"", ""docs""};ttint mm_found = -1;ttint i;ttfor (i = 0; i < 3; i++)tttif (mm_subsects[i] && !strcmp(mm_subsects[i], cmd_params[0].str))ttttmm_found = i;ttif (mm_found >= 0)tttfor (i = 0; i < cmd_mm[mm_found].entries; i++)ttttcmd_mm[mm_found].print((cmd_mm_entry_t *)tttttt       (((byte *)cmd_mm[mm_found].data)ttttttt+ i * cmd_mm[mm_found].size_per_entry), 0);ttelse {tttif (!s) {ttttsciprintf(""You need a state to do that!"");ttttreturn 1;ttt}ttttttif (!strcmp(""selectors"", cmd_params[0].str))ttttreturn c_selectornames(s);tttelse if (!strcmp(""syscalls"", cmd_params[0].str))ttttreturn c_kernelnames(s);tttelse if (!strcmp(""suffixes"", cmd_params[0].str)tttt || !strcmp(""suffices"", cmd_params[0].str)tttt || !strcmp(""sufficos"", cmd_params[0].str))tttt ttttreturn c_list_suffices(s);tttelse if (!strcmp(""words"", cmd_params[0].str))ttttreturn c_list_words(s);tttelse if (strcmp (""restypes"", cmd_params[0].str) == 0) {ttttint i;ttttfor (i = 0; i < sci_invalid_resource; i++)tttttsciprintf (""%s"", sci_resource_types[i]);ttt}tttelse {ttttint res = get_resource_number (cmd_params[0].str);ttttif (res == -1)tttttsciprintf (""Unknown resource type: '%s'"", cmd_params[0].str);ttttelse {tttttint i;tttttfor (i = 0; i < sci_max_resource_nr[s->resmgr->sci_version]; i++)ttttttif (scir_test_resource (s->resmgr, res, i))tttttttsciprintf (""%s.%03d"", sci_resource_types[res], i);tttt}ttt}tt}t}telsettsciprintf (""list can only be used with one argument"");treturn 0;}",2,"cwe119,cwe120"
"SNSSendMsg2MCgrp (ISNS_Msg *p_msg){    int  status;    int  len;    int  display_debug;    struct sockaddr_in  mc_dest_sock;    char dot_not_addr[INET_ADDR_LEN];    len          = sizeof (SNS_Msg_Hdr) + p_msg->hdr.msg_len;    SNSConvertPayloadHTON(p_msg);    p_msg->hdr.type     = htons (p_msg->hdr.type);      p_msg->hdr.xid      = htons (p_msg->hdr.xid);      p_msg->hdr.msg_len  = htons (p_msg->hdr.msg_len);      p_msg->hdr.flags    = htons ((short)(p_msg->hdr.flags | ISNS_FLAG_SND_SERVER                                  | ISNS_FLAG_LAST_PDU | ISNS_FLAG_FIRST_PDU));      p_msg->hdr.version  = htons (SNS_VERSION);      p_msg->hdr.sequence = htons (p_msg->hdr.sequence);      status = SUCCESS;    if (sns_comm_support == SNS_LAYER_2)    {       inet_ntoa_b (mc_sock.sin_addr, dot_not_addr);       if ( sendto(sd, (void *)p_msg, len,                   0, (struct sockaddr *)&mc_sock,                    sizeof(struct sockaddr_in)) == ERROR)          status = ERROR;    }    else      {       bzero ((char *) &mc_dest_sock, sizeof (struct sockaddr_in));       mc_dest_sock.sin_family      = AF_INET;       mc_dest_sock.sin_port        = htons((short)sns_comm_mcast_port);       mc_dest_sock.sin_addr.s_addr = htonl(sns_comm_mcast_grp);       inet_ntoa_b (mc_dest_sock.sin_addr, dot_not_addr);       if ( sendto(mc_sd, (void *)p_msg, len,                   0, (struct sockaddr *)&mc_dest_sock,                    sizeof(struct sockaddr_in)) == ERROR)          status = ERROR;   }    display_debug = 0;    if (sns_comm_debug == 3)       display_debug = (p_msg->hdr.type != sns_comm_msg_filter);    __DEBUG (display_debug,             (iSNS Sending bcast/mcast msg id %d, len %d, xid %d to %s),             p_msg->hdr.type, p_msg->hdr.msg_len,              p_msg->hdr.xid, dot_not_addr);    return (status);   }",2,"cwe119,cwe120"
"CAST_ofb64_encrypt(const unsigned char *in, unsigned char *out,tttlong length, const CAST_KEY *schedule, unsigned char *ivec,tttint *num)t{tregister CAST_LONG v0,v1,t;tregister int n= *num;tregister long l=length;tunsigned char d[8];tregister char *dp;tCAST_LONG ti[2];tunsigned char *iv;tint save=0;tiv=ivec;tn2l(iv,v0);tn2l(iv,v1);tti[0]=v0;tti[1]=v1;tdp=(char *)d;tl2n(v0,dp);tl2n(v1,dp);twhile (l--)tt{ttif (n == 0)ttt{tttCAST_encrypt((CAST_LONG *)ti,schedule);tttdp=(char *)d;tttt=ti[0]; l2n(t,dp);tttt=ti[1]; l2n(t,dp);tttsave++;ttt}tt*(out++)= *(in++)^d[n];ttn=(n+1)&0x07;tt}tif (save)tt{ttv0=ti[0];ttv1=ti[1];ttiv=ivec;ttl2n(v0,iv);ttl2n(v1,iv);tt}tt=v0=v1=ti[0]=ti[1]=0;t*num=n;t}",2,"cwe119,cwe120"
"makeTempDirname(char        *result,                size_t       nbytes,                const char  *subdir){size_t  len;    PROCNAME(""makeTempDirname"");    if (!result)        return ERROR_INT(""result not defined"", procName, 1);    if (subdir && ((subdir[0] == '.') || (subdir[0] == '/')))        return ERROR_INT(""subdir not an actual subdirectory"", procName, 1);         #ifdef _WIN32    {        char dirt[MAX_PATH];        GetTempPath(sizeof(dirt), dirt);        snprintf(result, nbytes, ""%s"", dirt);    }#else    snprintf(result, nbytes, ""%s"", ""/tmp"");#endif                if (subdir) {        len = strlen(result);        strncat(result, ""/"", nbytes - len);        strncat(result, subdir, nbytes - len - 1);    }    return 0;}",2,"cwe119,cwe120"
"fuse_compat_open(struct fuse_fs *fs, const char *path,ttt    struct fuse_file_info *fi){tint err;tif (!fs->compat || fs->compat >= 25)tterr = fs->op.open(path, fi);telse if (fs->compat == 22) {ttstruct fuse_file_info_compat tmp;ttmemcpy(&tmp, fi, sizeof(tmp));tterr = ((struct fuse_operations_compat22 *) &fs->op)->open(path,ttttttttt  &tmp);ttmemcpy(fi, &tmp, sizeof(tmp));ttfi->fh = tmp.fh;t} elsetterr = ((struct fuse_operations_compat2 *) &fs->op)ttt->open(path, fi->flags);treturn err;}",2,"cwe120,cweother"
"duplicate_search_and_fix(e2fsck_t ctx, ext2_filsys fs,tttt    ext2_ino_t ino,tttt    struct fill_dir_struct *fd){tstruct problem_contexttpctx;tstruct hash_entry t*ent, *prev;tintttti, j;tinttttfixed = 0;tchartttnew_name[256];t__u16tttnew_len;tintttthash_alg;tclear_problem_context(&pctx);tpctx.ino = ino;thash_alg = fs->super->s_def_hash_version;tif ((hash_alg <= EXT2_HASH_TEA) &&t    (fs->super->s_flags & EXT2_FLAGS_UNSIGNED_HASH))tthash_alg += 3;tfor (i=1; i < fd->num_array; i++) {ttent = fd->harray + i;ttprev = ent - 1;ttif (!ent->dir->inode ||tt    ((ent->dir->name_len & 0xFF) !=tt     (prev->dir->name_len & 0xFF)) ||tt    (strncmp(ent->dir->name, prev->dir->name,ttt     ent->dir->name_len & 0xFF)))tttcontinue;ttpctx.dirent = ent->dir;ttif ((ent->dir->inode == prev->dir->inode) &&tt    fix_problem(ctx, PR_2_DUPLICATE_DIRENT, &pctx)) {ttte2fsck_adjust_inode_count(ctx, ent->dir->inode, -1);tttent->dir->inode = 0;tttfixed++;tttcontinue;tt}ttmemcpy(new_name, ent->dir->name, ent->dir->name_len & 0xFF);ttnew_len = ent->dir->name_len;ttmutate_name(new_name, &new_len);ttfor (j=0; j < fd->num_array; j++) {tttif ((i==j) ||ttt    ((ent->dir->name_len & 0xFF) !=ttt     (fd->harray[j].dir->name_len & 0xFF)) ||ttt    (strncmp(new_name, fd->harray[j].dir->name,tttt     new_len & 0xFF)))ttttcontinue;tttmutate_name(new_name, &new_len);tttj = -1;tt}ttnew_name[new_len & 0xFF] = 0;ttpctx.str = new_name;ttif (fix_problem(ctx, PR_2_NON_UNIQUE_FILE, &pctx)) {tttmemcpy(ent->dir->name, new_name, new_len & 0xFF);tttent->dir->name_len = new_len;tttext2fs_dirhash(hash_alg, ent->dir->name,tttt       ent->dir->name_len & 0xFF,tttt       fs->super->s_hash_seed,tttt       &ent->hash, &ent->minor_hash);tttfixed++;tt}t}treturn fixed;}",2,"cwe119,cwe120"
"sge_is_admin_user(const char *username){   bool       ret = false;   const char *admin_user;#ifdef INTERIX   char       fq_name[1024];#endif   admin_user = bootstrap_get_admin_user();   if(admin_user != NULL && username != NULL) {#ifdef INTERIX             wl_build_fq_local_name(admin_user, fq_name);      admin_user = fq_name;#endif      ret = strcmp(username, admin_user)==0 ? true : false;    }   return ret;}",2,"cwe119,cwe120"
"pipe_color_transformer(Gif_Colormap *gfcm, void *thunk){  int i, status;  FILE *f;  Gif_Color *col = gfcm->col;  Gif_Colormap *new_cm = 0;  char *command = (char *)thunk;#ifdef HAVE_MKSTEMP# ifdef P_tmpdir  char tmp_file[] = P_tmpdir ""/gifsicle.XXXXXX"";# else  char tmp_file[] = ""/tmp/gifsicle.XXXXXX"";# endif#else  char *tmp_file = tmpnam(0);#endif  char *new_command;#ifdef HAVE_MKSTEMP  if (mkstemp(tmp_file) < 0)    fatal_error(""can't create temporary file!"");#else  if (!tmp_file)    fatal_error(""can't create temporary file!"");#endif  new_command = Gif_NewArray(char, strlen(command) + strlen(tmp_file) + 4);  sprintf(new_command, ""%s  >%s"", command, tmp_file);  f = popen(new_command, ""w"");  if (!f)    fatal_error(""can't run color transformation command: %s"", strerror(errno));  Gif_DeleteArray(new_command);  for (i = 0; i < gfcm->ncol; i++)    fprintf(f, ""%d %d %d"", col[i].gfc_red, col[i].gfc_green, col[i].gfc_blue);  errno = 0;  status = pclose(f);  if (status < 0) {    error(1, ""color transformation error: %s"", strerror(errno));    goto done;  } else if (status > 0) {    error(1, ""color transformation command failed"");    goto done;  }  f = fopen(tmp_file, ""r"");  if (!f || feof(f)) {    error(1, ""color transformation command generated no output"", command);    if (f) fclose(f);    goto done;  }  new_cm = read_colormap_file(""<color transformation>"", f);  fclose(f);  if (new_cm) {    int nc = new_cm->ncol;    if (nc < gfcm->ncol) {      nc = gfcm->ncol;      warning(1, ""too few colors in color transformation results"");    } else if (nc > gfcm->ncol)      warning(1, ""too many colors in color transformation results"");    for (i = 0; i < nc; i++)      col[i] = new_cm->col[i];  } done:  remove(tmp_file);  Gif_DeleteColormap(new_cm);}",2,"cwe120,cweother"
"dhcpctl_get_boolean (int *result,tttt    dhcpctl_handle h, const char *value_name){tisc_result_t status;tdhcpctl_data_string data = (dhcpctl_data_string)0;tint rv;ttstatus = dhcpctl_get_value (&data, h, value_name);tif (status != ISC_R_SUCCESS)ttreturn status;tif (data -> len != sizeof rv) {ttomapi_data_string_dereference (&data, MDL);ttreturn ISC_R_UNEXPECTED;t}tmemcpy (&rv, data -> value, sizeof rv);t*result = ntohl (rv);treturn ISC_R_SUCCESS;}",2,"cwe120,cweother"
"tty_set_terminators(char *buf, int len){tif (debug & DEBUG_FLAG_TTY) {ttint i;ttDEBUG_TTY(""set terminators... %d bytes"", len);ttDEBUG_TTY(""terms: "");ttfor (i=0; i<len; i++)tttDEBUGLOG(DEBUG_FLAG_TTY, ""%02x "", buf[i]);ttDEBUGLOG(DEBUG_FLAG_TTY, """");t}tmemset(terminators, 0, sizeof(terminators));tmemcpy(terminators, buf, len);}",2,"cwe120,cweother"
"db_gethook (lua_State *L) {  int arg;  lua_State *L1 = getthread(L, &arg);  char buff[5];  int mask = lua_gethookmask(L1);  lua_Hook hook = lua_gethook(L1);  if (hook != NULL && hook != hookf)       lua_pushliteral(L, ""external hook"");  else {    gethooktable(L);    lua_pushthread(L1); lua_xmove(L1, L, 1);    lua_rawget(L, -2);        lua_remove(L, -2);     }  lua_pushstring(L, unmakemask(mask, buff));  lua_pushinteger(L, lua_gethookcount(L1));  return 3;}",2,"cwe119,cwe120"
"""lcrt_shell_show(struct lcrt_qconnect *lqconnect){    GtkWidget *vbox;    GtkWidget *vbox_spec;    GtkWidget *hbox2;    GtkWidget *label_shell;    GtkWidget *combobox_shell;    GtkWidget *hbox3;    struct lcrt_window *parent;tint i;    const char *shells[LCRT_SHELL_SUPPORT_NUMBER] = {LCRT_SHELL_SUPPORT};    static struct lcrt_shell_if slshell, *lshell = &slshell;    memset(lshell, 0, sizeof(struct lcrt_shell_if));    lqconnect->private_data = lshell;    parent = lqconnect->parent;    vbox = GTK_DIALOG (lqconnect->q_connect)->vbox;    vbox_spec = gtk_vbox_new (FALSE, 0);    lqconnect->q_vbox_spec = vbox_spec;    gtk_widget_show (vbox_spec);    gtk_box_pack_start (GTK_BOX (vbox), vbox_spec, TRUE, TRUE, 0);    gtk_box_reorder_child (GTK_BOX (vbox), vbox_spec, 1);    gtk_widget_set_size_request (vbox_spec, -1, 210);    hbox2 = gtk_hbox_new (FALSE, 0);    gtk_widget_show (hbox2);    gtk_box_pack_start (GTK_BOX (vbox_spec), hbox2, TRUE, TRUE, 0);    gtk_widget_set_size_request (hbox2, -1, 25);    label_shell = gtk_label_new (lqconnect->config.value[LCRT_Q_SHELL]);    gtk_widget_show (label_shell);    gtk_box_pack_start (GTK_BOX (hbox2), label_shell, FALSE, FALSE, 0);    gtk_widget_set_size_request (label_shell, 90, 25);    gtk_misc_set_alignment (GTK_MISC (label_shell), 0, 0.5);    combobox_shell = gtk_combo_box_entry_new_text ();    lshell->shell = combobox_shell;    gtk_widget_show (combobox_shell);    gtk_box_pack_start (GTK_BOX (hbox2), combobox_shell, FALSE, TRUE, 0);    gtk_widget_set_size_request (combobox_shell, 220 , 25);        for (i = 0; i < LCRT_SHELL_SUPPORT_NUMBER; i++) {        gtk_combo_box_append_text (GTK_COMBO_BOX (combobox_shell), shells[i]);    }    debug_where();    //gtk_entry_set_editable(GTK_ENTRY(GTK_BIN(combobox_shell)->child), FALSE);    gtk_entry_set_max_length(GTK_ENTRY(GTK_BIN(combobox_shell)->child), PASSWORD_LEN);    hbox3 = gtk_hbox_new (FALSE, 0);    gtk_widget_show (hbox3);    gtk_box_pack_start (GTK_BOX (vbox_spec), hbox3, TRUE, TRUE, 0);    gtk_widget_set_size_request (hbox3, -1, 185);    if (lqconnect->flag == LCRT_QCONNECT_SESSION_OPTION) {        struct lcrtc_user *user;        if ((user = lcrt_user_find_by_name(&parent->u_config, lqconnect->uname)) != NULL) {ttt/* NOTE: there is very ugly, we use passwd field to store shell index */            gtk_combo_box_set_active(GTK_COMBO_BOX(lshell->shell), atoi(user->password));        }    } else {    tgtk_widget_set_sensitive(lqconnect->q_bt_connect, TRUE);        gtk_combo_box_set_active(GTK_COMBO_BOX(lshell->shell), 0); //default shell is 'bash'    }}""",3,"cwe119,cwe120,cweother"
"process_psqlrc(char *argv0){tchartthome[MAXPGPATH];tcharttrc_file[MAXPGPATH];tcharttmy_exec_path[MAXPGPATH];tcharttetc_path[MAXPGPATH];tchart   *envrc = getenv(""PSQLRC"");tif (find_my_exec(argv0, my_exec_path) < 0)t{ttfprintf(stderr, _(""%s: could not find own program executable""), argv0);ttexit(EXIT_FAILURE);t}tget_etc_path(my_exec_path, etc_path);tsnprintf(rc_file, MAXPGPATH, ""%s/%s"", etc_path, SYSPSQLRC);tprocess_psqlrc_file(rc_file);tif (envrc != NULL && strlen(envrc) > 0)t{tt ttchart   *envrc_alloc = pstrdup(envrc);ttexpand_tilde(&envrc_alloc);ttprocess_psqlrc_file(envrc_alloc);t}telse if (get_home_path(home))t{ttsnprintf(rc_file, MAXPGPATH, ""%s/%s"", home, PSQLRC);ttprocess_psqlrc_file(rc_file);t}}",3,"cwe119,cwe120,cweother"
"server_print_request (call_frame_t *frame){        server_conf_t   *conf = NULL;        xlator_t        *this = NULL;        server_state_t  *state = NULL;        char             resolve_vars[256];        char             resolve2_vars[256];        char             loc_vars[256];        char             loc2_vars[256];        char             other_vars[512];        char             caller[512];        char            *op = ""UNKNOWN"";        GF_VALIDATE_OR_GOTO (""server"", frame, out);        this = frame->this;        conf = this->private;        GF_VALIDATE_OR_GOTO (""server"", conf, out);        if (!conf->trace)                goto out;        state = CALL_STATE (frame);        memset (resolve_vars, '0', 256);        memset (resolve2_vars, '0', 256);        memset (loc_vars, '0', 256);        memset (loc2_vars, '0', 256);        memset (other_vars, '0', 256);        print_caller (caller, 256, frame);        if (!server_resolve_is_empty (&state->resolve)) {                server_print_resolve (resolve_vars, 256, &state->resolve);                server_print_loc (loc_vars, 256, &state->loc);        }        if (!server_resolve_is_empty (&state->resolve2)) {                server_print_resolve (resolve2_vars, 256, &state->resolve2);                server_print_loc (loc2_vars, 256, &state->loc2);        }        server_print_params (other_vars, 512, state);        switch (frame->root->type) {        case GF_OP_TYPE_FOP:                op = (char *)gf_fop_list[frame->root->op];                break;        default:                op = """";                break;        }        gf_log (this->name, GF_LOG_INFO,                ""%s%s%s%s%s%s%s"",                op, caller,                resolve_vars, loc_vars, resolve2_vars, loc2_vars, other_vars);out:        return;}",2,"cwe119,cwe120"
"CL_Rcon_f (void)r{rtcharttmessage[1024];rtsizebuf_ttbuffer;rtinttti;rtnetadr_ttto;rrtif ( !(rcon_client_password->string && rcon_client_password->string[0]) && Cmd_Argc() < 3)rt{rttCom_Printf (""You must set 'rcon_password' before issuing an rcon command."");rttreturn;rt}rrtNET_Config (true);tt rtSZ_Init( &buffer, (byte *) message, 1024 );rtbuffer.allowoverflow = true;rtSZ_SetName( &buffer, ""RCon buffer"", false );rrtSZ_Print (&buffer, ""xffxffxffxffrcon "");rtif ( rcon_client_password->string && rcon_client_password->string[0] )rt{rttSZ_Print (&buffer, """""");rttSZ_Print (&buffer, rcon_client_password->string);rttSZ_Print (&buffer, """" "");rt}rrtfor (i=1 ; i<Cmd_Argc() ; i++)rt{rttSZ_Print (&buffer, """""");rttSZ_Print (&buffer, Cmd_Argv(i));rttSZ_Print (&buffer, """" "");rt}rrtif ( buffer.overflowed )rt{rttCom_Printf (""Rcon command too long"");rttreturn;rt}rrtif (cls.state >= ca_connected)rttto = cls.netchan.remote_address;rtelsert{rttif (!strlen(rcon_address->string))rtt{rtttCom_Printf (""You must either be connected, or set the 'rcon_address' cvar to issue rcon commands"");rrtttreturn;rtt}rttNET_StringToAdr (rcon_address->string, &to);rttif (to.port == 0)rtttto.port = BigShort (PORT_SERVER);rt}rrtNET_SendPacket (NS_CLIENT, strlen(message)+1, message, to);r}",2,"cwe119,cwe120"
"mlxsw_sp_port_get_stats(struct net_device *dev,tttt    struct ethtool_stats *stats, u64 *data){tstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);tstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;tchar ppcnt_pl[MLXSW_REG_PPCNT_LEN];tint i;tint err;tmlxsw_reg_ppcnt_pack(ppcnt_pl, mlxsw_sp_port->local_port);terr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ppcnt), ppcnt_pl);tfor (i = 0; i < MLXSW_SP_PORT_HW_STATS_LEN; i++)ttdata[i] = !err ? mlxsw_sp_port_hw_stats[i].getter(ppcnt_pl) : 0;}",2,"cwe119,cwe120"
"open_bin_files(NetParameters *params) {  DIR * FD;                     struct dirent* curr_file;     char * bin_pos;               char * method_pos;            char bin_num[5];              int bin_i;                    int num_files = 0;               if (NULL == (FD = opendir(params->inputDir))) {    fprintf(stderr, ""Error : Failed to open input directory - %s"", strerror(errno));    exit(-1);  }  while ((curr_file = readdir(FD))) {         if (strcmp(curr_file->d_name, ""."") == 0 || strcmp(curr_file->d_name, "".."") == 0) {      continue;    }         bin_pos = strstr(curr_file->d_name, "".bin"");    if(bin_pos) {             if(strstr(curr_file->d_name, params->fileprefix) != NULL) {                 char method[5];        sprintf(method, "".%s"", params->method);        method_pos = strstr(curr_file->d_name, method);        if (method_pos) {          num_files++;                     int size = (bin_pos - (method_pos + 3)) * sizeof(char);          memcpy(bin_num, method_pos + (3 * sizeof(char)), size);          bin_num[size] = 0;            bin_i = atoi(bin_num);                                char filename[1024];          sprintf(filename, ""%s/%s"", params->inputDir, curr_file->d_name);          if (!params->quiet) {            printf(""  Found file: %s"", filename);          }          FILE * fh = fopen(filename, ""rb"");          if (fh == NULL) {            fprintf(stderr, ""ERROR: could not open bin file: '%s':"", filename);            exit(-1);          }          params->files[bin_i] = fh;          params->num_files++;                                fread(&params->numGenes, sizeof(int), 1, fh);          fread(&params->numLines[bin_i], sizeof(int), 1, fh);        }      }    }  }  if (num_files == 0) {    fprintf(stderr, ""ERROR: Could not find any matrix .bin files."");    exit(-1);  }}",3,"cwe119,cwe120,cweother"
"promptblocks(mydd_t * dd){    char        ans[80];    printf(""Would you like to coalesce the following linked-block element:"");    printf(""ttag = %dtref = %d(y/n): "", dd->tag, dd->ref);    fgets(ans,80,stdin);    if ((ans[0] == 'y') || (ans[0] == 'Y'))        return (1);    else        return (0);}",2,"cwe119,cwe120"
"__ecereMethod___ecereNameSpace__ecere__sys__TempFile_Write(struct __ecereNameSpace__ecere__com__Instance * this, unsigned char * buffer, unsigned int size, unsigned int count){struct __ecereNameSpace__ecere__sys__TempFile * __ecerePointer___ecereNameSpace__ecere__sys__TempFile = (struct __ecereNameSpace__ecere__sys__TempFile *)(this ? (((char *)this) + __ecereClass___ecereNameSpace__ecere__sys__TempFile->offset) : 0);int writeSize = size * count;int written = writeSize;if(__ecerePointer___ecereNameSpace__ecere__sys__TempFile->size - __ecerePointer___ecereNameSpace__ecere__sys__TempFile->position < writeSize){__ecerePointer___ecereNameSpace__ecere__sys__TempFile->size += writeSize - (__ecerePointer___ecereNameSpace__ecere__sys__TempFile->size - __ecerePointer___ecereNameSpace__ecere__sys__TempFile->position);if(__ecerePointer___ecereNameSpace__ecere__sys__TempFile->allocated < __ecerePointer___ecereNameSpace__ecere__sys__TempFile->size){__ecerePointer___ecereNameSpace__ecere__sys__TempFile->allocated *= 2;if(__ecerePointer___ecereNameSpace__ecere__sys__TempFile->allocated < __ecerePointer___ecereNameSpace__ecere__sys__TempFile->size)__ecerePointer___ecereNameSpace__ecere__sys__TempFile->allocated = __ecerePointer___ecereNameSpace__ecere__sys__TempFile->size * 2;__ecerePointer___ecereNameSpace__ecere__sys__TempFile->buffer = __ecereNameSpace__ecere__com__eSystem_Renew(__ecerePointer___ecereNameSpace__ecere__sys__TempFile->buffer, sizeof(unsigned char) * (__ecerePointer___ecereNameSpace__ecere__sys__TempFile->allocated));}}memcpy(__ecerePointer___ecereNameSpace__ecere__sys__TempFile->buffer + __ecerePointer___ecereNameSpace__ecere__sys__TempFile->position, buffer, writeSize);__ecerePointer___ecereNameSpace__ecere__sys__TempFile->position += written;return written / size;}",2,"cwe120,cwe476"
"ipmi_sensor_get_sensor_reading_factors(tstruct ipmi_intf * intf, tstruct sdr_record_full_sensor * sensor, tuint8_t reading){tstruct ipmi_rq req;tstruct ipmi_rs * rsp;tuint8_t req_data[2];tchar id[17];tif (intf == NULL || sensor == NULL)ttreturn -1;tmemset(id, 0, sizeof(id));tmemcpy(id, sensor->id_string, 16);treq_data[0] = sensor->keys.sensor_num;treq_data[1] = reading;tmemset(&req, 0, sizeof(req));treq.msg.netfn = IPMI_NETFN_SE;treq.msg.cmd   = GET_SENSOR_FACTORS;treq.msg.data  = req_data;treq.msg.data_len = sizeof(req_data);trsp = intf->sendrecv(intf, &req);tif (rsp == NULL) {ttlprintf(LOG_ERR, ""Error updating reading factor for sensor %s (#%02x)"",tttid, sensor->keys.sensor_num);ttreturn -1;t} else if (rsp->ccode) {ttreturn -1;t} else {tt tt tt  ttmemcpy(&sensor->mtol, &rsp->data[1], sizeof(sensor->mtol));ttmemcpy(&sensor->bacc, &rsp->data[3], sizeof(sensor->bacc));ttreturn 0;t}}",2,"cwe119,cwe120"
"print_msg(int Level, const char *fmt, ...){tauto va_list ap;tauto char    String[LONG_STRING_SIZE];tva_start(ap, fmt);tvsnprintf(String, LONG_STRING_SIZE, fmt, ap);tva_end(ap);tif (Level & PRT_ERR)ttfprintf(stderr, ""%s"", String);telsettfprintf(stdout, ""%s"", String);treturn 0;}",3,"cwe119,cwe120,cweother"
"_anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog){    int s, rv;    char _port[6];       struct addrinfo hints, *servinfo, *p;    snprintf(_port,6,""%d"",port);    memset(&hints,0,sizeof(hints));    hints.ai_family = af;    hints.ai_socktype = SOCK_STREAM;    hints.ai_flags = AI_PASSIVE;         if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {        anetSetError(err, ""%s"", gai_strerror(rv));        return ANET_ERR;    }    for (p = servinfo; p != NULL; p = p->ai_next) {        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)            continue;        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) goto error;        goto end;    }    if (p == NULL) {        anetSetError(err, ""unable to bind socket"");        goto error;    }error:    s = ANET_ERR;end:    freeaddrinfo(servinfo);    return s;}",2,"cwe119,cwe120"
"qfits_getkey_r(const char* line, char* key){    int                i;    if (line==NULL) {#ifdef DEBUG_FITSHEADER        printf(""qfits_getkey: NULL input line"");#endif        return NULL;    }         if (!strncmp(line, ""        "", 8)) {        strcpy(key, ""        "");        return key;    }         if (!strncmp(line, ""HISTORY "", 8)) {        strcpy(key, ""HISTORY"");        return key;    }    if (!strncmp(line, ""COMMENT "", 8)) {        strcpy(key, ""COMMENT"");        return key;    }    if (!strncmp(line, ""END "", 4)) {        strcpy(key, ""END"");        return key;    }t     if (!strncmp(line, ""CONTINUE "", 9)) {        strcpy(key, ""CONTINUE"");        return key;    }    memset(key, 0, 81);         i=0;    while (line[i]!='=' && i<80) i++;    if (i>=80) {        qfits_error(""qfits_getkey: cannot find equal sign in line: ""%.80s"""", line);        return NULL;    }    i--;         while (line[i]==' ' && i>=0) i--;    if (i<0) {        qfits_error(""qfits_getkey: error backtracking on blanks in line: ""%s"""", line);        return NULL;    }    i++;         strncpy(key, line, i);         key[i+1] = '0';    return key;}",2,"cwe120,cweother"
"printMyItemsRow(char **row, int printNewline){tconst char *myitems_description[MAX_TDS][MAX_TDS_LENGTH] = {tt{0, 0, 0, 0, 0, 0},tt{0, 0, 0, 0, 0, 0},tt{""Description:t%s"", 0, ""Seller:tt%s"", 0, 0,"" (%s)""},tt{ ""Bids:tt%s"", 0, 0, 0, 0, 0},tt{ ""Price:tt%s"", 0, 0, 0, 0, 0},tt{ ""Shipping:t%s"", 0, 0, 0, 0, 0},tt{ ""Time left:t%s"", 0, 0, 0, 0, 0},tt{ 0, 0, 0, 0, 0, 0},t};tint column = 0;tint ret = printNewline;tint item_nr=0;t tfor (; row[column]; ++column) {ttmemBuf_t buf;ttchar *value = NULL;ttif (column == 0) {  tttstatic const char search[] = ""value="";tttchar *tmp = strstr(row[column], search);tttif (tmp) {ttttint i;tttttmp += sizeof(search) - 1;ttttfor (; !isdigit(*tmp); ++tmp)ttttt;ttttfor (i = 1; isdigit(tmp[i]); ++i)ttttt;ttttvalue = myStrndup(tmp, (size_t)(i));ttttprintLog(stdout, ""ItemNr:tt%s"", value);ttttfree(value);ttt}tt}ttstrToMemBuf(row[column], &buf);  ttfor (item_nr = 0; item_nr < MAX_TDS_LENGTH; item_nr++) {tttvalue = getNonTag(&buf);ttt tttif ((column==2)&&(item_nr==0)&&strstr(value,""ENDING SOON""))ttttvalue = getNonTag(&buf);ttt tttif (column >= MAX_TDS || !myitems_description[column][item_nr])ttttcontinue;ttt tttprintLog(stdout, myitems_description[column][item_nr], value ? value : """");tt}t}tprintf("""");t treturn ret;}",2,"cwe119,cwe120"
"chat_do_menu_selection_filtered(char *MenuTexts[MAX_ANSWERS_PER_PERSON], enemy *chat_droid, const char *topic){tint MenuSelection;tchar *FilteredChatMenuTexts[MAX_ANSWERS_PER_PERSON];tint i;tint use_counter = 0;t tfor (i = 0; i < MAX_ANSWERS_PER_PERSON; i++) {ttFilteredChatMenuTexts[i] = """";ttif (chat_control_chat_flags[i] && !(strcmp(topic, ChatRoster[i].topic))) {tttDebugPrintf(MENU_SELECTION_DEBUG, ""%2d. "", i);tttDebugPrintf(MENU_SELECTION_DEBUG, ""%s"", MenuTexts[i]);tttfflush(stdout);tttfflush(stderr);tttFilteredChatMenuTexts[use_counter] = MenuTexts[i];tttuse_counter++;tt}t}t t tMenuSelection = chat_do_menu_selection(FilteredChatMenuTexts, chat_droid);t t t tif (MenuSelection != (-1)) {ttuse_counter = 0;ttfor (i = 0; i < MAX_ANSWERS_PER_PERSON; i++) {tttif (chat_control_chat_flags[i] && !(strcmp(topic, ChatRoster[i].topic))) {ttttFilteredChatMenuTexts[use_counter] = MenuTexts[i];ttttuse_counter++;ttttif (MenuSelection == use_counter) {tttttDebugPrintf(1, ""Original MenuSelect: %d. Transposed MenuSelect: %d."", MenuSelection, i + 1);tttttreturn (i + 1);tttt}ttt}tt}t}treturn (MenuSelection);}",2,"cwe119,cwe120"
"on_gpac_log(void *cbk, u32 ll, u32 lm, const char *fmt, va_list list){tFILE *logs = cbk;tif (rti_logs && (lm & GF_LOG_RTI)) {ttchar szMsg[2048];ttvsprintf(szMsg, fmt, list);ttUpdateRTInfo(szMsg + 6  );t} else {ttif (log_time_start) fprintf(logs, ""[At %d]"", gf_sys_clock() - log_time_start);ttvfprintf(logs, fmt, list);ttfflush(logs);t}}",3,"cwe119,cwe120,cweother"
"maildb_txt_save_mail(int char_id, int i, int store, struct mail_data md[MAIL_STORE_MAX]){tchar filename[1056];tFILE *fp;tunsigned int j;tint n = 0, lock;tnullpo_retr(false, md);tsprintf(filename, ""%s%d.txt"", mail_dir, char_id);tfp = lock_fopen(filename, &lock);tif(fp == NULL)t{ttprintf(""maildb_txt_save_mail: can't write [%s] !!! data is lost !!!"", filename);ttreturn false;t}twhile(n < store)t{ttfprintf(fp, ""%u,%dt%st%st%st%dt%u,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%ut%ut%ut"",tttmd[n].mail_num, md[n].read, md[n].char_name, md[n].receive_name, md[n].title, md[n].zeny,tttmd[n].item.id, md[n].item.nameid, md[n].item.amount, md[n].item.equip,tttmd[n].item.identify, md[n].item.refine, md[n].item.attribute,tttmd[n].item.card[0], md[n].item.card[1], md[n].item.card[2], md[n].item.card[3], md[n].item.limit,tttmd[n].times, md[n].body_size);ttfor(j = 0; j < md[n].body_size; j++) {tttfprintf(fp, ""%02X"", (unsigned char)(md[n].body[j]));tt}ttfprintf(fp, NEWLINE);ttn++;t}tlock_fclose(fp, filename, &lock);treturn true;}",3,"cwe119,cwe120,cweother"
"t_dns_name_init(void) {tintttrval;tintttresult;tdns_name_ttname;tunsigned chartoffsets[1];trval = 0;tt_assert(""dns_name_init"", 1, T_REQUIRED, ""%s"", a3);tdns_name_init(&name, offsets);t tif (name.ndata != NULL) {ttt_info(""name.ndata is not NULL"");tt++rval;t}tif (name.length != 0) {ttt_info(""name.length is not 0"");tt++rval;t}tif (name.labels != 0) {ttt_info(""name.labels is not 0"");tt++rval;t}tif (name.attributes != 0) {ttt_info(""name.attributes is not 0"");tt++rval;t}tif (name.offsets != offsets) {ttt_info(""name.offsets is incorrect"");tt++rval;t}tif (name.buffer != NULL) {ttt_info(""name.buffer is not NULL"");tt++rval;t}tif (rval == 0)ttresult = T_PASS;telsettresult = T_FAIL;tt_result(result);}",2,"cwe119,cwe120"
"_run_script_as_user(const char *name, const char *path, stepd_step_rec_t *job,tt    int max_wait, char **env){tint status, rc, opt;tpid_t cpid;tstruct exec_wait_info *ei;txassert(env);tif (path == NULL || path[0] == '0')ttreturn 0;tdebug(""[job %u] attempting to run %s [%s]"", job->jobid, name, path);tif (_access(path, 5, job->pwd->pw_uid, job->pwd->pw_gid) < 0) {tterror(""Could not run %s [%s]: access denied"", name, path);ttreturn -1;t}tif ((ei = fork_child_with_wait_info(0)) == NULL) {tterror (""executing %s: fork: %m"", name);ttreturn -1;t}tif ((cpid = exec_wait_get_pid (ei)) == 0) {ttstruct priv_state sprivs;ttchar *argv[2];tt ttif ((job->jobid != 0) &&t tt    (container_g_add_pid(job->jobid, getpid(), job->uid)tt     != SLURM_SUCCESS))ttterror(""container_g_add_pid(%u): %m"", job->jobid);ttargv[0] = (char *)xstrdup(path);ttargv[1] = NULL;ttif (_drop_privileges(job, true, &sprivs, false) < 0) {ttterror(""run_script_as_user _drop_privileges: %m"");ttt tttexit(127);tt}ttif (_become_user(job, &sprivs) < 0) {ttterror(""run_script_as_user _become_user failed: %m"");ttt tttexit(127);tt}ttif (chdir(job->cwd) == -1)ttterror(""run_script_as_user: couldn't ""ttt      ""change working dir to %s: %m"", job->cwd);#ifdef SETPGRP_TWO_ARGSttsetpgrp(0, 0);#elsettsetpgrp();#endiftt ttexec_wait_child_wait_for_parent (ei);ttexecve(path, argv, env);tterror(""execve(): %m"");ttexit(127);t}tif (exec_wait_signal_child (ei) < 0)tterror (""run_script_as_user: Failed to wakeup %s"", name);texec_wait_info_destroy (ei);tif (max_wait < 0)ttopt = 0;telsettopt = WNOHANG;twhile (1) {ttrc = waitpid(cpid, &status, opt);ttif (rc < 0) {tttif (errno == EINTR)ttttcontinue;ttterror(""waidpid: %m"");tttstatus = 0;tttbreak;tt} else if (rc == 0) {tttsleep(1);tttif ((--max_wait) <= 0) {ttttkillpg(cpid, SIGKILL);ttttopt = 0;ttt}tt} else  {ttt tttbreak;tt}t}t tkillpg(cpid, SIGKILL);treturn status;}",2,"cwe119,cwe120"
"""pool_accept(struct pool *pp, struct worker *w, const struct poolsock *ps){tstruct worker *w2;tstruct wrk_accept *wa, *wa2;tCHECK_OBJ_NOTNULL(pp, POOL_MAGIC);tCHECK_OBJ_NOTNULL(w, WORKER_MAGIC);tCHECK_OBJ_NOTNULL(ps, POOLSOCK_MAGIC);tCHECK_OBJ_NOTNULL(ps->lsock, LISTEN_SOCK_MAGIC);tLck_AssertHeld(&pp->mtx);tLck_Unlock(&pp->mtx);tassert(sizeof *wa == WS_Reserve(w->ws, sizeof *wa));twa = (void*)w->ws->f;twhile (1) {ttmemset(wa, 0, sizeof *wa);ttwa->magic = WRK_ACCEPT_MAGIC;ttif (ps->lsock->sock < 0) {ttt/* Socket Shutdown */tttLck_Lock(&pp->mtx);tttreturn (-1);tt}ttif (VCA_Accept(ps->lsock, wa) < 0) {tttw->stats.sess_fail++;ttt/* We're going to pace in vca anyway... */ttt(void)WRK_TrySumStat(w);tttcontinue;tt}ttLck_Lock(&pp->mtx);ttif (VTAILQ_EMPTY(&pp->idle))tttreturn (0);ttw2 = VTAILQ_FIRST(&pp->idle);ttVTAILQ_REMOVE(&pp->idle, w2, list);ttLck_Unlock(&pp->mtx);ttassert(sizeof *wa2 == WS_Reserve(w2->ws, sizeof *wa2));ttwa2 = (void*)w2->ws->f;ttmemcpy(wa2, wa, sizeof *wa);ttAZ(pthread_cond_signal(&w2->cond));t}}""",2,"cwe120,cwe476"
"amdlibSetInsCfgKeyword(amdlibINS_CFG   *insCfg,                                         char            *keywName,                                        char            *keywVal,                                        char            *keywCmt,                                        amdlibERROR_MSG errMsg){     int i;    char name[amdlibKEYW_NAME_LEN+1];    char currentName[amdlibKEYW_NAME_LEN+1];        strcpy(name, keywName);    amdlibStripBlanks(name);             for (i = 0; i < insCfg->nbKeywords; i++)    {        strcpy(currentName, insCfg->keywords[i].name);        amdlibStripBlanks(currentName);                 if (strcmp(name, currentName) == 0)        {            memset(insCfg->keywords[i].value, '0',                    sizeof(char[amdlibKEYW_VAL_LEN+1]));            memset(insCfg->keywords[i].comment, '0',                   sizeof(char[amdlibKEYW_CMT_LEN+1]));            strcpy(insCfg->keywords[i].value, keywVal);            strcpy(insCfg->keywords[i].comment, keywCmt);            return amdlibSUCCESS;        }    }         if (i < amdlibNB_INS_CFG_KEYW)    {        strcpy(insCfg->keywords[i].name, keywName);        strcpy(insCfg->keywords[i].value, keywVal);        if (keywCmt != NULL || strlen(keywCmt) != 0)        {            strcpy(insCfg->keywords[i].comment, keywCmt);        }        insCfg->nbKeywords++;        return amdlibSUCCESS;    }        amdlibSetErrMsg(""insCfg array is full - impossible to insert %s"", keywName);    return amdlibFAILURE;}",2,"cwe119,cwe120"
"access_deny(access_t access, char *ip, char *mask){    struct sockaddr_storage ip_addr;    int netsize;    if(j_inet_pton(ip, &ip_addr) <= 0)        return 1;    netsize = _access_calc_netsize(mask, ip_addr.ss_family==AF_INET ? 32 : 128);    access->deny = (access_rule_t) realloc(access->deny, sizeof(struct access_rule_st) * (access->ndeny + 1));    memcpy(&access->deny[access->ndeny].ip, &ip_addr, sizeof(ip_addr));    access->deny[access->ndeny].mask = netsize;    access->ndeny++;    return 0;}",2,"cwe120,cweother"
"ssl3_InitPendingCipherSpec(sslSocket *ss, PK11SymKey *pms){    ssl3CipherSpec  *  pwSpec;    ssl3CipherSpec  *  cwSpec;    SECStatus          rv;    PORT_Assert( ss->opt.noLocks || ssl_HaveSSL3HandshakeLock(ss));    ssl_GetSpecWriteLock(ss);t     PORT_Assert(ss->ssl3.prSpec == ss->ssl3.pwSpec);    pwSpec        = ss->ssl3.pwSpec;    cwSpec        = ss->ssl3.cwSpec;    if (pms || (!pwSpec->msItem.len && !pwSpec->master_secret)) {trv = ssl3_DeriveMasterSecret(ss, pms);tif (rv != SECSuccess) {t    goto done;   t}    }#ifndef NO_PKCS11_BYPASS    if (ss->opt.bypassPKCS11 && pwSpec->msItem.len && pwSpec->msItem.data) {t tconst ssl3KEADef * kea_def = ss->ssl3.hs.kea_def;tPRBool             isTLS   = (PRBool)(kea_def->tls_keygen ||                                (pwSpec->version > SSL_LIBRARY_VERSION_3_0));tpwSpec->bypassCiphers = PR_TRUE;trv = ssl3_KeyAndMacDeriveBypass( pwSpec, ttt     (const unsigned char *)&ss->ssl3.hs.client_random,ttt     (const unsigned char *)&ss->ssl3.hs.server_random,ttt     isTLS, ttt     (PRBool)(kea_def->is_limited));tif (rv == SECSuccess) {t    rv = ssl3_InitPendingContextsBypass(ss);t}    } else#endif    if (pwSpec->master_secret) {trv = ssl3_DeriveConnectionKeysPKCS11(ss);tif (rv == SECSuccess) {t    rv = ssl3_InitPendingContextsPKCS11(ss);t}    } else {tPORT_Assert(pwSpec->master_secret);tPORT_SetError(SEC_ERROR_LIBRARY_FAILURE);trv = SECFailure;    }    if (rv != SECSuccess) {tgoto done;    }         if (!IS_DTLS(ss)) {tpwSpec->read_seq_num.high = pwSpec->write_seq_num.high = 0;    } else {tif (cwSpec->epoch == PR_UINT16_MAX) {t     t    PORT_SetError(SEC_ERROR_LIBRARY_FAILURE);t    rv = SECFailure;t    goto done;t}t tpwSpec->epoch = cwSpec->epoch + 1;tpwSpec->read_seq_num.high = pwSpec->write_seq_num.high =t    pwSpec->epoch << 16;tdtls_InitRecvdRecords(&pwSpec->recvdRecords);    }    pwSpec->read_seq_num.low = pwSpec->write_seq_num.low = 0;done:    ssl_ReleaseSpecWriteLock(ss);t     if (rv != SECSuccess)tssl_MapLowLevelError(SSL_ERROR_SESSION_KEY_GEN_FAILURE);    return rv;}",2,"cwe119,cwe120"
"snd_card_register(struct snd_card *card){tint err;tif (snd_BUG_ON(!card))ttreturn -EINVAL;tif (!card->registered) {tterr = device_add(&card->card_dev);ttif (err < 0)tttreturn err;ttcard->registered = true;t}tif ((err = snd_device_register_all(card)) < 0)ttreturn err;tmutex_lock(&snd_card_mutex);tif (snd_cards[card->number]) {tt ttmutex_unlock(&snd_card_mutex);ttreturn snd_info_card_register(card);  t}tif (*card->id) {tt ttchar tmpid[sizeof(card->id)];ttmemcpy(tmpid, card->id, sizeof(card->id));ttsnd_card_set_id_no_lock(card, tmpid, tmpid);t} else {tt ttconst char *src;ttsrc = *card->shortname ? card->shortname : card->longname;ttsnd_card_set_id_no_lock(card, src,tttttretrieve_id_from_card_name(src));t}tsnd_cards[card->number] = card;tmutex_unlock(&snd_card_mutex);tinit_info_for_card(card);#if IS_ENABLED(CONFIG_SND_MIXER_OSS)tif (snd_mixer_oss_notify_callback)ttsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_REGISTER);#endiftreturn 0;}",2,"cwe119,cwe120"
"hexdump(ios_t *dest, const char *buffer, size_t len, size_t startoffs){    size_t offs=0;    size_t i, pos;    char ch, linebuffer[16];    char hexc[4];    static char *spc50 = ""                                                  "";    hexc[2] = hexc[3] = ' ';    do {        ios_printf(dest, ""%.8x  "", offs+startoffs);        pos = 10;        for(i=0; i < 16 && offs < len; i++, offs++) {            ch = buffer[offs];            linebuffer[i] = (ch<32 || ch>=0x7f) ? '.' : ch;            hexc[0] = hexdig[((unsigned char)ch)>>4];            hexc[1] = hexdig[ch&0x0f];            pos += ios_write(dest, hexc, (i==7 || i==15) ? 4 : 3);        }        for(; i < 16; i++)            linebuffer[i] = ' ';        ios_write(dest, spc50, 60-pos);        ios_putc('|', dest);        ios_write(dest, linebuffer, 16);        ios_write(dest, ""|"", 2);    } while (offs < len);}",2,"cwe119,cwe120"
"process_lingering_close(event_conn_state_t *cs, const apr_pollfd_t *pfd){    apr_socket_t *csd = ap_get_conn_socket(cs->c);    char dummybuf[2048];    apr_size_t nbytes;    apr_status_t rv;    struct timeout_queue *q;    q = (cs->pub.state == CONN_STATE_LINGER_SHORT) ?  &short_linger_q : &linger_q;         do {        nbytes = sizeof(dummybuf);        rv = apr_socket_recv(csd, dummybuf, &nbytes);    } while (rv == APR_SUCCESS);    if (APR_STATUS_IS_EAGAIN(rv)) {        return;    }    apr_thread_mutex_lock(timeout_mutex);    rv = apr_pollset_remove(event_pollset, pfd);    AP_DEBUG_ASSERT(rv == APR_SUCCESS);    rv = apr_socket_close(csd);    AP_DEBUG_ASSERT(rv == APR_SUCCESS);    TO_QUEUE_REMOVE(*q, cs);    apr_thread_mutex_unlock(timeout_mutex);    TO_QUEUE_ELEM_INIT(cs);    apr_pool_clear(cs->p);    ap_push_pool(worker_queue_info, cs->p);}",2,"cwe119,cwe120"
"AlterDomainDefault(List *names, Node *defaultRaw){tTypeName   *typename;tOidtttdomainoid;tHeapTuplettup;tParseState *pstate;tRelationtrel;tchart   *defaultValue;tNodet   *defaultExpr = NULL;tt tDatumttnew_record[Natts_pg_type];tcharttnew_record_nulls[Natts_pg_type];tcharttnew_record_repl[Natts_pg_type];tHeapTupletnewtuple;tForm_pg_type typTup;t ttypename = makeTypeNameFromNameList(names);tdomainoid = typenameTypeId(NULL, typename);t trel = heap_open(TypeRelationId, RowExclusiveLock);ttup = SearchSysCacheCopy(TYPEOID,ttttttt ObjectIdGetDatum(domainoid),ttttttt 0, 0, 0);tif (!HeapTupleIsValid(tup))ttelog(ERROR, ""cache lookup failed for type %u"", domainoid);ttypTup = (Form_pg_type) GETSTRUCT(tup);t tcheckDomainOwner(tup, typename);t tMemSet(new_record, (Datum) 0, sizeof(new_record));tMemSet(new_record_nulls, ' ', sizeof(new_record_nulls));tMemSet(new_record_repl, ' ', sizeof(new_record_repl));t tif (defaultRaw)t{tt ttpstate = make_parsestate(NULL);tt ttdefaultExpr = cookDefault(pstate, defaultRaw,tttttttt  typTup->typbasetype,tttttttt  typTup->typtypmod,tttttttt  NameStr(typTup->typname));tt ttdefaultValue = deparse_expression(defaultExpr,ttttttttdeparse_context_for(NameStr(typTup->typname),tttttttttttttInvalidOid),tttttttttt  false, false);tt ttnew_record[Anum_pg_type_typdefaultbin - 1] = DirectFunctionCall1(textin,ttttttttttttttt CStringGetDatum(tttttttttttt nodeToString(defaultExpr)));ttnew_record_repl[Anum_pg_type_typdefaultbin - 1] = 'r';ttnew_record[Anum_pg_type_typdefault - 1] = DirectFunctionCall1(textin,ttttttttttt  CStringGetDatum(defaultValue));ttnew_record_repl[Anum_pg_type_typdefault - 1] = 'r';t}telsett t{ttnew_record_nulls[Anum_pg_type_typdefaultbin - 1] = 'n';ttnew_record_repl[Anum_pg_type_typdefaultbin - 1] = 'r';ttnew_record_nulls[Anum_pg_type_typdefault - 1] = 'n';ttnew_record_repl[Anum_pg_type_typdefault - 1] = 'r';t}tnewtuple = heap_modifytuple(tup, RelationGetDescr(rel),ttttttttnew_record, new_record_nulls,ttttttttnew_record_repl);tsimple_heap_update(rel, &tup->t_self, newtuple);tCatalogUpdateIndexes(rel, newtuple);t tGenerateTypeDependencies(typTup->typnamespace,ttttttt domainoid,ttttttt typTup->typrelid,ttttttt 0,  ttttttt typTup->typowner,ttttttt typTup->typinput,ttttttt typTup->typoutput,ttttttt typTup->typreceive,ttttttt typTup->typsend,ttttttt typTup->typanalyze,ttttttt typTup->typelem,ttttttt typTup->typbasetype,ttttttt defaultExpr,ttttttt true);tt t theap_close(rel, NoLock);theap_freetuple(newtuple);}",3,"cwe119,cwe120,cwe476"
"shapiro_wilk (const double *x, int t1, int t2, double *W, double *pval) {    int n1 = 0;              float *a = NULL;t     float *xf = NULL;        int i, t, n2, n = 0;    int err = 0;    *W = *pval = NADBL;    for (t=t1; t<=t2; t++) {tif (!na(x[t])) n++;    }         n1 = n;    err = sw_sample_check(n, n1);    if (err) {treturn err;    }t         n2 = fmod(n, 2.0);    n2 = (n2 == 0)?  n / 2 : (n - 1) / 2;    xf = malloc(n * sizeof *xf);    a = malloc(n2 * sizeof *a);    if (xf == NULL || a == NULL) {terr = E_ALLOC;    } else {ti = 0;tfor (t=t1; t<=t2; t++) {t    if (!na(x[t])) {ttxf[i++] = x[t];t    }t}tqsort(xf, n, sizeof *xf, compare_floats);t tsw_coeff(n, n2, a);terr = sw_w(xf, n, n1, a, W, pval);    } t    free(a);    free(xf);t    return err;}",2,"cwe120,cweother"
"NsInitThreads(void){    char *env;    int err;    err = pthread_key_create(&key, FreeThread);    if (err != 0) {tNsThreadFatal(""NsPthreadsInit"", ""pthread_key_create"", err);    }    stackdown = StackDown(&env);    pagesize = getpagesize();    env = getenv(""NS_THREAD_GUARDSIZE"");    if (env == NULLt    || Tcl_GetInt(NULL, env, &guardsize) != TCL_OKt    || guardsize < 2) {tguardsize = 2 * pagesize;    }    guardsize = PageRound(guardsize);    markpages = getenv(""NS_THREAD_MARKPAGES"") ? 1 : 0;    dumpdir = getenv(""NS_THREAD_DUMPDIR"");    env = getenv(""NS_THREAD_LOGFILE"");    if (env != NULL) {tif (strcmp(env, ""-"") == 0) {t    logfp = stderr;t} else {t    logfp = fopen(env, ""a"");t}    }    Ns_MutexSetName(&uidlock, ""ns:uidlock"");}",2,"cwe469,cweother"
"Realloc(void *p, int64 size, char *mesg){ if ((p = realloc(p,size)) == NULL)    { if (mesg == NULL)        fprintf(stderr,""%s: Out of memory"",Prog_Name);      else        fprintf(stderr,""%s: Out of memory (%s)"",Prog_Name,mesg);    }  return (p);}",2,"cwe469,cweother"
"netsnmp_register_old_api(const char *moduleName,                         struct variable *var,                         size_t varsize,                         size_t numvars,                         const oid * mibloc,                         size_t mibloclen,                         int priority,                         int range_subid,                         oid range_ubound,                         netsnmp_session * ss,                         const char *context, int timeout, int flags){    unsigned int    i;         for (i = 0; i < numvars; i++) {        struct variable *vp;        netsnmp_handler_registration *reginfo =            SNMP_MALLOC_TYPEDEF(netsnmp_handler_registration);        if (reginfo == NULL)            return SNMP_ERR_GENERR;tvp = netsnmp_duplicate_variable((struct variable *)ttttt((char *) var + varsize * i));        reginfo->handler = get_old_api_handler();        reginfo->handlerName = strdup(moduleName);        reginfo->rootoid_len = (mibloclen + vp->namelen);        reginfo->rootoid =            (oid *) malloc(reginfo->rootoid_len * sizeof(oid));        if (reginfo->rootoid == NULL)            return SNMP_ERR_GENERR;        memcpy(reginfo->rootoid, mibloc, mibloclen * sizeof(oid));        memcpy(reginfo->rootoid + mibloclen, vp->name, vp->namelen               * sizeof(oid));        reginfo->handler->myvoid = (void *) vp;        reginfo->handler->data_clonet    = (void *(*)(void *))netsnmp_duplicate_variable;        reginfo->handler->data_free = free;        reginfo->priority = priority;        reginfo->range_subid = range_subid;        reginfo->range_ubound = range_ubound;        reginfo->timeout = timeout;        reginfo->contextName = (context) ? strdup(context) : NULL;        reginfo->modes = HANDLER_CAN_RWRITE;                 if (netsnmp_register_handler(reginfo) != MIB_REGISTERED_OK) {                         SNMP_FREE(vp);        }    }    return SNMPERR_SUCCESS;}",2,"cwe120,cweother"
"detect_gs (void){#ifdef UNIX  int pid, f[2], dum, fd, count;  char *argv[6] = { ""gs"", ""-q"", ""-sDEVICE=nullpage"", ""-dBATCH"", """", NULL };  char *temp;  FILE *file;  temp = g_strconcat (g_get_tmp_dir (), ""/gs_detect.XXXXXX"", NULL);  fd = mkstemp (temp);  if (fd == -1)    return PROGRAM_NOT_FOUND;  file = fdopen (fd, ""w"");  if (file == NULL)    return PROGRAM_NOT_FOUND;  fputs (""(125) = quit"", file);  fclose (file);  if ((pipe (f) == -1) || ((pid = fork ()) < 0))    return PROGRAM_NOT_FOUND;  if (pid == 0)    {      close (f[0]);      dup2 (f[1], STDOUT_FILENO);      close (f[1]);      argv[3] = temp;      if (prop.path_gs != NULL)texecv(prop.path_gs, argv);      puts (""42"");      fflush (stdout);#ifdef GS_PATH      execv (GS_PATH ""/gs"", argv);#endif      puts (""42"");      fflush (stdout);      execvp (""gs"", argv);      puts (""42"");      fflush (stdout);      execv (""/usr/bin/gs"", argv);      puts (""42"");      fflush (stdout);      execv (""/usr/local/bin/gs"", argv);      puts (""42"");      fflush (stdout);      execv (""/sw/bin/gs"", argv);      puts (""42"");      fflush (stdout);      _exit (0);    }  close (f[1]);  wait (NULL);  count = 0;  file = fdopen (f[0], ""r"");  while (!feof (file))    {      fscanf (file, ""%d"", &dum);      if (dum == 42)      {tdum = 0;tcount++;      }    }  fclose (file);  unlink (temp);  g_free (temp);  if (dum != 125)    return PROGRAM_NOT_FOUND;  if (count == 0)    return PROGRAM_IN_PREF_PATH;  if (count == 1)    return PROGRAM_IN_PROVIDED_PATH;  if (count == 2)    return PROGRAM_IN_PATH;  if (count == 3)    return PROGRAM_IN_USR_BIN;  if (count == 4)    return PROGRAM_IN_USR_LOCAL_BIN;  if (count == 5)    return PROGRAM_IN_SW_BIN;#endif  return PROGRAM_NOT_FOUND;}",3,"cwe119,cwe120,cweother"
"file_elf_version(char *file){tint fd, size;tElf32_Ehdr *elf32;tElf64_Ehdr *elf64;tchar header[MIN_NETDUMP_ELF_HEADER_SIZE];tchar buf[BUFSIZE];tif ((fd = open(file, O_RDONLY)) < 0) {ttsprintf(buf, ""%s: open"", file);ttperror(buf);ttreturn -1;t}tsize = MIN_NETDUMP_ELF_HEADER_SIZE;        if (read(fd, header, size) != size) {                sprintf(buf, ""%s: read"", file);                perror(buf);ttclose(fd);ttreturn -1;t}tclose(fd);telf32 = (Elf32_Ehdr *)&header[0];telf64 = (Elf64_Ehdr *)&header[0];        if (STRNEQ(elf32->e_ident, ELFMAG) &&t    (elf32->e_ident[EI_CLASS] == ELFCLASS32) &&  t    (elf32->e_ident[EI_DATA] == ELFDATA2LSB) &&    t    (elf32->e_ident[EI_VERSION] == EV_CURRENT)) {ttreturn (elf32->e_version);t} else if (STRNEQ(elf64->e_ident, ELFMAG) &&t    (elf64->e_ident[EI_CLASS] == ELFCLASS64) &&t    (elf64->e_ident[EI_VERSION] == EV_CURRENT)) {ttreturn (elf64->e_version);t} ttreturn -1;}",3,"cwe119,cwe120,cweother"
"getrest(){  char whichchr;  whichchr = ' ';  while (!(P_eoln(pedfile) || whichchr == 'f')) {    whichchr = getc(pedfile);    if (whichchr == '')      whichchr = ' ';  }  fscanf(pedfile, ""%*[^]"");  getc(pedfile);}",2,"cwe120,cweother"
"xmt_get_script_et_by_name(const char *_name){tchar name[1024];txmt_strip_name((char *)_name, name);tif (!strcmp(name, ""eventIn"") || !strcmp(name, ""inputOnly"") ) return GF_SG_SCRIPT_TYPE_EVENT_IN;telse if (!strcmp(name, ""eventOut"") || !strcmp(name, ""outputOnly"")) return GF_SG_SCRIPT_TYPE_EVENT_OUT;telse if (!strcmp(name, ""field"") || !strcmp(name, ""initializeOnly"") ) return GF_SG_SCRIPT_TYPE_FIELD;telse return GF_SG_EVENT_UNKNOWN;}",2,"cwe119,cwe120"
"decay_conversion (tree exp){  tree type;  enum tree_code code;  type = TREE_TYPE (exp);  if (type == error_mark_node)    return error_mark_node;  exp = mark_rvalue_use (exp);  exp = resolve_nondeduced_context (exp);  if (type_unknown_p (exp))    {      cxx_incomplete_type_error (exp, TREE_TYPE (exp));      return error_mark_node;    }     exp = decl_constant_value_safe (exp);  if (error_operand_p (exp))    return error_mark_node;  if (NULLPTR_TYPE_P (type) && !TREE_SIDE_EFFECTS (exp))    return nullptr_node;     code = TREE_CODE (type);  if (code == VOID_TYPE)    {      error (""void value not ignored as it ought to be"");      return error_mark_node;    }  if (invalid_nonstatic_memfn_p (exp, tf_warning_or_error))    return error_mark_node;  if (code == FUNCTION_TYPE || is_overloaded_fn (exp))    return cp_build_addr_expr (exp, tf_warning_or_error);  if (code == ARRAY_TYPE)    {      tree adr;      tree ptrtype;      if (TREE_CODE (exp) == INDIRECT_REF)treturn build_nop (build_pointer_type (TREE_TYPE (type)),ttt  TREE_OPERAND (exp, 0));      if (TREE_CODE (exp) == COMPOUND_EXPR)t{t  tree op1 = decay_conversion (TREE_OPERAND (exp, 1));t  return build2 (COMPOUND_EXPR, TREE_TYPE (op1),ttt TREE_OPERAND (exp, 0), op1);t}      if (!lvalue_p (exp)t  && ! (TREE_CODE (exp) == CONSTRUCTOR && TREE_STATIC (exp)))t{t  error (""invalid use of non-lvalue array"");t  return error_mark_node;t}             if (TREE_CODE (exp) == TARGET_EXPR)t{t  error (""taking address of temporary array"");t  return error_mark_node;t}      ptrtype = build_pointer_type (TREE_TYPE (type));      if (TREE_CODE (exp) == VAR_DECL)t{t  if (!cxx_mark_addressable (exp))t    return error_mark_node;t  adr = build_nop (ptrtype, build_address (exp));t  return adr;t}             adr = cp_build_addr_expr (exp, tf_warning_or_error);      return cp_convert (ptrtype, adr);    }     exp = convert_bitfield_to_declared_type (exp);        type = TREE_TYPE (exp);  if (!CLASS_TYPE_P (type) && cv_qualified_p (type))    exp = build_nop (cv_unqualified (type), exp);  return exp;}",2,"cwe476,cweother"
input(struct lex_record *p){tint       val;tif (p->lookahead_valid) {ttp->lookahead_valid = 0;ttval = p->lookahead;t}telse if (p->s) {ttval = *(p->s)++;t}telse {ttval = fgetc(p->f);t}treturn val;},3,"cwe119,cwe120,cweother"
"report_range(void){    struct FPRange drange;    struct Range range;    char buff[1024], buff2[300];    RASTER_MAP_TYPE inp_type;    inp_type = G_raster_map_type(name, mapset);    if (inp_type != CELL_TYPE) {tif (G_read_fp_range(name, mapset, &drange) <= 0)t    G_fatal_error(_(""Unable to read fp range of raster map <%s>""),ttt  G_fully_qualified_name(name, mapset));tG_get_fp_range_min_max(&drange, &old_dmin, &old_dmax);tif (G_is_d_null_value(&old_dmin) || G_is_d_null_value(&old_dmax))t    G_important_message(_(""Data range of raster map <%s> is empty""),ttttG_fully_qualified_name(name, mapset));telse {t    sprintf(buff, ""%.10f"", old_dmin);t    sprintf(buff2, ""%.10f"", old_dmax);t    G_trim_decimal(buff);t    G_trim_decimal(buff2);t    G_message(_(""Data range of raster map <%s> is %s to %s (entire map)""),tt      G_fully_qualified_name(name, mapset), buff, buff2);t}    }    if (G_read_range(name, mapset, &range) <= 0)tG_fatal_error(_(""Unable to read range of raster map <%s>""),tt      G_fully_qualified_name(name, mapset));    G_get_range_min_max(&range, &old_min, &old_max);    if (G_is_c_null_value(&old_min) || G_is_c_null_value(&old_max))tG_important_message(_(""Integer data range of raster map <%s> is empty""),ttt    G_fully_qualified_name(name, mapset));    elsetG_message(_(""Integer data range of raster mao <%s> is %d to %d""),tt  G_fully_qualified_name(name, mapset), (int) old_min, (int) old_max);    return 0;}",2,"cwe119,cwe120"
"TIFFReadRGBAStrip(TIFF* tif, uint32 row, uint32 * raster ){    char temsg[1024] = """";    TIFFRGBAImage img;    int tok;    uint32trowsperstrip, rows_to_read;    if( TIFFIsTiled( tif ) )    {ttTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),                  ""Can't use TIFFReadRGBAStrip() with tiled file."");treturn (0);    }        TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);    if( (row % rowsperstrip) != 0 )    {ttTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif),tttt""Row passed to TIFFReadRGBAStrip() must be first in a strip."");ttreturn (0);    }    if (TIFFRGBAImageOK(tif, emsg) && TIFFRGBAImageBegin(&img, tif, 0, emsg)) {        img.row_offset = row;        img.col_offset = 0;        if( row + rowsperstrip > img.height )            rows_to_read = img.height - row;        else            rows_to_read = rowsperstrip;        tok = TIFFRGBAImageGet(&img, raster, img.width, rows_to_read );        tTIFFRGBAImageEnd(&img);    } else {ttTIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), ""%s"", emsg);ttok = 0;    }        return (ok);}",2,"cwe119,cwe120"
"rinoo_socket_readb(t_socket *socket, t_buffer *buffer){tssize_t res;tif (buffer_isfull(buffer) && buffer_extend(buffer, buffer_size(buffer)) != 0) {ttreturn -1;t}tres = socket->class->read(socket,tttt  buffer_ptr(buffer) + buffer_size(buffer),tttt  buffer_msize(buffer) - buffer_size(buffer));tif (res <= 0) {ttreturn -1;t}tbuffer_setsize(buffer, buffer_size(buffer) + res);treturn res;}",2,"cwe120,cweother"
"get_deviation(char* a, char* b){tsize_t len_a = strlen(a);tsize_t len_b = strlen(b);tint m = len_a + 1;tint n = len_b + 1;tint d[m][n];ttfor (int i = 0; i < m; i++)ttd[i][0] = i;tttfor (int i = 0; i < n; i++)ttd[0][i] = i;ttint cand_size = len_a;tCandidate** candidates = (Candidate**)malloc(cand_size * sizeof(Candidate*));;tfor (int i = 0; i < cand_size; i++)tttcandidates[i] = new Candidate((char*)""NULL"", numeric_limits<int>::max());ttfor (unsigned int j = 1; j < len_b + 1; j++)ttfor (unsigned int i = 1; i < len_a + 1; i++)tttif (a[i-1] == b[j-1])ttttd[i][j] = d[i-1][j-1];tttelsettttd[i][j] = minim(d[i-1][j], d[i][j-1], d[i-1][j-1]) + 1;tttttfor (unsigned int i = 1; i < len_a+1; i++) {ttCandidate* cand = candidates[i-1];ttcand->set_dist(d[i][len_b]);ttcand->set_word(b);ttcand->set_nr_words(1);ttcand->set_freq(dictionary->get_frequency(b));t}ttreturn candidates;}",2,"cwe120,cweother"
"virtfn_add(struct pci_dev *dev, int id, int reset){tint i;tint rc = -ENOMEM;tu64 size;tchar buf[VIRTFN_ID_LEN];tstruct pci_dev *virtfn;tstruct resource *res;tstruct pci_sriov *iov = dev->sriov;tstruct pci_bus *bus;tmutex_lock(&iov->dev->sriov->lock);tbus = virtfn_add_bus(dev->bus, pci_iov_virtfn_bus(dev, id));tif (!bus)ttgoto failed;tvirtfn = pci_alloc_dev(bus);tif (!virtfn)ttgoto failed0;tvirtfn->devfn = pci_iov_virtfn_devfn(dev, id);tvirtfn->vendor = dev->vendor;tpci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_DID, &virtfn->device);tpci_setup_device(virtfn);tvirtfn->dev.parent = dev->dev.parent;tvirtfn->physfn = pci_dev_get(dev);tvirtfn->is_virtfn = 1;tvirtfn->multifunction = 0;tfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {ttres = &dev->resource[i + PCI_IOV_RESOURCES];ttif (!res->parent)tttcontinue;ttvirtfn->resource[i].name = pci_name(virtfn);ttvirtfn->resource[i].flags = res->flags;ttsize = pci_iov_resource_size(dev, i + PCI_IOV_RESOURCES);ttvirtfn->resource[i].start = res->start + size * id;ttvirtfn->resource[i].end = virtfn->resource[i].start + size - 1;ttrc = request_resource(res, &virtfn->resource[i]);ttBUG_ON(rc);t}tif (reset)tt__pci_reset_function(virtfn);tpci_device_add(virtfn, virtfn->bus);tmutex_unlock(&iov->dev->sriov->lock);tsprintf(buf, ""virtfn%u"", id);trc = sysfs_create_link(&dev->dev.kobj, &virtfn->dev.kobj, buf);tif (rc)ttgoto failed1;trc = sysfs_create_link(&virtfn->dev.kobj, &dev->dev.kobj, ""physfn"");tif (rc)ttgoto failed2;tkobject_uevent(&virtfn->dev.kobj, KOBJ_CHANGE);tpci_bus_add_device(virtfn);treturn 0;failed2:tsysfs_remove_link(&dev->dev.kobj, buf);failed1:tpci_dev_put(dev);tmutex_lock(&iov->dev->sriov->lock);tpci_stop_and_remove_bus_device(virtfn);failed0:tvirtfn_remove_bus(dev->bus, bus);failed:tmutex_unlock(&iov->dev->sriov->lock);treturn rc;}",2,"cwe119,cwe120"
"uild_zonelists_node(pg_data_t *pgdat, struct zonelist *zonelist,ttttint nr_zones){tstruct zone *zone;tenum zone_type zone_type = MAX_NR_ZONES;tdo {ttzone_type--;ttzone = pgdat->node_zones + zone_type;ttif (populated_zone(zone)) {tttzoneref_set_zone(zone,tttt&zonelist->_zonerefs[nr_zones++]);tttcheck_highest_zone(zone_type);tt}t} while (zone_type);treturn nr_zones;}",2,"cwe119,cwe120"
"hour_of_year(int vdate, int vtime){  int year, month, day, houroy;  int hour, minute, second;  cdiDecodeDate(vdate, &year, &month, &day);  cdiDecodeTime(vtime, &hour, &minute, &second);        if ( month >= 1 && month <= 12 && day >= 1 && day <=31 && hour >= 0 && hour < 24 )    houroy = ((month-1)*31 + day - 1)*25 + hour + 1;  else    houroy = 0;  if ( houroy < 0 || houroy >= MAX_HOUR )    {      char vdatestr[32], vtimestr[32];      date2str(vdate, vdatestr, sizeof(vdatestr));      time2str(vtime, vtimestr, sizeof(vtimestr));      cdoAbort(""Hour of year %d out of range (%s %s)!"", houroy, vdatestr, vtimestr);    }  return (houroy);}",2,"cwe119,cwe120"
"gn_atem_sms_handle(){tgn_errorterror;tcharttbuffer[MAX_LINE_LENGTH];tdata.sms->memory_type = SMSType;tdata.sms->number = SMSNumber;terror = gn_sms_get(&data, sm);tswitch (error) {tcase GN_ERR_NONE:ttgn_atem_sms_print(buffer, data.sms, INTERACT_MODE);ttgn_atem_string_out(buffer);ttbreak;tdefault:ttgsprintf(buffer, MAX_LINE_LENGTH, _(""rNo message under number %dr""), SMSNumber);ttgn_atem_string_out(buffer);ttbreak;t}treturn;}",2,"cwe119,cwe120"
"rm_unwanted_fn(unsigned logopt, const char *file, const struct stat *st, int when, void *arg){tdev_t dev = *(dev_t *) arg;tchar buf[MAX_ERR_BUF];tstruct stat newst;tif (!st)ttreturn 0;tif (when == 0) {ttif (st->st_dev != dev)tttreturn 0;ttreturn 1;t}tif (lstat(file, &newst)) {ttcrit(logopt, ""unable to stat file, possible race condition"");ttreturn 0;t}tif (newst.st_dev != dev) {ttcrit(logopt, ""file %s has the wrong device, possible race condition"",tt     file);ttreturn 0;t}tif (S_ISDIR(newst.st_mode)) {ttdebug(logopt, ""removing directory %s"", file);ttif (rmdir(file)) {tttchar *estr = strerror_r(errno, buf, MAX_ERR_BUF);tttwarn(logopt,ttt      ""unable to remove directory %s: %s"", file, estr);tttreturn 0;tt}t} else if (S_ISREG(newst.st_mode)) {ttcrit(logopt, ""attempting to remove files from a mounted ""tt     ""directory. file %s"", file);ttreturn 0;t} else if (S_ISLNK(newst.st_mode)) {ttdebug(logopt, ""removing symlink %s"", file);ttunlink(file);t}treturn 1;}",2,"cwe119,cwe120"
"hexchat_emit_print (hexchat_plugin *ph, const char *event_name, ...){tva_list args;t tchar *argv[4] = {NULL, NULL, NULL, NULL};tint i = 0;tva_start (args, event_name);twhile (1)t{ttargv[i] = va_arg (args, char *);ttif (!argv[i])tttbreak;tti++;ttif (i >= 4)tttbreak;t}ti = text_emit_by_name ((char *)event_name, ph->context, (time_t) 0,tttttt   argv[0], argv[1], argv[2], argv[3]);tva_end (args);treturn i;}",2,"cwe119,cwe120"
"print_align(blist, style)struct blocks_list *blist;int style;{   int np, seq;   int nseq;   struct blocks_list *bcur, *bfirst;   struct seqseq *sseq;       nseq = blist->nseq;   sseq = (struct seqseq *) malloc (nseq * sizeof(struct seqseq));                 bfirst = blist->next;   if (bfirst->block == NULL) return(0);       for (seq = 0; seq < nseq; seq++)   {      sseq[seq].seq = seq;      sseq[seq].pos = 0;   }   format_seqs(sseq, bfirst->block);   np = 1;   bcur = bfirst->next;   while (bcur != NULL && bcur->block != NULL)   {             if (bcur->block->num_sequences == blist->nseq)      {                    format_seqs(sseq, bcur->block);      }      else      {         printf(""ERROR in block %s: %d sequences found but "",ttbcur->block->number, bcur->block->num_sequences);         printf("" %d expected"", blist->nseq);      }      np++;      bcur = bcur->next;   }     if (style < 2)      printf(""%d sequences are included in %d blocks"",            blist->nseq, blist->nblock);   if (style == 1)      posfai_seqs(sseq, blist);   else if (style == 2) fasta_seqs(sseq, blist);   else if (style == 3) msf_seqs(sseq, blist);   else if (style == 4) giant(sseq, blist);   else if (style == 5) stockholm_seqs(sseq, blist, 1);   else if (style == 6) stockholm_seqs(sseq, blist, 0);   else                 short_seqs(sseq, blist);   return(np);}",2,"cwe120,cweother"
"mgmt_cancel_bonding(int index, bdaddr_t *bdaddr){tchar buf[MGMT_HDR_SIZE + sizeof(struct mgmt_addr_info)];tstruct mgmt_hdr *hdr = (void *) buf;tstruct mgmt_addr_info *cp = (void *) &buf[sizeof(*hdr)];tchar addr[18];tba2str(bdaddr, addr);tDBG(""hci%d bdaddr %s"", index, addr);tmemset(buf, 0, sizeof(buf));thdr->opcode = htobs(MGMT_OP_CANCEL_PAIR_DEVICE);thdr->len = htobs(sizeof(*cp));thdr->index = htobs(index);tbacpy(&cp->bdaddr, bdaddr);tif (write(mgmt_sock, &buf, sizeof(buf)) < 0)ttreturn -errno;treturn 0;}",2,"cwe119,cwe120"
"php_getimagetype(IMAGE_STREAM * stream){tchar filetype[12];tif((stream_read(stream, filetype, 3)) != 3) {ttIMAGE_error = ""Read error"";ttreturn IMAGE_FILETYPE_ERROR;t} tif (!memcmp(filetype, _signature_gif, 3)) {ttreturn IMAGE_FILETYPE_GIF;t} else if (!memcmp(filetype, _signature_jpg, 3)) {ttreturn IMAGE_FILETYPE_JPEG;t} else if (!memcmp(filetype, _signature_png, 3)) {ttif (stream_read(stream, filetype+3, 5) != 5) {tttIMAGE_error = ""Read error"";tttreturn IMAGE_FILETYPE_ERROR;tt}ttif (!memcmp(filetype, _signature_png, 8)) {tttreturn IMAGE_FILETYPE_PNG;tt} else {tttIMAGE_error = ""PNG file corrupted by ASCII conversion"";tttreturn IMAGE_FILETYPE_ERROR;tt} t} else if (!memcmp(filetype, _signature_bmp, 2)) {ttreturn IMAGE_FILETYPE_BMP;t t}tif (stream_read(stream, filetype+3, 1) != 1) {ttIMAGE_error = ""Read error"";ttreturn IMAGE_FILETYPE_ERROR;t} tif (!memcmp(filetype, _signature_tif_ii, 4)) {ttreturn IMAGE_FILETYPE_TIFF_II;t} elsetif (!memcmp(filetype, _signature_tif_mm, 4)) {ttreturn IMAGE_FILETYPE_TIFF_MM;t}t t#if 0tif (stream_read(stream, filetype+4, 8) != 8) {ttIMAGE_error = ""Read error"";ttreturn IMAGE_FILETYPE_ERROR;t}tt    tif (!memcmp(filetype, _signature_jp2, 12)) {ttreturn IMAGE_FILETYPE_JP2;t} tif (php_get_wbmp(stream, NULL, 1)) {ttreturn IMAGE_FILETYPE_WBMP;t}tif (php_get_xbm(stream, NULL)) {ttreturn IMAGE_FILETYPE_XBM;t}t#endifttreturn IMAGE_FILETYPE_UNKNOWN;}",2,"cwe119,cwe120"
"pseudo_command(char *input){        int i;tHIST_ENTRY *entry;tint idx, found;tchar *p;        clean_line(input);                 if (STREQ(input, ""h"") || STRNEQ(input, ""hi"")) {                dump_history();                pc->command_line[0] = NULLCHAR;                return TRUE;        }        if (STREQ(input, ""r"") || STREQ(input, ""!!"")) {                if (!history_offset)                        error(FATAL, ""no commands entered!"");                entry = history_get(history_offset);                strcpy(input, entry->line);                fprintf(fp, ""%s%s"", pc->prompt, input);                return TRUE;        }        if ((input[0] == 'r') && decimal(&input[1], 0)) {                if (!history_offset)                        error(FATAL, ""no commands entered!"");                p = &input[1];                goto rerun;        }tif (STRNEQ(input, ""r "")) {                if (!history_offset)                        error(FATAL, ""no commands entered!"");ttp = first_nonspace(&input[1]);rerun:ttif (decimal(p, 0)) {tttidx = atoi(p);tttif (idx == 0)ttttgoto invalid_repeat_request;tttif (idx > history_offset) tttterror(FATAL, ""command %d not entered yet!"",tttttidx);t                tentry = history_get(idx);               ttstrcpy(input, entry->line);                tfprintf(fp, ""%s%s"", pc->prompt, input);                treturn TRUE;tt} ttidx = -1;ttfound = FALSE;        tfor (i = history_offset; i > 0; i--) {                tentry = history_get(i);tttif (STRNEQ(entry->line, p)) {ttttfound = TRUE;ttttbreak;ttt}        t}ttif (found) {tttstrcpy(input, entry->line);tttfprintf(fp, ""%s%s"", pc->prompt, input);tttreturn TRUE;tt}invalid_repeat_request:ttfprintf(fp, ""invalid repeat request: %s"", input);ttstrcpy(input, """");ttreturn TRUE;t}treturn FALSE;}",2,"cwe120,cweother"
"tunio_open(char *dev) {tstruct ifreq ifr;tint fd, r;tlogmsg(LOGGER_DEBUG, ""Opening device ..."");tfd = open(""/dev/net/tun"", O_RDWR);tif(fd == -1) {ttlogmsg(LOGGER_CRIT, ""Could not open tun device: %s"", strerror(errno));ttreturn -1;t}tlogmsg(LOGGER_DEBUG, ""Setting up ifreq ..."");tmemset(&ifr, 0, sizeof(ifr));tifr.ifr_flags = IFF_TUN | IFF_NO_PI;tif(dev) if(*dev) strncpy(ifr.ifr_name, dev, IFNAMSIZ);tlogmsg(LOGGER_DEBUG, ""Setting options ..."");tr = ioctl(fd, TUNSETIFF, (void *)&ifr);tif(r < 0) { close(fd); return -1; }tif(dev) strcpy(dev, ifr.ifr_name);treturn fd;}",2,"cwe120,cweother"
"gf_log_init (const char *file){        if (!file){                fprintf (stderr, ""ERROR: no filename specified"");                return -1;        }        if (strcmp (file, ""-"") == 0) {                gf_log_logfile = stderr;                return 0;        }        filename = gf_strdup (file);        if (!filename) {                fprintf (stderr, ""ERROR: updating log-filename failed: %s"",                         strerror (errno));                return -1;        }        logfile = fopen (file, ""a"");        if (!logfile){                fprintf (stderr, ""ERROR: failed to open logfile ""%s"" (%s)"",                         file, strerror (errno));                return -1;        }        gf_log_logfile = logfile;        return 0;}",2,"cwe469,cweother"
"ata_sff_data_xfer(struct ata_device *dev, unsigned char *buf,ttt       unsigned int buflen, int rw){tstruct ata_port *ap = dev->link->ap;tvoid __iomem *data_addr = ap->ioaddr.data_addr;tunsigned int words = buflen >> 1;t tif (rw == READ)ttioread16_rep(data_addr, buf, words);telsettiowrite16_rep(data_addr, buf, words);t tif (unlikely(buflen & 0x01)) {ttunsigned char pad[2] = { };tt ttbuf += buflen - 1;tt ttif (rw == READ) {tttioread16_rep(data_addr, pad, 1);ttt*buf = pad[0];tt} else {tttpad[0] = *buf;tttiowrite16_rep(data_addr, pad, 1);tt}ttwords++;t}treturn words << 1;}",2,"cwe119,cwe120"
"nfs4_schedule_state_manager(struct nfs_client *clp){tstruct task_struct *task;tchar buf[INET6_ADDRSTRLEN + sizeof(""-manager"") + 1];tif (test_and_set_bit(NFS4CLNT_MANAGER_RUNNING, &clp->cl_state) != 0)ttreturn;t__module_get(THIS_MODULE);tatomic_inc(&clp->cl_count);t trcu_read_lock();tsnprintf(buf, sizeof(buf), ""%s-manager"",tttrpc_peeraddr2str(clp->cl_rpcclient, RPC_DISPLAY_ADDR));trcu_read_unlock();ttask = kthread_run(nfs4_run_state_manager, clp, ""%s"", buf);tif (IS_ERR(task)) {ttprintk(KERN_ERR ""%s: kthread_run: %ld"",ttt__func__, PTR_ERR(task));ttnfs4_clear_state_manager_bit(clp);ttnfs_put_client(clp);ttmodule_put(THIS_MODULE);t}}",2,"cwe119,cwe120"
"register_proxy_object(struct serial_proxy *prx){tstruct serial_adapter *adapter = prx->adapter;tchar path[MAX_PATH_LENGTH + 1];tsnprintf(path, MAX_PATH_LENGTH, ""%s/proxy%d"",tttadapter_get_path(adapter->btd_adapter), sk_counter++);tif (!g_dbus_register_interface(adapter->conn, path,tttttSERIAL_PROXY_INTERFACE,tttttproxy_methods, NULL, NULL,tttttprx, proxy_path_unregister)) {tterror(""D-Bus failed to register %s path"", path);ttreturn -1;t}tprx->path = g_strdup(path);tadapter->proxies = g_slist_append(adapter->proxies, prx);tDBG(""Registered proxy: %s"", path);treturn 0;}",2,"cwe119,cwe120"
"test_family_compat(void){    hid_t       file = (-1), fapl;    hid_t       dset;    char        dname[]=""dataset"";    char        filename[1024];    char        pathname[1024], pathname_individual[1024];    char        newname[1024], newname_individual[1024];    int         counter = 0;    TESTING(""FAMILY file driver backward compatibility"");         fapl = h5_fileaccess();    if(H5Pset_fapl_family(fapl, (hsize_t)FAMILY_SIZE2, H5P_DEFAULT) < 0)        TEST_ERROR;    h5_fixname(COMPAT_BASENAME, fapl, filename, sizeof filename);    h5_fixname(FILENAME[3], fapl, newname, sizeof newname);    pathname[0] = '0';    HDstrcat(pathname, filename);         HDsnprintf(newname_individual, sizeof(newname_individual), newname, counter);    HDsnprintf(pathname_individual, sizeof(pathname_individual), pathname, counter);    while(h5_make_local_copy(pathname_individual, newname_individual) >= 0) {        counter++;        HDsnprintf(newname_individual, sizeof(newname_individual), newname, counter);        HDsnprintf(pathname_individual, sizeof(pathname_individual), pathname, counter);    }         if((file = H5Fopen(newname, H5F_ACC_RDWR, fapl)) < 0)        TEST_ERROR;    if((dset = H5Dopen2(file, dname, H5P_DEFAULT)) < 0)        TEST_ERROR;    if(H5Dclose(dset) < 0)        TEST_ERROR;    if(H5Fclose(file) < 0)        TEST_ERROR;         if((file = H5Fopen(newname, H5F_ACC_RDWR, fapl)) < 0)        TEST_ERROR;    if((dset = H5Dopen2(file, dname, H5P_DEFAULT)) < 0)        TEST_ERROR;    if(H5Dclose(dset) < 0)        TEST_ERROR;    if(H5Fclose(file) < 0)        TEST_ERROR;    h5_cleanup(FILENAME, fapl);    PASSED();    return 0;error:    H5E_BEGIN_TRY {        H5Fclose(file);        H5Pclose(fapl);    } H5E_END_TRY;    return -1;}",2,"cwe119,cwe120"
"fileio_debug_dump(fileio_prop_t *prop, int write_file){  FILE *f;  char buf[100];  const char *type;  fileio_prop_t *ptr;    printf(""fileio: dumping file properties..."");  for (ptr = prop;ptr != NULL;ptr = ptr->next)    {      switch (ptr->type)        {        case FILEIO_TYPE_UNKNOWN:  type = ""(UNKNOWN)""; break;        case FILEIO_TYPE_COM:      type = ""(COM)""; break;        case FILEIO_TYPE_BAS:      type = ""(BASIC)""; break;        case FILEIO_TYPE_PROT_BAS: type = ""(BASIC*)""; break;        default:                   type = ""(?)""; break;        }            printf(""fileio: %-14s %-10s - "", ptr->name, type);      printf(""%04x-%04lx/"",  ptr->load_addr, ptr->load_addr + ptr->size + 1);      if (ptr->autostart)        printf(""%04x"", ptr->start_addr);      else        printf("" -  "");      printf("" : %5ld bytes [%s]"", ptr->size, ptr->filetype);      if (write_file)        {          sprintf(buf, "".out-%s"", ptr->name);          f = fopen(buf, ""wb"");          if (f)            {              while (ptr->size > 0)                {                  ptr->data++;                  ptr->size--;                  if (ptr->size == 0)                    break;                  fwrite(ptr->data, 1, 128, f);                  ptr->data += 128;                  ptr->size -= 128;                }              fclose(f);              printf("" -> '%s'"", buf);            }        }      printf("""");    }  printf(""fileio: done."");}",3,"cwe119,cwe120,cweother"
"_elm_theme_clear(Elm_Theme *th){   const char *p;   EINA_LIST_FREE(th->themes, p)      eina_stringshare_del(p);   EINA_LIST_FREE(th->overlay, p)      eina_stringshare_del(p);   EINA_LIST_FREE(th->extension, p)      eina_stringshare_del(p);   if (th->cache)     {        eina_hash_free(th->cache);        th->cache = NULL;     }   if (th->cache_data)     {        eina_hash_free(th->cache_data);        th->cache_data = NULL;     }   if (th->theme)     {        eina_stringshare_del(th->theme);        th->theme = NULL;     }   if (th->ref_theme)     {        th->ref_theme->referrers =           eina_list_remove(th->ref_theme->referrers, th);        elm_theme_free(th->ref_theme);        th->ref_theme = NULL;     }}",3,"cwe119,cwe120,cweother"
"jtagmkI_setparm(PROGRAMMER * pgm, unsigned char parm,ttt    unsigned char value){  unsigned char buf[3], resp[2];  if (verbose >= 2)    fprintf(stderr, ""%s: jtagmkI_setparm()"", progname);  buf[0] = CMD_SET_PARAM;  buf[1] = parm;  buf[2] = value;  if (verbose >= 2)    fprintf(stderr, ""%s: jtagmkI_setparm(): ""t    ""Sending set parameter command (parm 0x%02x): "",t    progname, parm);  jtagmkI_send(pgm, buf, 3);  jtagmkI_recv(pgm, resp, 2);  if (resp[0] != RESP_OK) {    if (verbose >= 2)      putc('', stderr);    fprintf(stderr,t    ""%s: jtagmkI_setparm(): ""t    ""timeout/error communicating with programmer (resp %c)"",t    progname, resp[0]);    return -1;  } else {    if (verbose == 2)      fprintf(stderr, ""OK"");  }  return 0;}",2,"cwe119,cwe120"
"nautilus_get_xdg_dir (const char *type){tint i;tif (cached_xdg_dirs == NULL) {ttupdate_xdg_dir_cache ();t}tfor (i = 0 ; cached_xdg_dirs != NULL && cached_xdg_dirs[i].type != NULL; i++) {ttif (strcmp (cached_xdg_dirs[i].type, type) == 0) {tttreturn g_strdup (cached_xdg_dirs[i].path);tt}t}tif (strcmp (""DESKTOP"", type) == 0) {ttreturn g_build_filename (g_get_home_dir (), DESKTOP_DIRECTORY_NAME, NULL);t}tif (strcmp (""TEMPLATES"", type) == 0) {ttreturn g_build_filename (g_get_home_dir (), ""Templates"", NULL);t}ttreturn g_strdup (g_get_home_dir ());}",2,"cwe469,cweother"
"is_exe(char *filename){tFILE *file;tchar buf[4];tchar header[] = {0x00, 0x00, 0x03, 0xf3};t tif (strstr(filename, "".exe"") || strstr(filename, "".EXE"")t    || strstr(filename, "".prg"") || strstr(filename, "".PRG""))ttreturn 1;t tif (strchr(filename, '.'))ttreturn 0;tfile = fopen(filename, ""rb"");tif (!file)ttreturn 0;tif (fread(buf, 1, 4, file) < 4) {ttfclose(file);ttreturn 0;t}tfclose(file);t treturn memcmp(buf, header, 4) == 0;}",3,"cwe119,cwe120,cweother"
"test_util_set_env_var_in_sl(void *ptr){     const char *base_env_vars_string =    ""PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/bin""    ""HOME=/home/foozer""    ""TERM=xterm""    ""SHELL=/bin/ksh""    ""USER=foozer""    ""LOGNAME=foozer""    ""USERNAME=foozer""    ""LANG=en_US.utf8""    ;  const char *new_env_vars_string =    ""TERM=putty""    ""DISPLAY=:18.0""    ;  const char *expected_resulting_env_vars_string =    ""PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/bin""    ""HOME=/home/foozer""    ""TERM=putty""    ""SHELL=/bin/ksh""    ""USER=foozer""    ""LOGNAME=foozer""    ""USERNAME=foozer""    ""LANG=en_US.utf8""    ""DISPLAY=:18.0""    ;  smartlist_t *merged_env_vars =    smartlist_new_from_text_lines(base_env_vars_string);  smartlist_t *new_env_vars =    smartlist_new_from_text_lines(new_env_vars_string);  smartlist_t *expected_resulting_env_vars =    smartlist_new_from_text_lines(expected_resulting_env_vars_string);     (void)ptr;  SMARTLIST_FOREACH(new_env_vars, char *, env_var,                    set_environment_variable_in_smartlist(merged_env_vars,                                                          env_var,                                                          _tor_free,                                                          1));  smartlist_sort_strings(merged_env_vars);  smartlist_sort_strings(expected_resulting_env_vars);  tt_want_int_op(smartlist_len(merged_env_vars), ==,                 smartlist_len(expected_resulting_env_vars));  {    int len = smartlist_len(merged_env_vars);    int i;    if (smartlist_len(expected_resulting_env_vars) < len) {      len = smartlist_len(expected_resulting_env_vars);    }    for (i = 0; i < len; ++i) {      tt_want_str_op(smartlist_get(merged_env_vars, i), ==,                     smartlist_get(expected_resulting_env_vars, i));    }  }     SMARTLIST_FOREACH(merged_env_vars, char *, x, tor_free(x));  smartlist_free(merged_env_vars);  smartlist_free(new_env_vars);  SMARTLIST_FOREACH(expected_resulting_env_vars, char *, x, tor_free(x));  smartlist_free(expected_resulting_env_vars);}",2,"cwe120,cweother"
"mount_autodir( char *path, pid_t pgrp,ttpid_t pid, int minp, int maxp){tint pipefd[ 2 ];tchar options[ 128 ];tchar our_name[ 128 ];tchar dot_path[ PATH_MAX+1 ];tstruct stat st;  tif( pipe( pipefd ) < 0 )ttmsglog( MSG_FATAL|LOG_ERRNO, ""mount_autodir: pipe"" );  tsnprintf( options, sizeof(options),tt""fd=%d,pgrp=%u,minproto=%d,maxproto=%d"",ttpipefd[1], (unsigned)pgrp, minp, maxp );tsnprintf( our_name, sizeof(our_name),tt""%s(pid%u)"", autodir_name(), (unsigned) pid);tif( mount( our_name, path, ""autofs"", MS_MGC_VAL, options ) )t{ttclose( pipefd[ 0 ] );ttclose( pipefd[ 1 ] );ttmsglog( MSG_FATAL|LOG_ERRNO,tttt""incorrect autofs module loaded? mount %s"", path );t}  tautodir.mounted = 1;tclose( pipefd[ 1 ] );t tautodir.k_pipe = pipefd[ 0 ];tif( fcntl( autodir.k_pipe, F_SETFL, O_NONBLOCK ) )ttmsglog( MSG_FATAL|LOG_ERRNO, ""mount_autodir: fcntl"" );tsnprintf( dot_path, sizeof(dot_path), ""%s/."", path );tautodir.ioctlfd = open( dot_path, O_RDONLY );  tif( autodir.ioctlfd < 0 )ttmsglog( MSG_FATAL|LOG_ERRNO, ""mount_autodir: open %s"", dot_path );tif( fstat( autodir.ioctlfd, &st ) < 0 )ttmsglog( MSG_FATAL|LOG_ERRNO, ""mount_autodir: fstat %s"", dot_path );tautodir.dev = st.st_dev;}",3,"cwe119,cwe120,cweother"
"main(int argc, char **argv){tchar cwd[1024];tint i, fd, err;tgetcwd(cwd, 1024);tfor (i = 1; i < argc; i ++) {ttconst char *arg = argv[i];ttif (!strncmp(arg, ""--chunk-db="", 11)) {tttarg += 11;tttif (!strncmp(arg, ""ro,"", 3))tttterr = add_chunkdb(CHUNKDB_RO, arg + 3);tttelse if (!strncmp(arg, ""rw,"", 3))tttterr = add_chunkdb(CHUNKDB_RW, arg + 3);tttelse {ttttfprintf(stderr, ""Invalid db spec: %s"", arg);ttttexit(-1);ttt}tt} else if (!strncmp(arg, ""--log="", 6)) {tttarg += 6;tttif (zunkfs_log_fd) {ttttfprintf(stderr, ""Log file specified more ""tttttt""than once"");ttttexit(-1);ttt}tttif (arg[1] == ',') {ttttif (!strchr(""EWT"", arg[0])) {tttttfprintf(stderr, ""Invalid log level."");tttttexit(-1);tttt}ttttzunkfs_log_level = arg[0];ttttarg += 2;ttt}tttif (!strcmp(arg, ""stderr""))ttttzunkfs_log_fd = stderr;tttelse if (!strcmp(arg, ""stdout""))ttttzunkfs_log_fd = stdout;tttelsettttzunkfs_log_fd = fopen(arg, ""w"");tt} else if (!strncmp(arg, ""--car"", 5)) {        fprintf(stderr, ""small ding on the front bumper... hardly visible."");        exit(-1);    } else {tttfprintf(stderr, ""Invalid option: %s"", arg);tttexit(-1);tt}t}tfd = open(SUPER_SECRET_FILE, O_RDONLY);tif (fd < 0) {ttfprintf(stderr, ""Can't open %s/%s: %s"", cwd,ttttSUPER_SECRET_FILE, strerror(errno));ttexit(-2);t}tfor (;;) {ttstruct disk_dentry dentry;ttint err = read_dentry(fd, &dentry);ttif (err < 0) {tttfprintf(stderr, ""read_dentry: %s"", strerror(errno));tttexit(-3);tt}ttif (!err)tttbreak;ttprintf(""%s %s 0%0o %""PRIu64"" %u %u %s"", ttttdigest_string(dentry.digest),ttttdigest_string(dentry.secret_digest),ttttdentry.mode,ttttdentry.size,ttttdentry.ctime,ttttdentry.mtime,ttttdentry.name);t}tclose(fd);treturn 0;}",3,"cwe119,cwe120,cweother"
"append_host_specific_args(const char *victim, const char *map, GHashTable * params, char **arg_list){    char *name = NULL;    int last = 0, lpc = 0, max = 0;    if (map == NULL) {                 crm_debug(""Using default arg map: port=uname"");        append_const_arg(""port"", victim, arg_list);        return;    }    max = strlen(map);    crm_debug(""Processing arg map: %s"", map);    for (; lpc < max + 1; lpc++) {        if (isalpha(map[lpc])) {                     } else if (map[lpc] == '=' || map[lpc] == ':') {            free(name);            name = calloc(1, 1 + lpc - last);            memcpy(name, map + last, lpc - last);            crm_debug(""Got name: %s"", name);            last = lpc + 1;        } else if (map[lpc] == 0 || map[lpc] == ',' || isspace(map[lpc])) {            char *param = NULL;            const char *value = NULL;            param = calloc(1, 1 + lpc - last);            memcpy(param, map + last, lpc - last);            last = lpc + 1;            crm_debug(""Got key: %s"", param);            if (name == NULL) {                crm_err(""Misparsed '%s', found '%s' without a name"", map, param);                free(param);                continue;            }            if (safe_str_eq(param, ""uname"")) {                value = victim;            } else {                char *key = crm_meta_name(param);                value = g_hash_table_lookup(params, key);                free(key);            }            if (value) {                crm_debug(""Setting '%s'='%s' (%s) for %s"", name, value, param, victim);                append_const_arg(name, value, arg_list);            } else {                crm_err(""No node attribute '%s' for '%s'"", name, victim);            }            free(name);            name = NULL;            free(param);            if (map[lpc] == 0) {                break;            }        } else if (isspace(map[lpc])) {            last = lpc;        }    }    free(name);}",2,"cwe119,cwe120"
"Gloves_off(){    long oldprop =tu.uprops[objects[uarmg->otyp].oc_oprop].extrinsic & ~WORN_GLOVES;    takeoff_mask &= ~W_ARMG;    switch(uarmg->otyp) {tcase LEATHER_GLOVES:t    break;tcase GAUNTLETS_OF_FUMBLING:t    if (!oldprop && !(HFumbling & ~TIMEOUT))ttHFumbling = EFumbling = 0;t    break;tcase GAUNTLETS_OF_POWER:t    makeknown(uarmg->otyp);t    flags.botl = 1;  t    break;tcase GAUNTLETS_OF_DEXTERITY:t    if (!cancelled_don) adj_abon(uarmg, -uarmg->spe);t    break;tdefault: impossible(unknown_type, c_gloves, uarmg->otyp);    }    setworn((struct obj *)0, W_ARMG);    cancelled_don = FALSE;    (void) encumber_msg();tt          if (uwep && uwep->otyp == CORPSE &&tttouch_petrifies(&mons[uwep->corpsenm])) {tchar kbuf[BUFSZ];tYou(""wield the %s in your bare %s."",t    corpse_xname(uwep, TRUE), makeplural(body_part(HAND)));tStrcpy(kbuf, an(corpse_xname(uwep, TRUE)));tinstapetrify(kbuf);tuwepgone();       }         if (u.twoweap && uswapwep && uswapwep->otyp == CORPSE &&ttouch_petrifies(&mons[uswapwep->corpsenm])) {tchar kbuf[BUFSZ];tYou(""wield the %s in your bare %s."",t    corpse_xname(uswapwep, TRUE), body_part(HAND));tStrcpy(kbuf, an(corpse_xname(uswapwep, TRUE)));tinstapetrify(kbuf);tuswapwepgone();t     }    return 0;}",2,"cwe119,cwe120"
"pdf14_push_transparency_group(pdf14_ctxt*ctx, gs_int_rect *rect,                              bool isolated, bool knockout,                              byte alpha, byte shape,                              gs_blend_mode_t blend_mode, bool idle,                              uint mask_id, int numcomps){    pdf14_buf *tos = ctx->stack;    pdf14_buf *buf, *backdrop;    bool has_shape, has_tags;    if_debug1m('v', ctx->memory,               ""[v]pdf14_push_transparency_group, idle = %d"", idle);         if (knockout)        isolated = true;    has_shape = tos->has_shape || tos->knockout;    has_tags = tos->has_tags;              buf = pdf14_buf_new(rect, has_tags, !isolated, has_shape, idle,                        numcomps+1, ctx->memory);    if_debug4m('v', ctx->memory,               ""[v]base buf: %d x %d, %d color channels, %d planes"",               buf->rect.q.x, buf->rect.q.y, buf->n_chan, buf->n_planes);    if (buf == NULL)        return_error(gs_error_VMerror);    buf->isolated = isolated;    buf->knockout = knockout;    buf->alpha = alpha;    buf->shape = shape;    buf->blend_mode = blend_mode;    buf->mask_id = mask_id;    buf->mask_stack = ctx->mask_stack;      ctx->mask_stack = NULL;      buf->saved = tos;    ctx->stack = buf;    if (buf->data == NULL)        return 0;    if (idle)        return 0;    backdrop = pdf14_find_backdrop_buf(ctx);    if (backdrop == NULL)        memset(buf->data, 0, buf->planestride * (buf->n_chan +                                                 (buf->has_shape ? 1 : 0)));    else        pdf14_preserve_backdrop(buf, tos, has_shape);#if RAW_DUMP         dump_raw_buffer(ctx->stack->rect.q.y-ctx->stack->rect.p.y,                ctx->stack->rowstride, ctx->stack->n_planes,                ctx->stack->planestride, ctx->stack->rowstride,                ""TransGroupPush"",ctx->stack->data);    global_index++;#endif    return 0;}",2,"cwe469,cwe476"
"drc_init(UINT8 cpunum, struct drcconfig *config)r{rtint address_bits = config->address_bits;rtint effective_address_bits = address_bits - config->lsbs_to_ignore;rtstruct drccore *drc;rrt rtdrc = malloc(sizeof(*drc));rtif (!drc)rttreturn NULL;rtmemset(drc, 0, sizeof(*drc));rrt rtdrc->pcptr        = config->pcptr;rtdrc->icountptr    = config->icountptr;rtdrc->esiptr       = config->esiptr;rtdrc->cb_reset     = config->cb_reset;rtdrc->cb_recompile = config->cb_recompile;rtdrc->cb_entrygen  = config->cb_entrygen;rtdrc->uses_fp      = config->uses_fp;rtdrc->uses_sse     = config->uses_sse;rtdrc->fpcw_curr    = fp_control[0];rrt rtdrc->cache_base = malloc(config->cache_size);rtif (!drc->cache_base)rttreturn NULL;rtdrc->cache_end = drc->cache_base + config->cache_size;rtdrc->cache_danger = drc->cache_end - 65536;rrt rtdrc->l1bits = effective_address_bits/2;rtdrc->l2bits = effective_address_bits - drc->l1bits;rtdrc->l1shift = config->lsbs_to_ignore + drc->l2bits;rtdrc->l2mask = ((1 << drc->l2bits) - 1) << config->lsbs_to_ignore;rtdrc->l2scale = 4 >> config->lsbs_to_ignore;rrt rtdrc->lookup_l1 = malloc(sizeof(*drc->lookup_l1) * (1 << drc->l1bits));rtdrc->lookup_l2_recompile = malloc(sizeof(*drc->lookup_l2_recompile) * (1 << drc->l2bits));rtif (!drc->lookup_l1 || !drc->lookup_l2_recompile)rttreturn NULL;rtmemset(drc->lookup_l1, 0, sizeof(*drc->lookup_l1) * (1 << drc->l1bits));rtmemset(drc->lookup_l2_recompile, 0, sizeof(*drc->lookup_l2_recompile) * (1 << drc->l2bits));rrt rtdrc->sequence_count_max = config->max_instructions;rtdrc->sequence_list = malloc(drc->sequence_count_max * sizeof(*drc->sequence_list));rtdrc->tentative_count_max = config->max_instructions;rtdrc->tentative_list = malloc(drc->tentative_count_max * sizeof(*drc->tentative_list));rtif (!drc->sequence_list || !drc->tentative_list)rttreturn NULL;rrt rtdrc_cache_reset(drc);rtreturn drc;r}",2,"cwe120,cweother"
"_rpc_step_complete(slurm_msg_t *msg){tstep_complete_msg_t *req = (step_complete_msg_t *)msg->data;tint               rc = SLURM_SUCCESS;tint               fd;tuid_t             req_uid;tdebug3(""Entering _rpc_step_complete"");tfd = stepd_connect(conf->spooldir, conf->node_name,ttt   req->job_id, req->job_step_id);tif (fd == -1) {tterror(""stepd_connect to %u.%u failed: %m"",tt      req->job_id, req->job_step_id);ttrc = ESLURM_INVALID_JOB_ID;ttgoto done;t}t treq_uid = g_slurm_auth_get_uid(msg->auth_cred, NULL);tif (!_slurm_authorized_user(req_uid)) {ttdebug(""step completion from uid %ld for job %u.%u"",tt      (long) req_uid, req->job_id, req->job_step_id);ttrc = ESLURM_USER_ID_MISSING;      ttgoto done2;t}trc = stepd_completion(fd, req);tif (rc == -1)ttrc = ESLURMD_JOB_NOTRUNNING;done2:tclose(fd);done:tslurm_send_rc_msg(msg, rc);treturn rc;}",2,"cwe119,cwe120"
"GSgetURLhtml(GopherObj *gs, char *ticket){     char *cp = GSgetURL(gs, ticket);     char *cp2;     int   views;     if ((cp != NULL) && (strncmp(cp, ""gopher://"", 9) == 0)) {t  if ( GSgplusInited(gs) ) {t       for (views=0; views< GSgetNumViews(gs); views++) {tt    if (!(strncasecmp(VIgetType(GSgetView(gs,views)),tttt      ""text/html"", 9))) {ttt cp = strdup(cp);ttt  ttt cp2 = strchr(cp+10, '/');ttt if (cp2 != NULL) {ttt      *(++cp2) = 'h';ttt      cp2++;ttt      if (strncmp(cp2, ""%2a"",3)==0) {tttt    tttt   cp2 = strstr(cp2, ""%20"");tttt   if (cp2 != NULL) {tttttcp2 +=3;tttttcp2 = strstr(cp2, ""%20"");tttttif (cp2 != NULL) {ttttt     cp2+=3;ttttt     *cp2 = 'h';ttttt}tttt   }ttt       } elsetttt    *cp2 = 'h';     ttt }tt     }t       }t  } t  if (strstr(cp, ""/1validate%201"") != NULL) {t       cp = strdup(cp);t       cp2 = strchr(cp+10, '/');t       if (cp2 != NULL) {tt    *(++cp2) = 'h';tt    *(++cp2) = 'h';tt    *(cp2+11) = 'h';t       }t  }t  else if (strstr(cp, ""/hhalidate%201"") != NULL) {t       cp = strdup(cp);t       cp2 = strchr(cp+10, '/');t       *(cp2+13) = 'h';t  } else if (*(GSgetPath(gs)) == '*') {t        t       ;t  }     }     return cp;}",2,"cwe120,cwe476"
"""agent_write_status (ctrl_t ctrl, const char *keyword, ...){  gpg_error_t err = 0;  va_list arg_ptr;  const char *text;  assuan_context_t ctx = ctrl->server_local->assuan_ctx;  char buf[950], *p;  size_t n;  va_start (arg_ptr, keyword);  p = buf;  n = 0;  while ( (text = va_arg (arg_ptr, const char *)) )    {      if (n)        {          *p++ = ' ';          n++;        }      for ( ; *text && n < DIM (buf)-3; n++, text++)        {          if (*text == '')            {              *p++ = '';              *p++ = 'n';            }          else if (*text == 'r')            {              *p++ = '';              *p++ = 'r';            }          else            *p++ = *text;        }    }  *p = 0;  err = assuan_write_status (ctx, keyword, buf);  va_end (arg_ptr);  return err;}""",2,"cwe119,cwe120"
"cin_decode_huffman(const unsigned char *src, int src_size, unsigned char *dst, int dst_size){    int b, huff_code = 0;    unsigned char huff_code_table[15];    unsigned char *dst_cur = dst;    unsigned char *dst_end = dst + dst_size;    const unsigned char *src_end = src + src_size;    memcpy(huff_code_table, src, 15); src += 15; src_size -= 15;    while (src < src_end) {        huff_code = *src++;        if ((huff_code >> 4) == 15) {            b = huff_code << 4;            huff_code = *src++;            *dst_cur++ = b | (huff_code >> 4);        } else            *dst_cur++ = huff_code_table[huff_code >> 4];        if (dst_cur >= dst_end)            break;        huff_code &= 15;        if (huff_code == 15) {            *dst_cur++ = *src++;        } else            *dst_cur++ = huff_code_table[huff_code];        if (dst_cur >= dst_end)            break;    }    return dst_cur - dst;}",2,"cwe119,cwe120"
"apply_termcap_settings(Console_IO_t * const mfp){         char const* term_name = getenv(""TERM"");    if (NULL != term_name) {        char    term_buff[4096];        int const ret = tgetent(term_buff, term_name);        if (1 == ret) {            get_termcap_number(""co"", &mfp->disp_width, 40, 512);            get_termcap_number(""li"", &mfp->disp_height, 16, 256);            get_termcap_string(""up"", mfp->str_up, sizeof(mfp->str_up));            get_termcap_string(""md"", mfp->str_emph, sizeof(mfp->str_emph));            get_termcap_string(""me"", mfp->str_norm, sizeof(mfp->str_norm));            get_termcap_string(""ce"", mfp->str_clreoln, sizeof(mfp->str_clreoln));        }    }}",3,"cwe119,cwe120,cweother"
"netvsc_set_mac_addr(struct net_device *ndev, void *p){tstruct sockaddr *addr = p;tchar save_adr[ETH_ALEN];tunsigned char save_aatype;tint err;tmemcpy(save_adr, ndev->dev_addr, ETH_ALEN);tsave_aatype = ndev->addr_assign_type;terr = eth_mac_addr(ndev, p);tif (err != 0)ttreturn err;terr = rndis_filter_set_device_mac(ndev, addr->sa_data);tif (err != 0) {tt ttmemcpy(ndev->dev_addr, save_adr, ETH_ALEN);ttndev->addr_assign_type = save_aatype;t}treturn err;}",2,"cwe119,cwe120"
"process_gpsfile(gbuint8 data[], route_head** track){  const int recordsizes[3] = {8, 20, 32};  int i, style, recsize;  int lat, lon, bintime, bindate;  waypoint* wpt;     style = be_read32(data + 28);  if (style > 2) {    fprintf(stderr, ""unknown GPS record style %d"", style);    return;  }  recsize = recordsizes[style];  for (i = 0; i <= 2048 - recsize; i += (i == 0) ? 32 : recsize) {    float latitude;    int manual_point = 0;    lat = be_read32(data + i + 0);    lon = be_read32(data + i + 4);         if (lat == -1 && lon == -1) {      continue;    }    if ((i == 0) && (be_read32(data + i + 8) & 0x80000000)) {             *track = NULL;    }    if (*track == NULL) {      time_t creation_time;      char buf[1024];      bintime = be_read32(data + i +  8) & 0x7FFFFFFF;      bindate = be_read32(data + i + 12);      creation_time = bintime2utc(bindate, bintime);      strftime(buf, 4096, ""DG-100 tracklog (%Y/%m/%d %H:%M:%S)"",               gmtime(&creation_time));      *track = route_head_alloc();      (*track)->rte_name = xstrdup(buf);      (*track)->rte_desc = xstrdup(""DG-100 GPS tracklog data"");      track_add_head(*track);    }    wpt = waypt_new();    latitude = bin2deg(lat);    if (latitude >= 100) {      manual_point = 1;      latitude -= 100;    }    else if (latitude <= -100) {      manual_point = 1;      latitude += 100;    }    wpt->latitude = latitude;    wpt->longitude = bin2deg(lon);    if (style >= 1) {      bintime = be_read32(data + i +  8) & 0x7FFFFFFF;      bindate = be_read32(data + i + 12);      wpt->creation_time = bintime2utc(bindate, bintime);             wpt->speed = KPH_TO_MPS(be_read32(data + i + 16) / 100.0);      wpt->wpt_flags.speed = 1;    }    if (style >= 2) {      wpt->altitude = be_read32(data + i + 20) / 10000.0;    }    if (manual_point) {      waypt_add(wpt);    }    else {      track_add_wpt(*track, wpt);    }  }}",2,"cwe119,cwe120"
"trace_get_user(struct trace_parser *parser, const char __user *ubuf,tsize_t cnt, loff_t *ppos){tchar ch;tsize_t read = 0;tssize_t ret;tif (!*ppos)tttrace_parser_clear(parser);tret = get_user(ch, ubuf++);tif (ret)ttgoto out;tread++;tcnt--;t tif (!parser->cont) {tt ttwhile (cnt && isspace(ch)) {tttret = get_user(ch, ubuf++);tttif (ret)ttttgoto out;tttread++;tttcnt--;tt}tt ttif (isspace(ch)) {ttt*ppos += read;tttret = read;tttgoto out;tt}ttparser->idx = 0;t}t twhile (cnt && !isspace(ch)) {ttif (parser->idx < parser->size - 1)tttparser->buffer[parser->idx++] = ch;ttelse {tttret = -EINVAL;tttgoto out;tt}ttret = get_user(ch, ubuf++);ttif (ret)tttgoto out;ttread++;ttcnt--;t}t tif (isspace(ch)) {ttparser->buffer[parser->idx] = 0;ttparser->cont = false;t} else if (parser->idx < parser->size - 1) {ttparser->cont = true;ttparser->buffer[parser->idx++] = ch;t} else {ttret = -EINVAL;ttgoto out;t}t*ppos += read;tret = read;out:treturn ret;}",2,"cwe120,cweother"
"adjustVMArgs(_TCHAR *javaVM, _TCHAR *jniLib, _TCHAR **vmArgv[]) {t t tif (permGen != NULL) {ttint specified = 0, i = -1;tt ttwhile ((*vmArgv)[++i] != NULL) {ttt tttif (!specified && _tcsncmp((*vmArgv)[i], XXPERMGEN, _tcslen(XXPERMGEN)) == 0) {ttttspecified = 1;ttt}tt}ttif (!specified && isSunVM(javaVM, jniLib)) {ttt_TCHAR ** oldArgs = *vmArgv;ttt_TCHAR *newArg = malloc((_tcslen(XXPERMGEN) + _tcslen(permGen) + 1) * sizeof(_TCHAR));ttt_stprintf(newArg, _T_ECLIPSE(""%s%s""), XXPERMGEN, permGen);ttt*vmArgv = malloc((i + 2) * sizeof(_TCHAR *));tttmemcpy(*vmArgv, oldArgs, i * sizeof(_TCHAR *));ttt(*vmArgv)[i] = newArg;ttt(*vmArgv)[i + 1] = 0;tt}t}}",2,"cwe120,cweother"
"log_write_direct(int log_id, const char *fmt, ...){    va_list ap;    time_t now;    char line[LOG_MAXLINELEN];    if (log_id < 0 || log_id >= LOG_MAXLOGS) return;        va_start(ap, fmt);    now = time(NULL);    _lock_logger();    vsnprintf(line, LOG_MAXLINELEN, fmt, ap);    if (_log_open (log_id))    {        int len = create_log_entry (log_id, """", line);        if (len > 0)            loglist[log_id].size += len;    }    _unlock_logger();    va_end(ap);    fflush(loglist[log_id].logfile);}",3,"cwe119,cwe120,cweother"
"ERR_print_errors_cb(int (*cb)(const char *str, size_t len, void *u),ttt void *u)t{tunsigned long l;tchar buf[256];tchar buf2[4096];tconst char *file,*data;tint line,flags;tunsigned long es;tCRYPTO_THREADID cur;tCRYPTO_THREADID_current(&cur);tes=CRYPTO_THREADID_hash(&cur);twhile ((l=ERR_get_error_line_data(&file,&line,&data,&flags)) != 0)tt{ttERR_error_string_n(l, buf, sizeof buf);ttBIO_snprintf(buf2, sizeof(buf2), ""%lu:%s:%s:%d:%s"", es, buf,tttfile, line, (flags & ERR_TXT_STRING) ? data : """");ttif (cb(buf2, strlen(buf2), u) <= 0)tttbreak;  tt}t}",2,"cwe119,cwe120"
"__ecereMethod_Sheet_EditSetData(struct __ecereNameSpace__ecere__com__Instance * this, void * setValue, unsigned int closingDropDown){struct __ecereNameSpace__ecere__gui__controls__DataBox * __ecerePointer___ecereNameSpace__ecere__gui__controls__DataBox = (struct __ecereNameSpace__ecere__gui__controls__DataBox *)(this ? (((char *)this) + __ecereClass___ecereNameSpace__ecere__gui__controls__DataBox->offset) : 0);__ecereMethod_Sheet_SetData(((struct __ecereNameSpace__ecere__com__Instance *)__ecereProp___ecereNameSpace__ecere__gui__Window_Get_master(__ecereProp___ecereNameSpace__ecere__gui__Window_Get_master(this))), setValue, this);}",2,"cwe119,cwe120"
"fuse_mnt_resolve_path (const char *progname, const char *orig){        char buf[PATH_MAX];        char *copy;        char *dst;        char *end;        char *lastcomp;        const char *toresolv;        if (!orig[0]) {                GFFUSE_LOGERR (""%s: invalid mountpoint '%s'"", progname, orig);                return NULL;        }        copy = strdup (orig);        if (copy == NULL) {                GFFUSE_LOGERR (""%s: failed to allocate memory"", progname);                return NULL;        }        toresolv = copy;        lastcomp = NULL;        for (end = copy + strlen (copy) - 1; end > copy && *end == '/'; end --);        if (end[0] != '/') {                char *tmp;                end[1] = '0';                tmp = strrchr (copy, '/');                if (tmp == NULL) {                        lastcomp = copy;                        toresolv = ""."";                } else {                        lastcomp = tmp + 1;                        if (tmp == copy)                                toresolv = ""/"";                }                if (strcmp (lastcomp, ""."") == 0 || strcmp (lastcomp, "".."") == 0) {                        lastcomp = NULL;                        toresolv = copy;                }                else if (tmp)                        tmp[0] = '0';        }        if (realpath (toresolv, buf) == NULL) {                GFFUSE_LOGERR (""%s: bad mount point %s: %s"", progname, orig,                               strerror (errno));                FREE (copy);                return NULL;        }        if (lastcomp == NULL)                dst = strdup (buf);        else {                dst = (char *) MALLOC (strlen (buf) + 1 + strlen (lastcomp) + 1);                if (dst) {                        unsigned buflen = strlen (buf);                        if (buflen && buf[buflen-1] == '/')                                sprintf (dst, ""%s%s"", buf, lastcomp);                        else                                sprintf (dst, ""%s/%s"", buf, lastcomp);                }        }        FREE (copy);        if (dst == NULL)                GFFUSE_LOGERR (""%s: failed to allocate memory"", progname);        return dst;}",3,"cwe119,cwe120,cwe469"
"server_list_timer(XtPointer meta_list, XtIntervalId * id){  char errbuf[128];  if (!connectdlg_serverlist_shell) {    return;  }  if (get_server_list(servers_list, errbuf, sizeof(errbuf)) != -1)  {    XawListChange(meta_list, servers_list, 0, 0, True);  }   num_lanservers_timer++;  if (lan_mode) {    if (num_lanservers_timer == 20) {      server_scan_finish(lan_scan);      lan_scan = NULL;      num_lanservers_timer = 0;      return;    }    (void)XtAppAddTimeOut(app_context, 250, server_list_timer,                          (XtPointer)meta_list);  } else {    if (num_lanservers_timer == 4) {      server_scan_finish(meta_scan);      meta_scan = NULL;      num_lanservers_timer = 0;      return;    }    (void)XtAppAddTimeOut(app_context, 500, server_list_timer,                          (XtPointer)meta_list);  }}",2,"cwe119,cwe120"
"""rdnum(void){tint  result, ch;tdo  {ttif  ((ch = getc(infile)) == '')tttline_count++;ttelse  if  (ch == '#')  {tttdo  ch = getc(infile);tttwhile  (ch != ''  &&  ch != EOF);tttline_count++;tt}t}  while  (isspace(ch));tif  (!isdigit(ch))tterror(1047);t/* {spdinit digit expected} */tresult = 0;tdo  {ttresult = result * 10 + ch - '0';ttch = getc(infile);t}  while  (isdigit(ch));tungetc(ch, infile);treturn  result;}""",2,"cwe120,cweother"
"""profile_init_path(const_profile_filespec_list_t filepath,                  profile_t *ret_profile){    unsigned int n_entries;    int i;    unsigned int ent_len;    const char *s, *t;    profile_filespec_t *filenames;    errcode_t retval;    /* count the distinct filename components */    for(s = filepath, n_entries = 1; *s; s++) {        if (*s == ':')            n_entries++;    }    /* the array is NULL terminated */    filenames = (profile_filespec_t*) malloc((n_entries+1) * sizeof(char*));    if (filenames == 0)        return ENOMEM;    /* measure, copy, and skip each one */    for(s = filepath, i=0; (t = strchr(s, ':')) || (t=s+strlen(s)); s=t+1, i++) {        ent_len = (unsigned int) (t-s);        filenames[i] = (char*) malloc(ent_len + 1);        if (filenames[i] == 0) {            /* if malloc fails, free the ones that worked */            while(--i >= 0) free(filenames[i]);            free(filenames);            return ENOMEM;        }        strncpy(filenames[i], s, ent_len);        filenames[i][ent_len] = 0;        if (*t == 0) {            i++;            break;        }    }    /* cap the array */    filenames[i] = 0;    retval = profile_init_flags((const_profile_filespec_t *) filenames, 0,                                ret_profile);    /* count back down and free the entries */    while(--i >= 0) free(filenames[i]);    free(filenames);    return retval;}""",2,"cwe120,cweother"
"_dump_resv_req(resv_desc_msg_t *resv_ptr, char *mode){tchar start_str[32] = ""-1"", end_str[32] = ""-1"", *flag_str = NULL;tchar *node_cnt_str = NULL;tint duration, i;tif (!(slurmctld_conf.debug_flags & DEBUG_FLAG_RESERVATION))ttreturn;tif (resv_ptr->start_time != (time_t) NO_VAL) {ttslurm_make_time_str(&resv_ptr->start_time,tttt    start_str, sizeof(start_str));t}tif (resv_ptr->end_time != (time_t) NO_VAL) {ttslurm_make_time_str(&resv_ptr->end_time,tttt    end_str,  sizeof(end_str));t}tif (resv_ptr->flags != (uint16_t) NO_VAL)ttflag_str = reservation_flags_string(resv_ptr->flags);tif (resv_ptr->duration == NO_VAL)ttduration = -1;telsettduration = resv_ptr->duration;tif (resv_ptr->node_cnt) {ttfor (i = 0; resv_ptr->node_cnt[i]; i++) {tttif (node_cnt_str) {ttttxstrfmtcat(node_cnt_str, "",%u"",ttttt   resv_ptr->node_cnt[i]);ttt} else {ttttxstrfmtcat(node_cnt_str, ""%u"",ttttt   resv_ptr->node_cnt[i]);ttt}tt}t}tinfo(""%s: Name=%s StartTime=%s EndTime=%s Duration=%d ""t     ""Flags=%s NodeCnt=%s NodeList=%s Features=%s ""t     ""PartitionName=%s Users=%s Accounts=%s Licenses=%s"",t     mode, resv_ptr->name, start_str, end_str, duration,t     flag_str, node_cnt_str, resv_ptr->node_list,t     resv_ptr->features, resv_ptr->partition,t     resv_ptr->users, resv_ptr->accounts, resv_ptr->licenses);txfree(flag_str);txfree(node_cnt_str);}",2,"cwe119,cwe120"
"_print_motd(){    FILE *fp;    size_t nbytes = 80;    char read[nbytes];    size_t result;    if ((fp = fopen(MOTD_FILE, ""r"")) == NULL) {        return (-1);    }    while ((result = fread(read, sizeof(char), nbytes, fp))) {                 result = fwrite(read, sizeof(char), result, stdout);    }    fclose(fp);    return (0);}",3,"cwe119,cwe120,cweother"
"do_sscanf (const char *src, const char *format, const char *args,t       DATASET *dset, int *n_items){    const char *r, *p, *q;    int nscan = 0;    int err = 0;    gretl_error_clear();#if PSDEBUG    fprintf(stderr, ""do_sscanf: src = '%s'"", src);    fprintf(stderr, ""do_sscanf: format = '%s'"", format);    fprintf(stderr, ""do_sscanf: args = '%s'"", args);#endif    r = src;    p = format;    q = args;    while (*r && *p && !err) {tif (isspace(*p)) {t    while (isspace(*r)) r++;t    while (isspace(*p)) p++;t}tif (*r == 't' && *p == '' && *(p+1) == 't') {t    r++;t    p += 2;t} else if (*r == '' && *p == '' && *(p+1) == 'n') {t    r++;t    p += 2;t} else if (*r == *p) {t    r++;t    p++;t} else if (*p == '%') {t    err = scan_arg(&r, &p, &q, dset, &nscan);t} else {t    break;t}    }    if (!err) {t*n_items = nscan;    }    return err;}",2,"cwe119,cwe120"
"client3_3_lk (call_frame_t *frame, xlator_t *this,              void *data){        clnt_args_t     *args       = NULL;        gfs3_lk_req      req        = {{0,},};        int32_t          gf_cmd     = 0;        int32_t          gf_type    = 0;        int64_t          remote_fd  = -1;        clnt_local_t    *local      = NULL;        clnt_conf_t     *conf       = NULL;        int              op_errno   = ESTALE;        int              ret        = 0;        if (!frame || !this || !data)                goto unwind;        args = data;        conf = this->private;        local = mem_get0 (this->local_pool);        if (!local) {                op_errno = ENOMEM;                goto unwind;        }        CLIENT_GET_REMOTE_FD (this, args->fd, DEFAULT_REMOTE_FD,                              remote_fd, op_errno, unwind);        ret = client_cmd_to_gf_cmd (args->cmd, &gf_cmd);        if (ret) {                op_errno = EINVAL;                gf_log (this->name, GF_LOG_WARNING,                        ""Unknown cmd (%d)!"", gf_cmd);                goto unwind;        }        switch (args->flock->l_type) {        case F_RDLCK:                gf_type = GF_LK_F_RDLCK;                break;        case F_WRLCK:                gf_type = GF_LK_F_WRLCK;                break;        case F_UNLCK:                gf_type = GF_LK_F_UNLCK;                break;        }        local->owner = frame->root->lk_owner;        local->cmd   = args->cmd;        local->fd    = fd_ref (args->fd);        frame->local = local;        req.fd    = remote_fd;        req.cmd   = gf_cmd;        req.type  = gf_type;        gf_proto_flock_from_flock (&req.flock, args->flock);        memcpy (req.gfid, args->fd->inode->gfid, 16);        GF_PROTOCOL_DICT_SERIALIZE (this, args->xdata, (&req.xdata.xdata_val),                                    req.xdata.xdata_len, op_errno, unwind);        ret = client_submit_request (this, &req, frame, conf->fops, GFS3_OP_LK,                                     client3_3_lk_cbk, NULL,                                     NULL, 0, NULL, 0, NULL,                                     (xdrproc_t)xdr_gfs3_lk_req);        if (ret) {                gf_log (this->name, GF_LOG_WARNING, ""failed to send the fop"");        }        GF_FREE (req.xdata.xdata_val);        return 0;unwind:        CLIENT_STACK_UNWIND (lk, frame, -1, op_errno, NULL, NULL);        GF_FREE (req.xdata.xdata_val);        return 0;}",2,"cwe120,cwe476"
"vflip(struct fp_img *img){tint width = img->width;tint data_len = img->width * img->height;tunsigned char rowbuf[width];tint i;tfor (i = 0; i < img->height / 2; i++) {ttint offset = i * width;ttint swap_offset = data_len - (width * (i + 1));tt ttmemcpy(rowbuf, img->data + offset, width);tt ttmemcpy(img->data + offset, img->data + swap_offset, width);tt ttmemcpy(img->data + swap_offset, rowbuf, width);t}}",2,"cwe119,cwe120"
"""gf_strip_whitespace (char *str, int len){        int     i = 0;        int     new_len = 0;        char    *new_str = NULL;        GF_ASSERT (str);        new_str = GF_CALLOC (1, len + 1, gf_common_mt_char);        if (new_str == NULL)                return -1;        for (i = 0; i < len; i++) {                if (!isspace (str[i]))                        new_str[new_len++] = str[i];        }        new_str[new_len] = '0';        if (new_len != len) {                memset (str, 0, len);                strncpy (str, new_str, new_len);        }        GF_FREE (new_str);        return new_len;}""",2,"cwe120,cwe476"
"add (unsigned char *prefix_, size_t size_){         if (!size_) {        ++refcnt;        return;    }    unsigned char c = *prefix_;    if (c < min || c >= min + count) {                          if (!count) {            min = c;            count = 1;            next.node = NULL;        }        else if (count == 1) {            unsigned char oldc = min;            trie_t *oldp = next.node;            count = (min < c ? c - min : min - c) + 1;            next.table = (trie_t**)                malloc (sizeof (trie_t*) * count);            alloc_assert (next.table);            for (unsigned short i = 0; i != count; ++i)                next.table [i] = 0;            min = std::min (min, c);            next.table [oldc - min] = oldp;        }        else if (min < c) {                         unsigned short old_count = count;            count = c - min + 1;            next.table = (trie_t**) realloc ((void*) next.table,                sizeof (trie_t*) * count);            zmq_assert (next.table);            for (unsigned short i = old_count; i != count; i++)                next.table [i] = NULL;        }        else {                         unsigned short old_count = count;            count = (min + old_count) - c;            next.table = (trie_t**) realloc ((void*) next.table,                sizeof (trie_t*) * count);            zmq_assert (next.table);            memmove (next.table + min - c, next.table,                old_count * sizeof (trie_t*));            for (unsigned short i = 0; i != min - c; i++)                next.table [i] = NULL;            min = c;        }    }         if (count == 1) {        if (!next.node) {            next.node = new (std::nothrow) trie_t;            alloc_assert (next.node);            ++live_nodes;        }        next.node->add (prefix_ + 1, size_ - 1);    }    else {        if (!next.table [c - min]) {            next.table [c - min] = new (std::nothrow) trie_t;            alloc_assert (next.table [c - min]);            ++live_nodes;        }        next.table [c - min]->add (prefix_ + 1, size_ - 1);    }}",2,"cwe476,cweother"
"""movemon(){    register struct monst *mtmp, *nmtmp;    register boolean somebody_can_move = FALSE;#if 0    /* part of the original warning code which was replaced in 3.3.1 */    warnlevel = 0;#endif    /*    Some of you may remember the former assertion here that    because of deaths and other actions, a simple one-pass    algorithm wasn't possible for movemon.  Deaths are no longer    removed to the separate list fdmon; they are simply left in    the chain with hit points <= 0, to be cleaned up at the end    of the pass.    The only other actions which cause monsters to be removed from    the chain are level migrations and losedogs().  I believe losedogs()    is a cleanup routine not associated with monster movements, and    monsters can only affect level migrations on themselves, not others    (hence the fetching of nmon before moving the monster).  Currently,    monsters can jump into traps, read cursed scrolls of teleportation,    and drink cursed potions of raise level to change levels.  These are    all reflexive at this point.  Should one monster be able to level    teleport another, this scheme would have problems.    */    for(mtmp = fmon; mtmp; mtmp = nmtmp) {tnmtmp = mtmp->nmon;t/* Find a monster that we have not treated yet.t */tif(DEADMONSTER(mtmp))t    continue;tif(mtmp->movement < NORMAL_SPEED)t    continue;tmtmp->movement -= NORMAL_SPEED;tif (mtmp->movement >= NORMAL_SPEED)t    somebody_can_move = TRUE;tif (vision_full_recalc) vision_recalc(0);t/* vision! */tif (minliquid(mtmp)) continue;tif (is_hider(mtmp->data)) {t    /* unwatched mimics and piercers may hide again  [MRS] */t    if(restrap(mtmp))   continue;t    if(mtmp->m_ap_type == M_AP_FURNITURE ||ttttmtmp->m_ap_type == M_AP_OBJECT)tt    continue;t    if(mtmp->mundetected) continue;t}t/* continue if the monster died fighting */tif (Conflict && !mtmp->iswiz && mtmp->mcansee) {t    /* Note:t     *  Conflict does not take effect in the first round.t     *  Therefore, A monster when stepping into the area willt     *  get to swing at you.t     *t     *  The call to fightm() must be _last_.  The monster mightt     *  have died if it returns 1.t     */t    if (couldsee(mtmp->mx,mtmp->my) &&tt(distu(mtmp->mx,mtmp->my) <= BOLT_LIM*BOLT_LIM) &&tttttttfightm(mtmp))ttcontinue;t/* mon might have died */t}tif(dochugw(mtmp))tt/* otherwise just move the monster */t    continue;    }#if 0    /* part of the original warning code which was replaced in 3.3.1 */    if(warnlevel > 0)twarn_effects();#endif    if (any_light_source())tvision_full_recalc = 1;t/* in case a mon moved with a light source */    dmonsfree();t/* remove all dead monsters */    /* a monster may have levteleported player -dlc */    if (u.utotype) {tdeferred_goto();t/* changed levels, so these monsters are dormant */tsomebody_can_move = FALSE;    }    return somebody_can_move;}""",2,"cwe119,cwe120"
"alloc_bootmem_huge_page(struct hstate *h){tstruct huge_bootmem_page *m;tint nr_nodes, node;tfor_each_node_mask_to_alloc(h, nr_nodes, node, &node_states[N_MEMORY]) {ttvoid *addr;ttaddr = memblock_virt_alloc_try_nid_nopanic(tttthuge_page_size(h), huge_page_size(h),tttt0, BOOTMEM_ALLOC_ACCESSIBLE, node);ttif (addr) {ttt tttm = addr;tttgoto found;tt}t}treturn 0;found:tBUG_ON(!IS_ALIGNED(virt_to_phys(m), huge_page_size(h)));t tlist_add(&m->list, &huge_boot_pages);tm->hstate = h;treturn 1;}",2,"cwe119,cwe120"
"send_raw(int fd, char *buf, int buflen, int user, int cmd){tchar packet[4096];tint len;tlen = MIN(sizeof(packet) - RAW_HDR_LEN, buflen);tmemcpy(packet, raw_header, RAW_HDR_LEN);tif (len) {ttmemcpy(&packet[RAW_HDR_LEN], buf, len);t}tlen += RAW_HDR_LEN;tpacket[RAW_HDR_CMD] = cmd | (user & 0x0F);tsendto(fd, packet, len, 0, (struct sockaddr*)&raw_serv, sizeof(raw_serv));}",2,"cwe119,cwe120"
"main_vsmxdec (void) {t  if (app_argc < 4)t    MAIN_INV_CMD_SYNTAX;t  uint8_t doDecompile = FALSE;t  FILE *fin = NULL, *fout = NULL;t  retrieve_from_opts (TRUE, 1, ""--decompile"", ""bool"", &doDecompile);t  int i;t  for (i = 2; i < app_argc; i++) {t    if (app_argv[i]) {t      if (!fin) {ttif (!strcmp (app_argv[i], ""-""))tt  fin = stdin;ttelse {tt  if (!(fin = fopen (app_argv[i], ""rb""))) {tt    error (""Cannot open file %s"", app_argv[i]);tt    return 1;tt  }tt}t      } else if (!fout) {ttif (!strcmp (app_argv[i], ""-""))tt  fout = stdout;ttelse {tt  if (!(fout = fopen (app_argv[i], ""wb""))) {tt    error (""Cannot open file %s"", app_argv[i]);tt    return 1;tt  }tt}t      } else {ttwarning (""Don't know what to do with option ""%s"""",tt    app_argv[i]);t      }t    }t  }t  if (!fin || !fout) {t    MAIN_INV_CMD_SYNTAX;t  }t  info (""Reading VSMX..."");t  VsmxMem *vm = readVSMX (fin);t  fclose (fin);t  uint8_t success = FALSE;t  if (vm) {t    info (""Writing decoded output..."");t    if (doDecompile)t      success = !VsmxDecompile (vm, fout);t    elset      success = !VsmxDecode (vm, fout);t    freeVsmxMem (vm);t  }t  fclose (fout);t  if (success)t    return 0;t  else {t    if (doDecompile) {t      error (""Failed to decompile VSMX."");t    } else {t      error (""Failed to decode VSMX."");t    }t    return RETERR_GENERIC_FAILED;t  }t}",2,"cwe469,cweother"
"get_realm_hash(request_rec *r, const char *user,                                   const char *realm, char **rethash){    apr_status_t rv;    const char *key;    authn_cache_dircfg *dcfg;    unsigned char val[MAX_VAL_LEN];    unsigned int vallen = MAX_VAL_LEN - 1;    dcfg = ap_get_module_config(r->per_dir_config, &authn_socache_module);    if (!configured || !dcfg->providers) {        return AUTH_USER_NOT_FOUND;    }    key = construct_key(r, dcfg->context, user, realm);    rv = socache_provider->retrieve(socache_instance, r->server,                                    (unsigned char*)key, strlen(key),                                    val, &vallen, r->pool);    if (APR_STATUS_IS_NOTFOUND(rv)) {                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01687)                      ""Authn cache: no credentials found for %s"", user);        return AUTH_USER_NOT_FOUND;    }    else if (rv == APR_SUCCESS) {                 ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(01688)                      ""Authn cache: found credentials for %s"", user);    }    else {                          ap_log_rerror(APLOG_MARK, APLOG_ERR, rv, r, APLOGNO(01689)                      ""Error accessing authentication cache"");        return AUTH_USER_NOT_FOUND;    }    *rethash = apr_pstrmemdup(r->pool, (char *)val, vallen);    return AUTH_USER_FOUND;}",2,"cwe119,cwe120"
"sec_port_read_utf8(unsigned int *index, unsigned char *inBuf, unsigned int inBufLen){  PRUint32 result;  unsigned int i = *index;  int bytes_left;  PRUint32 min_value;  PORT_Assert(i < inBufLen);  if ( (inBuf[i] & 0x80) == 0x00 ) {    result = inBuf[i++];    bytes_left = 0;    min_value = 0;  } else if ( (inBuf[i] & 0xE0) == 0xC0 ) {    result = inBuf[i++] & 0x1F;    bytes_left = 1;    min_value = 0x80;  } else if ( (inBuf[i] & 0xF0) == 0xE0) {    result = inBuf[i++] & 0x0F;    bytes_left = 2;    min_value = 0x800;  } else if ( (inBuf[i] & 0xF8) == 0xF0) {    result = inBuf[i++] & 0x07;    bytes_left = 3;    min_value = 0x10000;  } else {    return BAD_UTF8;  }  while (bytes_left--) {    if (i >= inBufLen || (inBuf[i] & 0xC0) != 0x80) return BAD_UTF8;    result = (result << 6) | (inBuf[i++] & 0x3F);  }     if (result < min_value || (result & 0xFFFFF800) == 0xD800 || result > 0x10FFFF) {    return BAD_UTF8;  }  *index = i;  return result;}",2,"cwe119,cwe120"
"generate_user_agent(void){    char         buf[128];    char         rev[128];    if(F_ON(F_QUELL_USERAGENT, ps_global))      return(NULL);    snprintf(buf, sizeof(buf),t     ""%sAlpine %s (%s %s)"",t     (pith_opt_user_agent_prefix) ? (*pith_opt_user_agent_prefix)() : """",t     ALPINE_VERSION, SYSTYPE,t     get_alpine_revision_string(rev, sizeof(rev)));    return(cpystr(buf));}",2,"cwe119,cwe120"
"elantech_detect(struct psmouse *psmouse, bool set_properties){tstruct ps2dev *ps2dev = &psmouse->ps2dev;tunsigned char param[3];tps2_command(&psmouse->ps2dev, NULL, PSMOUSE_CMD_RESET_DIS);tif (ps2_command(ps2dev,  NULL, PSMOUSE_CMD_DISABLE) ||t    ps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE11) ||t    ps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE11) ||t    ps2_command(ps2dev,  NULL, PSMOUSE_CMD_SETSCALE11) ||t    ps2_command(ps2dev, param, PSMOUSE_CMD_GETINFO)) {ttpsmouse_dbg(psmouse, ""sending Elantech magic knock failed."");ttreturn -1;t}t tif (param[0] != 0x3c || param[1] != 0x03 ||t    (param[2] != 0xc8 && param[2] != 0x00)) {ttpsmouse_dbg(psmouse,ttt    ""unexpected magic knock result 0x%02x, 0x%02x, 0x%02x."",ttt    param[0], param[1], param[2]);ttreturn -1;t}t tif (synaptics_send_cmd(psmouse, ETP_FW_VERSION_QUERY, param)) {ttpsmouse_dbg(psmouse, ""failed to query firmware version."");ttreturn -1;t}tpsmouse_dbg(psmouse,tt    ""Elantech version query result 0x%02x, 0x%02x, 0x%02x."",tt    param[0], param[1], param[2]);tif (!elantech_is_signature_valid(param)) {ttpsmouse_dbg(psmouse,ttt    ""Probably not a real Elantech touchpad. Aborting."");ttreturn -1;t}tif (set_properties) {ttpsmouse->vendor = ""Elantech"";ttpsmouse->name = ""Touchpad"";t}treturn 0;}",2,"cwe119,cwe120"
"DecodeBitmap(char* dir, BitmapType type, int num, int x, int y)r{rtchar file[MAX_PATH];rrtswitch (type)rt{rtcase PC1_BITMAPS:rttbitmap_pc_name(num,dir,file);rttif (bitmap_pc1_decode(file,x,y))rtttreturn bitmap;rttbreak;rrtcase PC2_BITMAPS:rttbitmap_pc_name(num,dir,file);rttif (bitmap_pc2_decode(file,x,y))rtttreturn bitmap;rttbreak;rrtcase AMIGA_BITMAPS:rttbitmap_noext_name(num,dir,file);rttif (bitmap_amiga_decode(file,x,y))rtttreturn bitmap;rttbreak;rrtcase C64_BITMAPS:rttbitmap_c64_name(num,dir,file);rttif (bitmap_c64_decode(file,type,num))rtttreturn bitmap;rttbreak;rrtcase BBC_BITMAPS:rttbitmap_bbc_name(num,dir,file);rttif (bitmap_bbc_decode(file,type,num))rtttreturn bitmap;rttbreak;rrtcase CPC_BITMAPS:rttbitmap_cpc_name(num,dir,file);rttif (bitmap_c64_decode(file,type,num))  rtttreturn bitmap;rttbreak;rrtcase MAC_BITMAPS:rttbitmap_noext_name(num,dir,file);rttif (bitmap_mac_decode(file,x,y))rtttreturn bitmap;rttbreak;rrtcase ST1_BITMAPS:rttbitmap_noext_name(num,dir,file);rttif (bitmap_st1_decode(file,x,y))rtttreturn bitmap;rttbreak;rrtcase ST2_BITMAPS:rttbitmap_st2_name(num,dir,file);rttif (bitmap_pc2_decode(file,x,y))rtttreturn bitmap;rttbreak;rt}rrtreturn NULL;r}",2,"cwe119,cwe120"
"write_pattern_c_code(char *name, Intersection board1d[BOARDSIZE],tt     int move_pos, int value, int boardsize, int patlen){  int k;  Hash_data pattern_hash;     hashdata_recalc(&pattern_hash, board1d, NO_MOVE);  printf(""  {{{"");  for (k = 0; k < NUM_HASHVALUES; k++) {    printf(""0x%lx"", pattern_hash.hashval[k]);    if (k < NUM_HASHVALUES - 1)      printf("","");  }  if (name)    printf(""}},%d,""%s"",%d,%d},"", patlen, name,t   OFFSET(I(move_pos) - (boardsize-1)/2,tt  J(move_pos) - (boardsize-1)/2),t   value);  else    printf(""}},-1,NULL,0,0},"");}",2,"cwe119,cwe120"
"rfc959_list_files (gftp_request * request){  intptr_t show_hidden_files, resolve_symlinks, passive_transfer;  char *tempstr, parms[3];  int ret;  g_return_val_if_fail (request != NULL, GFTP_EFATAL);  g_return_val_if_fail (request->datafd > 0, GFTP_EFATAL);  if ((ret = rfc959_data_connection_new (request, 0)) < 0)    return (ret);  gftp_lookup_request_option (request, ""show_hidden_files"", &show_hidden_files);  gftp_lookup_request_option (request, ""resolve_symlinks"", &resolve_symlinks);  gftp_lookup_request_option (request, ""passive_transfer"", &passive_transfer);  *parms = '0';  strcat (parms, show_hidden_files ? ""a"" : """");  strcat (parms, resolve_symlinks ? ""L"" : """");  tempstr = g_strconcat (""LIST"", *parms != '0' ? "" -"" : """", parms, ""r"",                          NULL);   ret = rfc959_send_command (request, tempstr, -1, 1, 0);  g_free (tempstr);  if (ret < 0)    return (ret);  else if (ret != '1')    {      request->logging_function (gftp_logging_error, request,                                 _(""Invalid response '%c' received from server.""),                                 ret);      return (GFTP_ERETRYABLE);    }  ret = 0;  if (!passive_transfer)    ret = rfc959_accept_active_connection (request);  return (ret);}",2,"cwe119,cwe120"
"dwim_ref(const char *str, int len, unsigned char *sha1, char **ref){tconst char **p, *r;tint refs_found = 0;t*ref = NULL;tfor (p = ref_rev_parse_rules; *p; p++) {ttchar fullref[PATH_MAX];ttunsigned char sha1_from_ref[20];ttunsigned char *this_result;ttthis_result = refs_found ? sha1_from_ref : sha1;ttmksnpath(fullref, sizeof(fullref), *p, len, str);ttr = resolve_ref(fullref, this_result, 1, NULL);ttif (r) {tttif (!refs_found++)tttt*ref = xstrdup(r);tttif (!warn_ambiguous_refs)ttttbreak;tt}t}treturn refs_found;}",2,"cwe119,cwe120"
"elf_find_dynamic_section(int fd, Elf_Ehdr *ehdr, Elf_Phdr *phdr){  int i;  if (lseek(fd, EHDR_PWU(e_phoff), SEEK_SET) == -1)  {    perror (""positioning for sections"");    return 1;  }  for (i = 0; i < EHDR_PHS(e_phnum); i++)  {    const size_t sz_phdr = is_e32() ? sizeof(Elf32_Phdr) : sizeof(Elf64_Phdr);    if (read(fd, phdr, sz_phdr) != (ssize_t)sz_phdr)    {      perror (""reading section header"");      return 1;    }    if (PHDR_PWU(p_type) == PT_DYNAMIC)      break;  }  if (i == EHDR_PHS(e_phnum))    {      fprintf (stderr, ""No dynamic section found."");      return 2;    }  if (0 == PHDR_POU(p_filesz))    {      fprintf (stderr, ""Length of dynamic section is zero."");      return 3;    }  return 0;}",2,"cwe120,cweother"
"check_secret_key( PKT_secret_key *sk, int n ){    int rc = G10ERR_BAD_PASS;    int i,mode;    if (sk && sk->is_protected && sk->protect.s2k.mode == 1002)      return 0;      if(n<0)      {tn=abs(n);tmode=1;      }    else      mode=0;    if( n < 1 )tn = (opt.batch && !opt.use_agent)? 1 : 3;      for(i=0; i < n && rc == G10ERR_BAD_PASS; i++ ) {        int canceled = 0;        const char *tryagain = NULL;tif (i) {            tryagain = N_(""Invalid passphrase; please try again"");            log_info (_(""%s ...""), _(tryagain));        }trc = do_check( sk, tryagain, mode, &canceled );tif( rc == G10ERR_BAD_PASS && is_status_enabled() ) {t    u32 kid[2];t    char buf[50];t    keyid_from_sk( sk, kid );t    sprintf(buf, ""%08lX%08lX"", (ulong)kid[0], (ulong)kid[1]);t    write_status_text( STATUS_BAD_PASSPHRASE, buf );t}tif( have_static_passphrase() || canceled)t    break;    }    if( !rc )twrite_status( STATUS_GOOD_PASSPHRASE );    return rc;}",2,"cwe119,cwe120"
"""read_line (gint fd, gchar * buffer, guint size){  gint idx;  gchar c;  gint r;  fd_set fds;  struct timeval tv;  tv.tv_sec = 1;  tv.tv_usec = 0;  FD_ZERO (&fds);  FD_SET (fd, &fds);  idx = 0;  while (TRUE) {    gint ret;    ret = select (fd+1, &fds, NULL, NULL, &tv);    if (ret == 0) {      /* timeout */      goto read_error;    } else if (ret == -1) {      /* error */      goto read_error;    }    r = read (fd, &c, 1);    if (r < 1) {      if (errno != EAGAIN && errno != EINTR)        goto read_error;    } else {      if (c == '')            /* end on  */        break;      if (c == 'r')            /* ignore r */        continue;      if (idx < size - 1)        buffer[idx++] = c;    }  }  buffer[idx] = '0';  return RTSP_OK;read_error:  {    return RTSP_ESYS;  }}""",3,"cwe120,cwe476,cweother"
"see_floor_items(game_event_type type, game_event_data *data, void *user){tint py = p_ptr->py;tint px = p_ptr->px;tsize_t floor_num = 0;tint floor_list[MAX_FLOOR_STACK + 1];tbool blind = ((p_ptr->timed[TMD_BLIND]) || (no_light()));tconst char *p = ""see"";tint can_pickup = 0;tsize_t i;t tfloor_num = scan_floor(floor_list, N_ELEMENTS(floor_list), py, px, 0x03);tif (floor_num == 0) return;tfor (i = 0; i < floor_num; i++)t    can_pickup += inven_carry_okay(object_byid(floor_list[i]));tt tif (floor_num == 1)t{tt ttobject_type *o_ptr = object_byid(floor_list[0]);ttchar o_name[80];ttif (!can_pickup)tttp = ""have no room for"";ttelse if (blind)tttp = ""feel"";tt ttif (blind)tttobject_desc(o_name, sizeof(o_name), o_ptr,tttttODESC_PREFIX | ODESC_BASE);ttelsetttobject_desc(o_name, sizeof(o_name), o_ptr,tttttODESC_PREFIX | ODESC_FULL);tt ttmessage_flush();ttmsg(""You %s %s."", p, o_name);t}telset{ttui_event e;ttif (!can_pickup)tp = ""have no room for the following objects"";ttelse if (blind)     p = ""feel something on the floor"";tt ttscreen_save();ttshow_floor(floor_list, floor_num, (OLIST_WEIGHT));ttprt(format(""You %s: "", p), 0, 0);tt tte = inkey_ex();ttTerm_event_push(&e);tt ttscreen_load();t}}",2,"cwe119,cwe120"
"eb_set_appendix_subbook_eb(EB_Appendix *appendix, EB_Subbook_Code subbook_code){    EB_Error_Code error_code;    EB_Appendix_Subbook *subbook;    char appendix_path_name[EB_MAX_PATH_LENGTH + 1];    Zio_Code zio_code;    LOG((""in: eb_set_appendix_subbook_eb(appendix=%d, subbook=%d)"",t(int)appendix->code, (int)subbook_code));         appendix->subbook_current = appendix->subbooks + subbook_code;    subbook = appendix->subbook_current;         if (eb_find_file_name2(appendix->path, subbook->directory_name,tEB_FILE_NAME_APPENDIX, subbook->file_name) != EB_SUCCESS) {terror_code = EB_ERR_FAIL_OPEN_APP;tgoto failed;    }    eb_compose_path_name2(appendix->path, subbook->directory_name,tsubbook->file_name, appendix_path_name);    eb_path_name_zio_code(appendix_path_name, ZIO_PLAIN, &zio_code);    if (zio_open(&subbook->zio, appendix_path_name, zio_code) < 0) {terror_code = EB_ERR_FAIL_OPEN_APP;tgoto failed;    }    LOG((""out: eb_set_appendix_subbook_eb() = %s"",teb_error_string(EB_SUCCESS)));    return EB_SUCCESS;       failed:    LOG((""out: eb_set_appendix_subbook_eb() = %s"",teb_error_string(error_code)));    return error_code;}",2,"cwe119,cwe120"
"cbf_set_bintext (cbf_node *column, unsigned int row,                     int         type,                     int         id,                     cbf_file   *file,                     long        start,                     long        size,                     int         checked_digest,                     const char *digest,                     int         bits,                     int         sign,                     int         realarray,                     const char *byteorder,                     size_t      dimover,                     size_t      dimfast,                     size_t      dimmid,                     size_t      dimslow,                     size_t      padding,            unsigned int         compression){  char text [(((sizeof (void *) +                sizeof (long int) * 2 +                sizeof (int) * 3) * CHAR_BIT) >> 2) + 57                +15+((5*sizeof (size_t)*3*CHAR_BIT)>>2)];  const char *new_text;  int errorcode;       if (!cbf_is_base64digest (digest))  {    digest = ""------------------------"";    checked_digest = 0;  }       sprintf (text, ""%x %p %lx %lx %1d %24s %x %d %d %14s %ld %ld %ld %ld %ld %u"",                   (unsigned int)id,                   (void *)file,                   (unsigned long)start,                   (unsigned long)size,                   checked_digest != 0,                   digest,                   (unsigned int)bits,                   sign,                   realarray,                   byteorder,                   (unsigned long)dimover,                   (unsigned long)dimfast,                    (unsigned long)dimmid,                    (unsigned long)dimslow,                    (unsigned long)padding,                   compression);  new_text = cbf_copy_string (NULL, text, (char) type);  if (!new_text)    return CBF_ALLOC;       cbf_onfailnez (cbf_add_fileconnection (&file, NULL),                 cbf_free_string (NULL, new_text))       errorcode = cbf_set_columnrow (column, row, new_text, 1);  if (errorcode)  {    cbf_free_string (NULL, new_text);    return errorcode | cbf_delete_fileconnection (&file);  }       return 0;}",2,"cwe119,cwe120"
"_PrintType(struct Type * type, char * string, unsigned int printName, unsigned int fullName, unsigned int printConst){PrePrintType(type, string, fullName, (((void *)0)), printConst);if(type->thisClass || (printName && type->name && type->name[0]))strcat(string, "" "");if((type->thisClass || type->staticMethod)){struct Symbol * _class = type->thisClass;if((type->classObjectType == 2 || type->classObjectType == 1) || (_class && !strcmp(_class->string, ""class""))){if(type->classObjectType == 1)strcat(string, ""class"");elsestrcat(string, type->byReference ? ""typed_object&"" : ""typed_object"");}else if(_class && _class->string){char * s = _class->string;if(fullName)strcat(string, s);else{char * name = __ecereNameSpace__ecere__sys__RSearchString(s, ""::"", strlen(s), 0x1, 0x0);if(name)name += 2;elsename = s;strcat(string, name);}}strcat(string, ""::"");}if(printName && type->name)PrintName(type, string, fullName);PostPrintType(type, string, fullName);if(type->bitFieldCount){char count[100];sprintf(count, "":%d"", type->bitFieldCount);strcat(string, count);}}",2,"cwe119,cwe120"
"gfarm_auth_random(void *buffer, size_t length){tunsigned char *p = buffer;tsize_t i = 0;tint fd, rv;t tif ((fd = open(PATH_URANDOM, O_RDONLY)) != -1) {ttfor (; i < length; i += rv) {tttrv = read(fd, p + i, length - i);tttif (rv == -1)ttttbreak;tt}ttclose(fd);ttif (i >= length)tttreturn;t}t tfor (; i < length; i++) {#ifdef HAVE_RANDOMttp[i] = gfarm_random();#elsettp[i] = gfarm_random() / (RAND_MAX + 1.0) * 256;#endift}}",2,"cwe120,cweother"
"genl_resolve_mcg(const char *family, const char *name, int *fam_id){tstruct rtnl_handle rth;tstruct nlmsghdr *nlh;tstruct genlmsghdr *ghdr;tstruct rtattr *tb[CTRL_ATTR_MAX + 1];tstruct rtattr *tb2[GENL_MAX_FAM_GRPS + 1];tstruct rtattr *tb3[CTRL_ATTR_MCAST_GRP_MAX + 1];tstruct rtattr *attrs;tint i, len, ret = -1;tstruct {ttstruct nlmsghdr n;ttchar buf[4096];t} req;tif (rtnl_open_byproto(&rth, 0, NETLINK_GENERIC)) {ttlog_error(""genl: cannot open rtnetlink"");ttreturn -1;t}tnlh = &req.n;tnlh->nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);tnlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;tnlh->nlmsg_type = GENL_ID_CTRL;tghdr = NLMSG_DATA(&req.n);tghdr->cmd = CTRL_CMD_GETFAMILY;taddattr_l(nlh, 128, CTRL_ATTR_FAMILY_NAME, family, strlen(family) + 1);tif (rtnl_talk(&rth, nlh, 0, 0, nlh, NULL, NULL, 0) < 0 ) {ttlog_error(""genl: error talking to kernel"");ttgoto out;t}tif (nlh->nlmsg_type != GENL_ID_CTRL) {ttlog_error(""genl: not a controller message %d"", nlh->nlmsg_type);ttgoto out;t}tghdr = NLMSG_DATA(nlh);tif (ghdr->cmd != CTRL_CMD_NEWFAMILY) {ttlog_error(""genl: unknown controller command %d"", ghdr->cmd);ttgoto out;t}tlen = nlh->nlmsg_len - NLMSG_LENGTH(GENL_HDRLEN);tif (len < 0) {ttlog_error(""genl: wrong controller message len %d"", len);ttgoto out;t}tattrs = (struct rtattr *)((char *)ghdr + GENL_HDRLEN);tparse_rtattr(tb, CTRL_ATTR_MAX, attrs, len);tif (!tb[CTRL_ATTR_FAMILY_ID]) {ttlog_error(""genl: missing CTRL_FAMILY_ID attribute"");ttgoto out;t}tif (!tb[CTRL_ATTR_MCAST_GROUPS])ttgoto out;ttif (fam_id)tt*fam_id =t*(uint32_t *)(RTA_DATA(tb[CTRL_ATTR_FAMILY_ID]));ttparse_rtattr_nested(tb2, GENL_MAX_FAM_GRPS, tb[CTRL_ATTR_MCAST_GROUPS]);ttfor (i = 1; i < GENL_MAX_FAM_GRPS; i++) {ttif (tb2[i]) {tttparse_rtattr_nested(tb3, CTRL_ATTR_MCAST_GRP_MAX, tb2[i]);tttif (!tb3[CTRL_ATTR_MCAST_GRP_ID] || !tb3[CTRL_ATTR_MCAST_GRP_NAME])ttttcontinue;tttif (strcmp(RTA_DATA(tb3[CTRL_ATTR_MCAST_GRP_NAME]), name))ttttcontinue;tttret =t*(uint32_t *)(RTA_DATA(tb3[CTRL_ATTR_MCAST_GRP_ID]));tttbreak;tt}t}out:trtnl_close(&rth);treturn ret;}",2,"cwe119,cwe120"
"scm_i_print_isym (SCM isym, SCM port){  const size_t isymnum = ISYMNUM (isym);  if (isymnum < (sizeof isymnames / sizeof (char *)))    scm_puts (isymnames[isymnum], port);  else    scm_ipruk (""isym"", isym, port);}",2,"cwe119,cwe120"
"cpor_key_store(const pdp_ctx_t *ctx, const pdp_key_t *k, const char *path){    int err, status = -1;    pdp_cpor_key_t *key = NULL;    char pri_keypath[MAXPATHLEN];      char pub_keypath[MAXPATHLEN];      FILE *pub_key = NULL;    FILE *pri_key = NULL;    unsigned char *Zp = NULL;    size_t Zp_size = 0;    if (!is_cpor(ctx) || !k || !path || (strlen(path) > MAXPATHLEN))        return -1;    key = k->cpor;         err = get_key_paths(pri_keypath, sizeof(pri_keypath),                        pub_keypath, sizeof(pub_keypath), path, ""cpor"");    if (err) goto cleanup;    if ((access(pri_keypath, F_OK) == 0) || (access(pub_keypath, F_OK) == 0)) {                 status = 0;        goto cleanup;    }         if ((pri_key = fopen(pri_keypath, ""w"")) == NULL) goto cleanup;    if ((pub_key = fopen(pub_keypath, ""w"")) == NULL) goto cleanup;    fwrite(&key->k_enc_size, sizeof(size_t), 1, pri_key);    if (ferror(pri_key)) goto cleanup;    fwrite(key->k_enc, key->k_enc_size, 1, pri_key);    if (ferror(pri_key)) goto cleanup;    fwrite(&key->k_mac_size, sizeof(size_t), 1, pri_key);    if (ferror(pri_key)) goto cleanup;    fwrite(key->k_mac, key->k_mac_size, 1, pri_key);    if (ferror(pri_key)) goto cleanup;    Zp_size = BN_num_bytes(key->Zp);    fwrite(&Zp_size, sizeof(size_t), 1, pri_key);    fwrite(&Zp_size, sizeof(size_t), 1, pub_key);    if ((Zp = malloc(Zp_size)) == NULL) goto cleanup;    memset(Zp, 0, Zp_size);    if (!BN_bn2bin(key->Zp, Zp)) goto cleanup;    fwrite(Zp, Zp_size, 1, pri_key);    fwrite(Zp, Zp_size, 1, pub_key);        status = 0;cleanup:    if (pri_key) fclose(pri_key);    if (pub_key) fclose(pub_key);    sfree(Zp, Zp_size);    if (status != 0) {        PDP_ERR(""Did not write key pair successfully."");        if (access(pub_keypath, F_OK) == 0) unlink(pub_keypath);        if (access(pri_keypath, F_OK) == 0) unlink(pri_keypath);    }    return status;}",3,"cwe119,cwe120,cweother"
"_compare_ints(_cs_io_t         *inp1,              _cs_io_t         *inp2,              const long long   cmp1[],              const long long   cmp2[],              size_t            block_start,              size_t            block_size,              size_t            n_echo,              long long        *n_echo_cur){  size_t i;  size_t n_diffs = 0;  for (i = 0; i < block_size; i++) {    if (cmp1[i] != cmp2[i])      n_diffs++;  }  if (n_diffs > 0) {    if (*n_echo_cur < 0) {      _echo_diff_headers(inp1, inp2);      *n_echo_cur = 0;    }    for (i = 0; i < block_size && (size_t)(*n_echo_cur) < n_echo; i++) {      if (cmp1[i] != cmp2[i]) {        unsigned long long j = block_start + i + 1;        printf(""    %12llu:  %lld  | %lld"", j, cmp1[i], cmp2[i]);        *n_echo_cur += 1;      }    }  }  return n_diffs;}",2,"cwe119,cwe120"
"mcxIOopen(  mcxIO*   xf,  mcxOnFail      ON_FAIL)   {  const char* fname    =  xf->fn->str   ;  if (!xf)      {  mcxErr(""mcxIOnew PBD"", ""received void object"")      ;  if (ON_FAIL == RETURN_ON_FAIL)         return STATUS_FAIL      ;  exit(1)   ;  }      if (mcxIOwarnOpenfp(xf, ""mcxIOopen PBD""))      return STATUS_OK   ;  if (!strcmp(fname, ""-""))      {  if (strchr(xf->mode, 'r'))         xf->fp =  stdin      ;  else if (strchr(xf->mode, 'w') || strchr(xf->mode, 'a'))         xf->fp =  stdout   ;  }      else if      (  !strcmp(fname, ""stderr"")      && (strchr(xf->mode, 'w') || strchr(xf->mode, 'a'))      )      xf->fp =  stderr   ;  else if ((xf->fp = fopen(fname, xf->mode)) == NULL)      {  if (ON_FAIL == RETURN_ON_FAIL)         return STATUS_FAIL      ;  mcxIOerr(xf, ""mcxIOopen"", ""can not be opened"")      ;  mcxExit(1)   ;  }      return STATUS_OK;  }",2,"cwe469,cweother"
"fits_check_endian(const qfits_header* header) {    char* filestr;    char* localstr;tchar pretty[FITS_LINESZ+1];tfilestr = qfits_header_getstr(header, ""ENDIAN"");    if (!filestr) {                 return 1;    }tqfits_pretty_string_r(filestr, pretty);tfilestr = pretty;    localstr = fits_get_endian_string();tif (strcmp(filestr, localstr)) {ttfprintf(stderr, ""File was written with endianness %s, this machine has endianness %s."", filestr, localstr);ttreturn -1;t}    return 0;}",2,"cwe119,cwe120"
"dev_vprintk_emit(int level, const struct device *dev,tt     const char *fmt, va_list args){tchar hdr[128];tsize_t hdrlen;thdrlen = create_syslog_header(dev, hdr, sizeof(hdr));treturn vprintk_emit(0, level, hdrlen ? hdr : NULL, hdrlen, fmt, args);}",2,"cwe119,cwe120"
hit_paddle(struct state *st){  if ( st->ball.x + st->ball.w >= st->r_paddle.x &&       st->bx > 0 )      {      if ((st->ball.y + st->ball.h > st->r_paddle.y) &&          (st->ball.y < st->r_paddle.y + st->r_paddle.h))        {          st->bx=-st->bx;          st->l_paddle.wait = 0;          st->r_paddle.wait = 1;          st->r_paddle.lock = 0;          st->l_paddle.lock = 0;        }      else        {          if (st->clock)          {            reset_score(st);          }          else          {            st->r_paddle.score++;            if (st->r_paddle.score >=10)              new_game(st);            else               start_game(st);          }        }    }  if (st->ball.x <= st->l_paddle.x + st->l_paddle.w &&      st->bx < 0 )      {      if ( st->ball.y + st->ball.h > st->l_paddle.y &&           st->ball.y < st->l_paddle.y + st->l_paddle.h)        {          st->bx=-st->bx;          st->l_paddle.wait = 1;          st->r_paddle.wait = 0;          st->r_paddle.lock = 0;          st->l_paddle.lock = 0;        }      else        {          if (st->clock)          {            reset_score(st);          }          else          {            st->l_paddle.score++;            if (st->l_paddle.score >= 10)              new_game(st);            else              start_game(st);          }        }    }},3,"cwe119,cwe120,cweother"
"set_loess_fit (GPT_SPEC *spec, int d, double q, gretl_matrix *x,ttt  gretl_matrix *y, gretl_matrix *yh){    int t, T = gretl_vector_get_length(y);    double *data;    data = realloc(spec->data, 3 * T * sizeof *data);    if (data == NULL) {treturn E_ALLOC;    }    for (t=0; t<T; t++) {tdata[t] = x->val[t];tdata[t+T] = y->val[t];tdata[t+2*T] = yh->val[t];    }    spec->data = data;    spec->nobs = spec->okobs = T;    sprintf(spec->lines[1].title, _(""loess fit, d = %d, q = %g""), d, q);    spec->lines[1].scale = 1.0;    spec->lines[1].pscale = NADBL;    spec->lines[1].style = GP_STYLE_LINES;    spec->lines[1].ncols = 2;    spec->fit = PLOT_FIT_LOESS;    return 0;}",2,"cwe120,cweother"
"sec80211_install ( struct net80211_crypto **which,tt       enum net80211_crypto_alg crypt,tt       const void *key, int len, const void *rsc ){tstruct net80211_crypto *crypto = *which;tstruct net80211_crypto *tbl_crypto;t tfree ( *which );t*which = NULL;tif ( crypt == NET80211_CRYPT_NONE ) {ttDBG ( ""802.11-Sec not installing null cryptography"" );ttreturn 0;t}t tfor_each_table_entry ( tbl_crypto, NET80211_CRYPTOS ) {ttif ( tbl_crypto->algorithm == crypt ) {tttcrypto = zalloc ( sizeof ( *crypto ) +ttttt  tbl_crypto->priv_len );tttif ( ! crypto ) {ttttDBG ( ""802.11-Sec out of memory"" );ttttreturn -ENOMEM;ttt}tttmemcpy ( crypto, tbl_crypto, sizeof ( *crypto ) );tttcrypto->priv = ( ( void * ) crypto +ttttt sizeof ( *crypto ) );tttbreak;tt}t}tif ( ! crypto ) {ttDBG ( ""802.11-Sec no support for cryptosystem %d"", crypt );ttreturn -( ENOTSUP | EUNIQ_10 | ( crypt << 8 ) );t}t*which = crypto;tDBG ( ""802.11-Sec installing cryptosystem %d as %p with key of ""t      ""length %d"", crypt, crypto, len );treturn crypto->init ( crypto, key, len, rsc );}",2,"cwe120,cweother"
"ipvideo_decode_0xf (const GstMveDemuxStream * s, unsigned char *frame,    const unsigned char **data, unsigned short *len){  int x, y;  unsigned char P[2];     CHECK_STREAM (len, 2);  P[0] = *(*data)++;  P[1] = *(*data)++;  for (y = 0; y < 8; ++y) {    for (x = 0; x < 4; ++x) {      *frame++ = P[y & 1];      *frame++ = P[(y & 1) ^ 1];    }    frame += s->width - 8;  }  return 0;}",2,"cwe119,cwe120"
"mgmt_add_uuid(int index, uuid_t *uuid, uint8_t svc_hint){tchar buf[MGMT_HDR_SIZE + sizeof(struct mgmt_cp_add_uuid)];tstruct mgmt_hdr *hdr = (void *) buf;tstruct mgmt_cp_add_uuid *cp = (void *) &buf[sizeof(*hdr)];tstruct controller_info *info = &controllers[index];tuuid_t uuid128;tuint128_t uint128;tDBG(""index %d"", index);tif (info->pending_uuid) {ttstruct pending_uuid *pending = g_new0(struct pending_uuid, 1);ttmemcpy(&pending->uuid, uuid, sizeof(*uuid));ttpending->svc_hint = svc_hint;ttinfo->pending_uuids = g_slist_append(info->pending_uuids,ttttttttpending);ttreturn 0;t}tuuid_to_uuid128(&uuid128, uuid);tmemset(buf, 0, sizeof(buf));thdr->opcode = htobs(MGMT_OP_ADD_UUID);thdr->len = htobs(sizeof(*cp));thdr->index = htobs(index);tntoh128((uint128_t *) uuid128.value.uuid128.data, &uint128);thtob128(&uint128, (uint128_t *) cp->uuid);tcp->svc_hint = svc_hint;tif (write(mgmt_sock, buf, sizeof(buf)) < 0)ttreturn -errno;tinfo->pending_uuid = TRUE;treturn 0;}",2,"cwe119,cwe120"
"MonEntropyClassesSet(const char *service, const char *direction, double entropy){char class[CF_MAXVARSIZE];const char *class_type = ""medium"";if (entropy > 0.9)   {   class_type = ""high"";   }if (entropy < 0.2)   {   class_type = ""low"";   }snprintf(class, CF_MAXVARSIZE, ""entropy_%s_%s_%s"", service, direction, class_type);AppendItem(&ENTROPIES,class,"""");}",2,"cwe119,cwe120"
"evaluate_realm(char *cmdline) {#ifdef GSSAPItchar *word;tchar buf[1024];tint n;tif (realm != NULL) {ttisc_mem_free(mctx, realm);ttrealm = NULL;t}tword = nsu_strsep(&cmdline, "" tr"");tif (word == NULL || *word == 0)ttreturn (STATUS_MORE);tn = snprintf(buf, sizeof(buf), ""@%s"", word);tif (n < 0 || (size_t)n >= sizeof(buf))ttfatal(""realm is too long"");trealm = isc_mem_strdup(mctx, buf);tif (realm == NULL)ttfatal(""out of memory"");treturn (STATUS_MORE);#elsetUNUSED(cmdline);treturn (STATUS_SYNTAX);#endif}",2,"cwe119,cwe120"
"create_text( char *orig_str, int char_width ){    int i, j;    int pos;    int last_space;    int new_line;    Text *text = 0;    char *str = 0;    text = calloc ( 1, sizeof( Text ) );         str = strdup( orig_str );         repl_new_lines( str );                   if ( char_width > 0 ) {        pos = 0;        while ( pos < strlen( str ) ) {            last_space = 0;            new_line = 0;            i = 0;            while ( !new_line && i < char_width && i + pos < strlen( str ) ) {                switch ( str[pos + i] ) {                    case '#': new_line = 1;                    case 32: last_space = i; break;                }                i++;            }            if ( i + pos >= strlen( str ) ) break;            if ( last_space == 0 ) {                                 last_space = char_width / 2;            }            str[pos + last_space] = 10;            pos += last_space;        }    }         if ( char_width > 0 ) {        for ( i = 0; i < strlen( str ); i++ )            if ( str[i] == 10 )                text->count++;                 if ( str[strlen( str ) - 1] != 10 )            text->count++;    }    else        text->count = 1;         text->lines = calloc( text->count, sizeof( char* ) );    pos = 0;         for ( j = 0; j < text->count; j++ ) {        i = 0;        while ( pos + i < strlen( str ) && str[pos + i] != 10 ) i++;        text->lines[j] = calloc( i + 1, sizeof( char ) );        strncpy( text->lines[j], str + pos, i );        text->lines[j][i] = 0;        pos += i; pos++;    }    if ( text->count == 0 )        fprintf( stderr, ""conv_to_text: warning: line_count is 0"" );    free( str );    return text;}",2,"cwe120,cweother"
"show_one_commit(struct commit *commit, int no_name){tstruct strbuf pretty;tconst char *pretty_str = ""(unavailable)"";tstruct commit_name *name = commit->util;tstrbuf_init(&pretty, 0);tif (commit->object.parsed) {ttpretty_print_commit(CMIT_FMT_ONELINE, commit,tttt    &pretty, 0, NULL, NULL, 0, 0);ttpretty_str = pretty.buf;t}tif (!prefixcmp(pretty_str, ""[PATCH] ""))ttpretty_str += 8;tif (!no_name) {ttif (name && name->head_name) {tttprintf(""[%s"", name->head_name);tttif (name->generation) {ttttif (name->generation == 1)tttttprintf(""^"");ttttelsetttttprintf(""~%d"", name->generation);ttt}tttprintf(""] "");tt}ttelsetttprintf(""[%s] "",ttt       find_unique_abbrev(commit->object.sha1, 7));t}tputs(pretty_str);tstrbuf_release(&pretty);}",2,"cwe119,cwe120"
"gssdp_resource_browser_set_target (GSSDPResourceBrowser *resource_browser,                                   const char           *target){        char *pattern;        char *version;        char *version_pattern;        GError *error;        g_return_if_fail (GSSDP_IS_RESOURCE_BROWSER (resource_browser));        g_return_if_fail (target != NULL);        g_return_if_fail (!resource_browser->priv->active);                g_free (resource_browser->priv->target);        resource_browser->priv->target = g_strdup (target);        if (resource_browser->priv->target_regex)                g_regex_unref (resource_browser->priv->target_regex);        version_pattern = ""([0-9]+)"";                 pattern = g_strndup (target,                             strlen (target) + strlen (version_pattern));        version = g_strrstr (pattern, "":"");        if (version != NULL &&            (g_strstr_len (pattern, -1, ""uuid:"") != pattern ||             version != g_strstr_len (pattern, -1, "":"")) &&            g_regex_match_simple (version_pattern,                                  version + 1,                                  G_REGEX_ANCHORED,                                  G_REGEX_MATCH_ANCHORED)) {                resource_browser->priv->version = atoi (version + 1);                strcpy (version + 1, version_pattern);        }        error = NULL;        resource_browser->priv->target_regex = g_regex_new (pattern,                                                            0,                                                            0,                                                            &error);        if (error) {                g_warning (""Error compiling regular expression '%s': %s"",                           pattern,                           error->message);                g_error_free (error);        }        g_free (pattern);        g_object_notify (G_OBJECT (resource_browser), ""target"");}",2,"cwe120,cweother"
"parse_setEvent( const char *token, char *line ){    char   ename[MTE_STR1_LEN+1];    char   buf[SPRINT_MAX_LEN];    oid    name_buf[MAX_OID_LEN];    size_t name_buf_len;    long   value;    int    wild = 1;    struct mteEvent  *entry;    char  *cp;    DEBUGMSGTL((""disman:event:conf"", ""Parsing setEvent config...  ""));    memset( ename, 0, sizeof(ename));    cp = copy_nword(line, ename,  MTE_STR1_LEN);    if (!cp || ename[0] == '0') {        config_perror(""syntax error: no event name"");        return;    }    if (cp && *cp=='-' && *(cp+1)=='I') {        wild = 0;                        cp = skip_token( cp );    }         cp = copy_nword(cp, buf,  SPRINT_MAX_LEN);    if ( buf[0] == '0' ) {        config_perror(""syntax error: no set OID"");        return;    }    name_buf_len = MAX_OID_LEN;    if (!snmp_parse_oid(buf, name_buf, &name_buf_len)) {        snmp_log(LOG_ERR, ""setEvent OID: %s"", buf);        config_perror(""unknown set OID"");        return;    }    if (cp && *cp == '=') {        cp = skip_token( cp );        }    if (!cp) {        config_perror(""syntax error: missing set value"");        return;    }    value = strtol( cp, NULL, 0);         entry = _find_typed_mteEvent_entry(""snmpd.conf"", ename, MTE_EVENT_SET);    if (!entry) {        return;    }    memcpy( entry->mteSetOID, name_buf, name_buf_len*sizeof(oid));    entry->mteSetOID_len = name_buf_len;    entry->mteSetValue   = value;    if (wild)        entry->flags       |= MTE_SET_FLAG_OBJWILD;    entry->mteEventActions |= MTE_EVENT_SET;    entry->flags           |= MTE_EVENT_FLAG_ENABLED |                              MTE_EVENT_FLAG_ACTIVE  |                              MTE_EVENT_FLAG_FIXED   |                              MTE_EVENT_FLAG_VALID;    return;}",2,"cwe119,cwe120"
"upsdrv_shutdown(void){tunsigned char command[10], answer[10];t tif (! autorestart) {ttcommand[0]=UPS_SET_TIMES_ON_BATTERY;ttcommand[1]=0x00;ttttt  ttcommand[2]=0x00;ttttt ttttcommand[3]=0x00;ttttt ttcommand[4]=0x00;ttttt ttttcommand[5]=0x01;ttttt ttcommand_write_sequence(command, 6, answer);t}t tcommand[0]=UPS_SET_SCHEDULING;tttcommand[1]=0x96;ttttt tcommand[2]=0x00;ttttt tcommand[3]=0x00;ttttt tcommand[4]=0x00;ttttt t tcommand[5]=0x01;ttttt tcommand[6]=0x00;ttttt tcommand[7]=0x00;ttttt tcommand[8]=0x00;ttttt tcommand_write_sequence(command, 9, answer);t t t }",2,"cwe119,cwe120"
"""json_read_double(InputStream * inp) {    char buf[256];    int pos = 0;    double n = 0;    char * end = buf;    for (;;) {        int ch = peek_stream(inp);        switch (ch) {        case '0':        case '1':        case '2':        case '3':        case '4':        case '5':        case '6':        case '7':        case '8':        case '9':        case '-':        case '+':        case 'e':        case 'E':        case '.':            if (pos >= (int)sizeof(buf) - 1) exception(ERR_BUFFER_OVERFLOW);            buf[pos++] = (char)read_stream(inp);            continue;        }        break;    }    if (pos == 0) exception(ERR_JSON_SYNTAX);    buf[pos++] = 0;    n = strtod(buf, &end);    if (*end != 0) exception(ERR_JSON_SYNTAX);    return n;}""",2,"cwe119,cwe120"
"send_packet6(struct interface_info *interface,tt     const unsigned char *raw, size_t len,tt     struct sockaddr_in6 *to) {tstruct msghdr m;tstruct iovec v;tstruct sockaddr_in6 dst;tint result;tstruct in6_pktinfo *pktinfo;tstruct cmsghdr *cmsg;tunsigned int ifindex;t tif (control_buf == NULL) {ttallocate_cmsg_cbuf();ttif (control_buf == NULL) {tttlog_error(""send_packet6: unable to allocate cmsg header"");tttreturn(ENOMEM);tt}t}tmemset(control_buf, 0, control_buf_len);t tmemset(&m, 0, sizeof(m));t tmemcpy(&dst, to, sizeof(dst));tm.msg_name = &dst;tm.msg_namelen = sizeof(dst);tifindex = if_nametoindex(interface->name);tif (no_global_v6_socket)ttdst.sin6_scope_id = ifindex;t tv.iov_base = (char *)raw;tv.iov_len = len;tm.msg_iov = &v;tm.msg_iovlen = 1;t tm.msg_control = control_buf;tm.msg_controllen = control_buf_len;tcmsg = CMSG_FIRSTHDR(&m);tcmsg->cmsg_level = IPPROTO_IPV6;tcmsg->cmsg_type = IPV6_PKTINFO;tcmsg->cmsg_len = CMSG_LEN(sizeof(*pktinfo));tpktinfo = (struct in6_pktinfo *)CMSG_DATA(cmsg);tmemset(pktinfo, 0, sizeof(*pktinfo));tpktinfo->ipi6_ifindex = ifindex;tm.msg_controllen = cmsg->cmsg_len;tresult = sendmsg(interface->wfdesc, &m, 0);tif (result < 0) {ttlog_error(""send_packet6: %m"");t}treturn result;}",2,"cwe120,cwe476"
"""esc(char c){    switch (c) {        case 'a': c = 'a'; break;        case 'b': c = 'b'; break;        case 'f': c = 'f'; break;        case 'n': c = ''; break;        case 'r': c = 'r'; break;        case 't': c = 't'; break;        case 'v': c = 'v'; break;        default:  break;    }    return (c);}""",2,"cwe119,cwe120"
"rc5t583_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm){tstruct rc5t583 *rc5t583 = dev_get_drvdata(dev->parent);tunsigned char alarm_data[NUM_YAL_REGS];tint ret;tret = rc5t583_rtc_alarm_irq_enable(dev, 0);tif (ret)ttreturn ret;talarm_data[0] = bin2bcd(alm->time.tm_min);talarm_data[1] = bin2bcd(alm->time.tm_hour);talarm_data[2] = bin2bcd(alm->time.tm_mday);talarm_data[3] = bin2bcd(alm->time.tm_mon + 1);talarm_data[4] = bin2bcd(alm->time.tm_year - 100);tret = regmap_bulk_write(rc5t583->regmap, RC5T583_RTC_AY_MIN, alarm_data,ttNUM_YAL_REGS);tif (ret) {ttdev_err(dev, ""rtc_set_alarm error %d"", ret);ttreturn ret;t}tif (alm->enabled)ttret = rc5t583_rtc_alarm_irq_enable(dev, 1);treturn ret;}",2,"cwe119,cwe120"
"kdb5_ldap_destroy_policy(int argc, char *argv[]){    char *me = progname;    krb5_error_code retval = 0;    krb5_ldap_policy_params *policyparams = NULL;    krb5_boolean print_usage = FALSE;    krb5_boolean no_msg = FALSE;    char *policy = NULL;    int mask = 0;    int force = 0;    char buf[5] = {0};    int i = 0;    if ((argc < 2) || (argc > 3)) {        goto err_usage;    }    for (i = 1; i < argc; i++) {        if (strcmp(argv[i], ""-force"") == 0) {            force++;        } else {                           if (policy != NULL)                goto err_usage;                         policy = strdup(argv[i]);            if (policy == NULL) {                retval = ENOMEM;                com_err(me, retval, _(""while destroying policy object""));                goto err_nomsg;            }        }    }    if (policy == NULL)        goto err_usage;    if (!force) {        printf(_(""This will delete the policy object '%s', are you sure?""),               policy);        printf(_(""(type 'yes' to confirm)? ""));        if (fgets(buf, sizeof(buf), stdin) == NULL) {            retval = EINVAL;            goto cleanup;        }        if (strcmp(buf, yes)) {            exit_status++;            goto cleanup;        }    }    if ((retval = init_ldap_realm (argc, argv)))        goto err_nomsg;    if ((retval = krb5_ldap_read_policy(util_context, policy, &policyparams, &mask)))        goto cleanup;    if ((retval = krb5_ldap_delete_policy(util_context, policy)))        goto cleanup;    printf(""** policy object '%s' deleted."", policy);    goto cleanup;err_usage:    print_usage = TRUE;err_nomsg:    no_msg = TRUE;cleanup:         krb5_ldap_free_policy (util_context, policyparams);    if (policy) {        free (policy);    }    if (print_usage) {        db_usage(DESTROY_POLICY);    }    if (retval) {        if (!no_msg)            com_err(me, retval, _(""while destroying policy object""));        exit_status++;    }    return;}",3,"cwe119,cwe120,cwe469"
"__ecereMethod_Workspace_UpdateSourceDirsArray(struct __ecereNameSpace__ecere__com__Instance * this, struct __ecereNameSpace__ecere__com__Instance * dirs){struct Workspace * __ecerePointer_Workspace = (struct Workspace *)(this ? (((char *)this) + __ecereClass_Workspace->offset) : 0);unsigned char * tokens[256];int c, numTokens;((void (*)(struct __ecereNameSpace__ecere__com__Instance *))__extension__ ({struct __ecereNameSpace__ecere__com__Instance * __internal_ClassInst = __ecerePointer_Workspace->sourceDirs;__internal_ClassInst ? __internal_ClassInst->_vTbl : __ecereClass___ecereNameSpace__ecere__com__List->_vTbl;})[__ecereVMethodID___ecereNameSpace__ecere__com__Container_Free])(__ecerePointer_Workspace->sourceDirs);{char ** s;struct __ecereNameSpace__ecere__com__Instance * __internalArray = (dirs);for(s = (char **)((struct __ecereNameSpace__ecere__com__Array *)(((char *)__internalArray + 24)))->array; s < (char **)((struct __ecereNameSpace__ecere__com__Array *)(((char *)__internalArray + 24)))->array + ((struct __ecereNameSpace__ecere__com__Array *)(((char *)__internalArray + 24)))->count; s++)((struct __ecereNameSpace__ecere__com__IteratorPointer * (*)(struct __ecereNameSpace__ecere__com__Instance *, uint64 value))__extension__ ({struct __ecereNameSpace__ecere__com__Instance * __internal_ClassInst = __ecerePointer_Workspace->sourceDirs;__internal_ClassInst ? __internal_ClassInst->_vTbl : __ecereClass___ecereNameSpace__ecere__com__List->_vTbl;})[__ecereVMethodID___ecereNameSpace__ecere__com__Container_Add])(__ecerePointer_Workspace->sourceDirs, (uint64)(__ecereFunction___ecereNameSpace__ecere__sys__CopyString((*s))));}__ecereMethod_Workspace_DropInvalidBreakpoints(this, (((void *)0)));(__ecereNameSpace__ecere__com__eInstance_DecRef(dirs), dirs = 0);}",3,"cwe119,cwe120,cwe476"
"find_in_subdir (const char *topdir, char *fname, int code){    DIR *dir;    struct dirent *dirent;    char finddir[MAXLEN];    int found = 0;         make_findname(finddir, topdir);    dir = opendir(finddir);    if (dir != NULL) {twhile (!found && (dirent = readdir(dir))) {t    if (got_subdir(finddir, dirent)) {ttfound = try_open_file(fname, finddir, dirent, code);t    }t}tclosedir(dir);    }    return found;}",2,"cwe119,cwe120"
"I_ReadSigSet(FILE * fd, struct SigSet *S){    char tag[256];    I_InitSigSet(S);    while (gettag(fd, tag)) {tif (eq(tag, ""title:""))t    get_title(fd, S);tif (eq(tag, ""nbands:""))t    get_nbands(fd, S);tif (eq(tag, ""class:""))t    get_class(fd, S);    }    return 1;ttt }",3,"cwe119,cwe120,cwe469"
"date_test_defmt(char *fmt, char *input){tstatic int i;tchar dbuf[11];tdate d;tint q, r;tr = rdefmtdate(&d, fmt, input);tprintf(""r: %d "", r);tif (r == 0)t{ttq = rdatestr(d, dbuf);ttprintf(""q: %d "", q);ttif (q == 0)tt{tttprintf(""date %d: %s"", i++, dbuf);tt}ttelsetttprintf("""");t}telsettcheck_return(r);}",2,"cwe119,cwe120"
"display_args_err(char *s, char **a, int err){    char  errstr[256], *errp;    FILE *fp = err ? stderr : stdout;    if(err && s){tsnprintf(errp = errstr, sizeof(errstr), ""%s: %s"", _(""Argument Error""), s);terrstr[sizeof(errstr)-1] = '0';    }    else      errp = s;#ifdeft_WINDOWS    if(errp)      mswin_messagebox(errp, err);    if(a && *a){tos_argsdialog(a);    }#else    if(errp)      fprintf(fp, ""%s"", errp);    while(a && *a)      fprintf(fp, ""%s"", *a++);#endif}",2,"cwe119,cwe120"
"mo_open_write(struct cdrom_device_info *cdi){tstruct packet_command cgc;tchar buffer[255];tint ret;tinit_cdrom_command(&cgc, &buffer, 4, CGC_DATA_READ);tcgc.quiet = 1;t tret = cdrom_mode_sense(cdi, &cgc, GPMODE_ALL_PAGES, 0);tif (ret)ttret = cdrom_mode_sense(cdi, &cgc, GPMODE_VENDOR_PAGE, 0);tif (ret) {ttcgc.buflen = 255;ttret = cdrom_mode_sense(cdi, &cgc, GPMODE_ALL_PAGES, 0);t}t tif (ret)ttreturn 0;treturn buffer[3] & 0x80;}",2,"cwe119,cwe120"
"e2_network_discovery(void){tfd_set rfds;tint fd, len;tSANE_Status status;tchar *ip, *query = ""EPSONPx00xffx00x00x00x00x00x00x00"";tunsigned char buf[76];tstruct timeval to;tstatus = sanei_udp_open_broadcast(&fd);tif (status != SANE_STATUS_GOOD)ttreturn;tsanei_udp_write_broadcast(fd, 3289, (unsigned char *) query, 15);tDBG(5, ""%s, sent discovery packet"", __func__);tto.tv_sec = 1;tto.tv_usec = 0;tFD_ZERO(&rfds);tFD_SET(fd, &rfds);tsanei_udp_set_nonblock(fd, SANE_TRUE);tif (select(fd + 1, &rfds, NULL, NULL, &to) > 0) {ttwhile ((len = sanei_udp_recvfrom(fd, buf, 76, &ip)) == 76) {tttDBG(5, "" response from %s"", ip);ttt tttif (strncmp((char *) buf, ""EPSON"", 5) == 0)ttttattach_one_net(ip);tt}t}tDBG(5, ""%s, end"", __func__);tsanei_udp_close(fd);}",2,"cwe119,cwe120"
"packet_show_sock(struct nlmsghdr *nlh, struct filter *f){tstruct packet_diag_msg *r = NLMSG_DATA(nlh);tstruct rtattr *tb[PACKET_DIAG_MAX+1];t__u32 rq;tparse_rtattr(tb, PACKET_DIAG_MAX, (struct rtattr*)(r+1),tt     nlh->nlmsg_len - NLMSG_LENGTH(sizeof(*r)));t tif (!tb[PACKET_DIAG_MEMINFO])ttreturn -1;tif (netid_width)ttprintf(""%-*s "", netid_width,ttttr->pdiag_type == SOCK_RAW ? ""p_raw"" : ""p_dgr"");tif (state_width)ttprintf(""%-*s "", state_width, ""UNCONN"");tif (tb[PACKET_DIAG_MEMINFO]) {tt__u32 *skmeminfo = RTA_DATA(tb[PACKET_DIAG_MEMINFO]);ttrq = skmeminfo[SK_MEMINFO_RMEM_ALLOC];t} elsettrq = 0;tprintf(""%-6d %-6d "", rq, 0);tif (r->pdiag_num == 3) {ttprintf(""%*s:"", addr_width, ""*"");t} else {ttchar tb2[16];ttprintf(""%*s:"", addr_width,tt       ll_proto_n2a(htons(r->pdiag_num), tb2, sizeof(tb2)));t}tif (tb[PACKET_DIAG_INFO]) {ttstruct packet_diag_info *pinfo = RTA_DATA(tb[PACKET_DIAG_INFO]);ttif (pinfo->pdi_index == 0)tttprintf(""%-*s "", serv_width, ""*"");ttelsetttprintf(""%-*s "", serv_width, xll_index_to_name(pinfo->pdi_index));t} elsettprintf(""%-*s "", serv_width, ""*"");tprintf(""%*s*%-*s"",t       addr_width, """", serv_width, """");tif (show_users) {ttchar ubuf[4096];ttif (find_users(r->pdiag_ino, ubuf, sizeof(ubuf)) > 0)tttprintf("" users:(%s)"", ubuf);t}tif (show_details) {tt__u32 uid = 0;ttif (tb[PACKET_DIAG_UID])tttuid = *(__u32 *)RTA_DATA(tb[PACKET_DIAG_UID]);ttprintf("" ino=%u uid=%u sk="", r->pdiag_ino, uid);ttif (r->pdiag_cookie[1] != 0)tttprintf(""%08x"", r->pdiag_cookie[1]);ttprintf(""%08x"", r->pdiag_cookie[0]);t}tif (show_bpf && tb[PACKET_DIAG_FILTER]) {ttstruct sock_filter *fil =tt       RTA_DATA(tb[PACKET_DIAG_FILTER]);ttint num = RTA_PAYLOAD(tb[PACKET_DIAG_FILTER]) /ttt  sizeof(struct sock_filter);ttprintf(""tbpf filter (%d): "", num);ttwhile (num) {tttprintf("" 0x%02x %u %u %u,"",ttt      fil->code, fil->jt, fil->jf, fil->k);tttnum--;tttfil++;tt}t}tprintf("""");treturn 0;}",2,"cwe119,cwe120"
"authenticate_plaintext(const char * username, const char * password) {tunsigned char md5[16];tchar hexmd5[32 + 1] = { 0 };tunsigned ndigit;t tMD5((const unsigned char *) password, strlen(password), md5);tfor(ndigit = 0; ndigit < 16; ++ndigit)ttsprintf(2 * ndigit + hexmd5, ""%02x"", md5[ndigit]);treturn authenticate(username, hexmd5);}",2,"cwe119,cwe120"
"_iodbcdm_cfg_merge_filedsn (PCONFIG pconfig, const char *filedsn,ttt    char *buf, size_t buf_sz, int wide){  BOOL override;t   WORD len;  char *p, *p_next;  char entries[1024];  char value[1024];  char drv_value[1024] = {""0""};  char *tmp = NULL;  int rc = 0;     if (SQLReadFileDSN (filedsn, ""ODBC"", ""DRIVER"", value, sizeof (value), &len) &&      len > 0)    {             if (_iodbcdm_cfg_find (pconfig, ""ODBC"", ""DRIVER"") == 0 &&t  !strcasecmp (value, pconfig->value))        override = TRUE;      else        override = FALSE;    }  else    override = TRUE;     if (!SQLReadFileDSN (filedsn, ""ODBC"", NULL,tt       entries, sizeof (entries), &len))    return -1;     _iodbcdm_cfg_write (pconfig, ""ODBC"", ""DSN"", NULL);     for (p = entries; *p != '0'; p = p_next)    {             p_next = strchr (p, ';');      if (p_next)        *p_next++ = '0';      if ((override || !strcasecmp (p, ""DRIVER"")) &&t  _iodbcdm_cfg_find (pconfig, ""ODBC"", p) == 0)        {t             continue;        }      if (!SQLReadFileDSN (filedsn, ""ODBC"", p, value, sizeof(value), &len))        return -1;      _iodbcdm_cfg_write (pconfig, ""ODBC"", p, value);    }     _iodbcdm_cfg_write (pconfig, ""ODBC"", ""FILEDSN"", NULL);  if (_iodbcdm_cfg_find (pconfig, ""ODBC"", ""DRIVER"") == 0)    strncpy(drv_value, pconfig->value, sizeof(drv_value));     _iodbcdm_cfg_write (pconfig, ""ODBC"", ""DRIVER"", NULL);     if ((rc =_iodbcdm_cfg_to_string (pconfig, ""ODBC"", buf, buf_sz)) == -1)    goto done;  tmp = strdup(buf);  strncpy(buf, ""DRIVER="", buf_sz);  CATBUF(buf, drv_value, buf_sz);  CATBUF(buf, "";"", buf_sz);  CATBUF(buf, tmp, buf_sz);  MEM_FREE(tmp);  if (wide)    {      SQLWCHAR *_in = dm_SQL_U8toW (buf, SQL_NTS);      if (_in == NULL)        {          rc = -1;          goto done;        }      WCSNCPY (buf, _in, buf_sz / sizeof (SQLWCHAR));      MEM_FREE (_in);    }  rc = 0;done:  if (drv_value[0])    _iodbcdm_cfg_write (pconfig, ""ODBC"", ""DRIVER"", drv_value);      return rc;}",3,"cwe119,cwe120,cwe476"
"ConfigCoding(const char *confstr){  char *reg[3];    int n, i;    for(i = 0; i < 3 ; i++)      reg[i] = malloc(strlen(confstr) + 1);    *reg[0] = *reg[1] = *reg[2] = '0';    sscanf(confstr, ""%s %s %s"", reg[0], reg[1], reg[2]);      for (i = 0; i < 3 && *reg[i]; i ++) {tn = (int)CodingByRegistry(reg[i]);tif (n < 0) {t    if (!strcasecmp(reg[i], ""EUC""))ttlInfo.sc = CODE_EUC;t    else if (!strcasecmp(reg[i], ""SJIS""))ttlInfo.sc = CODE_SJIS; t    elsettlInfo.sc = 0;t} else if (n & CHR_DBC)t    lInfo.db = n & ~CHR_DFLD;telset    lInfo.sb = n & ~CHR_SFLD;#if 0{FILE *fp=fopen(""errlog"", ""a"");fprintf(fp,""[<%s> %d %d %d %d]"", reg[i], n, lInfo.sb, lInfo.db, lInfo.sc);fclose(fp);}#endif    }    return SUCCESS;}",3,"cwe119,cwe120,cweother"
"""courier_authdebug( const char *ofmt, const char *fmt, va_list ap ){tchartbuf[DEBUG_MESSAGE_SIZE];tintti;tinttlen;t/* print into buffer to be able to replace control and other unwanted chars. */tvsnprintf( buf, DEBUG_MESSAGE_SIZE, fmt, ap );tlen = strlen( buf );t/* replace nonprintable chars by dot */tfor( i=0 ; i<len ; i++ )ttif( !isprint(buf[i]) )tttbuf[i] = '.';t/* emit it */treturn fprintf( stderr, ofmt , buf );}""",3,"cwe119,cwe120,cweother"
"""skipcomment (LoadF *lf, int *cp) {  int c = *cp = skipBOM(lf);  if (c == '#') {  /* first line is a comment (Unix exec. file)? */    do {  /* skip first line */      c = getc(lf->f);    } while (c != EOF && c != '') ;    *cp = getc(lf->f);  /* skip end-of-line, if present */    return 1;  /* there was a comment */  }  else return 0;  /* no comment */}""",2,"cwe120,cweother"
"CSV_stats( Transfer_Info *stats ) {         max_size_t speed = (max_size_t)(((double)stats->TotalLen * 8.0) / (stats->endTime - stats->startTime));    char timestamp[16];    CSV_timestamp( timestamp, sizeof(timestamp) );    if ( stats->mUDP != (char)kMode_Server ) {                 printf( reportCSV_bw_format,                 timestamp,                 (stats->reserved_delay == NULL ? "",,,"" : stats->reserved_delay),                stats->transferID,                 stats->startTime,                 stats->endTime,                 stats->TotalLen,                 speed);    } else {                 printf( reportCSV_bw_jitter_loss_format,                 timestamp,                 (stats->reserved_delay == NULL ? "",,,"" : stats->reserved_delay),                stats->transferID,                 stats->startTime,                 stats->endTime,                 stats->TotalLen,                 speed,                stats->jitter*1000.0,                 stats->cntError,                 stats->cntDatagrams,                (100.0 * stats->cntError) / stats->cntDatagrams, stats->cntOutofOrder );    }    if ( stats->free == 1 && stats->reserved_delay != NULL ) {        free( stats->reserved_delay );    }}",3,"cwe119,cwe120,cweother"
"run_dsa_gen (int keysize, const char *filename){  gcry_sexp_t key, private_key;  FILE *fp;  key = dsa_gen (keysize);  private_key = gcry_sexp_find_token (key, ""private-key"", 0);  if (!private_key)    die (""private key not found in genkey result"");  print_dsa_domain_parameters (key);  fp = fopen (filename, ""wb"");  if (!fp)    die (""can't create `%s': %s"", filename, strerror (errno));  print_sexp (private_key, fp);  fclose (fp);  gcry_sexp_release (private_key);  gcry_sexp_release (key);}",2,"cwe469,cweother"
"is_dir_empty(char *path){    char fullpath[PATH_MAX];    struct stat64 statbuf;    struct dirent *dir;    DIR *dirdesc;        dirdesc = opendir(path);    if (!dirdesc)    {      sysprintf(""cannot open directory %s"", path);        return -1;    }        while ((dir = readdir(dirdesc)) != NULL)    {        concatenate_paths(fullpath, sizeof(fullpath), path, dir->d_name);        if (lstat64(fullpath, &statbuf)!=0)        {   sysprintf (""cannot stat %s"", fullpath);            closedir(dirdesc);            return -1;        }        if (strcmp(dir->d_name,""."")!=0 && strcmp(dir->d_name,"".."")!=0)        {            closedir(dirdesc);            return 1;          }            }    closedir(dirdesc);    return 0;}",3,"cwe119,cwe120,cwe469"
"lam_send_selected_ssi_modules(void){  lam_ssi_module_t *module;  lam_ssi_rpi_t rpi;  lam_ssi_crmpi_t crmpi;  struct nmsg nhead;  struct mpi_app_extra_info maei;  if (0 == getenv(""LAMRANK""))    return LAMERROR;     LAM_ZERO_ME(maei);  LAM_ZERO_ME(nhead);  nhead.nh_node = _kio.ki_jobid.jid_node;  nhead.nh_event = (-_kio.ki_jobid.jid_pid) & 0xBFFFFFFF;  nhead.nh_type = 2;  nhead.nh_flags = DINT4DATA;     nhead.nh_data[0] = lam_myproc->p_gps.gps_grank;  nhead.nh_length = sizeof(maei);  nhead.nh_msg = (char *) &maei;     module = (lam_ssi_module_t *) al_top(lam_ssi_rpi_base_available);  rpi = *((lam_ssi_rpi_t *) module->lsm_module);  memcpy(maei.maei_rpi.masi_name,          rpi.lsr_meta_info.ssi_module_name,          sizeof(maei.maei_rpi.masi_name));   maei.maei_rpi.masi_major_ver =    ltot(rpi.lsr_meta_info.ssi_module_major_version);  maei.maei_rpi.masi_minor_ver =    ltot(rpi.lsr_meta_info.ssi_module_minor_version);  maei.maei_rpi.masi_release_ver =    ltot(rpi.lsr_meta_info.ssi_module_release_version);     if (mpi_nparent == 0) {    if (lam_ssi_crmpi_base_available != NULL) {      module = (lam_ssi_module_t *) al_top(lam_ssi_crmpi_base_available);    }  } else {    module = NULL;  }  if ((NULL == lam_ssi_crmpi_base_available) ||       (NULL == module)) {    strcpy(maei.maei_crmpi.masi_name, ""none"");    maei.maei_crmpi.masi_major_ver = -1;    maei.maei_crmpi.masi_minor_ver = -1;    maei.maei_crmpi.masi_release_ver = -1;  } else {    crmpi = *((lam_ssi_crmpi_t *) module->lsm_module);    memcpy(maei.maei_crmpi.masi_name,           crmpi.lscrm_meta_info.ssi_module_name,           sizeof(maei.maei_crmpi.masi_name));    maei.maei_crmpi.masi_major_ver =      ltot(crmpi.lscrm_meta_info.ssi_module_major_version);    maei.maei_crmpi.masi_minor_ver =      ltot(crmpi.lscrm_meta_info.ssi_module_minor_version);    maei.maei_crmpi.masi_release_ver =      ltot(crmpi.lscrm_meta_info.ssi_module_release_version);  }  if (nsend(&nhead))    return LAMERROR;   return 0;}",3,"cwe120,cwe469,cweother"
"printcol (DISPLAY *dp){  static FTSENT **array;  static int lastentries = -1;  FTSENT *p;  int base, chcnt, col, colwidth, num;  int numcols, numrows, row;  if ((colwidth = compute_columns (dp, &numcols)) == 0)    return;     if (dp->entries > lastentries)    {      FTSENT **a;      if ((a = realloc (array, dp->entries * sizeof (FTSENT *))) == NULL)t{t  fprintf (stderr, ""realloci: %s "", strerror (errno));t  printscol (dp);t  return;t}      lastentries = dp->entries;      array = a;    }  for (p = dp->list, num = 0; p; p = p->fts_link)    if (p->fts_number != NO_PRINT)      array[num++] = p;  numrows = num / numcols;  if (num % numcols)    ++numrows;  if (dp->list->fts_level != FTS_ROOTLEVEL && (f_longform || f_size))    printf (""total %lu"", howmany (dp->btotal, blocksize));  for (row = 0; row < numrows; ++row)    {      for (base = row, col = 0;;)t{t  chcnt = printaname (array[base], dp->s_inode, dp->s_block);t  if ((base += numrows) >= num)t    break;t  if (++col == numcols)t    break;t  while (chcnt++ < colwidth)t    putchar (' ');t}      putchar ('');    }}",2,"cwe476,cweother"
"SUBR_alloc(ushort code){  int size;  int count;  void *ptr;  char *copy;  SUBR_ENTER();  if (NPARAM == 2)    count = SUBR_get_integer(&PARAM[1]);  else    count = 1;    if (TYPE_is_null(PARAM->type))  {    size = 1;    copy = NULL;  }  if (TYPE_is_string(PARAM->type))  {    size = PARAM->_string.len + 1;    copy = PARAM->_string.addr + PARAM->_string.start;  }  else  {    size = SUBR_get_integer(PARAM);    copy = NULL;  }    if (count <= 0 || size <= 0)    THROW(E_ARG);    ALLOC(&ptr, size * count, ""SUBR_alloc"");    if (copy)  {    size--;    memcpy(ptr, copy, size);    ((char *)ptr)[size] = 0;  }    RETURN->type = T_POINTER;  RETURN->_pointer.value = ptr;    SUBR_LEAVE();}",2,"cwe119,cwe120"
"xsettings_manager_new (Display                *display,tt       int                     screen,tt       XSettingsTerminateFunc  terminate,tt       void                   *cb_data){  XSettingsManager *manager;  Time timestamp;  XClientMessageEvent xev;  char buffer[256];  manager = g_slice_new (XSettingsManager);  manager->display = display;  manager->screen = screen;  sprintf(buffer, ""_XSETTINGS_S%d"", screen);  manager->selection_atom = XInternAtom (display, buffer, False);  manager->xsettings_atom = XInternAtom (display, ""_XSETTINGS_SETTINGS"", False);  manager->manager_atom = XInternAtom (display, ""MANAGER"", False);  manager->terminate = terminate;  manager->cb_data = cb_data;  manager->settings = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, (GDestroyNotify) xsettings_setting_free);  manager->serial = 0;  manager->overrides = NULL;  manager->window = XCreateSimpleWindow (display,ttttt RootWindow (display, screen),ttttt 0, 0, 10, 10, 0,ttttt WhitePixel (display, screen),ttttt WhitePixel (display, screen));  XSelectInput (display, manager->window, PropertyChangeMask);  timestamp = get_server_time (display, manager->window);  XSetSelectionOwner (display, manager->selection_atom,tt      manager->window, timestamp);     if (XGetSelectionOwner (display, manager->selection_atom) ==      manager->window)    {      xev.type = ClientMessage;      xev.window = RootWindow (display, screen);      xev.message_type = manager->manager_atom;      xev.format = 32;      xev.data.l[0] = timestamp;      xev.data.l[1] = manager->selection_atom;      xev.data.l[2] = manager->window;      xev.data.l[3] = 0;t       xev.data.l[4] = 0;t             XSendEvent (display, RootWindow (display, screen),tt  False, StructureNotifyMask, (XEvent *)&xev);    }  else    {      manager->terminate (manager->cb_data);    }    return manager;}",2,"cwe119,cwe120"
"hashcash_parse( const char* token, int* vers, int* bits, char* utct,tt    int utct_max, char* token_resource, int res_max, tt    char** ext, int ext_max ) {    char ver_arr[MAX_VER+1] = {0};    char bits_arr[3+1] = {0};    char *bits_str = bits_arr, *ver = ver_arr;    char *rnd = NULL, *cnt = NULL;    char *state = NULL ;    int ver_len = 0 , utct_len = 0 , res_len = 0 , bit_len = 0 , rnd_len = 0 , cnt_len = 0 ;         if ( ext != NULL ) { *ext = NULL; }    if ( !sstrtok( token, "":"", &ver, MAX_VER, &ver_len, &state ) ) {treturn 0;    }    *vers = atoi( ver ); if ( *vers < 0 ) { return 0; }    if ( *vers == 0 ) {t*bits = -1;tif ( !sstrtok( NULL, "":"", &utct, utct_max, &utct_len, &state ) ||t     !sstrtok( NULL, "":"", &token_resource, res_max,&res_len,&state ) ||t     !sstrtok( NULL, "":"", &rnd, 0, &rnd_len, &state ) ) {t    return 0;t}    } else if ( *vers == 1 ) {tif ( !sstrtok( NULL, "":"", &bits_str, 3, &bit_len, &state ) ||t     !sstrtok( NULL, "":"", &utct, utct_max, &utct_len, &state ) ||t     !sstrtok( NULL, "":"", &token_resource, res_max,&res_len,&state ) ||t     !sstrtok( NULL, "":"", ext, 0, &ext_max, &state ) ||t     !sstrtok( NULL, "":"", &rnd, 0, &rnd_len, &state ) ||t     !sstrtok( NULL, "":"", &cnt, 0, &cnt_len, &state ) ) {t    return 0; t}t*bits = atoi( bits_str ); if ( *bits < 0 ) { return 0; }tif ( strspn( cnt, VALID_STR_CHARS ) != cnt_len ) { return 0; }    }    if ( rnd == NULL || strspn( rnd, VALID_STR_CHARS ) != rnd_len ) { return 0; }    return 1;}",4,"cwe119,cwe120,cwe476,cweother"
"nfs_dns_show(struct seq_file *m, struct cache_detail *cd,ttstruct cache_head *h){tstruct nfs_dns_ent *item;tlong ttl;tif (h == NULL) {ttseq_puts(m, ""# ip address      hostname        ttl"");ttreturn 0;t}titem = container_of(h, struct nfs_dns_ent, h);tttl = item->h.expiry_time - seconds_since_boot();tif (ttl < 0)ttttl = 0;tif (!test_bit(CACHE_NEGATIVE, &h->flags)) {ttchar buf[INET6_ADDRSTRLEN+IPV6_SCOPE_ID_LEN+1];ttrpc_ntop((struct sockaddr *)&item->addr, buf, sizeof(buf));ttseq_printf(m, ""%15s "", buf);t} elsettseq_puts(m, ""<none>          "");tseq_printf(m, ""%15s %ld"", item->hostname, ttl);treturn 0;}",2,"cwe119,cwe120"
"init_sock(void){tint rc;tstruct addrinfo *ai;tstruct addrinfo hints;tchar remote[BUF_SIZE];tint one=1;tif (sock >= 0) {ttsyslog(LOG_NOTICE, ""socket already setup"");tttransport_ok = 1;ttreturn ET_SUCCESS;t}tmemset(&hints, '0', sizeof(hints));thints.ai_flags = AI_ADDRCONFIG|AI_NUMERICSERV;thints.ai_socktype = SOCK_STREAM;tsnprintf(remote, BUF_SIZE, ""%u"", config.port);trc = getaddrinfo(config.remote_server, remote, &hints, &ai);tif (rc) {ttif (!quiet)tttsyslog(LOG_ERR,tttt""Error looking up remote host: %s - exiting"",ttttgai_strerror(rc));ttif (rc == EAI_NONAME || rc == EAI_NODATA)tttreturn ET_PERMANENT;ttelsetttreturn ET_TEMPORARY;t}tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);tif (sock < 0) {ttif (!quiet)tttsyslog(LOG_ERR, ""Error creating socket: %s"",tttstrerror(errno));ttfreeaddrinfo(ai);ttreturn ET_TEMPORARY;t}tsetsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof (int));tif (config.local_port != 0) {ttstruct sockaddr_in address;ttttmemset (&address, 0, sizeof(address));ttaddress.sin_family = AF_INET;ttaddress.sin_port = htons(config.local_port);ttaddress.sin_addr.s_addr = htonl(INADDR_ANY);ttif (bind(sock, (struct sockaddr *)&address, sizeof(address))) {tttif (!quiet)ttttsyslog(LOG_ERR,ttt       ""Cannot bind local socket to port %d"",tttttconfig.local_port);tttstop_sock();tttreturn ET_TEMPORARY;tt}t}tif (connect(sock, ai->ai_addr, ai->ai_addrlen)) {ttif (!quiet)tttsyslog(LOG_ERR, ""Error connecting to %s: %s"",ttttconfig.remote_server, strerror(errno));ttfreeaddrinfo(ai);ttstop_sock();ttreturn ET_TEMPORARY;t}tfreeaddrinfo(ai);tsetsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (char *)&one, sizeof (int));t tif (config.format == F_MANAGED)ttsetsockopt(sock, IPPROTO_TCP, TCP_NODELAY,tttt(char *)&one, sizeof (int));#ifdef USE_GSSAPItif (USE_GSS) {ttif (negotiate_credentials ())tttreturn ET_PERMANENT;t}#endifttransport_ok = 1;tsyslog(LOG_NOTICE, ""Connected to %s"", config.remote_server);treturn ET_SUCCESS;}",2,"cwe119,cwe120"
"est_node_optimize(ESTNODE *node){  CBLIST *reqheads;  CBDATUM *reqbody;  const char *kbuf;  char url[ESTPATHBUFSIZ], *vbuf;  int rescode, err;  assert(node);  err = FALSE;  sprintf(url, ""%s/optimize"", node->url);  reqheads = cblistopen();  if(cbmaprnum(node->heads) > 0){    cbmapiterinit(node->heads);    while((kbuf = cbmapiternext(node->heads, NULL)) != NULL){      vbuf = cbsprintf(""%s: %s"", kbuf, cbmapiterval(kbuf, NULL));      cblistpush(reqheads, vbuf, -1);      free(vbuf);    }  }  cblistpush(reqheads, ""Content-Type: "" ESTFORMTYPE, -1);  reqbody = cbdatumopen(NULL, -1);  if(!est_url_shuttle(url, node->pxhost, node->pxport, node->timeout, ESTRESLIMSIZE, node->auth,                      reqheads, cbdatumptr(reqbody), cbdatumsize(reqbody),                      &rescode, NULL, NULL)){    node->status = -1;    err = TRUE;  }  if(!err){    node->status = rescode;    if(rescode != 200) err = TRUE;  }  cbdatumclose(reqbody);  cblistclose(reqheads);  return err ? FALSE : TRUE;}",2,"cwe119,cwe120"
"_mesa_unpack_dudv_span_byte( struct gl_context *ctx,                             GLuint n, GLenum dstFormat, GLbyte dest[],                             GLenum srcFormat, GLenum srcType,                             const GLvoid *source,                             const struct gl_pixelstore_attrib *srcPacking,                             GLbitfield transferOps ){   ASSERT(dstFormat == GL_DUDV_ATI);   ASSERT(srcFormat == GL_DUDV_ATI ||t  srcFormat == GL_DU8DV8_ATI);   ASSERT(srcType == GL_UNSIGNED_BYTE ||          srcType == GL_BYTE ||          srcType == GL_UNSIGNED_SHORT ||          srcType == GL_SHORT ||          srcType == GL_UNSIGNED_INT ||          srcType == GL_INT ||          srcType == GL_HALF_FLOAT_ARB ||          srcType == GL_FLOAT);       {      GLint dstComponents;      GLbyte *dst = dest;      GLuint i;      GLfloat (*rgba)[4] = malloc(4 * n * sizeof(GLfloat));      if (!rgba) {         _mesa_error(ctx, GL_OUT_OF_MEMORY, ""pixel unpacking"");         return;      }      dstComponents = _mesa_components_in_format( dstFormat );             assert(dstComponents > 0);             extract_float_rgba(n, rgba, srcFormat, srcType, source,                         srcPacking->SwapBytes);                    for (i = 0; i < n; i++) {                   dst[0] = FLOAT_TO_BYTE(rgba[i][RCOMP]);         dst[1] = FLOAT_TO_BYTE(rgba[i][GCOMP]);         dst += dstComponents;      }      free(rgba);   }}",2,"cwe120,cweother"
"""my_strntod_mb2_or_mb4(CHARSET_INFO *cs,                      char *nptr, size_t length,                       char **endptr, int *err){  char     buf[256];  double   res;  register char *b= buf;  register const uchar *s= (const uchar*) nptr;  const uchar *end;  my_wc_t  wc;  int     cnv;  *err= 0;  /* Cut too long strings */  if (length >= sizeof(buf))    length= sizeof(buf) - 1;  end= s + length;  while ((cnv= cs->cset->mb_wc(cs,&wc,s,end)) > 0)  {    s+= cnv;    if (wc > (int) (uchar) 'e' || !wc)      break;                                        /* Can't be part of double */    *b++= (char) wc;  }  *endptr= b;  res= my_strtod(buf, endptr, err);  *endptr= nptr + cs->mbminlen * (size_t) (*endptr - buf);  return res;}""",3,"cwe119,cwe120,cweother"
"cgi_parallel_fname(basename, buf, buflen)     char *basename, *buf;     int buflen;{  int dlen;  char *env_var, *dir_end;     env_var = getenv(""PATH_TRANSLATED"");  if (!env_var)    return 1;  dir_end = strrchr(env_var, '/');  if (!dir_end)    return 1;  dlen = dir_end - env_var + 1;  if (1 + dlen + strlen(basename) > buflen)    return 1;  strncpy(buf, env_var, dlen);  strcpy(buf+dlen, basename);  return 0;}",2,"cwe469,cweother"
"read_value(glibtop *server,t   const char *device,t   const char *filename,t   guint64 *value){    char buffer[BUFSIZ];    if(try_file_to_buffer(buffer,    ttt  sizeof buffer,ttt  ""/sys/class/net/%s/statistics/%s"",ttt  device,ttt  filename))    {tglibtop_warn_io_r(server,ttt  ""Failed to open ""/sys/class/net/%s/statistics/%s"""",ttt  device,ttt  filename);treturn FALSE;    }    *value = strtoull(buffer, NULL, 10);    return TRUE;}",2,"cwe119,cwe120"
"rasero_sum_dialog_get_file_checksum (BraseroSumDialog *self,tttt      const gchar *file_path,tttt      gchar **checksum,tttt      GError **error){tBraseroBurnResult result;tgchar buffer [33];tGFile *file_src;tgchar *tmppath;tgchar *scheme;tgchar *uri;tgchar *src;tFILE *file;tint read;t tfile_src = g_file_new_for_commandline_arg (file_path);tif (!file_src) {ttg_set_error (error,ttt     BRASERO_BURN_ERROR,ttt     BRASERO_BURN_ERROR_GENERAL,ttt     _(""""%s"" is not a valid URI""),ttt     file_path);ttreturn BRASERO_BURN_ERR;t}ttmppath = NULL;tscheme = g_file_get_uri_scheme (file_src);tif (strcmp (scheme, ""file"")) {tturi = g_file_get_uri (file_src);ttg_object_unref (file_src);ttresult = brasero_sum_dialog_download (self,tttttt      uri,tttttt      &tmppath,tttttt      error);ttif (result != BRASERO_BURN_CANCEL) {tttg_free (scheme);tttreturn result;tt}ttsrc = tmppath;t}telse {ttsrc = g_file_get_path (file_src);ttg_object_unref (file_src);t}tg_free (scheme);t tfile = fopen (src, ""r"");tif (!file) {                int errsv = errno;ttif (tmppath)tttg_remove (tmppath);ttg_free (src);ttg_set_error (error,ttt     BRASERO_BURN_ERROR,ttt     BRASERO_BURN_ERROR_GENERAL,ttt     ""%s"",ttt     g_strerror (errsv));ttreturn BRASERO_BURN_ERR;t}tread = fread (buffer, 1, sizeof (buffer) - 1, file);tif (read)ttbuffer [read] = '0';tif (tmppath)ttg_remove (tmppath);tg_free (src);tif (ferror (file)) {ttg_set_error (error,ttt     BRASERO_BURN_ERROR,ttt     BRASERO_BURN_ERROR_GENERAL,ttt     ""%s"",ttt     g_strerror (errno));ttfclose (file);ttreturn BRASERO_BURN_ERR;t}tfclose (file);t*checksum = strdup (buffer);treturn BRASERO_BURN_OK;}",2,"cwe120,cweother"
"cmpdatetime(const void *s1, const void *s2){  int cmp = 0;  timeinfo_t *x = (timeinfo_t *) s1;  timeinfo_t *y = (timeinfo_t *) s2;     if      ( x->datetime < y->datetime ) cmp = -1;  else if ( x->datetime > y->datetime ) cmp =  1;  return (cmp);}",2,"cwe119,cwe120"
"Float_To_String(double d){  char *p, *q, *e;  static char buff[32];  sprintf(buff, ""%#.17g"", d);t   p = buff;ttt   while (*p == ' ')    p++;  if (p != buff)tt     {      q = buff;      while ((*q++ = *p++))t;    }  p = strchr(buff, '.');  if (p == NULL)tt     return buff;  if (p[1] == '0')tt     {      strcat(buff, ""0"");      return buff;    }  e = strchr(buff, 'e');t   if (e == NULL)    e = buff + strlen(buff);  p = e - 1;  while (*p == '0')    p--;  q = (*p == '.') ? p + 2 : p + 1;t   if (q != e)    while ((*q++ = *e++))t       ;  return buff;}",3,"cwe119,cwe120,cweother"
"stop_gsync (char *master, char *slave, char **msg){        int32_t         ret     = 0;        int             pfd     = -1;        pid_t           pid     = 0;        char            pidfile[PATH_MAX] = {0,};        char            buf [1024] = {0,};        int             i       = 0;        GF_ASSERT (THIS);        GF_ASSERT (THIS->private);        pfd = gsyncd_getpidfile (master, slave, pidfile);        if (pfd == -2) {                gf_log ("""", GF_LOG_ERROR, GEOREP"" stop validation ""                        "" failed for %s & %s"", master, slave);                ret = -1;                goto out;        }        if (gsync_status_byfd (pfd) == -1) {                gf_log ("""", GF_LOG_ERROR, ""gsyncd b/w %s & %s is not""                        "" running"", master, slave);                if (msg)                        *msg = gf_strdup (""Warning: ""GEOREP"" session was in ""                                          ""corrupt  state"");                                 goto out;        }        if (pfd < 0)                goto out;        ret = read (pfd, buf, 1024);        if (ret > 0) {                pid = strtol (buf, NULL, 10);                ret = kill (-pid, SIGTERM);                if (ret) {                        gf_log ("""", GF_LOG_WARNING,                                ""failed to kill gsyncd"");                        goto out;                }                for (i = 0; i < 20; i++) {                        if (gsync_status_byfd (pfd) == -1) {                                                                 usleep (50000);                                break;                        }                        usleep (50000);                }                kill (-pid, SIGKILL);                unlink (pidfile);        }        ret = 0;out:        sys_close (pfd);        return ret;}",3,"cwe119,cwe120,cweother"
"nmea_wayptpr(const waypoint* wpt){  char obuf[200];  double lat,lon;  char* s;  int cksum;  lat = degrees2ddmm(wpt->latitude);  lon = degrees2ddmm(wpt->longitude);  if (global_opts.synthesize_shortnames) {    s = mkshort_from_wpt(mkshort_handle, wpt);  } else {    s = mkshort(mkshort_handle, wpt->shortname);  }  snprintf(obuf, sizeof(obuf),  ""GPWPL,%08.3f,%c,%09.3f,%c,%s"",           fabs(lat), lat < 0 ? 'S' : 'N',           fabs(lon), lon < 0 ? 'W' : 'E', s          );  cksum = nmea_cksum(obuf);  gbfprintf(file_out, ""$%s*%02X"", obuf, cksum);  if (sleepus >= 0) {    gbfflush(file_out);    gb_sleep(sleepus);  }  xfree(s);}",2,"cwe119,cwe120"
"fdb_download(int checkhost){    int karma, i, len;    uint32_t * fdb;    char * filename, * p;    char ourhostname[255], hostname[255], path[PATH_MAX];    currentKarma(0, &karma);    fdb=lk_properties_andOrSearch(EXACT|ORS, NULL, ""path"", """");    if (!fdb)        return;    if (checkhost) {        if (gethostname(ourhostname, 255) != 0) ourhostname[0] = '0';        len = strlen(ourhostname) + 1;    }    for (i=0; fdb[i]; i++) {        filename=lk_properties_get_property(fdb[i], ""path"");        if (!filename)            continue;        memcpy(hostname, filename, 255);        for (p=hostname; *p != '0'; p++)            if (*p == ':')                break;        *p = '0';        if (checkhost && memcmp(hostname, ourhostname, len) != 0)            continue;        memcpy(path, p+1, PATH_MAX);        printf(""Downloading fid %i to %s"", fdb[i], path);        fprintf(stderr, ""lk_rio_read %s"",         CHECK(lk_rio_read(karma, fdb[i], path)));    }    free(fdb);}",3,"cwe119,cwe120,cweother"
"get_ivl_start_stop_common_str_scm (GttGhtml *ghtml, GttInterval *ivl,ttttt time_t starp, gboolean prt_date){tchar buff[100];tif (prt_date) {ttxxxqof_print_date_buff (buff, 100, starp);t} else {        switch (config_time_format)         {            case TIME_FORMAT_AM_PM: {                strftime (buff, 100, ""%r"", localtime (&starp));                break;            }            case TIME_FORMAT_24_HS: {                strftime (buff, 100, ""%T"", localtime (&starp));                break;            }            case TIME_FORMAT_LOCALE: {                xxxqof_print_time_buff (buff, 100, starp);                break;            }        }t}tGString *str;tstr = g_string_new (NULL);tif (ghtml->show_links)t{ttg_string_append_printf (str, ""<a href=""gtt:interval:0x%lx"">"", (long) ivl);t}tg_string_append (str, buff);tif (ghtml->show_links)t{ttg_string_append (str, ""</a>"");t}treturn scm_from_locale_string (str->str);}",2,"cwe119,cwe120"
"update_refs_for_switch(struct checkout_opts *opts,tttt   struct branch_info *old,tttt   struct branch_info *new){tstruct strbuf msg;tconst char *old_desc;tif (opts->new_branch) {ttcreate_branch(old->name, opts->new_branch, new->name, 0,ttt      opts->new_branch_log, opts->track);ttnew->name = opts->new_branch;ttsetup_branch_path(new);t}tstrbuf_init(&msg, 0);told_desc = old->name;tif (!old_desc)ttold_desc = sha1_to_hex(old->commit->object.sha1);tstrbuf_addf(&msg, ""checkout: moving from %s to %s"",tt    old_desc, new->name);tif (new->path) {ttcreate_symref(""HEAD"", new->path, msg.buf);ttif (!opts->quiet) {tttif (old->path && !strcmp(new->path, old->path))ttttfprintf(stderr, ""Already on ""%s"""",tttttnew->name);tttelsettttfprintf(stderr, ""Switched to%s branch ""%s"""",tttttopts->new_branch ? "" a new"" : """",tttttnew->name);tt}t} else if (strcmp(new->name, ""HEAD"")) {ttupdate_ref(msg.buf, ""HEAD"", new->commit->object.sha1, NULL,ttt   REF_NODEREF, DIE_ON_ERR);ttif (!opts->quiet) {tttif (old->path)ttttfprintf(stderr, ""Note: moving to ""%s"" which isn't a local branchIf you want to create a new branch from this checkout, you may do so(now or later) by using -b with the checkout command again. Example:  git checkout -b <new_branch_name>"", new->name);tttdescribe_detached_head(""HEAD is now at"", new->commit);tt}t}tremove_branch_state();tstrbuf_release(&msg);tif (!opts->quiet && (new->path || !strcmp(new->name, ""HEAD"")))ttreport_tracking(new);}",2,"cwe119,cwe120"
"makeGlobalSalt(NSSLOWKEYDBHandle *handle){    DBT saltKey;    DBT saltData;    unsigned char saltbuf[16];    int status;        saltKey.data = SALT_STRING;    saltKey.size = sizeof(SALT_STRING) - 1;    saltData.data = (void *)saltbuf;    saltData.size = sizeof(saltbuf);    RNG_GenerateGlobalRandomBytes(saltbuf, sizeof(saltbuf));         status = keydb_Put(handle, &saltKey, &saltData, 0);    if ( status ) {treturn(SECFailure);    }    return(SECSuccess);}",2,"cwe119,cwe120"
"describe_change (const char *file, mode_t old_mode, mode_t mode,                 enum Change_status changed){  char perms[12];tt   char old_perms[12];  const char *fmt;  if (changed == CH_NOT_APPLIED)    {      printf (_(""neither symbolic link %s nor referent has been changed""),              quote (file));      return;    }  strmode (mode, perms);  perms[10] = '0';tt   strmode (old_mode, old_perms);  old_perms[10] = '0';tt   switch (changed)    {    case CH_SUCCEEDED:      fmt = _(""mode of %s changed from %04lo (%s) to %04lo (%s)"");      break;    case CH_FAILED:      fmt = _(""failed to change mode of %s from %04lo (%s) to %04lo (%s)"");      break;    case CH_NO_CHANGE_REQUESTED:      fmt = _(""mode of %s retained as %04lo (%s)"");      printf (fmt, quote (file),              (unsigned long int) (mode & CHMOD_MODE_BITS), &perms[1]);      return;    default:      abort ();    }  printf (fmt, quote (file),          (unsigned long int) (old_mode & CHMOD_MODE_BITS), &old_perms[1],          (unsigned long int) (mode & CHMOD_MODE_BITS), &perms[1]);}",3,"cwe119,cwe120,cweother"
"""StringToDouble(const char *text,const double interval){  char    *q;  double    value;  if (MagickStrToD(text,&q,&value) == 0)    return 0.0;  if (strchr(q,'%') != (char *) NULL)    value*=interval/100.0;  return(value);}""",2,"cwe119,cwe120"
"G_ask_colors(const char *name, const char *mapset, struct Colors *pcolr){    char buff[128];    int answ;    struct FPRange range;    DCELL min, max;    G_init_colors(pcolr);         if (G_read_fp_range(name, mapset, &range) < 0)treturn -1;    G_get_fp_range_min_max(&range, &min, &max);    if (G_is_d_null_value(&min) || G_is_d_null_value(&max)) {tsprintf(buff, _("" The raster map %s@%s is empty""), name, mapset);tG_warning(buff);treturn -1;    }       ASK:    G_clear_screen();    fprintf(stderr,t    _(""Color table needed for file [%s] in mapset [%s].""), name,t    mapset);    fprintf(stderr, _(""Please identify the type desired:""));    fprintf(stderr, _(""    1:  Random colors""));    fprintf(stderr, _(""    2:  Red, green, and blue color ramps""));    fprintf(stderr, _(""    3:  Color wave""));    fprintf(stderr, _(""    4:  Gray scale""));    fprintf(stderr, _(""    5:  Aspect""));    fprintf(stderr, _(""    6:  Rainbow colors""));    fprintf(stderr, _(""    7:  Red through yellow to green""));    fprintf(stderr, _(""    8:  Green through yellow to red""));    fprintf(stderr, _(""RETURN  quit""));    fprintf(stderr, ""> "");    for (;;) {tif (!G_gets(buff))t    goto ASK;tG_strip(buff);tif (*buff == 0)t    return -1;tif (sscanf(buff, ""%d"", &answ) != 1)t    answ = -1;tswitch (answ) {tcase 1:t    return G_make_random_colors(pcolr, (CELL) min, (CELL) max);tcase 2:t    return G_make_ramp_fp_colors(pcolr, min, max);tcase 3:t    return G_make_wave_fp_colors(pcolr, min, max);tcase 4:t    return G_make_grey_scale_fp_colors(pcolr, min, max);tcase 5:t    return G_make_aspect_fp_colors(pcolr, min, max);tcase 6:t    return G_make_rainbow_fp_colors(pcolr, min, max);tcase 7:t    return G_make_ryg_fp_colors(pcolr, min, max);tcase 8:t    return G_make_gyr_fp_colors(pcolr, min, max);tdefault:t    fprintf(stderr, _(""%s invalid; Try again > ""), buff);t    break;t}    }}",2,"cwe119,cwe120"
"synaptics_reconnect(struct psmouse *psmouse){tstruct synaptics_data *priv = psmouse->private;tstruct synaptics_data old_priv = *priv;tunsigned char param[2];tint retry = 0;tint error;tdo {ttpsmouse_reset(psmouse);ttif (retry) {ttt tttssleep(1);tt}ttps2_command(&psmouse->ps2dev, param, PSMOUSE_CMD_GETID);tterror = synaptics_detect(psmouse, 0);t} while (error && ++retry < 3);tif (error)ttreturn -1;tif (retry > 1)ttpsmouse_dbg(psmouse, ""reconnected after %d tries"", retry);tif (synaptics_query_hardware(psmouse)) {ttpsmouse_err(psmouse, ""Unable to query device."");ttreturn -1;t}tif (synaptics_set_mode(psmouse)) {ttpsmouse_err(psmouse, ""Unable to initialize device."");ttreturn -1;t}tif (old_priv.identity != priv->identity ||t    old_priv.model_id != priv->model_id ||t    old_priv.capabilities != priv->capabilities ||t    old_priv.ext_cap != priv->ext_cap) {ttpsmouse_err(psmouse,ttt    ""hardware appears to be different: id(%ld-%ld), model(%ld-%ld), caps(%lx-%lx), ext(%lx-%lx)."",ttt    old_priv.identity, priv->identity,ttt    old_priv.model_id, priv->model_id,ttt    old_priv.capabilities, priv->capabilities,ttt    old_priv.ext_cap, priv->ext_cap);ttreturn -1;t}treturn 0;}",2,"cwe119,cwe120"
"ghw_read_sm_hdr (struct ghw_handler *h, int *list){  unsigned char hdr[4] = { 0, 0, 0, 0 };    int res;  if (fread (hdr, sizeof (hdr), 1, h->stream) != 1)    {      if (feof (h->stream))treturn ghw_res_eof;      elsetreturn ghw_res_error;    }  if (memcmp (hdr, ""SNP"", 4) == 0)    {      res = ghw_read_snapshot (h);      if (res < 0)treturn res;      return ghw_res_snapshot;    }  else if (memcmp (hdr, ""CYC"", 4) == 0)    {      res = ghw_read_cycle_start (h);      if (res < 0)treturn res;      res = ghw_read_cycle_cont (h, list);      if (res < 0)treturn res;            return ghw_res_cycle;    }  else if (memcmp (hdr, ""DIR"", 4) == 0)    {      res = ghw_read_directory (h);    }  else if (memcmp (hdr, ""TAI"", 4) == 0)    {      res = ghw_read_tailer (h);    }  else     {      fprintf (stderr, ""unknown GHW section %c%c%c%c"",t       hdr[0], hdr[1], hdr[2], hdr[3]);      return -1;    }  if (res != 0)    return res;  return ghw_res_other;}",2,"cwe119,cwe120"
"eb_compose_path_name(const char *path_name, const char *file_name,    char *composed_path_name){#ifndef DOS_FILE_PATH    if (strcmp(path_name, ""/"") == 0)tsprintf(composed_path_name, ""%s%s"", path_name, file_name);    elsetsprintf(composed_path_name, ""%s/%s"", path_name, file_name);#else    if (is_ebnet_url(path_name))tsprintf(composed_path_name, ""%s/%s"", path_name, file_name);    else if (ASCII_ISALPHA(*path_name) && strcmp(path_name + 1, "":"") == 0)tsprintf(composed_path_name, ""%s%s"", path_name, file_name);    elsetsprintf(composed_path_name, ""%s%s"", path_name, file_name);#endif}",2,"cwe120,cwe469"
"ttv_I2CWrite(struct bttv *btv, unsigned char addr, unsigned char b1,tt    unsigned char b2, int both){tunsigned char buffer[2];tint bytes = both ? 2 : 1;tif (0 != btv->i2c_rc)ttreturn -1;tbtv->i2c_client.addr = addr >> 1;tbuffer[0] = b1;tbuffer[1] = b2;tif (bytes != i2c_master_send(&btv->i2c_client, buffer, bytes))ttreturn -1;treturn 0;}",2,"cwe119,cwe120"
"cmd_repeat(void){tulong delay;tchar buf[BUFSIZE]; tchar bufsave[BUFSIZE];tFILE *incoming_fp;tif (argcnt == 1)ttcmd_usage(pc->curcmd, SYNOPSIS);tdelay = 0;tif (args[1][0] == '-') {ttswitch (args[1][1])tt{ttdefault:ttcase NULLCHAR:tttcmd_usage(pc->curcmd, SYNOPSIS);ttcase '1':ttcase '2':ttcase '3':ttcase '4':ttcase '5':ttcase '6':ttcase '7':ttcase '8':ttcase '9':ttcase '0':tttdelay = dtol(&args[1][1], FAULT_ON_ERROR, NULL);tttconcat_args(buf, 2, FALSE);tttbreak;tt}t} else ttconcat_args(buf, 1, FALSE);tcheck_special_handling(buf);tstrcpy(pc->command_line, buf);tresolve_aliases();tif (!argcnt)ttreturn;tstrcpy(buf, pc->command_line);tstrcpy(bufsave, buf);targcnt = parse_line(buf, args);tif (!argcnt)ttreturn;tif (STREQ(args[0], ""<"") && (pc->flags & TTY) &&            (pc->flags & SCROLL) && pc->scroll_command) tterror(FATAL, tt""scrolling must be turned off when repeating an input file"");tpc->curcmd_flags |= REPEAT;tincoming_fp = fp;twhile (TRUE) {ttoptind = 0;ttfp = incoming_fp;ttexec_command();ttfree_all_bufs();ttwait_for_children(ZOMBIES_ONLY);ttif (received_SIGINT() || !output_open())tttbreak;ttif ((pc->flags & TTY) && !is_a_tty(""/dev/tty""))tttbreak;ttif (!(pc->curcmd_flags & REPEAT))tttbreak;ttif (delay)tttsleep(delay);ttstrcpy(buf, bufsave);ttargcnt = parse_line(buf, args);t}}",3,"cwe119,cwe120,cwe469"
"test_object_raw_chars__find_invalid_chars_in_oid(void){tgit_oid out;tunsigned char exp[] = {tt0x16, 0xa6, 0x77, 0x70, 0xb7,tt0xd8, 0xd7, 0x23, 0x17, 0xc4,tt0xb7, 0x75, 0x21, 0x3c, 0x23,tt0xa8, 0xbd, 0x74, 0xf5, 0xe0,t};tchar in[41] = ""16a67770b7d8d72317c4b775213c23a8bd74f5e0"";tunsigned int i;tfor (i = 0; i < 256; i++) {ttin[38] = (char)i;ttif (git__fromhex(i) >= 0) {tttexp[19] = (unsigned char)(git__fromhex(i) << 4);tttcl_git_pass(git_oid_fromstr(&out, in));tttcl_assert(memcmp(out.id, exp, sizeof(out.id)) == 0);tt} else {tttcl_git_fail(git_oid_fromstr(&out, in));tt}t}}",2,"cwe119,cwe120"
"nfs3_log_rw_call (uint32_t xid, char *op, struct nfs3_fh *fh, offset3 offt,                  count3 count, int stablewrite){        char    fhstr[1024];tif (THIS->ctx->log.loglevel < GF_LOG_DEBUG)ttreturn;        nfs3_fh_to_str (fh, fhstr);        if (stablewrite == -1)                gf_log (GF_NFS3, GF_LOG_DEBUG, ""XID: %x, %s: args: %s, offset:""                        "" %""PRIu64"",  count: %""PRIu32, xid, op, fhstr, offt,                        count);        else                gf_log (GF_NFS3, GF_LOG_DEBUG, ""XID: %x, %s: args: %s, offset:""                        "" %""PRIu64"",  count: %""PRIu32"", %s"", xid, op, fhstr,                        offt, count,                        (stablewrite == UNSTABLE)?""UNSTABLE"":""STABLE"");}",2,"cwe119,cwe120"
"matroska_convert_tag(AVFormatContext *s, EbmlList *list,                                 AVMetadata **metadata, char *prefix){    MatroskaTag *tags = list->elem;    char key[1024];    int i;    for (i=0; i < list->nb_elem; i++) {        const char *lang = strcmp(tags[i].lang, ""und"") ? tags[i].lang : NULL;        if (prefix)  snprintf(key, sizeof(key), ""%s/%s"", prefix, tags[i].name);        else         av_strlcpy(key, tags[i].name, sizeof(key));        if (tags[i].def || !lang) {        av_metadata_set(metadata, key, tags[i].string);        if (tags[i].sub.nb_elem)            matroska_convert_tag(s, &tags[i].sub, metadata, key);        }        if (lang) {            av_strlcat(key, ""-"", sizeof(key));            av_strlcat(key, lang, sizeof(key));            av_metadata_set(metadata, key, tags[i].string);            if (tags[i].sub.nb_elem)                matroska_convert_tag(s, &tags[i].sub, metadata, key);        }    }}",2,"cwe119,cwe120"
"event_output_event_direction (pstdout_state_t pstate,ttt      ipmi_sel_parse_ctx_t sel_parse_ctx,ttt      uint8_t *sel_record,ttt      unsigned int sel_record_len,ttt      int comma_separated_output,ttt      int debug,ttt      unsigned int flags){  char outbuf[EVENT_OUTPUT_BUFLEN+1];  int outbuf_len;  int ret;  assert (sel_parse_ctx);    if ((ret = _sel_parse_record_string (pstate,tttt       sel_parse_ctx,tttt       sel_record,tttt       sel_record_len,tttt       debug,tttt       flags,tttt       outbuf,tttt       &outbuf_len,tttt       ""%k"")) < 0)    return (-1);    if (!ret)    return (0);  if (comma_separated_output)    {      if (outbuf_len)        PSTDOUT_PRINTF (pstate, "",%s"", outbuf);      else        PSTDOUT_PRINTF (pstate, "",%s"", EVENT_NA_STRING);    }  else    {      if (outbuf_len)        PSTDOUT_PRINTF (pstate, "" | %-17s"", outbuf);      else        PSTDOUT_PRINTF (pstate, "" | %-17s"", EVENT_NA_STRING);    }  return (1);}",2,"cwe119,cwe120"
"read_login_password (int fd){t t#define MAX_LENGTH 8192t#define MAX_BLOCK 256t tgchar *buf = egg_secure_alloc (MAX_BLOCK);tgchar *ret = NULL;tint r, len = 0;tfor (;;) {ttr = read (fd, buf, MAX_BLOCK);ttif (r < 0) {tttif (errno == EAGAIN)ttttcontinue;tttegg_secure_free (ret);tttegg_secure_free (buf);tttreturn NULL;tt} else if (r == 0 || len > MAX_LENGTH) {tttbreak;tt} else {tttret = egg_secure_realloc (ret, len + r + 1);tttmemset (ret + len, 0, r + 1);tttlen = len + r;tttstrncat (ret, buf, r);tt}t}tegg_secure_free (buf);treturn ret;}",2,"cwe120,cweother"
"dumbfile_mgetl(DUMBFILE *f){tunsigned long rv, b;tASSERT(f);tif (f->pos < 0)ttreturn -1;trv = (*f->dfs->getc)(f->file);tif ((signed long)rv < 0) {ttf->pos = -1;ttreturn rv;t}trv <<= 24;tb = (*f->dfs->getc)(f->file);tif ((signed long)b < 0) {ttf->pos = -1;ttreturn b;t}trv |= b << 16;tb = (*f->dfs->getc)(f->file);tif ((signed long)b < 0) {ttf->pos = -1;ttreturn b;t}trv |= b << 8;tb = (*f->dfs->getc)(f->file);tif ((signed long)b < 0) {ttf->pos = -1;ttreturn b;t}trv |= b;tf->pos += 4;treturn rv;}",2,"cwe120,cweother"
"rfbDecryptPasswdFromFile(char *fname){    FILE *fp;    int i, ch;    unsigned char *passwd = (unsigned char *)malloc(9);    if ((fp = fopen(fname,""r"")) == NULL) {tfree(passwd);treturn NULL;    }    for (i = 0; i < 8; i++) {tch = getc(fp);tif (ch == EOF) {t    fclose(fp);t    free(passwd);t    return NULL;t}tpasswd[i] = ch;    }    fclose(fp);    rfbDesKey(fixedkey, DE1);    rfbDes(passwd, passwd);    passwd[8] = 0;    return (char *)passwd;}",2,"cwe120,cweother"
"main(void) {    ssh_session session;    ssh_channel channel;    char buffer[256];    int nbytes;    int rc;    session = connect_ssh(""localhost"", NULL, 0);    if (session == NULL) {        ssh_finalize();        return 1;    }    channel = ssh_channel_new(session);;    if (channel == NULL) {        ssh_disconnect(session);        ssh_free(session);        ssh_finalize();        return 1;    }    rc = ssh_channel_open_session(channel);    if (rc < 0) {        goto failed;    }    rc = ssh_channel_request_exec(channel, ""lsof"");    if (rc < 0) {        goto failed;    }    nbytes = ssh_channel_read(channel, buffer, sizeof(buffer), 0);    while (nbytes > 0) {        if (fwrite(buffer, 1, nbytes, stdout) != (unsigned int) nbytes) {            goto failed;        }        nbytes = ssh_channel_read(channel, buffer, sizeof(buffer), 0);    }    if (nbytes < 0) {        goto failed;    }    ssh_channel_send_eof(channel);    ssh_channel_close(channel);    ssh_channel_free(channel);    ssh_disconnect(session);    ssh_free(session);    ssh_finalize();    return 0;failed:    ssh_channel_close(channel);    ssh_channel_free(channel);    ssh_disconnect(session);    ssh_free(session);    ssh_finalize();    return 1;}",2,"cwe119,cwe120"
"GMT_parse_f_option (char *arg){t tchar copy[BUFSIZ], p[BUFSIZ], *c = NULL;tGMT_LONG i, k = 1, ic, pos = 0, code, *col = VNULL;tGMT_LONG both_i_and_o = FALSE, start = -1, stop = -1;tif (arg[0] == 'i')t ttcol = GMT_io.in_col_type;telse if (arg[0] == 'o')t ttcol = GMT_io.out_col_type;telse {ttt ttboth_i_and_o = TRUE;ttk = 0;t}tmemset ((void *)copy, 0, (size_t)BUFSIZ);t tstrncpy (copy, &arg[k], (size_t)BUFSIZ);t tif (copy[0] == 'g') {t ttif (both_i_and_o) {tttGMT_io.in_col_type[GMT_X] = GMT_io.out_col_type[GMT_X] = GMT_IS_LON;tttGMT_io.in_col_type[GMT_Y] = GMT_io.out_col_type[GMT_Y] = GMT_IS_LAT;tt}ttelse {tttcol[GMT_X] = GMT_IS_LON;tttcol[GMT_Y] = GMT_IS_LAT;tt}ttreturn (0);t}twhile ((GMT_strtok (copy, "","", &pos, p))) {t ttif ((c = strchr (p, '-')))t tttsscanf (p, ""%"" GMT_LL ""d-%"" GMT_LL ""d"", &start, &stop);ttelse if (isdigit ((int)p[0]))t tttstart = stop = atoi (p);ttelsetttt tttstart++, stop++;ttic = (int) p[strlen(p)-1];t ttswitch (ic) {tttcase 'T':t ttttcode = GMT_IS_ABSTIME;ttttbreak;tttcase 't':t ttttcode = GMT_IS_RELTIME;ttttbreak;tttcase 'x':t ttttcode = GMT_IS_LON;ttttbreak;tttcase 'y':t ttttcode = GMT_IS_LAT;ttttbreak;tttcase 'f':t ttttcode = GMT_IS_FLOAT;ttttbreak;tttdefault:t ttttfprintf (stderr, ""%s: GMT Error: Malformed -i argument [%s]"", GMT_program, arg);ttttreturn 1;ttttbreak;tt}tt ttif (both_i_and_o)tttfor (i = start; i <= stop; i++) GMT_io.in_col_type[i] = GMT_io.out_col_type[i] = code;ttelsetttfor (i = start; i <= stop; i++) col[i] = code;t}treturn (0);}",3,"cwe119,cwe120,cweother"
"add_hintdevice(struct ast_hint *hint, const char *devicelist){tstruct ast_str *str;tchar *parse;tchar *cur;tstruct ast_hintdevice *device;tint devicelength;tif (!hint || !devicelist) {tt ttreturn 0;t}tif (!(str = ast_str_thread_get(&hintdevice_data, 16))) {ttreturn -1;t}tast_str_set(&str, 0, ""%s"", devicelist);tparse = parse_hint_device(str);twhile ((cur = strsep(&parse, ""&""))) {ttdevicelength = strlen(cur);ttdevice = ao2_t_alloc(sizeof(*device) + devicelength, hintdevice_destroy,ttt""allocating a hintdevice structure"");ttif (!device) {tttreturn -1;tt}ttstrcpy(device->hintdevice, cur);ttao2_ref(hint, +1);ttdevice->hint = hint;ttao2_t_link(hintdevices, device, ""Linking device into hintdevice container."");ttao2_t_ref(device, -1, ""hintdevice is linked so we can unref"");t}treturn 0;}",2,"cwe119,cwe120"
"stk500_chip_erase(PROGRAMMER * pgm, AVRPART * p){  unsigned char cmd[4];  unsigned char res[4];  if (pgm->cmd == NULL) {    fprintf(stderr,t    ""%s: Error: %s programmer uses stk500_chip_erase() but does not""t    ""provide a cmd() method."",t    progname, pgm->type);    return -1;  }  if (p->op[AVR_OP_CHIP_ERASE] == NULL) {    fprintf(stderr, ""chip erase instruction not defined for part ""%s"""",            p->desc);    return -1;  }  pgm->pgm_led(pgm, ON);  memset(cmd, 0, sizeof(cmd));  avr_set_bits(p->op[AVR_OP_CHIP_ERASE], cmd);  pgm->cmd(pgm, cmd, res);  usleep(p->chip_erase_delay);  pgm->initialize(pgm, p);  pgm->pgm_led(pgm, OFF);  return 0;}",3,"cwe119,cwe120,cweother"
"ReadConfig(const char *filename){tFILEt*capFp;tchartline[MAX_COLS], *p;tchartbuf[BUF_SIZE];tstruct capability *c;tintti;tintterrors = 0;tt  tif ((capFp = fopen(filename, ""r"")) == NULL) {ttfprintf(stderr, ""Error: can't open config filerr"");ttperror(filename);ttreturn FAILURE;t}twhile(fgets(line, MAX_COLS, capFp) != NULL) {tnextLabel:ttif ((p = strchr(line, '#')) != NULL)ttt*p = '0';ttif (strchr(line, ':') == NULL) continue;  ttfor (p = strtok(line, label_delim); p != NULL; p = strtok(NULL, label_delim)) {ttt tttif ((c = FindCap(p)) != NULL) {tttt ttttchar *l = buf;ttttwhile (fgets(line, MAX_COLS, capFp) != NULLtttt       && line[0] == 't') {tttttchar *l2 = line;tttttwhile (*l2 != '' && *l2 != '#') {tttttt*l++ = *l2++;ttttt}ttttt*l++ = '';tttt}tttt*l = '0';ttttif (! c->initialized) {ttttt tttttif (c->arg) {#ifdeftDEBUGttttttfprintf(stderr, ""Capability %s set to arg %sr"",tttttttc->name, c->arg);#endifttttttif (c->func(c->arg) < 0)ttttttterrors++;ttttt} else {#ifdeftDEBUGttttttfprintf(stderr, ""Capability %s set to %s"",tttttttc->name, buf);#endifttttttif (c->func(buf) < 0)ttttttterrors++;ttttt}tttttc->initialized = 1;tttt}ttttgoto nextLabel;t ttt}tt}t}t tfor (i = 0, c = cap; i < MAX_CAPS; i++, c++) {ttif ((c->name != NULL) && !c->initialized) {tttif (c->arg) {#ifdeftDEBUGttttfprintf(stderr, ""Capability %s defaults to arg %sr"", c->name, c->arg);#endifttttif (c->func(c->arg) < 0)ttttterrors++;ttt} else if (c->def_value) {#ifdeftDEBUGttttfprintf(stderr, ""Capability %s defaults to %sr"", c->name, c->def_value);#endifttttif (c->func(c->def_value) < 0)ttttterrors++;ttt} else {ttttfprintf(stderr, ""Error: entry for capability `%s' not foundrr"", c->name);tttterrors++;ttt}tt}t}tfclose(capFp);#ifdeftDEBUGtfprintf(stderr, ""Finished reading config filer"");#endiftif (errors)ttreturn FAILURE;telsettreturn SUCCESS;}",3,"cwe119,cwe120,cweother"
"gf_term_attach_service(GF_Terminal *term, GF_InputService *service_hdl){tBool net_check_interface(GF_InputService *ifce);tGF_Scene *scene;tGF_ObjectManager *odm;tGF_ClientService *ns;tif (!net_check_interface(service_hdl)) return;tif (term->root_scene) gf_term_disconnect(term);tgf_term_lock_net(term, 1);tt tscene = gf_scene_new(NULL);todm = gf_odm_new();tgf_sg_set_script_action(scene->graph, term_script_action, term);tscene->root_od = odm;tterm->root_scene = scene;todm->parentscene = NULL;todm->subscene = scene;todm->term = term;tGF_SAFEALLOC(odm->net_service , GF_ClientService);todm->net_service->term = term;todm->net_service->owner = odm;todm->net_service->ifce = service_hdl;todm->net_service->url = gf_strdup(""Internal Service Handler"");todm->net_service->Clocks = gf_list_new();tgf_list_add(term->net_services, odm->net_service);tgf_term_lock_net(term, 0);tns = odm->net_service;t todm->net_service->ifce->ConnectService(odm->net_service->ifce, odm->net_service, odm->net_service->url);tgf_term_cleanup_pending_session(term, ns);}",2,"cwe469,cwe476"
"cgifiledecode(struct rfc2045 *p, struct rfc2045id *a, void *b){off_t start_pos, end_pos, start_body;chartbuf[512];inttn;struct cgigetfileinfo *c;off_ttdummy;ta=a;tc=(struct cgigetfileinfo *)b;tif (c->filenum == 0)treturn;t tif (disposition_name)ttfree(disposition_name);tif (disposition_filename)ttfree(disposition_filename);tif (rfc2231_udecodeDisposition(p, ""name"", NULL, &disposition_name) < 0t    ||t    rfc2231_udecodeDisposition(p, ""filename"", NULL,tttt       &disposition_filename) < 0)t{ttdisposition_name=disposition_filename=NULL;ttenomem();t}tif (!p->content_dispositiont    || strcmp(p->content_disposition, ""form-data""))treturn;tif (!*disposition_name)treturn;tif (!*disposition_filename)treturn;trfc2045_mimepos(p, &start_pos, &end_pos, &start_body,ttt&dummy, &dummy);tif (start_body == end_pos)t tttreturn;tif ( --c->filenum )treturn;t tif ( (*c->start_file)(disposition_name, disposition_filename,ttt      c->voidarg) )ttreturn;tif (lseek(cgiformfd, start_body, SEEK_SET) == -1)ttenomem();trfc2045_cdecode_start(p, c->file, c->voidarg);twhile (start_body < end_pos)t{ttn=sizeof(buf);ttif (n > end_pos - start_body)tttn=end_pos-start_body;ttn=read(cgiformfd, buf, n);ttif (n <= 0)tenomem();ttrfc2045_cdecode(p, buf, n);ttstart_body += n;t}trfc2045_cdecode_end(p);t(*c->end_file)(c->voidarg);}",3,"cwe119,cwe120,cweother"
"even_better_line (EvenBetterCtx *ebc, uchar **dest,                      const ET_SrcPixel *const *src){  ET_Rll *rll_buf[M];  int i;  int source_width = ebc->source_width;  int dest_width = ebc->dest_width;#ifdef USE_AVEC  if (ebc->using_vectors == 2)    {      even_better_line_fastprep (ebc, dest, src);    }  else#endif    {      for (i = 0; i < ebc->n_planes; i++)        {          rll_buf[i] = (ET_Rll *)malloc (source_width * sizeof(ET_Rll));          even_better_compress_rll (rll_buf[i], src[i], source_width, dest_width);        }      even_better_line_rll (ebc, dest, (const ET_Rll * const *)rll_buf);      for (i = 0; i < ebc->n_planes; i++)        free (rll_buf[i]);    }}",2,"cwe120,cweother"
"do_query (const int sock, const char *query){  char buf[200], *p;  FILE *fi;  int i = 0, hide = hide_discl;  fi = fdopen (sock, ""r"");  if (write (sock, query, strlen (query)) < 0)    err_sys (""write"");  if (shutdown (sock, 1) < 0)    err_sys (""shutdown"");  while (fgets (buf, 200, fi))    {tttt       if (hide == 1)t{t  if (strncmp (buf, hide_strings[i + 1], strlen (hide_strings[i + 1]))t      == 0)t    hide = 2;tt t  continue;tt t}      if (hide == 0)t{t  for (i = 0; hide_strings[i] != NULL; i += 2)t    {t      if (strncmp (buf, hide_strings[i], strlen (hide_strings[i])) ==tt  0)tt{tt  hide = 1;t tt  break;tt}t    }t  if (hide == 1)t    continue;tt t}#ifdef EXT_6BONE             if (strncmp (buf, ""% referto:"", 10) == 0)t{t  char nh[256], np[16], nq[1024];t  if (sscanf (buf, REFERTO_FORMAT, nh, np, nq) == 3)t    {t      int fd;t      if (verb)ttprintf (_(""Detected referral to %s on %s.""), nq, nh);t      strcat (nq, ""r"");t      fd = openconn (nh, np);t      do_query (fd, nq);t      closeconn (fd);t      continue;t    }t}#endif      for (p = buf; *p && *p != 'r' && *p != ''; p++);      *p = '0';      fprintf (stdout, ""%s"", buf);    }  if (ferror (fi))    err_sys (""fgets"");  if (hide == 1)    err_quit (_(""Catastrophic error: disclaimer text has been changed.""tt""Please upgrade this program.""));}",3,"cwe119,cwe120,cweother"
"putRaster(const char *template, int32 xdim, int32 ydim, int imageNumber,          uint8 *image){    FILE       *fd;    char        fileName[DF_MAXFNLEN];    if (!template)           template = getTemplate(""image"", imageNumber);    convert(template, imageNumber, xdim, ydim, fileName);    if (verbose)        printf(""Writing into image file : %s"", fileName);    if ((fd = fopen(fileName, ""wb"")) == NULL)      {          puts(""Unable to open file. Exiting..."");          exit(1);      }    if (fwrite(image, (size_t) xdim, (size_t) ydim, fd) != (unsigned) ydim)      {          puts(""Unable to write to file. Exiting..."");          exit(1);      }    if (fclose(fd))      {          puts(""Unable to close file. Exiting..."");          exit(1);      }}",3,"cwe119,cwe120,cweother"
"snmp_error(netsnmp_session * psess,           int *p_errno, int *p_snmp_errno, char **p_str){    char            buf[SPRINT_MAX_LEN];    int             snmp_errnumber;    if (p_errno)        *p_errno = psess->s_errno;    if (p_snmp_errno)        *p_snmp_errno = psess->s_snmp_errno;    if (p_str == NULL)        return;    strcpy(buf, """");    snmp_errnumber = psess->s_snmp_errno;    if (snmp_errnumber >= SNMPERR_MAX && snmp_errnumber <= SNMPERR_GENERR) {tif (snmp_detail_f) {            snprintf(buf, sizeof(buf), ""%s (%s)"", api_errors[-snmp_errnumber],tt    snmp_detail);            buf[sizeof(buf)-1] = '0';t    snmp_detail_f = 0;t}telset    strlcpy(buf, api_errors[-snmp_errnumber], sizeof(buf));    } else {        if (snmp_errnumber) {            snprintf(buf, sizeof(buf), ""Unknown Error %d"", snmp_errnumber);            buf[sizeof(buf)-1] = '0';        }    }         if (psess->s_errno) {        const char* error = strerror(psess->s_errno);        if(error == NULL)            error = ""Unknown Error"";        snprintf (&buf[strlen(buf)], sizeof(buf)-strlen(buf),                 "" (%s)"", error);    }    buf[sizeof(buf)-1] = '0';    *p_str = strdup(buf);}",2,"cwe119,cwe120"
"showhelp_cb( FL_OBJECT * obj  FL_UNUSED_ARG,             long        arg ){    switch ( arg )    {        case HELP_VERSION:            load_it( mainhelp );            break;        case HELP_GENERAL:            load_it( generalhelp );            break;        case HELP_MOUSE:            load_it( mousehelp );            break;        case HELP_KEYBOARD:            load_it( keyhelp );            break;        case HELP_GROUP:            load_it( grouphelp );            break;        case HELP_TEST:            load_it( testhelp );            break;        case HELP_SAVE:            load_it( savehelp );            break;    }}",2,"cwe119,cwe120"
"ddsche_write_mf_branch_state(csbe_context *cx,                              Hmdf_table *hmdf,                              int clustering_number,                             int mt_number){    Func_table *fpt;    ASSERT_SCHEDULER_MODULE;    fpt = search_func_table(hmdf->block->module->entry);    if (!opt_direct_scheduler) {tif ((opt_frame || (opt_recursive && fpt->rec_flg)) && opt_c_dynamic_scheduler)            csbe_printf(cx,                        ""%s(/*mtg_id*/%d,/*cl_no*/%d,/*mt_no*/%d, %s);"",                        SCHE_FUNC_NAME_MFBS,                        hmdf->mtg_id, clustering_number, mt_number,                        LOCAL_FRAME_POINTER_NAME);        else            csbe_printf(cx,                        ""%s(/*mtg_id*/%d,/*cl_no*/%d,/*mt_no*/%d);"",                        SCHE_FUNC_NAME_MFBS,                        hmdf->mtg_id, clustering_number, mt_number);    } else {        char name[64];        ddsche_make_mf_branch_module_name(name,                                          hmdf->mtg_id,                                          clustering_number,                                          mt_number);tif ((opt_frame || (opt_recursive && fpt->rec_flg)) && opt_c_dynamic_scheduler)            csbe_printf(cx, ""%s(%s);"", name, LOCAL_FRAME_POINTER_NAME);        else            csbe_printf(cx, ""%s();"", name);    }}",2,"cwe119,cwe120"
"lak_auth_fastbind(tLAK *lak,tconst char *user,tconst char *service,tconst char *realm,tconst char *password) {tint rc;tLAK_USER *lu = NULL;tchar *dn = NULL;tchar id[LAK_BUF_LEN];t*id = '0';tif (lak->conf->use_sasl) {ttstrlcpy(id, user, LAK_BUF_LEN);ttif (!strchr(id, '@') &&tt    (ISSET(realm))) {tttstrlcat(id, ""@"", LAK_BUF_LEN);tttstrlcat(id, realm, LAK_BUF_LEN);tt}t} else {ttrc = lak_expand_tokens(lak->conf->filter, user, service, realm, NULL, &dn);ttif (rc != LAK_OK ||             EMPTY(dn))tttgoto done;t}ttttrc = lak_user(tttdn,ttid,ttNULL,ttlak->conf->mech,ttlak->conf->realm,ttpassword,tt&lu);tif (rc != LAK_OK)ttgoto done;trc = lak_bind(lak, lu);tif ( rc == LAK_OK &&t    (ISSET(lak->conf->group_dn) ||         ISSET(lak->conf->group_filter)) )            rc = lak_group_member(lak, user, service, realm, dn);done:;tif (lu)ttlak_user_free(lu);tif (dn != NULL)ttfree(dn);treturn rc;}",2,"cwe119,cwe120"
"""ignore_invalid_option_add (ARGPARSE_ARGS *arg, FILE *fp){  IIO_ITEM_DEF item;  int c;  char name[100];  int namelen = 0;  int ready = 0;  enum { skipWS, collectNAME, skipNAME, addNAME} state = skipWS;  while (!ready)    {      c = getc (fp);      if (c == '')        ready = 1;      else if (c == EOF)        {          c = '';          ready = 1;        }    again:      switch (state)        {        case skipWS:          if (!isascii (c) || !isspace(c))            {              namelen = 0;              state = collectNAME;              goto again;            }          break;        case collectNAME:          if (isspace (c))            {              state = addNAME;              goto again;            }          else if (namelen < DIM(name)-1)            name[namelen++] = c;          else /* Too long.  */            state = skipNAME;          break;        case skipNAME:          if (isspace (c))            {              state = skipWS;              goto again;            }          break;        case addNAME:          name[namelen] = 0;          if (!ignore_invalid_option_p (arg, name))            {              item = xmalloc (sizeof *item + namelen);              strcpy (item->name, name);              item->next = (IIO_ITEM_DEF)arg->internal.iio_list;              arg->internal.iio_list = item;            }          state = skipWS;          goto again;        }    }}""",3,"cwe119,cwe120,cweother"
"update_due_button(GtkWidget *button, struct tm *t){   const char *short_date;   char str[255];   if (t) {      get_pref(PREF_SHORTDATE, NULL, &short_date);      strftime(str, sizeof(str), short_date, t);      gtk_label_set_text(GTK_LABEL(GTK_BIN(button)->child), str);   } else {      gtk_label_set_text(GTK_LABEL(GTK_BIN(button)->child), _(""No Date""));   }}",2,"cwe119,cwe120"
"dessert_msg_new(dessert_msg_t **msgout) {tdessert_msg_t *msg;tmsg = malloc(DESSERT_MAXFRAMEBUFLEN);tif (msg == NULL) {ttdessert_err(""failed to allocate buffer for new message!"");ttreturn (-ENOMEM);t}tmemset(msg, 0, DESSERT_MAXFRAMEBUFLEN);tmsg->l2h.ether_type = htons(DESSERT_ETHPROTO);tmemset(msg->l2h.ether_dhost, 255, ETHER_ADDR_LEN);tmemcpy(msg->proto, dessert_proto, DESSERT_PROTO_STRLEN);tmsg->ver = dessert_ver;tmsg->ttl = 0xff;tmsg->u8 = 0x00;tmsg->u16 = htons(0xbeef);tmsg->hlen = htons(sizeof(dessert_msg_t));tmsg->plen = htons(0);t*msgout = msg;treturn (DESSERT_OK);}",2,"cwe120,cweother"
"e_fm2_init(void){   char path[PATH_MAX];   eina_init();   ecore_init();   _e_storage_volume_edd_init();   e_user_dir_concat_static(path, ""fileman/metadata"");   ecore_file_mkpath(path);   _e_fm2_meta_path = strdup(path);   {      static const Evas_Smart_Class sc =      {         ""e_fm"",         EVAS_SMART_CLASS_VERSION,         _e_fm2_smart_add,           _e_fm2_smart_del,           _e_fm2_smart_move,           _e_fm2_smart_resize,           _e_fm2_smart_show,           _e_fm2_smart_hide,           _e_fm2_smart_color_set,           _e_fm2_smart_clip_set,           _e_fm2_smart_clip_unset,           NULL,         NULL,         NULL,         NULL,         NULL,         NULL,         NULL      };      _e_fm2_smart = evas_smart_class_new(&sc);   }    e_fm2_custom_file_init();   e_fm2_op_registry_init();   efreet_mime_init();       _e_fm2_mime_flush = ecore_timer_add(60.0, _e_fm2_mime_flush_cb, NULL);   _e_fm2_mime_clear = ecore_timer_add(600.0, _e_fm2_mime_clear_cb, NULL);   _e_fm2_icon_desktop_str = eina_stringshare_add(""DESKTOP"");   _e_fm2_icon_thumb_str = eina_stringshare_add(""THUMB"");   _e_fm2_mime_inode_directory = eina_stringshare_add(""inode/directory"");   _e_fm2_mime_app_desktop = eina_stringshare_add(""application/x-desktop"");   _e_fm2_mime_app_edje = eina_stringshare_add(""application/x-extension-edj"");   _e_fm2_mime_text_uri_list = eina_stringshare_add(""text/uri-list"");   _e_fm2_xds = eina_stringshare_add(""XdndDirectSave0"");   _e_fm2_favorites_thread = ecore_thread_run(_e_fm2_favorites_thread_cb,                                              _e_fm2_thread_cleanup_cb,                                              _e_fm2_thread_cleanup_cb, NULL);       E_LIST_HANDLER_APPEND(_e_fm_handlers, E_EVENT_FM_OP_REGISTRY_ADD, _e_fm2_op_registry_entry_add_cb, NULL);   E_LIST_HANDLER_APPEND(_e_fm_handlers, E_EVENT_FM_OP_REGISTRY_DEL, _e_fm2_op_registry_entry_del_cb, NULL);   E_LIST_HANDLER_APPEND(_e_fm_handlers, E_EVENT_FM_OP_REGISTRY_CHANGED, _e_fm2_op_registry_entry_changed_cb, NULL);       E_LIST_HANDLER_APPEND(_e_fm_handlers, E_EVENT_SYS_HIBERNATE, _e_fm2_sys_suspend_hibernate, NULL);   E_LIST_HANDLER_APPEND(_e_fm_handlers, E_EVENT_SYS_RESUME, _e_fm2_sys_suspend_hibernate, NULL);   return 1;}",2,"cwe119,cwe120"
"m_get(int m, int n)r#endifr{r   MATt*matrix;r   intti;r   r   if (m < 0 || n < 0)r     error(E_NEG,""m_get"");rr   if ((matrix=NEW(MAT)) == (MAT *)NULL )r     error(E_MEM,""m_get"");r   else if (mem_info_is_on()) {r      mem_bytes(TYPE_MAT,0,sizeof(MAT));r      mem_numvar(TYPE_MAT,1);r   }r   r   matrix->m = m;ttmatrix->n = matrix->max_n = n;r   matrix->max_m = m;tmatrix->max_size = m*n;r#ifndef SEGMENTEDr   if ((matrix->base = NEW_A(m*n,Real)) == (Real *)NULL )r   {r      free(matrix);r      error(E_MEM,""m_get"");r   }r   else if (mem_info_is_on()) {r      mem_bytes(TYPE_MAT,0,m*n*sizeof(Real));r   }r#elser   matrix->base = (Real *)NULL;r#endifr   if ((matrix->me = (Real **)calloc(m,sizeof(Real *))) == r       (Real **)NULL )r   {tfree(matrix->base);tfree(matrix);rterror(E_MEM,""m_get"");r     }r   else if (mem_info_is_on()) {r      mem_bytes(TYPE_MAT,0,m*sizeof(Real *));r   }r   r#ifndef SEGMENTEDr    r   for ( i=0; i<m; i++ )r     matrix->me[i] = &(matrix->base[i*n]);r#elser   for ( i = 0; i < m; i++ )r     if ( (matrix->me[i]=NEW_A(n,Real)) == (Real *)NULL )r       error(E_MEM,""m_get"");r     else if (mem_info_is_on()) {rtmem_bytes(TYPE_MAT,0,n*sizeof(Real));r       }r#endifr   r   return (matrix);r}",2,"cwe476,cweother"
"tex_print_coeff_custom (const model_coeff *mc, PRN *prn){    char fmt[12];    pprintf(prn, ""%s & "", mc->name);    if (colspec[0][0]) {t tif (na(mc->b)) {t    pprintf(prn, ""multicolumn{1}{c}{rm %s}"", A_(""undefined""));t} else {t    sprintf(fmt, ""$%s$"", colspec[0]);t    pprintf(prn, fmt, mc->b);t}    }    if (!colspec[1][0] && !colspec[2][0] && !colspec[3][0]) {tpputs(prn, "" "");treturn 0;    }    if (colspec[1][0]) {tif (colspec[0][0]) {t    pputs(prn, "" & "");t}t tif (na(mc->se)) {t    pprintf(prn, ""multicolumn{1}{c}{rm %s}"", A_(""undefined""));t} else {t    pprintf(prn, colspec[1], mc->se);t}    }    if (!colspec[2][0] && !colspec[3][0]) {tpputs(prn, "" "");treturn 0;    }    if (colspec[2][0]) {tif (colspec[0][0] || colspec[1][0]) {t    pputs(prn, "" & "");t}t tif (na(mc->tval)) {t    pprintf(prn, ""multicolumn{1}{c}{rm %s}"", A_(""undefined""));t} else {t    sprintf(fmt, ""$%s$"", colspec[2]);t    pprintf(prn, fmt, mc->tval);t}    }     if (colspec[3][0]) {tif (colspec[0][0] || colspec[1][0] || colspec[2][0]) {t    pputs(prn, "" & "");t}t tif (mc->show_pval) {t    if (na(mc->pval)) {ttpprintf(prn, ""multicolumn{1}{c}{rm %s}"", A_(""undefined""));t    } else {ttpprintf(prn, colspec[3], mc->pval);t    }t} else if (!na(mc->slope)) {t    pprintf(prn, colspec[3], mc->slope);t} else {t    pprintf(prn, ""multicolumn{1}{c}{}"");t}    }      pputs(prn, "" "");    return 0;}",2,"cwe119,cwe120"
"show_idle(char *tty){    struct stat buf;    time_t cur_time;    long diff_time;    int sec, min, hour, day, has;    char dev_file[80];    sprintf(dev_file, ""/dev/%s"", tty);    USER_PRIVS(nuid, ngid);    if (stat((char *) dev_file, &buf) != 0) {tNOBODY_PRIVS;treturn;    }    NOBODY_PRIVS;    if (!buf.st_atime || !buf.st_mtime)treturn;    cur_time = time(NULL);    diff_time = buf.st_mtime < buf.st_atimett? (long) cur_time - (long) buf.st_mtimett: (long) cur_time - (long) buf.st_atime;    if (diff_time < 0)tdiff_time = 0;    sec = min = hour = day = has = 0;    if (diff_time > 86400)tday = hour = has = 1;    else if (diff_time > 3600)thour = min = has = 1;    else if (diff_time > 59)tmin = sec = has = 1;    else if (diff_time > 0)tsec = has = 1;    if (has)tprintf("" idle "");    if (day) {tday = diff_time / 86400;tdiff_time -= day * 86400;tprintf(""%d %s "", day, (day > 1) ? ""days"" : ""day"");    }    if (hour) {thour = diff_time / 3600;tdiff_time -= hour * 3600;tif (prog_config.config_bits2 & SHOW_TIMESTAMP)t    printf(""%d %s "", hour, (hour > 1) ? ""hours"" : ""hour"");telset    printf(""%02d:"", hour);    } elsetif (!(prog_config.config_bits2 & SHOW_TIMESTAMP) && has)t    printf(""00:"");    if (min) {tmin = diff_time / 60;tdiff_time -= min * 60;tif (prog_config.config_bits2 & SHOW_TIMESTAMP)t    printf(""%d %s "", min, (min > 1) ? ""minutes"" : ""minute"");telset    printf(""%02d:"", min);    } elsetif (!(prog_config.config_bits2 & SHOW_TIMESTAMP) && has)t    printf(""00:"");    if (sec) {tsec = diff_time;tif (prog_config.config_bits2 & SHOW_TIMESTAMP)t    printf(""%d %s"", sec, (sec > 1) ? ""seconds"" : ""second"");telset    printf(""%02d"", sec);    } elsetif (!(prog_config.config_bits2 & SHOW_TIMESTAMP) && has)t    printf(""00"");}",3,"cwe119,cwe120,cweother"
"memo_put(PicklerObject *self, PyObject *obj){    char pdata[30];    Py_ssize_t len;    Py_ssize_t idx;    const char memoize_op = MEMOIZE;    if (self->fast)        return 0;    idx = PyMemoTable_Size(self->memo);    if (PyMemoTable_Set(self->memo, obj, idx) < 0)        return -1;    if (self->proto >= 4) {        if (_Pickler_Write(self, &memoize_op, 1) < 0)            return -1;        return 0;    }    else if (!self->bin) {        pdata[0] = PUT;        PyOS_snprintf(pdata + 1, sizeof(pdata) - 1,                      ""%"" PY_FORMAT_SIZE_T ""d"", idx);        len = strlen(pdata);    }    else {        if (idx < 256) {            pdata[0] = BINPUT;            pdata[1] = (unsigned char)idx;            len = 2;        }        else if (idx <= 0xffffffffL) {            pdata[0] = LONG_BINPUT;            pdata[1] = (unsigned char)(idx & 0xff);            pdata[2] = (unsigned char)((idx >> 8) & 0xff);            pdata[3] = (unsigned char)((idx >> 16) & 0xff);            pdata[4] = (unsigned char)((idx >> 24) & 0xff);            len = 5;        }        else {              PickleState *st = _Pickle_GetGlobalState();            PyErr_SetString(st->PicklingError,                            ""memo id too large for LONG_BINPUT"");            return -1;        }    }    if (_Pickler_Write(self, pdata, len) < 0)        return -1;    return 0;}",2,"cwe119,cwe120"
"update_line_calcul() {  int line;  char str[12];     if (token_count%2 == 0)    line = (int)(token_count/2-1);  else    line = (int)(token_count/2);  if(line==-1)    return;  sprintf(str, ""%d"",token_result());  g_object_set(calcul_line_item[line*2],      ""text"", BLANK, NULL);  g_object_set(calcul_line_item_back[line*2], ""text"", BLANK, NULL);  if(line < gcomprisBoard->level-1) {ttt     g_object_set(calcul_line_item[line*2+1],      ""text"", BLANK, NULL);    g_object_set(calcul_line_item_back[line*2+1], ""text"", BLANK, NULL);  }}",2,"cwe119,cwe120"
"DC_ChannelGetSLP(GF_InputService *plug, LPNETCHANNEL channel, char **out_data_ptr, u32 *out_data_size, GF_SLHeader *out_sl_hdr, Bool *sl_compressed, GF_Err *out_reception_status, Bool *is_new_data){tDummyChannel *dc;tDCReader *read = (DCReader *) plug->priv;tdc = DC_GetChannel(read, channel);tif (!dc) return GF_STREAM_NOT_FOUND;tmemset(out_sl_hdr, 0, sizeof(GF_SLHeader));tout_sl_hdr->compositionTimeStampFlag = 1;tout_sl_hdr->compositionTimeStamp = dc->start;tout_sl_hdr->accessUnitStartFlag = 1;t*sl_compressed = 0;t*out_reception_status = GF_OK;t*is_new_data = 1;treturn GF_OK;}",2,"cwe120,cweother"
"wt_next(struct word_tokenizer *wt){t tif (wt->word_start >= wt->string + wt->string_len) {ttnext_token_status = NEXT_TOKEN_END;ttreturn NULL;t}t tsize_t sep_len = strspn(wt->word_start, "" t"");ttwt->word_start = wt->word_start + sep_len;t tif (*wt->word_start == ''') {ttwt->word_stop = 1 + strpbrk(wt->word_start + 1, ""'"");ttif (NULL == wt->word_stop) {tttwt->word_stop = wt->string + wt->string_len; }t} else if (*wt->word_start == '""') {ttwt->word_stop = 1 + strpbrk(wt->word_start + 1, """""");ttif (NULL == wt->word_stop) {tttwt->word_stop = wt->string + wt->string_len; }t} else {ttwt->word_stop = strpbrk(wt->word_start, "" t"");ttif (NULL == wt->word_stop) {tttwt->word_stop = wt->string + wt->string_len; }t}t tint wlen = wt->word_stop - wt->word_start;tchar *word = malloc((wlen + 1) * sizeof(char));tif (NULL == word) { ttnext_token_status = NEXT_TOKEN_ERROR;ttreturn NULL;t}t tstrncpy(word, wt->word_start, wlen);tword[wlen] = '0';#ifdef __CYGWIN__t tif (strcmp("""", word) == 0) {ttnext_token_status = NEXT_TOKEN_END;ttreturn NULL;t}#endift twt->word_start = wt->word_stop + 1;treturn word;}",2,"cwe120,cwe469"
"camLoadJPEG2YUV(CamImage* image, char *filename)r{r              struct jpeg_decompress_struct _dcinfo;r         struct jpeg_error_mgr _jerr;r    JSAMPLE *bufferUncompLine;r    FILE *infile;r    char str[256];rr    if ((infile = fopen(filename, ""rb"")) == NULL) {rtsprintf(str,""Can't open jpeg file named '%s'"", filename);rtcamError(""camLoadJPEG"",str);rtreturn 0;r    }rr              _dcinfo.err = jpeg_std_error(&_jerr);r    _jerr.error_exit = camJPEGMyErrorExit;r         jpeg_create_decompress(&_dcinfo);rr    jpeg_stdio_src(&_dcinfo, infile);   r    jpeg_read_header(&_dcinfo, TRUE);r         _dcinfo.out_color_space = JCS_YCbCr;r    r                    r          r         jpeg_start_decompress(&_dcinfo);r     r         camAllocateRGBImage(image, _dcinfo.output_width, _dcinfo.output_height);r         image->channelSeq[0]='Y';r    image->channelSeq[1]='U';r    image->channelSeq[2]='V';r    image->channelSeq[3]=0;r    image->colorModel[0]='Y';r    image->colorModel[1]='U';r    image->colorModel[2]='V';r    image->colorModel[3]=0;r    r          r          r    while (_dcinfo.output_scanline < _dcinfo.output_height) {rt t tbufferUncompLine = (JSAMPLE*)(image->imageData + _dcinfo.output_scanline * image->widthStep);rtjpeg_read_scanlines(&_dcinfo, &bufferUncompLine, 1);r    }r    jpeg_finish_decompress(&_dcinfo);r         jpeg_destroy_decompress(&_dcinfo);r    fclose(infile);r    return 1;r}",3,"cwe119,cwe120,cweother"
"run_command(int sockfd, const char *command,ttt   char *buffer, size_t bufsize){tchar *p;tssize_t size, len;tif (echo) {ttfprintf(outputfp, ""%s"", command);t}t tif (write(sockfd, command, strlen(command)) < 0) return -1;tif (write(sockfd, ""r"", 2) < 0) return -1;t tsize = 0;tbuffer[0] = '0';tmemset(buffer, 0, bufsize);twhile (1) {ttint rcode;ttfd_set readfds;ttFD_ZERO(&readfds);ttFD_SET(sockfd, &readfds);ttrcode = select(sockfd + 1, &readfds, NULL, NULL, NULL);ttif (rcode < 0) {tttif (errno == EINTR) continue;tttfprintf(stderr, ""%s: Failed selecting: %s"",ttttprogname, strerror(errno));tttexit(1);tt}ttif (rcode == 0) {tttfprintf(stderr, ""%s: Server closed the connection."",ttttprogname);tttexit(1);tt}#ifdef MSG_DONTWAITttlen = recv(sockfd, buffer + size,ttt   bufsize - size - 1, MSG_DONTWAIT);#elsett ttlen = recv(sockfd, buffer + size, 1, 0);#endifttif (len < 0) {ttt tttif ((errno == EAGAIN) || (errno == EINTR)) {ttttcontinue;ttt}tttfprintf(stderr, ""%s: Error reading socket: %s"",ttttprogname, strerror(errno));tttexit(1);tt}ttif (len == 0) return 0;t ttsize += len;ttbuffer[size] = '0';tt ttp = strstr(buffer, ""radmin> "");ttif (p &&tt    ((p == buffer) || tt     (p[-1] == '') ||tt     (p[-1] == 'r'))) {ttt*p = '0';tttif (p[-1] == '') p[-1] = '0';tttbreak;tt}t}t tif (!buffer[0]) return 1;tbuffer[size] = '0';  treturn 2;}",2,"cwe469,cweother"
"""nm_setting_diff (NMSetting *a,                 NMSetting *b,                 NMSettingCompareFlags flags,                 gboolean invert_results,                 GHashTable **results){tGParamSpec **property_specs;tguint n_property_specs;tguint i;tNMSettingDiffResult a_result = NM_SETTING_DIFF_RESULT_IN_A;tNMSettingDiffResult b_result = NM_SETTING_DIFF_RESULT_IN_B;tgboolean results_created = FALSE;tg_return_val_if_fail (results != NULL, FALSE);tg_return_val_if_fail (a != NULL, FALSE);tg_return_val_if_fail (NM_IS_SETTING (a), FALSE);tif (b) {ttg_return_val_if_fail (NM_IS_SETTING (b), FALSE);ttg_return_val_if_fail (G_OBJECT_TYPE (a) == G_OBJECT_TYPE (b), FALSE);t}t/* If the caller is calling this function in a pattern like this to gett * complete diffs:t *t * nm_setting_diff (A, B, FALSE, &results);t * nm_setting_diff (B, A, TRUE, &results);t *t * and wants us to invert the results so that the second invocation comest * out correctly, do that here.t */tif (invert_results) {tta_result = NM_SETTING_DIFF_RESULT_IN_B;ttb_result = NM_SETTING_DIFF_RESULT_IN_A;t}tif (*results == NULL) {tt*results = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);ttresults_created = TRUE;t}t/* And now all properties */tproperty_specs = g_object_class_list_properties (G_OBJECT_GET_CLASS (a), &n_property_specs);tfor (i = 0; i < n_property_specs; i++) {ttGParamSpec *prop_spec = property_specs[i];ttGValue a_value = { 0 }, b_value = { 0 };ttNMSettingDiffResult r = NM_SETTING_DIFF_RESULT_UNKNOWN, tmp;ttgboolean different = TRUE;tt/* Handle compare flags */ttif (!should_compare_prop (a, prop_spec->name, flags, prop_spec->flags))tttcontinue;ttif (strcmp (prop_spec->name, NM_SETTING_NAME) == 0)tttcontinue;ttif (b) {tttg_value_init (&a_value, prop_spec->value_type);tttg_object_get_property (G_OBJECT (a), prop_spec->name, &a_value);tttg_value_init (&b_value, prop_spec->value_type);tttg_object_get_property (G_OBJECT (b), prop_spec->name, &b_value);tttdifferent = !!g_param_values_cmp (prop_spec, &a_value, &b_value);tttif (different) {ttttif (!g_param_value_defaults (prop_spec, &a_value))tttttr |= a_result;ttttif (!g_param_value_defaults (prop_spec, &b_value))tttttr |= b_result;ttt}tttg_value_unset (&a_value);tttg_value_unset (&b_value);tt} elsetttr = a_result;  /* only in A */ttif (different) {ttttmp = GPOINTER_TO_UINT (g_hash_table_lookup (*results, prop_spec->name));tttg_hash_table_insert (*results, g_strdup (prop_spec->name), GUINT_TO_POINTER (tmp | r));tt}t}tg_free (property_specs);t/* Don't return an empty hash table */tif (results_created && !g_hash_table_size (*results)) {ttg_hash_table_destroy (*results);tt*results = NULL;t}treturn !(*results);}""",2,"cwe469,cwe476"
"mtd_get_info(libmtd_t desc, struct mtd_info *info){tDIR *sysfs_mtd;tstruct dirent *dirent;tstruct libmtd *lib = (struct libmtd *)desc;tmemset(info, 0, sizeof(struct mtd_info));tif (!lib->sysfs_supported)ttreturn legacy_mtd_get_info(info);tinfo->sysfs_supported = 1;t tsysfs_mtd = opendir(lib->sysfs_mtd);tif (!sysfs_mtd) {ttif (errno == ENOENT) {ttterrno = ENODEV;tttreturn -1;tt}ttreturn sys_errmsg(""cannot open ""%s"""", lib->sysfs_mtd);t}tinfo->lowest_mtd_num = INT_MAX;twhile (1) {ttint mtd_num, ret;ttchar tmp_buf[256];tterrno = 0;ttdirent = readdir(sysfs_mtd);ttif (!dirent)tttbreak;ttif (strlen(dirent->d_name) >= 255) {ttterrmsg(""invalid entry in %s: ""%s"""",ttt       lib->sysfs_mtd, dirent->d_name);ttterrno = EINVAL;tttgoto out_close;tt}ttret = sscanf(dirent->d_name, MTD_NAME_PATT""%s"",ttt     &mtd_num, tmp_buf);ttif (ret == 1) {tttinfo->mtd_dev_cnt += 1;tttif (mtd_num > info->highest_mtd_num)ttttinfo->highest_mtd_num = mtd_num;tttif (mtd_num < info->lowest_mtd_num)ttttinfo->lowest_mtd_num = mtd_num;tt}t}tif (!dirent && errno) {ttsys_errmsg(""readdir failed on ""%s"""", lib->sysfs_mtd);ttgoto out_close;t}tif (closedir(sysfs_mtd))ttreturn sys_errmsg(""closedir failed on ""%s"""", lib->sysfs_mtd);tif (info->lowest_mtd_num == INT_MAX)ttinfo->lowest_mtd_num = 0;treturn 0;out_close:tclosedir(sysfs_mtd);treturn -1;}",3,"cwe119,cwe120,cweother"
"""fingerprint_scan(fingerprint_ty *fp, const char *fn){    int             fd;    unsigned char   ibuf[1024];    long            nbytes;    int             err;    if (fn)    {        struct stat st;        /*         * The most common case is to obtain a fingerprint for         * a file.  In the rare case that it is a directory,         * we need to do things differently.         */        if (stat(fn, &st) == 0 && S_ISDIR(st.st_mode))        {            return fingerprint_scan_dir(fp, fn);        }        /*         * Assume it's a normal file.         * (Slow things will happen if, say, it's a tape device.)         */        fd = open(fn, O_RDONLY|O_BINARY, 0666);        if (fd < 0)            return -1;    }    else    {        fd = 0;    }    for (;;)    {        nbytes = read(fd, ibuf, sizeof(ibuf));        if (nbytes < 0)        {            if (fn)            {                err = errno;                close(fd);                errno = err;            }            return -1;        }        if (nbytes == 0)            break;        fingerprint_addn(fp, ibuf, nbytes);    }    if (fn && close(fd) < 0)        return -1;    return 0;}""",3,"cwe119,cwe120,cweother"
"mark_irqflags(struct task_struct *curr, struct held_lock *hlock){t tif (!hlock->trylock) {ttif (hlock->read) {tttif (curr->hardirq_context)ttttif (!mark_lock(curr, hlock,ttttttLOCK_USED_IN_HARDIRQ_READ))tttttreturn 0;tttif (curr->softirq_context)ttttif (!mark_lock(curr, hlock,ttttttLOCK_USED_IN_SOFTIRQ_READ))tttttreturn 0;tt} else {tttif (curr->hardirq_context)ttttif (!mark_lock(curr, hlock, LOCK_USED_IN_HARDIRQ))tttttreturn 0;tttif (curr->softirq_context)ttttif (!mark_lock(curr, hlock, LOCK_USED_IN_SOFTIRQ))tttttreturn 0;tt}t}tif (!hlock->hardirqs_off) {ttif (hlock->read) {tttif (!mark_lock(curr, hlock,tttttLOCK_ENABLED_HARDIRQ_READ))ttttreturn 0;tttif (curr->softirqs_enabled)ttttif (!mark_lock(curr, hlock,ttttttLOCK_ENABLED_SOFTIRQ_READ))tttttreturn 0;tt} else {tttif (!mark_lock(curr, hlock,tttttLOCK_ENABLED_HARDIRQ))ttttreturn 0;tttif (curr->softirqs_enabled)ttttif (!mark_lock(curr, hlock,ttttttLOCK_ENABLED_SOFTIRQ))tttttreturn 0;tt}t}t tif (!hlock->trylock && (curr->lockdep_reclaim_gfp & __GFP_FS)) {ttif (hlock->read) {tttif (!mark_lock(curr, hlock, LOCK_USED_IN_RECLAIM_FS_READ))tttttreturn 0;tt} else {tttif (!mark_lock(curr, hlock, LOCK_USED_IN_RECLAIM_FS))tttttreturn 0;tt}t}treturn 1;}",2,"cwe120,cweother"
"coff_link_check_ar_symbols (bfd *abfd,ttt    struct bfd_link_info *info,ttt    bfd_boolean *pneeded,ttt    bfd **subsbfd){  bfd_size_type symesz;  bfd_byte *esym;  bfd_byte *esym_end;  *pneeded = FALSE;  symesz = bfd_coff_symesz (abfd);  esym = (bfd_byte *) obj_coff_external_syms (abfd);  esym_end = esym + obj_raw_syment_count (abfd) * symesz;  while (esym < esym_end)    {      struct internal_syment sym;      enum coff_symbol_classification classification;      bfd_coff_swap_sym_in (abfd, esym, &sym);      classification = bfd_coff_classify_symbol (abfd, &sym);      if (classification == COFF_SYMBOL_GLOBALt  || classification == COFF_SYMBOL_COMMON)t{t  const char *name;t  char buf[SYMNMLEN + 1];t  struct bfd_link_hash_entry *h;t   t  name = _bfd_coff_internal_syment_name (abfd, &sym, buf);t  if (name == NULL)t    return FALSE;t  h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);t   t  if (!ht      && info->pei386_auto_importt      && CONST_STRNEQ (name, ""__imp_""))t    h = bfd_link_hash_lookup (info->hash, name + 6, FALSE, FALSE, TRUE);t   t  if (h != (struct bfd_link_hash_entry *) NULLt      && h->type == bfd_link_hash_undefined)t    {t      if (!(*info->callbackstt    ->add_archive_element) (info, abfd, name, subsbfd))ttreturn FALSE;t      *pneeded = TRUE;t      return TRUE;t    }t}      esym += (sym.n_numaux + 1) * symesz;    }     return TRUE;}",2,"cwe119,cwe120"
"ay_irc_got_privmsg(const char *recipient, const char *message,tirc_message_prefix *prefix, irc_account *ia){tConversation *ecr;tctcp_extended_data_list *data_list = NULL;tctcp_extended_data *element = NULL;tecr = ay_conversation_find_by_name(ia->data, recipient);t tif (ecr || !strcmp(recipient, ia->nick)) {ttdata_list = ctcp_get_extended_data(message, strlen(message));ttwhile (data_list) {tttelement = (ctcp_extended_data *)data_list->ext_data;tttswitch (element->type) {tttcase CTCP_ACTION:{ttttchar buf[BUF_LEN];ttttchar *msg;ttttttttmsg = strip_color((unsigned char *)tttttt  element->data);ttttttttg_snprintf(buf, BUF_LEN,ttttt   ""*%s %s"", prefix->nick, msg);ttttttttif (ecr)tttttay_conversation_display_notification(ecr,ttttttttt     buf, IRC_CTCP_ACTION);ttttelse {tttttay_irc_process_incoming_messagetttttt(recipient,tttttt buf,tttttt prefix, ia);tttt}ttttttttif (msg) {tttttfree(msg);tttttmsg = NULL;tttt}ttttttttbreak;ttt}tttcase CTCP_VERSION:{tttt ttttchar *msg = ctcp_gen_version_responsettttt(PACKAGE_NAME,ttttt PACKAGE_VERSION ""-"" RELEASE,ttttt HOST);ttttttttirc_send_notice(prefix->nick, msg, ia);ttttbreak;ttt}tttcase CTCP_SOURCE:ttttbreak;tttcase CTCP_USERINFO:ttttbreak;tttcase CTCP_CLIENTINFO:ttttbreak;tttcase CTCP_TIME:{tttt ttttchar *msg = ctcp_gen_time_response();ttttirc_send_notice(prefix->nick, msg, ia);ttttbreak;ttt}tttcase CTCP_PING:{tttt ttttchar *msg =tttttctcp_gen_ping_response(element->ttttttt       data);ttttirc_send_notice(prefix->nick, msg, ia);ttttbreak;ttt}tttcase CTCP_SED:ttttbreak;tttcase CTCP_DCC:ttttbreak;tttcase CTCP_FINGER:ttttbreak;tttcase CTCP_ERRMSG:ttttbreak;tttdefault:{ttttif ( element->data && element->data[0])tttttay_irc_process_incoming_messagetttttt(recipient, element->data,tttttt prefix, ia);ttt}ttt}tttdata_list = data_list->next;tt}t}tctcp_free_extended_data(data_list);}",2,"cwe119,cwe120"
"ReadLine(FILE * fp){    int thechar;    while (1) {        thechar = getc(fp);        if (thechar == EOF) {            fclose(fp);            return 0;        }        if (thechar == 0x0a)            return 1;                    if (thechar == 0x0d) {            thechar = getc(fp);            if (thechar == EOF) {                fclose(fp);                return 0;            }            if (thechar == 0x0d)                return 1;                    ungetc(thechar, fp);                 return 1;        }    }}",2,"cwe120,cweother"
"pm8001_update_flash(struct pm8001_hba_info *pm8001_ha){tstruct pm8001_ioctl_payloadt*payload;tDECLARE_COMPLETION_ONSTACK(completion);tu8tt*ioctlbuffer;tstruct fw_control_infot*fwControl;tu32ttpartitionSize, partitionSizeTmp;tu32ttloopNumber, loopcount;tstruct pm8001_fw_image_header *image_hdr;tu32ttsizeRead = 0;tu32ttret = 0;tu32ttlength = 1024 * 16 + sizeof(*payload) - 1;tif (pm8001_ha->fw_image->size < 28) {ttpm8001_ha->fw_status = FAIL_FILE_SIZE;ttreturn -EFAULT;t}tioctlbuffer = kzalloc(length, GFP_KERNEL);tif (!ioctlbuffer) {ttpm8001_ha->fw_status = FAIL_OUT_MEMORY;ttreturn -ENOMEM;t}timage_hdr = (struct pm8001_fw_image_header *)pm8001_ha->fw_image->data;twhile (sizeRead < pm8001_ha->fw_image->size) {ttpartitionSizeTmp =ttt*(u32 *)((u8 *)&image_hdr->image_length + sizeRead);ttpartitionSize = be32_to_cpu(partitionSizeTmp);ttloopcount = DIV_ROUND_UP(partitionSize + HEADER_LEN,tttttIOCTL_BUF_SIZE);ttfor (loopNumber = 0; loopNumber < loopcount; loopNumber++) {tttpayload = (struct pm8001_ioctl_payload *)ioctlbuffer;tttpayload->length = 1024*16;tttpayload->id = 0;tttfwControl =ttt      (struct fw_control_info *)&payload->func_specific;tttfwControl->len = IOCTL_BUF_SIZE;    tttfwControl->size = partitionSize + HEADER_LEN; tttfwControl->retcode = 0; tttfwControl->offset = loopNumber * IOCTL_BUF_SIZE; tt ttif (((loopcount-loopNumber) == 1) &&ttt((partitionSize + HEADER_LEN) % IOCTL_BUF_SIZE)) {tttfwControl->len =tttt(partitionSize + HEADER_LEN) % IOCTL_BUF_SIZE;tttmemcpy((u8 *)fwControl->buffer,tttt(u8 *)pm8001_ha->fw_image->data + sizeRead,tttt(partitionSize + HEADER_LEN) % IOCTL_BUF_SIZE);tttsizeRead +=tttt(partitionSize + HEADER_LEN) % IOCTL_BUF_SIZE;tt} else {tttmemcpy((u8 *)fwControl->buffer,tttt(u8 *)pm8001_ha->fw_image->data + sizeRead,ttttIOCTL_BUF_SIZE);tttsizeRead += IOCTL_BUF_SIZE;tt}ttpm8001_ha->nvmd_completion = &completion;ttret = PM8001_CHIP_DISP->fw_flash_update_req(pm8001_ha, payload);ttif (ret) {tttpm8001_ha->fw_status = FAIL_OUT_MEMORY;tttgoto out;tt}ttwait_for_completion(&completion);ttif (fwControl->retcode > FLASH_UPDATE_IN_PROGRESS) {tttpm8001_ha->fw_status = fwControl->retcode;tttret = -EFAULT;tttgoto out;tt}tt}t}out:tkfree(ioctlbuffer);treturn ret;}",2,"cwe120,cweother"
"com_passwd(char * arg){tchar * p;tint ret;tchar newpass[AFP_MAX_PASSWORD_LEN];tif (!server) {ttprintf(""Not connected to a server"");ttgoto error;t}tp = getpass(""New password: "");tstrncpy(newpass,p,AFP_MAX_PASSWORD_LEN);tret=ml_passwd(server,url.username,url.password,newpass);tif (ret) {ttprintf(""Could not change password"");ttgoto error;t}treturn 0;error:treturn -1;}",3,"cwe119,cwe120,cweother"
"mdb_ole_read_full(MdbHandle *mdb, MdbColumn *col, size_t *size){tchar ole_ptr[MDB_MEMO_OVERHEAD];tchar *result = malloc(MDB_BIND_SIZE);tsize_t result_buffer_size = MDB_BIND_SIZE;tsize_t len, pos;tmemcpy(ole_ptr, col->bind_ptr, MDB_MEMO_OVERHEAD);tlen = mdb_ole_read(mdb, col, ole_ptr, MDB_BIND_SIZE);tmemcpy(result, col->bind_ptr, len);tpos = len;twhile ((len = mdb_ole_read_next(mdb, col, ole_ptr))) {ttif (pos+len >= result_buffer_size) {tttresult_buffer_size += MDB_BIND_SIZE;tttresult = realloc(result, result_buffer_size);tt}ttmemcpy(result + pos, col->bind_ptr, len);ttpos += len;t}tif (size)tt*size = pos;treturn result;}",2,"cwe119,cwe120"
"load_config( ){    char file_name[512];    PData *pd;          check_config_dir_name();    reset_config();         sprintf( file_name, ""%s/%s"", config.dir_name, ""lgeneral.conf"" );    if ( ( pd = parser_read_file( ""config"", file_name ) ) == 0 ) {        fprintf( stderr, ""%s"", parser_get_error() );        return;    }         parser_get_int( pd, ""grid"", &config.grid );    parser_get_int( pd, ""tran"", &config.tran );    parser_get_int( pd, ""bar"", &config.show_bar );    parser_get_int( pd, ""width"", &config.width );    parser_get_int( pd, ""height"", &config.height );    parser_get_int( pd, ""fullscreen"", &config.fullscreen );    parser_get_int( pd, ""anim_speed"", &config.anim_speed );    parser_get_int( pd, ""supply"", &config.supply );    parser_get_int( pd, ""weather"", &config.weather );    parser_get_int( pd, ""fog_of_war"", &config.fog_of_war );    parser_get_int( pd, ""cpu_turn"", &config.show_cpu_turn );    parser_get_int( pd, ""deploy"", &config.deploy_turn );    parser_get_int( pd, ""purchase"", &config.purchase );    parser_get_int( pd, ""ai_debug"", &config.ai_debug );    parser_get_int( pd, ""sound_on"", &config.sound_on );    parser_get_int( pd, ""sound_volume"", &config.sound_volume );    parser_get_int( pd, ""music_on"", &config.music_on );    parser_get_int( pd, ""music_volume"", &config.music_volume );    parser_free( &pd );}",2,"cwe119,cwe120"
"generator_matrix(char *fname, MATRIX *M) {tint i, j;tFILE *fptr;tfptr = fopen(fname, ""r"");tif (!fptr) {ttfprintf(stderr, ""Error opening %s"", fname);ttreturn -1;t}tfscanf(fptr, ""%d %d %d"", &M->rows, &M->cols, &M->q);tM->m = (unsigned int **)malloc(M->rows * sizeof(unsigned int *));tfor (i=0; i<M->rows; i++) ttM->m[i] = (unsigned int *)malloc(M->cols * sizeof(unsigned int));tfor (i=0; i<M->rows; i++) {ttfor (j=0; j<M->cols; j++) fscanf(fptr, ""%d "", &M->m[i][j]);t}treturn 0;}",2,"cwe120,cweother"
"dcc_handle_new_ack (struct DCC *dcc){tguint32 ack;tchar buf[16];tgboolean done = FALSE;tmemcpy (&ack, dcc->ack_buf, 4);tdcc->ack = ntohl (ack);t tif (dcc->size <= 0xffffffff)t{tt ttif (dcc->ack < dcc->resumable)tttdcc->ackoffset = TRUE;ttif (dcc->ackoffset)tttdcc->ack += dcc->resumable;t}t tif (dcc->pos >= dcc->size && dcc->ack >= (dcc->size & 0xffffffff))t{ttdcc->ack = dcc->size;t ttdcc_close (dcc, STAT_DONE, FALSE);ttdcc_calc_average_cps (dcc);t tt ttsprintf (buf, ""%d"", dcc->cps);ttEMIT_SIGNAL (XP_TE_DCCSENDCOMP, dcc->serv->front_session,tttttt file_part (dcc->file), dcc->nick, buf, NULL, 0);ttdone = TRUE;t}telse if ((!dcc->fastsend) && (dcc->ack >= (dcc->pos & 0xffffffff)))t{ttdcc_send_data (NULL, 0, (gpointer)dcc);t}#ifdef USE_DCC64t tdcc->ack = (dcc->pos & G_GINT64_CONSTANT (0xffffffff00000000)) |ttttt(dcc->ack & 0xffffffff);t #endiftreturn done;}",2,"cwe119,cwe120"
"send_probe_request(struct wif *wi){    int len;    unsigned char p[4096], r_smac[6];    memcpy(p, PROBE_REQ, 24);    len = 24;    p[24] = 0x00;           p[25] = 0x00;           len += 2;    memcpy(p+len, RATES, 16);    len += 16;    r_smac[0] = 0x00;    r_smac[1] = rand() & 0xFF;    r_smac[2] = rand() & 0xFF;    r_smac[3] = rand() & 0xFF;    r_smac[4] = rand() & 0xFF;    r_smac[5] = rand() & 0xFF;    memcpy(p+10, r_smac, 6);    if (wi_write(wi, p, len, NULL) == -1) {        switch (errno) {        case EAGAIN:        case ENOBUFS:            usleep(10000);            return 0;          }        perror(""wi_write()"");        return -1;    }    return 0;}",3,"cwe119,cwe120,cweother"
"main(int argc, char* argv[])r{r    Pa_Initialize();rr    Pa_SetDevicesChangedCallback(NULL, devicesChangedCallback);rr    for(;;){r        printDevices();r        r        printf( ""press [enter] to update the device list. or q + [enter] to quit."" );r        char ch = getchar();r        if( ch == 'q' )r            break;r    r        Pa_UpdateAvailableDeviceList();r    }rr    Pa_Terminate();rrtreturn 0;r}",2,"cwe120,cweother"
"alloc_word_desc (){  WORD_DESC *temp;  ocache_alloc (wdcache, WORD_DESC, temp);  temp->flags = 0;  temp->word = 0;  return temp;}",2,"cwe119,cwe120"
"caml_debugger_init(void){  char * address;  char * port, * p;  struct hostent * host;  int n;  caml_register_global_root(&marshal_flags);  marshal_flags = caml_alloc(2, Tag_cons);  Store_field(marshal_flags, 0, Val_int(1));    Store_field(marshal_flags, 1, Val_emptylist);  address = getenv(""CAML_DEBUG_SOCKET"");  if (address == NULL) return;  dbg_addr = address;#ifdef _WIN32  winsock_startup();  (void)atexit(winsock_cleanup);#endif     port = NULL;  for (p = address; *p != 0; p++) {    if (*p == ':') { *p = 0; port = p+1; break; }  }  if (port == NULL) {#ifndef _WIN32         sock_domain = PF_UNIX;    sock_addr.s_unix.sun_family = AF_UNIX;    strncpy(sock_addr.s_unix.sun_path, address,            sizeof(sock_addr.s_unix.sun_path));    sock_addr_len =      ((char *)&(sock_addr.s_unix.sun_path) - (char *)&(sock_addr.s_unix))        + strlen(address);#else    caml_fatal_error(""Unix sockets not supported"");#endif  } else {         sock_domain = PF_INET;    for (p = (char *) &sock_addr.s_inet, n = sizeof(sock_addr.s_inet);         n > 0; n--) *p++ = 0;    sock_addr.s_inet.sin_family = AF_INET;    sock_addr.s_inet.sin_addr.s_addr = inet_addr(address);    if (sock_addr.s_inet.sin_addr.s_addr == -1) {      host = gethostbyname(address);      if (host == NULL)        caml_fatal_error_arg(""Unknown debugging host %s"", address);      memmove(&sock_addr.s_inet.sin_addr, host->h_addr, host->h_length);    }    sock_addr.s_inet.sin_port = htons(atoi(port));    sock_addr_len = sizeof(sock_addr.s_inet);  }  open_connection();  caml_debugger_in_use = 1;  caml_trap_barrier = caml_stack_high;}",2,"cwe120,cweother"
"read_random_bytes(void *buf, size_t len){    int fd;    int rc;    fd = open(""/dev/urandom"", O_RDONLY);    if(fd < 0) {trc = -1;    } else {        rc = read(fd, buf, len);        if(rc < 0 || (unsigned)rc < len)            rc = -1;        close(fd);    }    return rc;}",2,"cwe120,cweother"
"expandargv (int *argcp, char ***argvp){     int i = 0;     int argv_dynamic = 0;     while (++i < *argcp)    {             const char *filename;             FILE *f;             long pos;             size_t len;             char *buffer;             char **file_argv;             size_t file_argc;             filename = (*argvp)[i];      if (filename[0] != '@')tcontinue;             f = fopen (++filename, ""r"");      if (!f)tcontinue;      if (fseek (f, 0L, SEEK_END) == -1)tgoto error;      pos = ftell (f);      if (pos == -1)tgoto error;      if (fseek (f, 0L, SEEK_SET) == -1)tgoto error;      buffer = (char *) xmalloc (pos * sizeof (char) + 1);      len = fread (buffer, sizeof (char), pos, f);      if (len != (size_t) post   t  && ferror (f))tgoto error;             buffer[len] = '0';             file_argv = buildargv (buffer);             if (!argv_dynamic)t{t  *argvp = dupargv (*argvp);t  if (!*argvp)t    {t      fputs (""out of memory"", stderr);t      exit (1);t    }t}             file_argc = 0;      while (file_argv[file_argc] && *file_argv[file_argc])t++file_argc;              *argvp = ((char **) ttxrealloc (*argvp, ttt  (*argcp + file_argc + 1) * sizeof (char *)));      memmove (*argvp + i + file_argc, *argvp + i + 1, t       (*argcp - i) * sizeof (char *));      memcpy (*argvp + i, file_argv, file_argc * sizeof (char *));             *argcp += file_argc - 1;             free (file_argv);      free (buffer);             --i;    error:             fclose (f);    }}",2,"cwe120,cweother"
"ompi_btl_usnic_dump_hex(uint8_t *addr, int len){    char buf[128];    size_t bufspace;    int i, ret;    char *p;    uint32_t sum=0;    p = buf;    memset(buf, 0, sizeof(buf));    bufspace = sizeof(buf) - 1;    for (i=0; i<len; ++i) {        ret = snprintf(p, bufspace, ""%02x "", addr[i]);        p += ret;        bufspace -= ret;        sum += addr[i];        if ((i&15) == 15) {            opal_output(0, ""%4x: %s"", i&~15, buf);            p = buf;            memset(buf, 0, sizeof(buf));            bufspace = sizeof(buf) - 1;        }    }    if ((i&15) != 0) {        opal_output(0, ""%4x: %s"", i&~15, buf);    }     }",2,"cwe119,cwe120"
"_fail_unless (int result, const char *file, int line, const char *expr, ...){  const char *msg;  send_loc_info (file, line);  if (!result) {    va_list ap;    char buf[BUFSIZ];    va_start (ap, expr);    msg = (const char *) va_arg (ap, char *);    if (msg == NULL)      msg = expr;    vsnprintf (buf, BUFSIZ, msg, ap);    va_end (ap);    send_failure_info (buf);    if (cur_fork_status () == CK_FORK) {#ifdef _POSIX_VERSION      exit (1);#endif      }  }}",3,"cwe119,cwe120,cweother"
"NC4_inq_grpname_full(int ncid, size_t *lenp, char *full_name){   char *name, grp_name[NC_MAX_NAME + 1];   int g, id = ncid, parent_id, *gid;   int i, ret = NC_NOERR;       for (g = 0; !nc_inq_grp_parent(id, &parent_id); g++, id = parent_id)      ;       if (!(name = malloc((g + 1) * (NC_MAX_NAME + 1) + 1)))      return NC_ENOMEM;   if (!(gid = malloc((g + 1) * sizeof(int))))   {      free(name);      return NC_ENOMEM;   }   assert(name && gid);       strcpy(name, ""/"");       gid[0] = ncid;   for (i = 1; i < g && !ret; i++)      ret = nc_inq_grp_parent(gid[i - 1], &gid[i]);       for (i = g - 1; !ret && i >= 0 && !ret; i--)   {      if ((ret = nc_inq_grpname(gid[i], grp_name)))         break;      strcat(name, grp_name);      if (i)         strcat(name, ""/"");   }       if (!ret && lenp)      *lenp = strlen(name);       if (!ret && full_name)      strcpy(full_name, name);   free(gid);   free(name);   return ret;}",3,"cwe119,cwe120,cweother"
"mailpop3_retr(mailpop3 * f, unsigned int indx, char ** result,tt  size_t * result_len){  char command[POP3_STRING_SIZE];  struct mailpop3_msg_info * msginfo;  int r;  if (f->pop3_state != POP3_STATE_TRANSACTION)    return MAILPOP3_ERROR_BAD_STATE;  msginfo = find_msg(f, indx);  if (msginfo == NULL) {    f->pop3_response = NULL;    return MAILPOP3_ERROR_NO_SUCH_MESSAGE;  }  snprintf(command, POP3_STRING_SIZE, ""RETR %ir"", indx);  r = send_command(f, command);  if (r == -1)    return MAILPOP3_ERROR_STREAM;  return mailpop3_get_content(f, msginfo, result, result_len);}",2,"cwe119,cwe120"
"manager_parking_status(struct mansession *s, const struct message *m){tstruct parkeduser *cur;tconst char *id = astman_get_header(m, ""ActionID"");tchar idText[256] = """";tstruct ao2_iterator iter;tstruct ast_parkinglot *curlot;tint numparked = 0;tlong now = time(NULL);tif (!ast_strlen_zero(id))ttsnprintf(idText, sizeof(idText), ""ActionID: %sr"", id);tastman_send_ack(s, m, ""Parked calls will follow"");titer = ao2_iterator_init(parkinglots, 0);twhile ((curlot = ao2_iterator_next(&iter))) {ttAST_LIST_LOCK(&curlot->parkings);ttAST_LIST_TRAVERSE(&curlot->parkings, cur, list) {tttastman_append(s, ""Event: ParkedCallr""tttt""Parkinglot: %sr""tttt""Exten: %dr""tttt""Channel: %sr""tttt""From: %sr""tttt""Timeout: %ldr""tttt""Duration: %ldr""tttt""CallerIDNum: %sr""tttt""CallerIDName: %sr""tttt""ConnectedLineNum: %sr""tttt""ConnectedLineName: %sr""tttt""%s""tttt""r"",ttttcurlot->name,ttttcur->parkingnum, ast_channel_name(cur->chan), cur->peername,tttt(long) cur->start.tv_sec + (long) (cur->parkingtime / 1000) - now,ttttnow - (long) cur->start.tv_sec,ttttS_COR(ast_channel_caller(cur->chan)->id.number.valid, ast_channel_caller(cur->chan)->id.number.str, """"),t ttttS_COR(ast_channel_caller(cur->chan)->id.name.valid, ast_channel_caller(cur->chan)->id.name.str, """"),ttttS_COR(ast_channel_connected(cur->chan)->id.number.valid, ast_channel_connected(cur->chan)->id.number.str, """"),t ttttS_COR(ast_channel_connected(cur->chan)->id.name.valid, ast_channel_connected(cur->chan)->id.name.str, """"),ttttidText);ttt++numparked;tt}ttAST_LIST_UNLOCK(&curlot->parkings);ttao2_ref(curlot, -1);t}tao2_iterator_destroy(&iter);tastman_append(s,tt""Event: ParkedCallsCompleter""tt""Total: %dr""tt""%s""tt""r"",ttnumparked, idText);treturn RESULT_SUCCESS;}",2,"cwe119,cwe120"
"Edit_parameter(int sim_handle){  int    num_params;  char  *param_val[1];  Param_details_struct param_details[REG_INITIAL_NUM_PARAMS];  int    i, index;  char   user_str[REG_MAX_STRING_LENGTH];  int    return_status = REG_SUCCESS;  int    handle;     handle = Choose_parameter(sim_handle, REG_TRUE);  if(handle == REG_PARAM_HANDLE_NOTSET)return REG_FAILURE;  param_val[0] = (char *)malloc(REG_MAX_STRING_LENGTH*sizeof(char));  if (!param_val[0]) return REG_FAILURE;       if(Get_param_number(sim_handle, REG_TRUE, &num_params) != REG_FAILURE){    if(num_params > REG_INITIAL_NUM_PARAMS){      num_params = REG_INITIAL_NUM_PARAMS;    }        if(Get_param_values(sim_handle,     tttREG_TRUE,    tttnum_params,tttparam_details) != REG_FAILURE){          for(i=0; i<num_params; i++){tif(param_details[i].handle == handle){t  fprintf(stderr, ""%d: %s = %s (%s,%s)"", i, param_details[i].label, tt  param_details[i].value, param_details[i].min_val, tt  param_details[i].max_val);t  index = i;t  break;t}      }      fprintf(stderr, ""Editing parameter with handle %d, ""t      ""current value = %s..."", t      handle, param_details[index].value);      fprintf(stderr, ""New value: "");      while(REG_TRUE){tscanf(""%s"", user_str);tif(user_str[0] != '' && user_str[0] != ' ')break;      }      strcpy(param_val[0], user_str);      return_status = Set_param_values(sim_handle,tttt       1,tttt       &(param_details[index].handle),tttt       param_val);    }  }  else{    return_status = REG_FAILURE;  }  if(param_val[0]){    free(param_val[0]);    param_val[0] = NULL;  }   return return_status;}",3,"cwe119,cwe120,cweother"
"parseArgs(int argc, char **argv){tint c;tsensord_args.isDaemon = (argv[0][strlen (argv[0]) - 1] == 'd');tif (!sensord_args.isDaemon) {ttfprintf(stderr, ""Sensord no longer runs as an commandline""ttt"" application."");ttreturn -1;  t}twhile ((c = getopt_long(argc, argv, shortOptions, longOptions, NULL))t       != EOF) {ttswitch(c) {ttcase 'i':tttif ((sensord_args.scanTime = parseTime(optarg)) < 0)ttttreturn -1;tttbreak;ttcase 'l':tttif ((sensord_args.logTime = parseTime(optarg)) < 0)ttttreturn -1;tttbreak;ttcase 't':tttif ((sensord_args.rrdTime = parseTime(optarg)) < 0)ttttreturn -1;tttbreak;ttcase 'T':tttsensord_args.rrdNoAverage = 1;tttbreak;ttcase 'f':tttsensord_args.syslogFacility = parseFacility(optarg);tttif (sensord_args.syslogFacility < 0)ttttreturn -1;tttbreak;ttcase 'a':tttsensord_args.doLoad = 1;tttbreak;ttcase 'c':tttsensord_args.cfgFile = optarg;tttbreak;ttcase 'p':tttsensord_args.pidFile = optarg;tttbreak;ttcase 'r':tttsensord_args.rrdFile = optarg;tttbreak;ttcase 'd':tttsensord_args.debug = 1;tttbreak;ttcase 'g':tttsensord_args.doCGI = 1;tttsensord_args.cgiDir = optarg;tttbreak;ttcase 'v':tttprintf(""sensord version %s"", LM_VERSION);tttexit(EXIT_SUCCESS);ttcase 'h':tttprintf(""Syntax: %s {options} {chips}%s"", argv[0],ttt       daemonSyntax);tttexit(EXIT_SUCCESS);ttcase ':':ttcase '?':tttprintf(""Try `%s --help' for more information."",ttt       argv[0]);tttreturn -1;ttdefault:tttfprintf(stderr,tttt""Internal error while parsing options."");tttreturn -1;tt}t}tif (sensord_args.doCGI && !sensord_args.rrdFile) {ttfprintf(stderr,ttt""Error: Incompatible --rrd-cgi without --rrd-file."");ttreturn -1;t}tif (sensord_args.rrdFile && !sensord_args.rrdTime) {ttfprintf(stderr,ttt""Error: Incompatible --rrd-file without --rrd-interval."");ttreturn -1;t}tif (!sensord_args.logTime && !sensord_args.scanTime &&t    !sensord_args.rrdFile) {ttfprintf(stderr,ttt""Error: No logging, alarm or RRD scanning."");ttreturn -1;t}treturn 0;}",2,"cwe120,cweother"
"__write_ports_addxprt(char *buf, struct net *net){tchar transport[16];tstruct svc_xprt *xprt;tint port, err;tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);tif (sscanf(buf, ""%15s %5u"", transport, &port) != 2)ttreturn -EINVAL;tif (port < 1 || port > USHRT_MAX)ttreturn -EINVAL;terr = nfsd_create_serv(net);tif (err != 0)ttreturn err;terr = svc_create_xprt(nn->nfsd_serv, transport, net,ttttPF_INET, port, SVC_SOCK_ANONYMOUS);tif (err < 0)ttgoto out_err;terr = svc_create_xprt(nn->nfsd_serv, transport, net,ttttPF_INET6, port, SVC_SOCK_ANONYMOUS);tif (err < 0 && err != -EAFNOSUPPORT)ttgoto out_close;t tnn->nfsd_serv->sv_nrthreads--;treturn 0;out_close:txprt = svc_find_xprt(nn->nfsd_serv, transport, net, PF_INET, port);tif (xprt != NULL) {ttsvc_close_xprt(xprt);ttsvc_xprt_put(xprt);t}out_err:tnfsd_destroy(net);treturn err;}",2,"cwe119,cwe120"
"dmp_udp_lines(FILE *f, struct udp_t *udpp){ register int32 i; register struct utline_t *utlp; int32 numins, sav_stlevel; char *chp, s1[RECLEN]; sav_stlevel = __pv_stlevel; __pv_stlevel = 4; __outlinpos = 0; numins = udpp->numins; for (utlp = udpp->utlines; utlp != NULL; utlp = utlp->utlnxt)  {   for (chp = utlp->tline, i = 0; i < numins; i++, chp++)    {               if (utlp->uledinum == i)      {                       if (utlp->utabsel == '0' && *chp == '1') __wrap_puts(""    r"", f);       else if (utlp->utabsel == '1' && *chp == '0') __wrap_puts(""    f"", f);       else if (utlp->utabsel == '*') __wrap_puts(""    *"", f);       else if (utlp->utabsel == 'p') __wrap_puts(""    p"", f);       else if (utlp->utabsel == 'n') __wrap_puts(""    n"", f);       else        {         sprintf(s1, "" (%c%c)"", (char) utlp->utabsel, *chp);         __wrap_puts(s1, f);        }      }           else { sprintf(s1, ""%5c"", *chp); __wrap_puts(s1, f); }    }   if (udpp->utyp != U_COMB)    { sprintf(s1, "" : %c "", *chp); __wrap_puts(s1, f); chp++; }   sprintf(s1, "" : %c ;"", *chp);   __nl_wrap_puts(s1, f);  } __pv_stlevel = sav_stlevel;}",2,"cwe119,cwe120"
"dundi_exec(struct ast_channel *chan, const char *context, const char *exten, int priority, const char *callerid, const char *data){tstruct dundi_result results[MAX_RESULTS];tint res;tint x=0;tchar req[1024];tconst char *dundiargs;tstruct ast_app *dial;tif (!strncasecmp(context, ""macro-"", 6)) {ttif (!chan) {tttast_log(LOG_NOTICE, ""Can't use macro mode without a channel!"");tttreturn -1;tt}tt ttif (!strcasecmp(exten, ""s"")) {tttexten = pbx_builtin_getvar_helper(chan, ""ARG1"");tttif (ast_strlen_zero(exten))ttttexten = ast_channel_macroexten(chan);tttif (ast_strlen_zero(exten))ttttexten = ast_channel_exten(chan);tttif (ast_strlen_zero(exten)) {ttttast_log(LOG_WARNING, ""Called in Macro mode with no ARG1 or MACRO_EXTEN?"");ttttreturn -1;ttt}tt}ttif (ast_strlen_zero(data))tttdata = ""e164"";t} else {ttif (ast_strlen_zero(data))tttdata = context;t}tres = dundi_lookup(results, MAX_RESULTS, chan, data, exten, 0);tif (res > 0) {ttsort_results(results, res);ttfor (x=0;x<res;x++) {tttif (ast_test_flag(results + x, DUNDI_FLAG_EXISTS)) {ttttif (!--priority)tttttbreak;ttt}tt}t}tif (x < res) {tt ttdundiargs = pbx_builtin_getvar_helper(chan, ""DUNDIDIALARGS"");ttsnprintf(req, sizeof(req), ""%s/%s,,%s"", results[x].tech, results[x].dest,tttS_OR(dundiargs, """"));ttdial = pbx_findapp(""Dial"");ttif (dial)tttres = pbx_exec(chan, dial, req);t} elsettres = -1;treturn res;}",2,"cwe119,cwe120"
"_ldapfull_set_crypt(moddata_t data, const char *scheme, const char *prefix, int saltlen, const char *passwd, char *buf, int buflen) {    const char *encrypted;    unsigned char salt[3];    static const char saltchars[] = ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./"";    if ((saltlen != 2) || (buflen < 14)) {        log_write(data->ar->c2s->log, LOG_ERR, ""Invalid crypt hash params"");        return 0;    }#ifdef HAVE_SSL    if( !RAND_bytes(salt,saltlen) )        return 0;    salt[0] = saltchars[salt[0] % 64];    salt[1] = saltchars[salt[1] % 64];    salt[2] = 0;#else         salt[0] = saltchars[random() % 64];    salt[1] = saltchars[random() % 64];    salt[2] = 0;#endif    encrypted = crypt(passwd, salt);    strncpy(buf, encrypted, buflen);    buf[buflen-1] = 0;    return 1;}",3,"cwe119,cwe120,cweother"
"reefnet_sensusultra_handshake (reefnet_sensusultra_device_t *device, unsigned short value){t tunsigned char handshake[SZ_HANDSHAKE + 2] = {0};tdc_status_t rc = reefnet_sensusultra_packet (device, handshake, sizeof (handshake), 0);tif (rc != DC_STATUS_SUCCESS)ttreturn rc;t tdevice->systime = dc_datetime_now ();tdevice->devtime = array_uint32_le (handshake + 4);t tmemcpy (device->handshake, handshake, SZ_HANDSHAKE);t tdc_event_clock_t clock;tclock.systime = device->systime;tclock.devtime = device->devtime;tdevice_event_emit (&device->base, DC_EVENT_CLOCK, &clock);t tdc_event_devinfo_t devinfo;tdevinfo.model = handshake[1];tdevinfo.firmware = handshake[0];tdevinfo.serial = array_uint16_le (handshake + 2);tdevice_event_emit (&device->base, DC_EVENT_DEVINFO, &devinfo);t tdc_event_vendor_t vendor;tvendor.data = device->handshake;tvendor.size = sizeof (device->handshake);tdevice_event_emit (&device->base, DC_EVENT_VENDOR, &vendor);t trc = reefnet_sensusultra_send_ushort (device, value);tif (rc != DC_STATUS_SUCCESS)ttreturn rc;treturn DC_STATUS_SUCCESS;}",2,"cwe119,cwe120"
"app_RAND_load_file(const char *file){    char buffer[200];    if(file == NULL)      file = RAND_file_name(buffer, sizeof buffer);    else if(RAND_egd(file) > 0){t tegdsocket = 1;treturn 1;    }    if(file == NULL || !RAND_load_file(file, -1)){tif(RAND_status() == 0){t    dprint((1, ""unable to load 'random state'""));t    dprint((1, ""This means that the random number generator has not been seeded""));t    dprint((1, ""with much random data.""));t}treturn 0;    }    seeded = 1;    return 1;}",2,"cwe119,cwe120"
"init_pci(void){twrite(""do pci stuff"");tshort x,y,t;    char macaddr[8];tunsigned long inp;tunsigned long dev;    unsigned long temp;    unsigned long iobase;    unsigned long inters; tfor (x=0; x < 128; x++){ttfor (y=0; y <16; y++){tttinp  = pci_readword(x,y,0,0);tttif (inp < 65535){ttttwrite(""pci device detected"");ttttdev = pci_readword(x,y,0,1);                switch (inp){                    case 0X000010ec:                          write(""realtek device found"");                        switch(dev){                            case 0xFFFF8139:                                                                                                       for (t=8; t <= 14; t++){                                                                          iobase = pci_readword(x,y,0,t);                                                                                                           if ((iobase & 0x1) == 0x1){                                                                                  iobase = iobase & 0XFFFFFFF0;                                                                                 char i;                                        for (i = 0; i < 6; i++)                                                                                 {                                            macaddr[i] = inb(iobase + i);                                            writehex(macaddr[i]);                                        }                                        write(""power on"");                                        outb(iobase + 0x52, 0);                                          write(""reset register"");                                        outb(iobase + 0x37, 0x10);                                          char still_reset = 0;                                        while(inb(iobase + 0x37) & 0x10){                                            write(""waiting for reset :)"");                                        }                                        write(""setup receive buffer"");                                                                                 char rx_buffer[8192 + 16];                                        outl(iobase + 0x30, (unsigned long) rx_buffer);                                        write(""setup interrupt"");                                                                                 outb(iobase + 0x3C, 0x08 | 0x04 | 0x02 | 0x01);                                                                                                                                                                   write(""configure buffer"");                                        outl(iobase + 0x44, 0x0f );                                                                                write(""start everything"");                                        outb(iobase + 0x37, 0x0C);                                        write(""done"");                                        break;                                    }                                }                               break;                            default:                                write(""unknown card found"");                        }                        break;                    default:                        write(""unknown vender"");                }ttt}tt}t}}",2,"cwe119,cwe120"
"isosurf_get_att(int id, Tcl_Interp * interp, int argc, char *argv[]){    int set, isosurf_id;    float c;    char mapname[100], temp[100];    if (argc != 5) {tTcl_SetResult(interp,tt      ""Usage: <map_obj> isosurf get_att isosurf_id [threshold | color | mask | transp | shin | emi]"",tt      TCL_VOLATILE);treturn (TCL_ERROR);    }    isosurf_id = atoi(argv[3]);    GVL_isosurf_get_att(id, isosurf_id, isosurf_att_atoi(argv[4]), &set, &c,tttmapname);    switch (set) {    case NOTSET_ATT:tTcl_AppendElement(interp, ""unset"");tbreak;    case MAP_ATT:tTcl_AppendElement(interp, ""map"");tTcl_AppendElement(interp, mapname);tbreak;    case CONST_ATT:tTcl_AppendElement(interp, ""const"");tsprintf(temp, ""%f"", c);tTcl_AppendElement(interp, temp);tbreak;    case FUNC_ATT:t tbreak;    }    return (TCL_OK);}",3,"cwe119,cwe120,cweother"
"ipset_flush(const char *name){tstruct rtnl_handle rth;tstruct req {ttstruct nlmsghdr n;ttstruct nfgenmsg nf;ttchar buf[4096];t} req;tuint8_t protocol = IPSET_PROTOCOL;tif (rtnl_open_byproto(&rth, 0, NETLINK_NETFILTER)) {ttlog_error(""ipset: cannot open rtnetlink"");ttreturn -1;t}ttmemset(&req, 0, sizeof(req) - 4096);treq.n.nlmsg_len = NLMSG_LENGTH(sizeof(struct nfgenmsg));treq.n.nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;treq.n.nlmsg_type = IPSET_CMD_FLUSH | (NFNL_SUBSYS_IPSET << 8);treq.nf.nfgen_family = AF_INET;treq.nf.version = NFNETLINK_V0;treq.nf.res_id = 0;taddattr_l(&req.n, 4096, IPSET_ATTR_PROTOCOL, &protocol, 1);taddattr_l(&req.n, 4096, IPSET_ATTR_SETNAME, name, strlen(name) + 1);ttif (rtnl_talk(&rth, &req.n, 0, 0, NULL, NULL, NULL, 0) < 0)ttgoto out_err;ttrtnl_close(&rth);treturn 0;out_err:trtnl_close(&rth);treturn -1;}",2,"cwe119,cwe120"
"max_numchars (const gretl_matrix *m){    char s[24];    int i, n = m->rows * m->cols;    int c, cmax = 0;    for (i=0; i<n && cmax<6; i++) {tsprintf(s, ""%g"", m->val[i]);tc = strlen(s);tif (c > cmax) {t    cmax = c;t}    }    return cmax;}",2,"cwe119,cwe120"
"InsertRowHDU(char *buffer, const char *data, int offset){  size_t    len;  if (data == NULL)    return offset;  len = strlen(data);  len = Min(len,80);    if (len > (size_t) (FITS_BLOCK_SIZE-offset))tlen = FITS_BLOCK_SIZE-offset;  (void) strncpy(buffer+offset,data,len);  return offset +80;}",2,"cwe119,cwe120"
"change_cafpr (int fprno){  char *data;  const char *s;  int i, c, rc;  unsigned char fpr[20];  data = cpr_get (""cardedit.change_cafpr"", _(""CA fingerprint: ""));  if (!data)    return -1;  trim_spaces (data);  cpr_kill_prompt ();  for (i=0, s=data; i < 20 && *s; )    {      while (spacep(s))        s++;      if (*s == ':')        s++;      while (spacep(s))        s++;      c = hextobyte (s);      if (c == -1)        break;      fpr[i++] = c;      s += 2;    }  xfree (data);  if (i != 20 || *s)    {      tty_printf (_(""Error: invalid formatted fingerprint.""));      return -1;    }  rc = agent_scd_setattr (fprno==1?""CA-FPR-1"":                          fprno==2?""CA-FPR-2"":                          fprno==3?""CA-FPR-3"":""x"", fpr, 20, NULL );  if (rc)    log_error (""error setting cafpr: %s"", gpg_strerror (rc));  write_sc_op_status (rc);  return rc;}",2,"cwe119,cwe120"
"__dump_inodelks (pl_inode_t *pl_inode){        pl_dom_list_t   *dom  = NULL;        pl_inode_lock_t *lock = NULL;        int             count = 0;        char            key[GF_DUMP_MAX_BUF_LEN];        char tmp[256];        list_for_each_entry (dom, &pl_inode->dom_list, inode_list) {                count = 0;                gf_proc_dump_build_key(key,                                       ""lock-dump.domain"",                                       ""domain"");                gf_proc_dump_write(key, ""%s"", dom->domain);                list_for_each_entry (lock, &dom->inodelk_list, list) {                        gf_proc_dump_build_key(key,                                               ""inodelk"",                                               ""inodelk[%d](ACTIVE)"",count );                        SET_FLOCK_PID (&lock->user_flock, lock);                        pl_dump_lock (tmp, 256, &lock->user_flock,                                      &lock->owner,                                      lock->transport,                                      &lock->granted_time.tv_sec,                                      &lock->blkd_time.tv_sec,                                      _gf_true);                        gf_proc_dump_write(key, tmp);                        count++;                }                list_for_each_entry (lock, &dom->blocked_inodelks, blocked_locks) {                        gf_proc_dump_build_key(key,                                               ""inodelk"",                                               ""inodelk[%d](BLOCKED)"",count );                        SET_FLOCK_PID (&lock->user_flock, lock);                        pl_dump_lock (tmp, 256, &lock->user_flock,                                      &lock->owner,                                      lock->transport,                                      0, &lock->blkd_time.tv_sec,                                      _gf_false);                        gf_proc_dump_write(key, tmp);                        count++;                }        }}",2,"cwe119,cwe120"
set_udpsyncto(byte ttyp) { switch (ttyp) {     case ENDMODULE: case ENDPRIMITIVE:   __syncto_class = SYNC_FLEVEL;   break;  case PRIMITIVE: case MODULE: case MACROMODULE:   __unget_vtok();   __syncto_class = SYNC_FLEVEL;   break; case INPUT: case OUTPUT: case REG: case TABLE:   __unget_vtok();   __syncto_class = SYNC_UDPLEVEL;   break;  default: return(FALSE); } return(TRUE);},2,"cwe119,cwe120"
"ind_socket_ai(struct evutil_addrinfo *ai, int reuse){tevutil_socket_t fd;tint on = 1, r;tint serrno;t tfd = socket(ai ? ai->ai_family : AF_INET, SOCK_STREAM, 0);tif (fd == -1) {tttevent_sock_warn(-1, ""socket"");tttreturn (-1);t}tif (evutil_make_socket_nonblocking(fd) < 0)ttgoto out;tif (evutil_make_socket_closeonexec(fd) < 0)ttgoto out;tif (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&on, sizeof(on))<0)ttgoto out;tif (reuse) {ttif (evutil_make_listen_socket_reuseable(fd) < 0)tttgoto out;t}tif (ai != NULL) {ttr = bind(fd, ai->ai_addr, (ev_socklen_t)ai->ai_addrlen);ttif (r == -1)tttgoto out;t}treturn (fd); out:tserrno = EVUTIL_SOCKET_ERROR();tevutil_closesocket(fd);tEVUTIL_SET_SOCKET_ERROR(serrno);treturn (-1);}",2,"cwe119,cwe120"
"rb_compile_warning(const char *file, int line, const char *fmt, ...){    char buf[BUFSIZ];    va_list args;    if (!RTEST(ruby_verbose)) return;    snprintf(buf, BUFSIZ, ""warning: %s"", fmt);    va_start(args, fmt);    compile_warn_print(file, line, buf, args);    va_end(args);}",2,"cwe119,cwe120"
"client3_1_unlink (call_frame_t *frame, xlator_t *this,                  void *data){        clnt_conf_t     *conf     = NULL;        clnt_args_t     *args     = NULL;        gfs3_unlink_req  req      = {{0,},};        int              ret      = 0;        int              op_errno = 0;        if (!frame || !this || !data)                goto unwind;        args = data;        if (!(args->loc && args->loc->parent))                goto unwind;        if (!uuid_is_null (args->loc->parent->gfid))                memcpy (req.pargfid,  args->loc->parent->gfid, 16);        else                memcpy (req.pargfid, args->loc->pargfid, 16);        GF_ASSERT_AND_GOTO_WITH_ERROR (this->name,                                       !uuid_is_null (*((uuid_t*)req.pargfid)),                                       unwind, op_errno, EINVAL);        req.bname = (char *)args->loc->name;        conf = this->private;        GF_PROTOCOL_DICT_SERIALIZE (this, args->xdata, (&req.xdata.xdata_val),                                    req.xdata.xdata_len, op_errno, unwind);        ret = client_submit_request (this, &req, frame, conf->fops,                                     GFS3_OP_UNLINK,                                     client3_1_unlink_cbk, NULL,                                     NULL, 0, NULL, 0,                                     NULL, (xdrproc_t)xdr_gfs3_unlink_req);        if (ret) {                gf_log (this->name, GF_LOG_WARNING, ""failed to send the fop"");        }        if (req.xdata.xdata_val)                GF_FREE (req.xdata.xdata_val);        return 0;unwind:        CLIENT_STACK_UNWIND (unlink, frame, -1, op_errno, NULL, NULL, NULL);        if (req.xdata.xdata_val)                GF_FREE (req.xdata.xdata_val);        return 0;}",2,"cwe120,cwe476"
"EvaluateANDString(char *class,struct Item *list,int fromIsInstallable){ char *sp, *atom;  char cbuff[CF_BUFSIZE];  int count = 1;  int negation = false;Debug4(""EvaluateANDString(%s)"",class);count = CountEvalAtoms(class);sp = class; while(*sp != '0')   {   negation = false;   while (*sp == '!')      {      negation = !negation;      sp++;      }   memset(cbuff,0,CF_BUFSIZE);   sp += GetANDAtom(sp,cbuff) + 1;   atom = cbuff;            if (IsBracketed(cbuff))      {      atom = cbuff+1;      Debug4(""Checking AND Atom %s?"",atom);            cbuff[strlen(cbuff)-1] = '0';            if (EvaluateORString(atom,list,fromIsInstallable))         {         if (negation)            {            Debug4(""EvalANDString-temp-result-neg1=false"");            return false;            }         else            {            Debug4(""EvalORString-temp-result count=%d"",count);            count--;            }         }      else         {         if (negation)            {            Debug4(""EvalORString-temp-result2 count=%d"",count);            count--;            }         else            {            return false;            }         }      continue;      }   else      {      atom = cbuff;      }             if (*sp == '.' || *sp == '&')      {      sp++;      }   Debug4(""Checking OR atom (%s)?"",atom);   CheckCommonErrors(atom);   if (IsItemIn(VNEGHEAP,atom))      {      if (negation)         {         Debug4(""EvalORString-temp-result3 count=%d"",count);         count--;         }      else         {         return false;         }      }    else if (IsItemIn(VHEAP,atom))      {      if (negation)         {         Debug4(""EvaluateANDString(%s) returns false by negation 1"",class);         return false;         }      else         {         Debug4(""EvalORString-temp-result3.5 count=%d"",count);         count--;         }      }    else if (IsItemIn(list,atom))      {      if (negation && !fromIsInstallable)         {         Debug4(""EvaluateANDString(%s) returns false by negation 2"",class);         return false;         }      else         {         Debug4(""EvalORString-temp-result3.6 count=%d"",count);         count--;         }      }    else if (negation)           {      Debug4(""EvalORString-temp-result4 count=%d"",count);      count--;      }   else             {      Debug4(""EvaluateANDString(%s) returns false ny negation 3"",class);      return false;      }   } if (count == 0)   {   Debug4(""EvaluateANDString(%s) returns true"",class);   return(true);   }else   {   Debug4(""EvaluateANDString(%s) returns false"",class);   return(false);   }}",2,"cwe119,cwe120"
"_cmdline_parse (int argc, char **argv){  char options[100];  int c;#if HAVE_GETOPT_LONG  struct option long_options[] =    {      { ""help"",                0, NULL, 'h'},      { ""version"",             0, NULL, 'v'},#ifndef NDEBUG      { ""config-file"",         1, NULL, 'c'},      { ""debug"",               0, NULL, 'd'},#endif        { NULL,                  0, NULL, 0},    };#endif    assert (argv);  memset (options, '0', sizeof (options));  strcat (options, ""hv"");#ifndef NDEBUG  strcat (options, ""c:d"");#endif       opterr = 0;#if HAVE_GETOPT_LONG  while ((c = getopt_long (argc, argv, options, long_options, NULL)) != -1)#else    while ((c = getopt (argc, argv, options)) != -1)#endif      {    switch (c)      {      case 'h':                _usage ();        break;      case 'v':                _version ();        break;#ifndef NDEBUG      case 'c':                if (!(conf.config_file = strdup (optarg)))          IPMIDETECTD_EXIT ((""strdup: %s"", strerror (errno)));        break;      case 'd':                conf.debug++;        break;#endif        case '?':      default:        IPMIDETECTD_EXIT ((""unknown command line option '%c'"", c));      }      }}",3,"cwe119,cwe120,cweother"
"iwl_dbgfs_plcp_delta_write(struct file *file,tttttconst char __user *user_buf,tttttsize_t count, loff_t *ppos) {tstruct iwl_priv *priv = file->private_data;tchar buf[8];tint buf_size;tint plcp;tmemset(buf, 0, sizeof(buf));tbuf_size = min(count, sizeof(buf) -  1);tif (copy_from_user(buf, user_buf, buf_size))ttreturn -EFAULT;tif (sscanf(buf, ""%d"", &plcp) != 1)ttreturn -EINVAL;tif ((plcp < IWL_MAX_PLCP_ERR_THRESHOLD_MIN) ||tt(plcp > IWL_MAX_PLCP_ERR_THRESHOLD_MAX))ttpriv->plcp_delta_threshold =tttIWL_MAX_PLCP_ERR_THRESHOLD_DISABLE;telsettpriv->plcp_delta_threshold = plcp;treturn count;}",2,"cwe119,cwe120"
"oc_check_allowed_sv(Slapi_PBlock *pb, Slapi_Entry *e, const char *type, struct objclass **oclist ){    struct objclass *oc;    int i, j;    inttrc = 1;                    if ( slapi_attr_type_cmp( type, ""objectclass"", SLAPI_TYPE_CMP_EXACT ) == 0 ) {      return( 0 );    } else if ( slapi_attr_type_cmp( type, ""entryid"", SLAPI_TYPE_CMP_EXACT ) == 0 ) {      return( 0 );    }             for (i = 0; rc != 0 && oclist[i] != NULL; i++) {      oc = oclist[i];             for ( j = 0; oc->oc_required && oc->oc_required[j] != NULL; j++ ) {        if ( slapi_attr_type_cmp( oc->oc_required[j],                                  type, SLAPI_TYPE_CMP_SUBTYPE ) == 0 ) {          rc = 0;          break;        }      }                if ( 0 != rc ) {                 for ( j = 0; oc->oc_allowed && oc->oc_allowed[j] != NULL; j++ ) {          if ( slapi_attr_type_cmp( oc->oc_allowed[j],                                    type, SLAPI_TYPE_CMP_SUBTYPE ) == 0 ||                strcmp( oc->oc_allowed[j],""*"" ) == 0 ) {            rc = 0;            break;          }        }               }    }    if ( 0 != rc ) {      char errtext[ BUFSIZ ];      char ebuf[ BUFSIZ ];      LDAPDebug( LDAP_DEBUG_ANY,         ""Entry ""%s"" -- attribute ""%s"" not allowed"",         slapi_entry_get_dn_const(e),         escape_string( type, ebuf ),         0);      if (pb) {        PR_snprintf( errtext, sizeof( errtext ),         ""attribute ""%s"" not allowed"",         escape_string( type, ebuf ) );        slapi_pblock_set( pb, SLAPI_PB_RESULT_TEXT, errtext );      }    }        return rc;}",2,"cwe119,cwe120"
"rpc2_login_decode(const json_t *val) {    const char *id;    const char *s;    json_t *res = json_object_get(val, ""result"");    if(!res) {        applog(LOG_ERR, ""JSON invalid result"");        goto err_out;    }    json_t *tmp;    tmp = json_object_get(res, ""id"");    if(!tmp) {        applog(LOG_ERR, ""JSON inval id"");        goto err_out;    }    id = json_string_value(tmp);    if(!id) {        applog(LOG_ERR, ""JSON id is not a string"");        goto err_out;    }    memcpy(&rpc2_id, id, 64);    if(opt_debug)        applog(LOG_DEBUG, ""Auth id: %s"", id);    tmp = json_object_get(res, ""status"");    if(!tmp) {        applog(LOG_ERR, ""JSON inval status"");        goto err_out;    }    s = json_string_value(tmp);    if(!s) {        applog(LOG_ERR, ""JSON status is not a string"");        goto err_out;    }    if(strcmp(s, ""OK"")) {        applog(LOG_ERR, ""JSON returned status ""%s"""", s);        return false;    }    return true;    err_out: return false;}",2,"cwe120,cwe469"
"ftp_status(FILE *ftp, char *statusstr){        char recbuf[MAXLEN];  int len;  len = strlen(statusstr);  while (1) {    if (!(fgets(recbuf,MAXLEN,ftp))) {#ifdef DEBUG      puts(""error reading response in ftp_status"");#endif      return 1;      }    #ifdef DEBUG    printf(""ftp_status, return string was %s"",recbuf);#endif    recbuf[len] = '0';      if (!strcmp(recbuf,statusstr)) {      return 0;      }    if (recbuf[0] > '3') {             return 1;     }  }}",2,"cwe119,cwe120"
"command_line (int argc, char *argv[]){tint c;ttt #ifdef HAS_GETOPT_LONGtwhile (1) { t ttint option_index = 0;ttstatic struct option long_options[] = {ttt{""allow-noident-file"", 0, 0, 'n'},ttt{""help"", 0, 0, 'h'},ttt{""usage"", 0, 0, 'u'},ttt{""version"", 0, 0, 'v'},ttt{""license"", 0, 0, 'l'},ttt{""force-inetd"", 0, 0, 'a'},ttt{""force-daemon"", 0, 0, 'd'},ttt{""use-user-ident"", 0, 0, 'i'},ttt{""dont-change-uid"", 0, 0, 's'},ttt{""always-random"", 0, 0, 'r'},ttt{""user-reply-file"", 1, 0, 'y'},ttt{""client-timeout"", 1, 0, 'o'},ttt{""daemon-maxclients"", 1, 0, 'm'},ttt{""daemon-port"", 1, 0, 'p'},ttt{0, 0, 0, 0},tt};ttc = getopt_long (argc, argv, ""nhuvrliady:o:ftTsm:p:"",tttlong_options, &option_index);ttif (c == -1) {tttbreak;tt}t#else        while ((c = getopt (argc, argv, ""nhuvrliady:o:ftTsm:p:"")) != -1) {#endifttswitch (c) {tttcase 'n':ttttAllow_NOIDENT = TRUE;ttttbreak;tttcase 'h':ttttprint_help ();ttttexit (0);tttcase 'u':ttttprint_usage ();ttttexit (0);ttttcase 'v':ttttprint_version ();ttttexit (0);tttcase 'l':ttttprint_license ();ttttexit (0);tttcase 'a':ttttService_Type = INETD;ttttbreak;tttcase 'd':ttttService_Type = DAEMON;ttttbreak;tttcase 'i':ttttUse_User_Ident = TRUE;ttttbreak;tttcase 's':ttttDont_Change_Uid = TRUE;ttttbreak;tttcase 'r':ttttReply_Always_Random = TRUE;ttttbreak;tttcase 'y':ttttUser_Ident_File = optarg;ttttbreak;tttcase 'o':ttttif ((Client_Timeout = atol (optarg)) == 0) {tttttfprintf (stderr, ""ERROR: Ident2: bad ""tttttt""value for arguement `o'"");tttttexit (1);tttt}ttttbreak;tttcase 'm':ttttif ((Max_Connections = atol (optarg)) == 0) {tttttfprintf (stderr, ""ERROR: Ident2: bad""tttttt"" value for arguement `m'"");tttttexit (1);tttt}ttttbreak;tttcase 'p':ttttif ((Ident_Port = atoi (optarg)) == 0) { tttttfprintf (stderr, ""ERROR: Ident2: bad""tttttt"" value for arguement `p'"");tttttexit (1);tttt}ttttbreak;tttcase '?':tttdefault:#ifdef HAS_GETOPT_LONGttttfprintf (stderr, ""ident2: bad command line:""tttt""t``ident2 --help | more'' for help""tttt""t``ident2 --usage'' for some examples"");#elsettttfprintf (stderr, ""ident2: bad command line:""tttt""t``ident2 -h | more'' for help""tttt""t``ident2 -u'' for some examples"");#endifttttexit (1);tt}t}}",2,"cwe120,cweother"
"glusterd_op_ac_send_commit_failed (glusterd_op_sm_event_t *event, void *ctx){        int                             ret = 0;        glusterd_req_ctx_t              *req_ctx = NULL;        dict_t                          *op_ctx = NULL;        GF_ASSERT (ctx);        req_ctx = ctx;        op_ctx = glusterd_op_get_ctx ();        ret = glusterd_op_commit_send_resp (req_ctx->req, req_ctx->op,                                            opinfo.op_ret, opinfo.op_errstr,                                            op_ctx);        glusterd_op_fini_ctx ();        if (opinfo.op_errstr && (strcmp (opinfo.op_errstr, """"))) {                GF_FREE (opinfo.op_errstr);                opinfo.op_errstr = NULL;        }        gf_log (THIS->name, GF_LOG_DEBUG, ""Returning with %d"", ret);        return ret;}",2,"cwe469,cwe476"
"""align_val( const char * cc ){    char s[ MAX_TYPE_NAME_LEN ],         *p;    int val;    fli_sstrcpy( s, cc, sizeof s );    if ( ( p = strchr( s, '|' ) ) )    {        *p = '0';        while ( isspace( ( int ) *--p  ) )            *p = '0';    }    val = get_vn_val( vn_align, s );    return p ? ( val | FL_ALIGN_INSIDE ) : val;}""",3,"cwe119,cwe120,cweother"
"add_connpt_2(struct fpga_model* model, int y, int x,tconst char* connpt_name, const char* suffix1, const char* suffix2,tint dup_warn){tchar name_buf[MAX_WIRENAME_LEN];tRC_CHECK(model);tsnprintf(name_buf, sizeof(name_buf), ""%s%s"", connpt_name, suffix1);tadd_connpt_name(model, y, x, name_buf, dup_warn,tt  0,   0);tsnprintf(name_buf, sizeof(name_buf), ""%s%s"", connpt_name, suffix2);tadd_connpt_name(model, y, x, name_buf, dup_warn,tt  0,   0);tRC_RETURN(model);}",2,"cwe119,cwe120"
"hash_filehandle(int hash, FILE *in, unsigned char *out, unsigned long *outlen){#ifdef LTC_NO_FILE    return CRYPT_NOP;#else    hash_state md;    unsigned char buf[512];    size_t x;    int err;    LTC_ARGCHK(out    != NULL);    LTC_ARGCHK(outlen != NULL);    LTC_ARGCHK(in     != NULL);    if ((err = hash_is_valid(hash)) != CRYPT_OK) {        return err;    }    if (*outlen < hash_descriptor[hash].hashsize) {       *outlen = hash_descriptor[hash].hashsize;       return CRYPT_BUFFER_OVERFLOW;    }    if ((err = hash_descriptor[hash].init(&md)) != CRYPT_OK) {       return err;    }    *outlen = hash_descriptor[hash].hashsize;    do {        x = fread(buf, 1, sizeof(buf), in);        if ((err = hash_descriptor[hash].process(&md, buf, x)) != CRYPT_OK) {           return err;        }    } while (x == sizeof(buf));    err = hash_descriptor[hash].done(&md, out);#ifdef LTC_CLEAN_STACK    zeromem(buf, sizeof(buf));#endif    return err;#endif}",2,"cwe476,cweother"
"""read_motd(char *filename){tint fd, len;tregister aMotd *temp, *last;tstruct stat Sb;tchar line[80];tregister char *tmp;ttif ((fd = open(filename, O_RDONLY)) == -1)ttreturn;tif (fstat(fd, &Sb) == -1)t    {ttclose(fd);ttreturn;t    }tif (Sb.st_mtime <= motd_mtime)t{ttclose(fd);ttreturn;t}tmotd_mtime = Sb.st_mtime;tfor(;motd != NULL;motd=last)t    {ttlast = motd->next;ttMyFree(motd->line);ttMyFree(motd);t    }t(void)dgets(-1, NULL, 0); /* make sure buffer is at empty pos */tlast = NULL;twhile ((len=dgets(fd, line, sizeof(line)-1)) > 0)t    {ttif ((tmp = strchr(line, '')) != NULL)ttt*tmp = (char) 0;ttelse if ((tmp = strchr(line, 'r')) != NULL)ttt*tmp = (char) 0;ttelsetttline[len] = '0';tttemp = (aMotd *)MyMalloc(sizeof(aMotd));tttemp->line = mystrdup(line);tttemp->next = NULL;tt       if (!motd)tttmotd = temp;ttelsetttlast->next = temp;ttlast = temp;t    }t(void)dgets(-1, NULL, 0); /* make sure buffer is at empty pos */tclose(fd);}""",4,"cwe119,cwe120,cwe469,cweother"
"wi_random_get_bytes(void *buffer, wi_uinteger_t length) {#ifndef HAVE_OPENSSL_SHA_Htunsigned chartt*p;tuint32_tttti;#endift#ifdef HAVE_OPENSSL_SHA_HtRAND_bytes(buffer, length);#elsetif(_wi_data_random_fd >= 0)ttread(_wi_data_random_fd, buffer, length);telsettmemset(buffer, 0, length);ttfor(p = buffer, i = 0; i < length; i++)tt*p++ ^= (_WI_DATA_RANDOM() >> 7) & 0xFF;#endif}",2,"cwe120,cweother"
"do_cmd_buy(cmd_code code, cmd_arg args[]){tint item = args[0].item;tint amt = args[1].number;tobject_type *o_ptr;ttobject_type object_type_body;tobject_type *i_ptr = &object_type_body;tchar o_name[80];tint price, item_new;tstore_type *st_ptr;tint this_store = current_store();tif (this_store == STORE_NONE)t{ttmsg_print(""You cannot purchase items when not in a store."");ttreturn;t}tst_ptr = &store[this_store];t to_ptr = &st_ptr->stock[item];t tobject_copy_amt(i_ptr, o_ptr, amt);t tif (!inven_carry_okay(i_ptr))t{ttmsg_print(""You cannot carry that many items."");ttreturn;t}t tobject_desc(o_name, sizeof(o_name), i_ptr, ODESC_PREFIX | ODESC_FULL);t tprice = price_item(i_ptr, FALSE, i_ptr->number);tif (price > p_ptr->au)t{ttmsg_print(""You cannot afford that purchase."");ttreturn;t}t tp_ptr->au -= price;t tstore_flags |= STORE_GOLD_CHANGE;t tobject_notice_everything(i_ptr);t tp_ptr->notice |= (PN_COMBINE | PN_REORDER | PN_SORT_QUIVER | PN_SQUELCH);t ti_ptr->ident &= ~(IDENT_STORE);t tif (one_in_(3)) message(MSG_STORE5, 0, ONE_OF(comment_accept));tmsg_format(""You bought %s for %ld gold."", o_name, (long)price);t ti_ptr->note = 0;t titem_new = inven_carry(i_ptr);t tobject_desc(o_name, sizeof(o_name), &inventory[item_new],ttttODESC_PREFIX | ODESC_FULL);tmsg_format(""You have %s (%c)."", o_name, index_to_label(item_new));t tif (o_ptr->tval == TV_WAND || o_ptr->tval == TV_STAFF)t{tto_ptr->pval -= i_ptr->pval;t}t thandle_stuff();t tstore_item_increase(this_store, item, -amt);tstore_item_optimize(this_store, item);t tif (st_ptr->stock_num == 0)t{ttint i;tt ttif (one_in_(STORE_SHUFFLE))tt{ttt tttmsg_print(""The shopkeeper retires."");ttt tttstore_shuffle(this_store);tttstore_flags |= STORE_FRAME_CHANGE;tt}tt ttelsett{ttt tttmsg_print(""The shopkeeper brings out some new stock."");tt}tt ttfor (i = 0; i < 10; ++i)tt{ttt tttstore_maint(this_store);tt}t}tevent_signal(EVENT_INVENTORY);tevent_signal(EVENT_EQUIPMENT);}",2,"cwe119,cwe120"
"rosh_prompt(int iargc, char *iargv[]){    int rv;    char cmdstr[ROSH_CMD_SZ];    char ipwdstr[ROSH_PATH_SZ];    char do_exit;    char **argv;    int argc;    rv = 0;    do_exit = false;    if (!getcwd(ipwdstr, ROSH_PATH_SZ))tstrcpy(ipwdstr, ""./"");    if (iargc > 1)tdo_exit = rosh_command(iargc - 1, &iargv[1], ipwdstr);    while (!(do_exit)) {t tprintf(""rosh: "");t tif (fgets(cmdstr, ROSH_CMD_SZ, stdin)) {t    argc = rosh_str2argv(&argv, cmdstr);t    do_exit = rosh_command(argc, argv, ipwdstr);t    rosh_free_argv(&argv);t} else {t    do_exit = false;t}    }    return rv;}",3,"cwe119,cwe120,cweother"
"""parse(FILE *fp) {  enum { SEEK, WORD } state;  int ch;  for(state = SEEK; (ch = fgetc(fp)) != EOF; ) {    switch(state) {    case SEEK:      if(isalnum(ch)) {tungetc(ch, fp);tstate = WORD;      }      break;    case WORD:      if(!isalnum(ch)) {tputchar('');tstate = SEEK;      } else {tputchar(ch);      }      break;    }  }  if(state == WORD)    putchar('');}""",2,"cwe120,cweother"
"v5PutSin(const struct sockaddr_in *sin, int sinLen, v5HeadType *reply){    reply->atyp=ATYP_V4;tt     switch (sin->sin_family) {tdefault:t    reply->cmd=SOCKS5_GENFAIL;t     tcase AF_INET:t    memcpy(reply->destAddr,&sin->sin_addr,4);t    memcpy(reply->destAddr+4,&sin->sin_port,sizeof(sin->sin_port));t    return 4+sizeof(sin->sin_port);#ifdef AF_INET6tcase AF_INET6:t    reply->atyp=ATYP_V6;t    memcpy(reply->destAddr,&sin->sin_addr,16);t    memcpy(reply->destAddr+16,&sin->sin_port,sizeof(sin->sin_port));t    return 16+sizeof(sin->sin_port);#endif    }}",2,"cwe120,cweother"
"lcddisplay(struct io_data *io_data, __maybe_unused SOCKETTYPE c, __maybe_unused char *param, bool isjson, __maybe_unused char group){tstruct api_data *root = NULL;tbool io_open = false;tchar *status, *lp;tdouble ghs;tchar szindex[32] = {0};tchar szfan[32] = {0};tchar sztemp[32] = {0};tchar szpool[32] = {0};tchar szuser[32] = {0};tstruct pool *pool = current_pool();tmessage(io_data, MSG_POOL, 0, NULL, isjson);tif (isjson)ttio_open = io_add(io_data, COMSTR JSON_POOLS);tghs = total_mhashes_done / 1000 / total_secs;tstrcpy(szindex, ""0"");troot = api_add_string(root, ""LCD"", szindex, false);troot = api_add_mhs(root, ""GHS5s"", &(g_displayed_rolling), false);troot = api_add_mhs(root, ""GHSavg"", &(ghs), false);tsprintf(szfan, ""%d"", g_max_fan);troot = api_add_string(root, ""fan"", szfan, false);tsprintf(sztemp, ""%d"", g_max_temp);troot = api_add_string(root, ""temp"", sztemp, false);tif(pool == NULL) {ttstrcpy(szpool, ""no"");ttstrcpy(szuser, ""no"");ttroot = api_add_string(root, ""pool"", szpool, false);ttroot = api_add_string(root, ""user"", szuser, false);t} else {ttroot = api_add_string(root, ""pool"", pool->rpc_url, false);ttroot = api_add_string(root, ""user"", pool->rpc_user, false);t}troot = print_data(io_data, root, isjson, isjson);tif (isjson && io_open)ttio_close(io_data);}",2,"cwe119,cwe120"
"netlink_ipaddress(ip_address *ipaddress, int cmd){tint status = 1;tstruct {ttstruct nlmsghdr n;ttstruct ifaddrmsg ifa;ttchar buf[256];t} req;tmemset(&req, 0, sizeof (req));treq.n.nlmsg_len = NLMSG_LENGTH(sizeof (struct ifaddrmsg));treq.n.nlmsg_flags = NLM_F_REQUEST;treq.n.nlmsg_type = cmd ? RTM_NEWADDR : RTM_DELADDR;treq.ifa = ipaddress->ifa;tif (IP_IS6(ipaddress)) {ttaddattr_l(&req.n, sizeof(req), IFA_LOCAL,ttt  &ipaddress->u.sin6_addr, sizeof(ipaddress->u.sin6_addr));t} else {ttaddattr_l(&req.n, sizeof(req), IFA_LOCAL,ttt  &ipaddress->u.sin.sin_addr, sizeof(ipaddress->u.sin.sin_addr));ttif (ipaddress->u.sin.sin_brd.s_addr)tttaddattr_l(&req.n, sizeof(req), IFA_BROADCAST,tttt  &ipaddress->u.sin.sin_brd, sizeof(ipaddress->u.sin.sin_brd));t}tif (ipaddress->label)ttaddattr_l(&req.n, sizeof (req), IFA_LABEL,ttt  ipaddress->label, strlen(ipaddress->label) + 1);tif (netlink_talk(&nl_cmd, &req.n) < 0)ttstatus = -1;treturn status;}",2,"cwe119,cwe120"
"update_log (SimulationState *state, simulation_t *sim){tchar const *txt [6] = {tt_(""Simulations""), _(""Iterations""), _(""# Input variables""),tt_(""# Output variables""), _(""Runtime""), _(""Run on"")t};tGtkTreeIter  iter;tGtkListStore *store;tGtkTreePath  *path;tGtkWidget    *view;tGString      *buf;tint          i;tview = go_gtk_builder_get_widget (state->gui, ""last-run-view"");tstore = gtk_list_store_new (2, G_TYPE_STRING, G_TYPE_STRING);tfor (i = 0; i < 6; i++) {ttbuf = g_string_new (NULL);ttswitch (i) {ttcase 0:tttg_string_append_printf (buf, ""%d"",ttttttsim->last_round -ttttttsim->first_round + 1);tttbreak;ttcase 1:tttg_string_append_printf (buf, ""%d"", sim->n_iterations);tttbreak;ttcase 2:tttg_string_append_printf (buf, ""%d"", sim->n_input_vars);tttbreak;ttcase 3:tttg_string_append_printf (buf, ""%d"", sim->n_output_vars);tttbreak;ttcase 4:tttg_string_append_printf (buf, ""%.2"" GNM_FORMAT_g,ttttttsim->end.tv_sec -ttttttsim->start.tv_sec +tttttt(sim->end.tv_usec -tttttt sim->start.tv_usec) /tttttt(gnm_float) G_USEC_PER_SEC);tttbreak;ttcase 5:tttdao_append_date (buf);tttbreak;ttdefault:tttg_string_append_printf (buf, ""Error"");tttbreak;tt}ttgtk_list_store_append (store, &iter);ttgtk_list_store_set (store, &iter, 0, txt [i], 1, buf->str, -1);ttg_string_free (buf, FALSE);t}tpath = gtk_tree_path_new_from_string (""0"");tif (gtk_tree_model_get_iter (GTK_TREE_MODEL (store), &iter, path)) {tt;tt t} else {ttg_warning (""Did not get a valid iterator"");t}tgtk_tree_path_free (path);tgtk_tree_view_append_columntt(GTK_TREE_VIEW (view),tt gtk_tree_view_column_new_with_attributestt (_(""Name""),tt  gtk_cell_renderer_text_new (), ""text"", 0, NULL));tgtk_tree_view_append_columntt(GTK_TREE_VIEW (view),tt gtk_tree_view_column_new_with_attributestt (_(""Value""),tt  gtk_cell_renderer_text_new (), ""text"", 1, NULL));tgtk_tree_view_set_model (GTK_TREE_VIEW (view), GTK_TREE_MODEL (store));tg_object_unref (store);}",2,"cwe119,cwe120"
"glade_gtk_listbox_set_child_property (GladeWidgetAdaptor *adaptor,                                      GObject            *container,                                      GObject            *child,                                      const gchar        *property_name,                                      GValue             *value){  g_return_if_fail (GTK_IS_LIST_BOX (container));  g_return_if_fail (GTK_IS_LIST_BOX_ROW (child));  g_return_if_fail (property_name != NULL || value != NULL);  if (strcmp (property_name, ""position"") == 0)    {      gint position;      position = g_value_get_int (value);      glade_gtk_listbox_reorder (GTK_LIST_BOX (container),                                 GTK_LIST_BOX_ROW (child),                                 position);    }  else    {             GWA_GET_CLASS (GTK_TYPE_CONTAINER)->child_set_property (adaptor,                                                              container,                                                              child,                                                              property_name,                                                              value);    }}",2,"cwe469,cweother"
"ssm_do (struct scanner *s){  SANE_Status ret = SANE_STATUS_GOOD;  unsigned char cmd[SET_SCAN_MODE_len];  size_t cmdLen = SET_SCAN_MODE_len;  unsigned char out[SSM_PAY_len];  size_t outLen = SSM_PAY_len;  DBG (10, ""ssm_do: start"");  if(!s->can_color){    DBG (10, ""ssm_do: unsupported, finishing"");    return ret;  }  memset(cmd,0,cmdLen);  set_SCSI_opcode(cmd, SET_SCAN_MODE_code);  set_SSM_pf(cmd, 1);  set_SSM_pay_len(cmd, outLen);  memset(out,0,outLen);  set_SSM_page_code(out, SM_pc_dropout);  set_SSM_page_len(out, SSM_PAGE_len);  set_SSM_DO_unk1(out, 0x03);  switch(s->dropout_color_f){    case COLOR_RED:      set_SSM_DO_unk2(out, 0x05);      set_SSM_DO_f_do(out,SSM_DO_red);      break;    case COLOR_GREEN:      set_SSM_DO_unk2(out, 0x05);      set_SSM_DO_f_do(out,SSM_DO_green);      break;    case COLOR_BLUE:      set_SSM_DO_unk2(out, 0x05);      set_SSM_DO_f_do(out,SSM_DO_blue);      break;    case COLOR_EN_RED:      set_SSM_DO_unk2(out, 0x05);      set_SSM_DO_f_en(out,SSM_DO_red);      break;    case COLOR_EN_GREEN:      set_SSM_DO_unk2(out, 0x05);      set_SSM_DO_f_en(out,SSM_DO_green);      break;    case COLOR_EN_BLUE:      set_SSM_DO_unk2(out, 0x05);      set_SSM_DO_f_en(out,SSM_DO_blue);      break;  }  switch(s->dropout_color_b){    case COLOR_RED:      set_SSM_DO_unk2(out, 0x05);      set_SSM_DO_b_do(out,SSM_DO_red);      break;    case COLOR_GREEN:      set_SSM_DO_unk2(out, 0x05);      set_SSM_DO_b_do(out,SSM_DO_green);      break;    case COLOR_BLUE:      set_SSM_DO_unk2(out, 0x05);      set_SSM_DO_b_do(out,SSM_DO_blue);      break;    case COLOR_EN_RED:      set_SSM_DO_unk2(out, 0x05);      set_SSM_DO_b_en(out,SSM_DO_red);      break;    case COLOR_EN_GREEN:      set_SSM_DO_unk2(out, 0x05);      set_SSM_DO_b_en(out,SSM_DO_green);      break;    case COLOR_EN_BLUE:      set_SSM_DO_unk2(out, 0x05);      set_SSM_DO_b_en(out,SSM_DO_blue);      break;  }  ret = do_cmd (      s, 1, 0,      cmd, cmdLen,      out, outLen,      NULL, NULL  );  DBG (10, ""ssm_do: finish"");  return ret;}",2,"cwe119,cwe120"
"_slurmd_job_log_init(stepd_step_rec_t *job){tchar argv0[64];tconf->log_opts.buffered = 1;t tconf->log_opts.stderr_level = LOG_LEVEL_ERROR + job->debug;tif (conf->log_opts.stderr_level > LOG_LEVEL_DEBUG3)ttconf->log_opts.stderr_level = LOG_LEVEL_DEBUG3;tsnprintf(argv0, sizeof(argv0), ""slurmstepd"");t tlog_alter(conf->log_opts, 0, NULL);tlog_set_argv0(argv0);t tif (!job->user_managed_io && !job->pty && job->task != NULL) {ttif (dup2(job->task[0]->stderr_fd, STDERR_FILENO) < 0) {ttterror(""job_log_init: dup2(stderr): %m"");tttreturn ESLURMD_IO_ERROR;tt}t}tverbose(""debug level = %d"", conf->log_opts.stderr_level);treturn SLURM_SUCCESS;}",2,"cwe119,cwe120"
"main( int argc, char *argv[] ){         int i;        char filename[FILENAME_MAX];        extern int ip;        u32 val;t        parse_cli_args(argc,argv);tif(input==NULL){ttprintf(""Error, an input file must be specified"");ttexit(-1);t}                         INIT_LIST_HEAD(&sym_head);       tif(listing!=NULL)ttif((listfile = fopen(listing, ""w""))==NULL){tttprintf(""Error writing to file %s"",argv[1]);ttttas_exit(""error"");       tt}tasm_open(input);  ttif(output==NULL){ttstrcpy(filename, input);ttstrtok(filename,"".0"");ttstrcat(filename, "".emu10k1"");ttoutput = filename;t}ttif((fp = fopen(output, ""w""))==NULL){ttprintf(""Error writing to file %s"",argv[1]);tttas_exit(""error"");       t}ttif(listing)ttfprintf(listfile,""Summary:"");                 header();                        val = __cpu_to_le32(ip);        fwrite(&val,sizeof(u16),1,fp);                                 for (i = 0; i < ip * 2; i++) {        tval = __cpu_to_le32(dsp_code[i]);                fwrite(&val,sizeof(u32),1,fp);tt                  t}         ttif(listing)ttfclose(listfile);tfclose(fp);        for(i=0;i<num_alloc;i++)                  free(ptralloc[i]);                treturn 0;   }",3,"cwe119,cwe120,cweother"
"make_transform_varname (char *vname, const char *orig, int ci, tttint aux, int len){    *vname = '0';    if (ci == DIFF) {tstrcpy(vname, ""d_"");tstrncat(vname, orig, len - 2);    } else if (ci == LDIFF) {tstrcpy(vname, ""ld_"");tstrncat(vname, orig, len - 3);    } else if (ci == SDIFF) {tstrcpy(vname, ""sd_"");tstrncat(vname, orig, len - 3);    } else if (ci == ORTHDEV) {tstrcpy(vname, ""o_"");tstrncat(vname, orig, len - 2);    } else if (ci == LOGS) {tstrcpy(vname, ""l_"");tstrncat(vname, orig, len - 2);    } else if (ci == SQUARE) {tstrcpy(vname, ""sq_"");tstrncat(vname, orig, len - 3);    } else if (ci == LAGS) {tchar ext[6];tif (aux >= 0) {t     t    sprintf(ext, ""_%d"", aux);t} else {t     t    sprintf(ext, ""%d"", -aux);t}tstrncat(vname, orig, len - strlen(ext));tstrcat(vname, ext);    } else if (ci == DUMMIFY) {tchar ext[6];tsprintf(ext, ""_%d"", aux);tstrcpy(vname, ""D"");tstrncat(vname, orig, len - strlen(ext) - 1);tstrcat(vname, ext);    } else if (ci == INVERSE) {tstrcpy(vname, ""i_"");tstrncat(vname, orig, len - 2);    }#if TRDEBUG    fprintf(stderr, ""make_transform_varname:""t    ""orig='%s', ci=%d, len=%d, vname='%s'"", t    orig, ci, len, vname);#endif    return 0;}",2,"cwe119,cwe120"
"""tou(const struct unicode_info *foo, const char *p,ttt int *err){tint pass;tsize_t i;tunicode_char *buffer=NULL;tsize_t buflen=0;t/* Two passes.  Count the output, alloc buffer, do it */tfor (pass=0; pass<2; pass++)t{ttif (pass)tt{tttif ((buffer=malloc((buflen+1)*sizeof(unicode_char)))ttt    == NULL)ttttreturn NULL;tt}ttbuflen=0;ttfor (i=0; p[i]; i++)tt{tttchar *q;tttstruct dec_base64_struct dc;tttif (p[i] != '+')ttt{ttttif (buffer)tttt{tttttbuffer[buflen]=(unsigned char)p[i];tttt}tttt++buflen;ttttcontinue;ttt}tttif (p[++i] == 0)ttttbreak;tttif (p[i] == '-')ttt{ttttif (buffer)tttttbuffer[buflen]='+';tttt++buflen;ttttcontinue;ttt}tttdc.cnt=0;tttdc.ucnt=0;tttdc.uc1=0;tttdc.flushing=0;tttdc.flushed=0;tttwhile ( p[i] && (q=strchr(base64tab, p[i])) != NULL)ttt{ttttif (dec_b64_char(&dc, (q-base64tab),tttttt &buffer,tttttt &buflen))tttt{tttttif (err)ttttt{tttttt*err=i;tttttterrno=EINVAL;ttttttreturn NULL;ttttt}ttttt/* Recover from decoding error */tttttdc.cnt=0;tttttdc.ucnt=0;tttttdc.uc1=0;tttt}tttt++i;ttt}tttdc.flushing=1;tttwhile (dc.cnt > 0)ttt{ttttif (dec_b64_char(&dc, 0,tttttt &buffer,tttttt &buflen))tttt{tttttif (err)ttttt{tttttt*err=i;tttttterrno=EINVAL;ttttttreturn NULL;ttttt}tttttdc.cnt=0;tttttdc.ucnt=0;tttttdc.uc1=0;tttt}ttt}tttif (p[i] == 0)ttttbreak;tttif (p[i] != '-')tttt--i;tt}ttif (pass)tttbuffer[buflen]=0;t}treturn buffer;}""",2,"cwe120,cweother"
"file_read_lines(const char* file, void* data, file_line_handler_t handler){tint fd;tssize_t ret;tchar buf[MAX_RECV_BUF];tstruct file_read_line_data split_data;tmemset(buf, 0, MAX_RECV_BUF);tLOG_TRACE(""Opening file %s for line reading."", file);tfd = open(file, 0);tif (fd == -1)t{ttLOG_ERROR(""Unable to open file %s: %s"", file, strerror(errno));ttreturn -2;t}tret = read(fd, buf, MAX_RECV_BUF-1);tclose(fd);tif (ret < 0)t{ttLOG_ERROR(""Unable to read from file %s: %s"", file, strerror(errno));ttreturn -1;t}telse  if (ret == 0)t{ttLOG_WARN(""File is empty."");ttreturn 0;t}tbuf[ret] = 0;t tsplit_data.handler = handler;tsplit_data.data = data;treturn string_split(buf, """", &split_data, file_read_line_handler);}",3,"cwe119,cwe120,cweother"
"CTNNETWORK_CreateGC(void){    unsigned long        valuemask;    XColortcolor;    XGCValuestvalues;    char        tc_large[MAX_STRING_LENGTH];    Fonttfontlarge;    if ((G_display_height < 400) || (G_display_width < 400)) {tstrcpy(tc_large, FONT_LG_B);    } else {tstrcpy(tc_large, FONT_LG_A);    }    if ((fontlarge = XLoadFont(G_display, tc_large)) == 0) {treturn (CTNNETWORK_NOFONT);    }    fontLG = XQueryFont(G_display, fontlarge);     XParseColor(G_display, G_cmap, ""red"", &color);    XAllocColor(G_display, G_cmap, &color);    G_red_color = values.background = color.pixel;    XParseColor(G_display, G_cmap, ""green"", &color);    XAllocColor(G_display, G_cmap, &color);    G_green_color = values.background = color.pixel;    XParseColor(G_display, G_cmap, ""white"", &color);    XAllocColor(G_display, G_cmap, &color);    G_white_color = values.foreground = color.pixel;    XParseColor(G_display, G_cmap, ""black"", &color);    XAllocColor(G_display, G_cmap, &color);    G_black_color = values.background = color.pixel;    valuemask = GCForeground | GCBackground | GCFont | GCFillStyle;    values.font = fontlarge;    values.fill_style = FillSolid;    values.foreground = G_white_color;    values.background = G_black_color;    if ((G_gclargeT = XCreateGC(G_display, RootWindow(G_display, G_screen),ttttvaluemask, &values)) == NULL) {tCOND_PushCondition(CTNNETWORK_NOGC, ""%s"",tt       ""CTNNETWORK: Cannot get requested graphics context"");treturn (CTNNETWORK_NOGC);    }    values.fill_style = FillSolid;    values.font = fontlarge;    values.foreground = G_green_color;    values.background = G_black_color;    if ((G_gcgreen = XCreateGC(G_display, RootWindow(G_display, G_screen),ttt       valuemask, &values)) == NULL) {tCOND_PushCondition(CTNNETWORK_NOGC, ""%s"",tt       ""CTNNETWORK: Cannot get requested graphics context"");treturn (CTNNETWORK_NOGC);    }    return (CTNNETWORK_NORMAL);}",2,"cwe119,cwe120"
"istgt_lu_get_nbserial(const char *nodebase){tISTGT_MD5CTX md5ctx;tuint8_t nbsmd5[ISTGT_MD5DIGEST_LEN];tchar buf[MAX_TMPBUF];tuint64_t nbs;tint idx;tint i;tsnprintf(buf, sizeof buf, ""%s"", nodebase);tif (strcasecmp(buf, ""iqn.2007-09.jp.ne.peach.istgt"") == 0t    || strcasecmp(buf, ""iqn.2007-09.jp.ne.peach"") == 0) {tt ttreturn 0;t}tistgt_md5init(&md5ctx);tistgt_md5update(&md5ctx, buf, strlen(buf));tistgt_md5final(nbsmd5, &md5ctx);tnbs = 0U;tidx = ISTGT_MD5DIGEST_LEN - 8;tif (idx < 0) {ttISTGT_WARNLOG(""missing MD5 length"");ttidx = 0;t}tfor (i = idx; i < ISTGT_MD5DIGEST_LEN; i++) {ttnbs |= (uint64_t) nbsmd5[i];ttnbs = nbs << 8;t}treturn nbs;}",2,"cwe119,cwe120"
"adis16400_show_serial_number(struct file *file,ttchar __user *userbuf, size_t count, loff_t *ppos){tstruct adis16400_state *st = file->private_data;tu16 lot1, lot2, serial_number;tchar buf[16];tsize_t len;tint ret;tret = adis_read_reg_16(&st->adis, ADIS16334_LOT_ID1, &lot1);tif (ret < 0)ttreturn ret;tret = adis_read_reg_16(&st->adis, ADIS16334_LOT_ID2, &lot2);tif (ret < 0)ttreturn ret;tret = adis_read_reg_16(&st->adis, ADIS16334_SERIAL_NUMBER,ttt&serial_number);tif (ret < 0)ttreturn ret;tlen = snprintf(buf, sizeof(buf), ""%.4x-%.4x-%.4x"", lot1, lot2,tttserial_number);treturn simple_read_from_buffer(userbuf, count, ppos, buf, len);}",2,"cwe119,cwe120"
"get_lively_stones(int color, signed char safe_stones[BOARDMAX]){  int pos;  memset(safe_stones, 0, BOARDMAX * sizeof(*safe_stones));  for (pos = BOARDMIN; pos < BOARDMAX; pos++)    if (IS_STONE(board[pos]) && find_origin(pos) == pos) {      if ((stackp == 0 && worm[pos].attack_codes[0] == 0) || !attack(pos, NULL)t  || (board[pos] == colort      && ((stackp == 0 && worm[pos].defense_codes[0] != 0)tt  || find_defense(pos, NULL))))tmark_string(pos, safe_stones, 1);    }}",2,"cwe119,cwe120"
DohGetc(DOH *obj) {  static DOH *lastdoh = 0;  DohBase *b = (DohBase *) obj;  DohObjInfo *objinfo;  if (obj == lastdoh) {    objinfo = b->type;    return (objinfo->doh_file->doh_getc) (b);  }  if (DohCheck(obj)) {    objinfo = b->type;    if (objinfo->doh_file->doh_getc) {      lastdoh = obj;      return (objinfo->doh_file->doh_getc) (b);    }    return EOF;  }  return fgetc((FILE *) b);},3,"cwe120,cwe469,cweother"
"plugin_priority_cmp(const plugin_priority_t *a,ttttttt   const plugin_priority_t *b, void *user){tint diff;tdiff = b->prio - a->prio;tif (!diff)t{t ttdiff = b->def - a->def;ttif (!diff)tt{t tttreturn strcmp(a->name, b->name);tt}t}treturn diff;}",2,"cwe119,cwe120"
read_map( FL_IMAGE * im ){    int i;    for ( i = 0; i < im->map_len; i++ )    {        im->red_lut[   i ] = getc( im->fpin );        im->green_lut[ i ] = getc( im->fpin );        im->blue_lut[  i ] = getc( im->fpin );    }},2,"cwe120,cweother"
"make_iconv_charset (char out[8], int fmt, uint8_t es){  strcpy (out, ""ucs-2le"");  if (es)    out[5] = 'b';tt   if (fmt == RCO_TEXT_FMT_UTF32)    out[4] = '4';  if (fmt == RCO_TEXT_FMT_UTF8) {    out[1] = 't';    out[2] = 'f';    out[4] = '8';    out[5] = '0';  }}",2,"cwe119,cwe120"
"logOrPrint (int level, FILE *fp, const char *fmt, ...){  va_list ap ;  va_start (ap,fmt) ;  if (fp != NULL)    {      vfprintf (fp,fmt,ap) ;      fputc ('',fp) ;    }  else    {      char buffer [512] ;             vsnprintf (buffer,sizeof (buffer),fmt,ap) ;      syslog (level,""%s"",buffer) ;    }  va_end (ap) ;}",3,"cwe119,cwe120,cweother"
"verify_then_decrypt(const unsigned char *ekey, size_t ekey_len,                         const unsigned char *mkey, size_t mkey_len,                        const unsigned char *ctxt, size_t ctxt_len,                        const unsigned char *mac, size_t mac_len,                        const unsigned char *iv, size_t iv_len,                        unsigned char *output, size_t *output_len){    EVP_CIPHER_CTX ctx;    EVP_CIPHER *cipher = NULL;    unsigned char auth[EVP_MAX_MD_SIZE];    size_t auth_len = EVP_MAX_MD_SIZE;    int len;        if (!ekey || !ekey_len || !mkey || !mkey_len ||         !ctxt || !ctxt_len || !mac || !mac_len || !output || !output_len)        return -1;        OpenSSL_add_all_algorithms();    memset(auth, 0, auth_len);         if (!HMAC(EVP_sha1(), mkey, mkey_len, ctxt, ctxt_len,               auth, (unsigned int *) &auth_len))        goto cleanup;    if (auth_len != mac_len) goto cleanup;    if (memcmp(mac, auth, mac_len) != 0) goto cleanup;    EVP_CIPHER_CTX_init(&ctx);    switch(ekey_len){        case 16:            cipher = (EVP_CIPHER *)EVP_aes_128_cbc();            break;        case 24:            cipher = (EVP_CIPHER *)EVP_aes_192_cbc();            break;        case 32:            cipher = (EVP_CIPHER *)EVP_aes_256_cbc();            break;        default:            return -1;    }    if (*output_len < ctxt_len) goto cleanup;    *output_len = 0;    if (!EVP_DecryptInit(&ctx, cipher, ekey, iv)) goto cleanup;    if (!EVP_DecryptUpdate(&ctx, output, (int *) output_len,                            ctxt, ctxt_len)) goto cleanup;    EVP_DecryptFinal(&ctx, output + *output_len, &len);    *output_len += len;        EVP_CIPHER_CTX_cleanup(&ctx);    return 0;    cleanup:    *output_len = 0;    return 1;}",2,"cwe119,cwe120"
"mag_verparse(char* ibuf){  int prodid = mm_unknown;  char version[1024];  pid_to_model_t* pp = pid_to_model;  got_version = 1;  sscanf(ibuf,""$PMGNVER,%d,%[^,]"", &prodid, version);  for (pp = pid_to_model; pp->model != mm_unknown; pp++) {    if (pp->pid == prodid) {      break;    }  }  if (prodid == 37) {    broken_sportrak = 1;  }  switch (pp->model) {  case mm_gps315320:  case mm_map410:    icon_mapping = gps315_icon_table;    setshort_length(mkshort_handle, 6);    setshort_mustupper(mkshort_handle, 1);    mag_cleanse = m315_cleanse;    break;  case mm_map330:  case mm_meridian:  case mm_sportrak:    icon_mapping = map330_icon_table;    setshort_length(mkshort_handle, wpt_len);    setshort_mustupper(mkshort_handle, 0);    mag_cleanse = m330_cleanse;    break;  default:    fatal(MYNAME "": Unknown receiver type %d, model version '%s'."", prodid, version);  }}",2,"cwe119,cwe120"
"trytoclose(File *f){tchar *t;tchar buf[256];tif(f == cmd)t ttreturn;tif(f->deleted)ttreturn;tif(fileisdirty(f) && !f->closeok){ttf->closeok = TRUE;ttif(f->name.s[0]){tttt = Strtoc(&f->name);tttstrncpy(buf, t, sizeof buf-1);tttfree(t);tt}elsetttstrcpy(buf, ""nameless file"");tterror_s(Emodified, buf);t}tf->deleted = TRUE;}",2,"cwe119,cwe120"
"G_write_range(const char *name, const struct Range *range){    FILE *fd;    char buf[200];    if (G_raster_map_type(name, G_mapset()) != CELL_TYPE) {tsprintf(buf, ""G_write_range(): the map is floating point!"");tgoto error;    }    fd = G_fopen_new_misc(""cell_misc"", ""range"", name);    if (!fd)tgoto error;    if (range->first_time)t     {tfclose(fd);treturn 0;    }    fprintf(fd, ""%ld %ld"", (long)range->min, (long)range->max);    fclose(fd);    return 0;  error:    G_remove_misc(""cell_misc"", ""range"", name);t     sprintf(buf, _(""can't write range file for [%s in %s]""),t    name, G_mapset());    G_warning(buf);    return -1;}",2,"cwe119,cwe120"
"pycann_save_file(const char *path, pycann_t *net) {  FILE *fd;  struct pycann_file_header header;  unsigned int i;  unsigned int *mod_neurons;     fd = fopen(path, ""w"");  if (fd==NULL) {    pycann_set_error(""Can't open file (for writing): %s"", path);    return -1;  }     memcpy(header.magic, PYCANN_FILE_MAGIC, PYCANN_FILE_MAGIC_LENGTH);  header.size = net->size;  header.learning_rate = net->learning_rate;  header.num_inputs = net->num_inputs;  header.num_outputs = net->num_outputs;  fwrite(&header, sizeof(header), 1, fd);     fwrite(net->gammas, 4*sizeof(pycann_float_t), net->size, fd);  fwrite(net->weights, sizeof(pycann_float_t), net->size*net->size, fd);  fwrite(net->thresholds, sizeof(pycann_float_t), net->size, fd);  fwrite(net->activations, sizeof(pycann_float_t), net->size, fd);  fwrite(net->mod_weights, sizeof(pycann_float_t), net->size, fd);  fwrite(net->inputs, sizeof(pycann_float_t), net->num_inputs, fd);  fwrite(net->activation_functions, sizeof(pycann_activation_function_t), net->size, fd);     mod_neurons = malloc(sizeof(unsigned int)*net->size);  for (i=0; i<header.size; i++) {    mod_neurons[i] = net->mod_neurons[i]-net->activations;  }  fwrite(mod_neurons, sizeof(unsigned int), net->size, fd);  free(mod_neurons);     fclose(fd);  return 0;}",2,"cwe120,cweother"
"coff_add_sym(char *name, int value, enum gpasmValTypes type){  gp_symbol_type *new = NULL;  char message[BUFSIZ];  int section_number = 0;  int class = C_EXT;   if(!state.obj.enabled)    return NULL;  switch (type) {  case gvt_extern:    section_number = N_UNDEF;    class = C_EXT;    break;  case gvt_global:    section_number = state.obj.section_num;    class = C_EXT;    break;  case gvt_static:    section_number = state.obj.section_num;    class = C_STAT;    break;  case gvt_address:    section_number = state.obj.section_num;    class = C_LABEL;    break;  case gvt_debug:    section_number = N_DEBUG;    class = C_NULL;    break;  case gvt_absolute:    section_number = N_ABS;    class = C_NULL;    break;  default:    return new;  }  new = gp_coffgen_findsymbol(state.obj.object, name);     if ((new != NULL) && (type == gvt_extern))  {    if ((new->type != class) ||         (new->section_number != section_number)) {      snprintf(message, sizeof(message),               ""Duplicate label or redefining symbol that cannot be redefined. (%s)"",               name);          gperror(GPE_UNKNOWN, message);    }  }  if ((new != NULL) && (type != gvt_extern) && (type != gvt_debug))  {    snprintf(message, sizeof(message),             ""Duplicate label or redefining symbol that cannot be redefined. (%s)"",             name);        gperror(GPE_DUPLAB, message);  } else {    new = gp_coffgen_addsymbol(state.obj.object);    new->name           = strdup(name);    new->value          = value;    new->section_number = section_number;    new->section        = state.obj.section;    new->type           = T_NULL;    new->class          = class;  }   return new;}",2,"cwe119,cwe120"
"sanei_epson2_scsi_inquiry(int fd, void *buf, size_t *buf_size){tunsigned char cmd[6];tint status;tmemset(cmd, 0, 6);tcmd[0] = INQUIRY_COMMAND;tcmd[4] = *buf_size > 255 ? 255 : *buf_size;tstatus = sanei_scsi_cmd(fd, cmd, sizeof cmd, buf, buf_size);treturn status;}",2,"cwe119,cwe120"
"cmd_user(char *user){    char userbuf[MAX_MAILBOX_BUFFER], *dot, *domain;    unsigned userlen;         if (!(kflag || popd_starttls_done || (extprops_ssf > 1) ||t  config_getswitch(IMAPOPT_ALLOWPLAINTEXT))) {tprot_printf(popd_out,tt    ""-ERR [AUTH] USER command only available under a layerr"");treturn;    }    if (popd_userid) {tprot_printf(popd_out, ""-ERR [AUTH] Must give PASS commandr"");treturn;    }    if (popd_canon_user(popd_saslconn, NULL, user, 0,tttSASL_CU_AUTHID | SASL_CU_AUTHZID,tttNULL, userbuf, sizeof(userbuf), &userlen) ||t      t     (popd_namespace.hier_sep == '.' && (dot = strchr(userbuf, '.')) &&t      !(config_virtdomains &&   tt(domain = strchr(userbuf, '@')) && (dot > domain))) ||t     strlen(userbuf) + 6 >= MAX_MAILBOX_BUFFER) {tprot_printf(popd_out, ""-ERR [AUTH] Invalid userr"");tsyslog(LOG_NOTICE,t       ""badlogin: %s plaintext %s invalid user"",t       popd_clienthost, beautify_string(user));    }    else {tpopd_userid = xstrdup(userbuf);tprot_printf(popd_out, ""+OK Name is a valid mailboxr"");    }}",2,"cwe119,cwe120"
"pisindentg(P *p){tint i_spc = 0;tint i_tab = 0;tP *q = pdup(p, USTR ""pisindentg"");tlong col;tint ch;tp_goto_bol(q);twhile (joe_isblank(p->b->o.charmap,ch = brc(q))) {ttif (ch == ' ')ttti_spc = 1;ttelse if (ch == 't')ttti_tab = 1;ttpgetc(q);t}tcol = q->col;tif (ch == '*' || ch == '/' || ch == '-' || ch =='%' || ch == '#' || ch == 'r' || ch == '')ttcol = 0;tif (col) {ttfound_space |= i_spc;ttfound_tab |= i_tab;t}tprm(q);treturn col;}",3,"cwe119,cwe120,cweother"
"ustats_close (){  if (eLstats != NULL)    {      if (fclose (eLstats) != 0)tulog (LOG_ERROR, ""fclose: %s"", strerror (errno));      eLstats = NULL;      fLstats_tried = FALSE;    }}",2,"cwe119,cwe120"
"decode_url_msg(t30_state_t *s, char *msg, const uint8_t *pkt, int len){    char text[77 + 1];         if (msg == NULL)        msg = text;    if (len < 3  ||  len > 77 + 3  ||  len != pkt[2] + 3)    {        unexpected_frame_length(s, pkt, len);        msg[0] = '0';        return;    }         memcpy(msg, &pkt[3], len - 3);    msg[len - 3] = '0';    span_log(&s->logging, SPAN_LOG_FLOW, ""Remote fax gave %s as: %d, %d, ""%s"""", t30_frametype(pkt[0]), pkt[0], pkt[1], msg);}",2,"cwe119,cwe120"
"job_write_as_single_file(lListElem *job, u_long32 ja_task_id,                                   sge_spool_flags_t flags) {   int ret = 0;   u_long32 job_id;   char job_dir_third[SGE_PATH_MAX] = """";   char spool_file[SGE_PATH_MAX] = """";   char tmp_spool_file[SGE_PATH_MAX] = """";   DENTER(TOP_LAYER, ""job_write_as_single_file"");   job_id = lGetUlong(job, JB_job_number);   sge_get_file_path(job_dir_third, JOB_SPOOL_DIR, FORMAT_THIRD_PART,                     flags, job_id, ja_task_id, NULL);   sge_mkdir(job_dir_third, 0755, 0, 0);   sge_get_file_path(spool_file, JOB_SPOOL_DIR_AS_FILE, FORMAT_DEFAULT,                     flags, job_id, ja_task_id, NULL);   sge_get_file_path(tmp_spool_file, JOB_SPOOL_DIR_AS_FILE, FORMAT_DOT_FILENAME,                     flags, job_id, ja_task_id, NULL);   ret = lWriteElemToDisk(job, tmp_spool_file, NULL, ""job"");   if (!ret && (rename(tmp_spool_file, spool_file) == -1)) {      DTRACE;      ret = 1;   }   DEXIT;   return ret;  }",2,"cwe119,cwe120"
"x509write_crt_set_basic_constraints( x509write_cert *ctx,                                         int is_ca, int max_pathlen ){    int ret;    unsigned char buf[9];    unsigned char *c = buf + sizeof(buf);    size_t len = 0;    memset( buf, 0, sizeof(buf) );    if( is_ca && max_pathlen > 127 )        return( POLARSSL_ERR_X509_BAD_INPUT_DATA );    if( is_ca )    {        if( max_pathlen >= 0 )        {            ASN1_CHK_ADD( len, asn1_write_int( &c, buf, max_pathlen ) );        }        ASN1_CHK_ADD( len, asn1_write_bool( &c, buf, 1 ) );    }    ASN1_CHK_ADD( len, asn1_write_len( &c, buf, len ) );    ASN1_CHK_ADD( len, asn1_write_tag( &c, buf, ASN1_CONSTRUCTED | ASN1_SEQUENCE ) );    return x509write_crt_set_extension( ctx, OID_BASIC_CONSTRAINTS,                                        OID_SIZE( OID_BASIC_CONSTRAINTS ),                                        0, buf + sizeof(buf) - len, len );}",2,"cwe119,cwe120"
"strkey(XKeyEvent *e){  void endchoice(void);  static XComposeStatus stat;  KeySym ks;  char buf[256];  int x, i, n=XLookupString(e, buf, sizeof(buf), &ks, &stat);  switch(ks) {  case XK_Return:  case XK_Linefeed:    selected=1;    endchoice();    break;  case XK_Left:    if(cur_pos)      --cur_pos;    break;  case XK_Right:    if(cur_pos<buf_len)      cur_pos++;    break;  case XK_Begin:    cur_pos=0;    break;  case XK_End:    cur_pos=buf_len;    break;  case XK_Delete:    if(cur_pos<buf_len) {      --buf_len;      for(x=cur_pos; x<buf_len; x++)tcmdline[x]=cmdline[x+1];    } else XBell(dpy, 100);    break;  case XK_BackSpace:    if(cur_pos>0) {      --buf_len;      for(x=--cur_pos; x<buf_len; x++)tcmdline[x]=cmdline[x+1];    } else XBell(dpy, 100);    break;  default:    for(i=0; i<n && buf_len<MAX_CMD_CHARS; i++) {      for(x=buf_len; x>cur_pos; --x)tcmdline[x]=cmdline[x-1];      cmdline[cur_pos++]=buf[i];      buf_len++;    }    if(i<n)      XBell(dpy, 100);  }  if(cur_pos<left_pos)    left_pos=cur_pos;  cur_x=6;  if(cur_pos>left_pos)    cur_x+=XTextWidth(dri.dri_Font, cmdline+left_pos, cur_pos-left_pos);  if(cur_pos<buf_len)    x=XTextWidth(dri.dri_Font, cmdline+cur_pos, 1);  else    x=dri.dri_Font->max_bounds.width;  if((x+=cur_x-(strgadw-6))>0) {    cur_x-=x;    while(x>0)      x-=XTextWidth(dri.dri_Font, cmdline+left_pos++, 1);    cur_x+=x;  }  refresh_str_text();}",2,"cwe119,cwe120"
"ds1343_update_alarm(struct device *dev){tstruct ds1343_priv *priv = dev_get_drvdata(dev);tunsigned int control, stat;tunsigned char buf[4];tint res = 0;tres = regmap_read(priv->map, DS1343_CONTROL_REG, &control);tif (res)ttreturn res;tres = regmap_read(priv->map, DS1343_STATUS_REG, &stat);tif (res)ttreturn res;tcontrol &= ~(DS1343_A0IE);tstat &= ~(DS1343_IRQF0);tres = regmap_write(priv->map, DS1343_CONTROL_REG, control);tif (res)ttreturn res;tres = regmap_write(priv->map, DS1343_STATUS_REG, stat);tif (res)ttreturn res;tbuf[0] = priv->alarm_sec < 0 || (priv->irqen & RTC_UF) ?tt0x80 : bin2bcd(priv->alarm_sec) & 0x7F;tbuf[1] = priv->alarm_min < 0 || (priv->irqen & RTC_UF) ?tt0x80 : bin2bcd(priv->alarm_min) & 0x7F;tbuf[2] = priv->alarm_hour < 0 || (priv->irqen & RTC_UF) ?tt0x80 : bin2bcd(priv->alarm_hour) & 0x3F;tbuf[3] = priv->alarm_mday < 0 || (priv->irqen & RTC_UF) ?tt0x80 : bin2bcd(priv->alarm_mday) & 0x7F;tres = regmap_bulk_write(priv->map, DS1343_ALM0_SEC_REG, buf, 4);tif (res)ttreturn res;tif (priv->irqen) {ttcontrol |= DS1343_A0IE;ttres = regmap_write(priv->map, DS1343_CONTROL_REG, control);t}treturn res;}",2,"cwe119,cwe120"
"DtCompileBuffer (    UINT8                   *Buffer,    char                    *StringValue,    DT_FIELD                *Field,    UINT32                  ByteLength){    ACPI_STATUS             Status;    char                    Hex[3];    UINT64                  Value;    UINT32                  i;    UINT32                  Count;         StringValue = DtNormalizeBuffer (StringValue, &Count);    Hex[2] = 0;    for (i = 0; i < Count; i++)    {                 Hex[0] = StringValue[(3 * i)];        Hex[1] = StringValue[(3 * i) + 1];                 Value = 0;        Status = DtStrtoul64 (Hex, &Value);        if (ACPI_FAILURE (Status))        {            DtError (ASL_ERROR, ASL_MSG_BUFFER_ELEMENT, Field, MsgBuffer);            goto Exit;        }        Buffer[i] = (UINT8) Value;    }Exit:    ACPI_FREE (StringValue);    return (ByteLength - Count);}",2,"cwe119,cwe120"
"extended_command(const char *ocommand) {    const char *cp = ocommand;    char *cpnext, command[MAX_BUF];    if ((cpnext = strchr(cp, ' '))!=NULL) {tint len = cpnext - ocommand;tif (len > (MAX_BUF -1 )) len = MAX_BUF-1;tstrncpy(command, ocommand, len);tcommand[len] = '0';tcp = command;twhile (*cpnext == ' ')t    cpnext++;tif (*cpnext == 0)t    cpnext = NULL;    }     #ifdef HAVE_LUA    if ( script_lua_command(cp, cpnext) )        return;#endif         if (!handle_local_command(cp, cpnext)) {t t t         strncpy(command, ocommand, MAX_BUF-1);tcommand[MAX_BUF-1]=0;tcp = strtok(command, "";"");twhile ( cp ) {t  while( *cp == ' ' ) cp++;  t  send_command(cp, cpl.count, 0);t  cp = strtok(NULL, "";"");t}    }}",2,"cwe119,cwe120"
"parse_edd_extensions(const char *dir, struct edd_info *edd_info){tchar filename[PATH_MAX];tchar line[1024];tuint16_t flags = 0;tFILE *fp;tsnprintf(filename, PATH_MAX, ""%s/%s"", dir, ""extensions"");tfilename[PATH_MAX-1] = 0;tfp = fopen(filename, ""r"");tif (!fp) {ttreturn -errno;t}twhile (fgets(line, 1024, fp)) {tt ttif (strstr(line, ""Fixed disk access"") == line)tttflags |= EDD_EXT_FIXED_DISK_ACCESS;ttelse if (strstr(line, ""Device locking and ejecting"") == line)tttflags |= EDD_EXT_DEVICE_LOCKING_AND_EJECTING;ttelse if (strstr(line, ""Enhanced Disk Drive support"") == line)tttflags |= EDD_EXT_ENHANCED_DISK_DRIVE_SUPPORT;ttelse if (strstr(line, ""64-bit extensions"") == line)tttflags |= EDD_EXT_64BIT_EXTENSIONS;t}tfclose(fp);tedd_info->interface_support = flags;treturn 0;}",3,"cwe119,cwe120,cweother"
"at2_read_buffer(PrivAT2data *privdata){    char buf[MAX_READ + 1];    int ret;    size_t count;    signed int s;    fd_set read_fd;    struct timeval tv;    if (privdata->fd == -1) {        error(errno, ""AT2[%s]: at2_read_buffer: fd = -1. Can not read"",               octstr_get_cstr(privdata->name));        return;    }    count = MAX_READ;#ifdef SSIZE_MAX    if (count > SSIZE_MAX)        count = SSIZE_MAX;#endif    tv.tv_sec = 0;    tv.tv_usec = 1000;    FD_ZERO(&read_fd);    FD_SET(privdata->fd, &read_fd);    ret = select(privdata->fd + 1, &read_fd, NULL, NULL, &tv);    if (ret == -1) {        if (!(errno == EINTR || errno == EAGAIN))            error(errno, ""AT2[%s]: error on select"", octstr_get_cstr(privdata->name));        return;    }    if (ret == 0)        return;    s = read(privdata->fd, buf, count);    if (s < 0) {        error(errno, ""AT2[%s]: at2_read_buffer: Error during read"",               octstr_get_cstr(privdata->name));        at2_close_device(privdata);    } else {        octstr_append_data(privdata->ilb, buf, s);        if(privdata->use_telnet)            at2_scan_for_telnet_escapes(privdata);    }}",3,"cwe119,cwe120,cweother"
"add_from_daemon_file_at_seek (int seek) {    char buffer[BUFFER_SIZE];    gboolean result;    FILE * f;    result = FALSE;    snprintf(buffer, BUFFER_SIZE, ""%s/%s/%s"",              getenv(""HOME""), GJAY_DIR, GJAY_DAEMON_DATA);    f = fopen(buffer, ""r"");    if (f) {        fseek(f, seek, SEEK_SET);        result = read_data(f);        if (result) {            gjay->songs_dirty = TRUE;        }        fclose(f);    }    return result;}",3,"cwe119,cwe120,cweother"
"opal_output_init(void){    int i;    char hostname[32];    char *str;    if (initialized) {        return true;    }    str = getenv(""OPAL_OUTPUT_STDERR_FD"");    if (NULL != str) {        default_stderr_fd = atoi(str);    }    str = getenv(""OPAL_OUTPUT_REDIRECT"");    if (NULL != str) {        if (0 == strcasecmp(str, ""syslog"")) {            opal_output_redirected_to_syslog = true;        }    }    str = getenv(""OPAL_OUTPUT_SYSLOG_PRI"");    if (NULL != str) {        if (0 == strcasecmp(str, ""info"")) {            opal_output_redirected_syslog_pri = LOG_INFO;        } else if (0 == strcasecmp(str, ""error"")) {            opal_output_redirected_syslog_pri = LOG_ERR;        } else if (0 == strcasecmp(str, ""warn"")) {            opal_output_redirected_syslog_pri = LOG_WARNING;        } else {            opal_output_redirected_syslog_pri = LOG_ERR;        }    } else {        opal_output_redirected_syslog_pri = LOG_ERR;    }    str = getenv(""OPAL_OUTPUT_SYSLOG_IDENT"");    if (NULL != str) {        redirect_syslog_ident = strdup(str);    }    OBJ_CONSTRUCT(&verbose, opal_output_stream_t);    if (opal_output_redirected_to_syslog) {        verbose.lds_want_syslog = true;        verbose.lds_syslog_priority = opal_output_redirected_syslog_pri;        if (NULL != str) {            verbose.lds_syslog_ident = strdup(redirect_syslog_ident);        }        verbose.lds_want_stderr = false;        verbose.lds_want_stdout = false;    } else {        verbose.lds_want_stderr = true;    }    gethostname(hostname, sizeof(hostname));    hostname[sizeof(hostname)-1] = '0';    asprintf(&verbose.lds_prefix, ""[%s:%05d] "", hostname, getpid());    for (i = 0; i < OPAL_OUTPUT_MAX_STREAMS; ++i) {        info[i].ldi_used = false;        info[i].ldi_enabled = false;        info[i].ldi_syslog = opal_output_redirected_to_syslog;        info[i].ldi_file = false;        info[i].ldi_file_suffix = NULL;        info[i].ldi_file_want_append = false;        info[i].ldi_fd = -1;        info[i].ldi_file_num_lines_lost = 0;    }         OBJ_CONSTRUCT(&mutex, opal_mutex_t);    initialized = true;         asprintf(&output_prefix, ""output-pid%d-"", getpid());    output_dir = strdup(opal_tmp_directory());         verbose_stream = opal_output_open(&verbose);    return true;}",3,"cwe119,cwe120,cweother"
"cvs_rlog_fgets(char * buff, int buflen, CvsServerCtx * ctx){    char lbuff[BUFSIZ];    int len;    len = read_line(ctx, lbuff);    debug(DEBUG_TCP, ""cvs_direct: rlog: read %s"", lbuff);    if (memcmp(lbuff, ""M "", 2) == 0)    {tmemcpy(buff, lbuff + 2, len - 2);tbuff[len - 2 ] = '';tbuff[len - 1 ] = 0;    }    else if (memcmp(lbuff, ""E "", 2) == 0)    {tdebug(DEBUG_APPMSG1, ""%s"", lbuff + 2);    }    else if (strcmp(lbuff, ""ok"") == 0 ||strcmp(lbuff, ""error"") == 0)    {tdebug(DEBUG_TCP, ""cvs_direct: rlog: got command completion"");treturn NULL;    }    return buff;}",3,"cwe119,cwe120,cwe469"
"open_tty(char *dev) {tint ttyfd;t tttyfd = open(dev, O_NONBLOCK | O_RDWR, 0);tif (ttyfd < 0) {ttfprintf(stderr, ""Failed to open device %s: %s"",tttdev, strerror(errno));ttexit(-1);t}t tif ((fdflags = fcntl(ttyfd, F_GETFL)) == -1) {ttfprintf(stderr, ""Couldn't get device %s flags: %s"",tttdev, strerror(errno));ttclose(ttyfd);ttexit(-1);t}tinitfdflags = fdflags;treturn(ttyfd);}",2,"cwe120,cweother"
"config_read_config(Config *conf, const char *name){    int c;    FILE* fin = fopen(name, ""r"");    if(fin == NULL) {        char error[512];        snprintf(error, 512, ""config file not found: %s"", name);        logger_log(""config"", LL_WARNING, error);        return;    }    c = fgetc(fin);    while(! feof(fin)) {        char cc = c;t        consume_whitespace(fin);        if(cc == '#') {            consume_comment(fin);        } else {            ungetc(c, fin);            consume_whitespace(fin);t                consume_line(conf, fin);                        consume_whitespace(fin);        }        consume_whitespace(fin);        c = fgetc(fin);    }    fclose(fin);}",3,"cwe119,cwe120,cweother"
"test_core_zstream__basic(void){tgit_zstream z = GIT_ZSTREAM_INIT;tchar out[128];tsize_t outlen = sizeof(out);tcl_git_pass(git_zstream_init(&z));tcl_git_pass(git_zstream_set_input(&z, data, strlen(data) + 1));tcl_git_pass(git_zstream_get_output(out, &outlen, &z));tcl_assert(git_zstream_done(&z));tcl_assert(outlen > 0);tgit_zstream_free(&z);tassert_zlib_equal(data, strlen(data) + 1, out, outlen);}",2,"cwe119,cwe120"
"authident(hbaPort *port){tcharttident_user[IDENT_USERNAME_MAX + 1];tif (get_role_line(port->user_name) == NULL)ttreturn STATUS_ERROR;tswitch (port->raddr.addr.ss_family)t{ttcase AF_INET:#ifdeftHAVE_IPV6ttcase AF_INET6:#endiftttif (!ident_inet(port->raddr, port->laddr, ident_user))ttttreturn STATUS_ERROR;tttbreak;#ifdef HAVE_UNIX_SOCKETSttcase AF_UNIX:tttif (!ident_unix(port->sock, ident_user))ttttreturn STATUS_ERROR;tttbreak;#endifttdefault:tttreturn STATUS_ERROR;t}tereport(DEBUG2,ttt(errmsg(""Ident protocol identifies remote user as ""%s"""",tttttident_user)));tif (check_ident_usermap(port->auth_arg, port->user_name, ident_user))ttreturn STATUS_OK;telsettreturn STATUS_ERROR;}",2,"cwe119,cwe120"
"__ecereMethod___ecereNameSpace__ecere__sys__Time_OnGetString(struct __ecereNameSpace__ecere__com__Class * class, double * this, char * tempString, void * fieldData, unsigned int * needClass){double time = *(double *)this;int value;char temp[256];tempString[0] = (char)0;value = (int)((double)(double)(time / (double)(60 * 60 * 24)));if(value){sprintf(temp, ""%d:"", value);strcat(tempString, temp);time -= value * 60 * 60 * 24;}value = (int)((double)(double)(time / (double)(60 * 60)));if(value){sprintf(temp, ""%d:"", value);strcat(tempString, temp);time -= value * 60 * 60;}value = (int)((double)(double)(time / (double)60));sprintf(temp, ""%d:"", value);strcat(tempString, temp);time -= value * 60;value = (int)((double)time);sprintf(temp, ""%02d"", value);strcat(tempString, temp);time -= value;return tempString;}",2,"cwe119,cwe120"
"cfg_put_int (int fh, int value, char *var){tchar buf[400];tint len;tif (value == -1)ttvalue = 1;tsnprintf (buf, sizeof buf, ""%s = %d"", var, value);tlen = strlen (buf);treturn (write (fh, buf, len) == len);}",2,"cwe119,cwe120"
"set_shellopts (){  char *value;  char tflag[N_O_OPTIONS];  int vsize, i, vptr, *ip, exported;  SHELL_VAR *v;  for (vsize = i = 0; o_options[i].name; i++)    {      tflag[i] = 0;      if (o_options[i].letter)t{t  ip = find_flag (o_options[i].letter);t  if (ip && *ip)t    {t      vsize += strlen (o_options[i].name) + 1;t      tflag[i] = 1;t    }t}      else if (GET_BINARY_O_OPTION_VALUE (i, o_options[i].name))t{t  vsize += strlen (o_options[i].name) + 1;t  tflag[i] = 1;t}    }  value = (char *)xmalloc (vsize + 1);  for (i = vptr = 0; o_options[i].name; i++)    {      if (tflag[i])t{t  strcpy (value + vptr, o_options[i].name);t  vptr += strlen (o_options[i].name);t  value[vptr++] = ':';t}    }  if (vptr)    vptr--;ttt   value[vptr] = '0';  v = find_variable (""SHELLOPTS"");     if (v)    {      VUNSETATTR (v, att_readonly);      exported = exported_p (v);    }  else    exported = 0;  v = bind_variable (""SHELLOPTS"", value, 0);     VSETATTR (v, att_readonly);  if (mark_modified_vars && exported == 0 && exported_p (v))    VUNSETATTR (v, att_exported);  free (value);}",3,"cwe119,cwe120,cweother"
"rwmime(struct rfc2045 *p){static char mimever[]=""Mime-Version: 1.0"";const char *te;structtrfc2045attr *a;tif (!p->parent)ttif (fdout_add(mimever, sizeof(mimever)-1))treturn (-1);tif (p->content_type)t{ttif (fdout_add(""Content-Type: "", 14) ||tttfdout_add(p->content_type, strlen(p->content_type)))tttreturn (-1);ttfor (a=p->content_type_attr; a; a=a->next)tt{tttif (!a->name || strcmp(a->name, ""boundary"") == 0)ttttcontinue;tttif ( fdout_add(""; "", 2) ||ttttfdout_attr(a))treturn (-1);tt}t}tif (p->firstparttt&& p->firstpart->next  )t{tchartbuf[80];tt++rw_boundary_cnt;ttsprintf(buf, ""-%d"", rw_boundary_cnt);ttif ( fdout_add(""; boundary="""", 12) ||tttfdout_add(rw_boundary_root, strlen(rw_boundary_root)) ||tttfdout_add(buf, strlen(buf)) ||tttfdout_add("""""", 1))treturn (-1);t}tif (fdout_add("""", 1))treturn (-1);t tte=TE(p);tif (te && p->firstpart == NULL)t{ttif (fdout_add(""Content-Transfer-Encoding: "", 27) ||tttfdout_add(te, strlen(te)) ||tttfdout_add("""", 1))treturn (-1);t}treturn (0);}",2,"cwe119,cwe120"
"createAbstractFileFromComp(AbstractFile* file) {InfoComp* info;AbstractFile* toReturn;uint8_t *compressed; if(!file) {return NULL;} info = (InfoComp*) malloc(sizeof(InfoComp));info->file = file;file->seek(file, 0);file->read(file, &(info->header), sizeof(info->header));flipCompHeader(&(info->header));if(info->header.signature != COMP_SIGNATURE) {free(info);return NULL;} if(info->header.compression_type != LZSS_SIGNATURE) {free(info);return NULL;} info->buffer = malloc(info->header.length_uncompressed);compressed = malloc(info->header.length_compressed);file->read(file, compressed, info->header.length_compressed); uint32_t real_uncompressed = decompress_lzss(info->buffer, compressed, info->header.length_compressed);real_uncompressed = info->header.length_uncompressed;if(real_uncompressed != info->header.length_uncompressed) {XLOG(5, ""mismatch: %d %d %d %x %x"", info->header.length_compressed, real_uncompressed, info->header.length_uncompressed, compressed[info->header.length_compressed - 2], compressed[info->header.length_compressed - 1]);free(compressed);free(info);return NULL;} XLOG(5, ""match: %d %d %d %x %x"", info->header.length_compressed, real_uncompressed, info->header.length_uncompressed, compressed[info->header.length_compressed - 2], compressed[info->header.length_compressed - 1]); free(compressed); info->dirty = FALSE; info->offset = 0; toReturn = (AbstractFile*) malloc(sizeof(AbstractFile));toReturn->data = info;toReturn->read = readComp;toReturn->write = writeComp;toReturn->seek = seekComp;toReturn->tell = tellComp;toReturn->getLength = getLengthComp;toReturn->close = closeComp;toReturn->type = AbstractFileTypeLZSS; return toReturn;}",2,"cwe120,cweother"
"setup_formatted_log_time(void){tpg_time_ttstamp_time;tcharttmsbuf[8];tif (!saved_timeval_set)t{ttgettimeofday(&saved_timeval, NULL);ttsaved_timeval_set = true;t}tstamp_time = (pg_time_t) saved_timeval.tv_sec;t tpg_strftime(formatted_log_time, FORMATTED_TS_LEN,t tttt""%Y-%m-%d %H:%M:%S     %Z"",ttttpg_localtime(&stamp_time, log_timezone));t tsprintf(msbuf, "".%03d"", (int) (saved_timeval.tv_usec / 1000));tmemcpy(formatted_log_time + 19, msbuf, 4);}",2,"cwe119,cwe120"
"send_mode_list(struct Client *client_p, struct Channel *chptr,               dlink_list *top, char flag){  int ts5 = !IsCapable(client_p, CAP_TS6);  dlink_node *lp;  struct Ban *banptr;  char pbuf[IRCD_BUFSIZE];  int tlen, mlen, cur_len, count = 0;  char *mp = NULL, *pp = pbuf;  if (top == NULL || top->length == 0)    return;  if (ts5)    mlen = ircsprintf(buf, "":%s MODE %s +"", me.name, chptr->chname);  else    mlen = ircsprintf(buf, "":%s BMASK %lu %s %c :"", me.id,                      (unsigned long)chptr->channelts, chptr->chname, flag);     cur_len = mlen + ts5;  mp = buf + mlen;  DLINK_FOREACH(lp, top->head)  {    banptr = lp->data;         tlen = banptr->len + 3 + ts5;         if (cur_len + (tlen - 1) > IRCD_BUFSIZE - 2 ||        (!IsCapable(client_p, CAP_TS6) &&         (count >= MAXMODEPARAMS || pp - pbuf >= MODEBUFLEN)))    {      *(pp - 1) = '0';         sendto_one(client_p, ""%s%s%s"", buf, ts5 ? "" "" : """", pbuf);      cur_len = mlen + ts5;      mp = buf + mlen;      pp = pbuf;      count = 0;    }    count++;    if (ts5)    {      *mp++ = flag;      *mp = '0';    }    pp += ircsprintf(pp, ""%s!%s@%s "", banptr->name, banptr->username,                     banptr->host);    cur_len += tlen;  }  *(pp - 1) = '0';     sendto_one(client_p, ""%s%s%s"", buf, ts5 ? "" "" : """", pbuf);}",3,"cwe119,cwe120,cweother"
"""arout(void){tRunet*p1;tBiobuft*fi;tinttc;tchart*s;tchartbuf[128];tfor (aptr = abuf; *aptr; aptr++) {ttif((*aptr)->command == ACOM) {tttfor(p1 = (*aptr)->u.text; *p1; p1++ )ttttBputrune(&fout, *p1);tttBputc(&fout, '');tt} else {tttfor(s = buf, p1= (*aptr)->u.text; *p1; p1++)ttttts += runetochar(s, p1);ttt*s = '0';tttif((fi = Bopen(buf, OREAD)) == 0)ttttcontinue;tttwhile((c = Bgetc(fi)) >= 0)ttttBputc(&fout, c);tttBterm(fi);tt}t}taptr = abuf;t*aptr = 0;}""",2,"cwe119,cwe120"
"latest_svn_release_changed(property_t prop){tchar data[sizeof svn_release_signature.data], hex[sizeof data * 2 + 1];tsize_t data_length, hex_length;t(void) prop;tsvn_release_signature.size = 0;tif (!svn_release_notification_can_verify())ttreturn FALSE;tgnet_prop_get_string(PROP_LATEST_SVN_RELEASE_SIGNATURE, hex, sizeof hex);thex_length = strlen(hex);tif (hex_length > 0 && hex_length / 2 < sizeof data) {ttstruct array signature;ttuint32 revision;tttime_t date;ttdata_length = base16_decode(data, sizeof data, hex, hex_length);ttrevision = GNET_PROPERTY(latest_svn_release_revision);ttdate = GNET_PROPERTY(latest_svn_release_date);ttsignature = array_init(data, data_length);ttif (svn_release_notification_verify(revision, date, &signature)) {tttg_message(""VMSG SVN release notify signature is valid: r%u (%s)"",ttttrevision, timestamp_to_string(date));tttmemcpy(svn_release_signature.data, data, data_length);tttsvn_release_signature.size = data_length;tt}t}treturn FALSE;}",2,"cwe119,cwe120"
"mtcp_safe_open(char const *filename, int flags, mode_t mode){    int fds[3];    int i, j, fd;    for(i = 0; i < 4; i++)    {        fd = mtcp_sys_open(filename, flags, mode);        if((fd != STDIN_FILENO) &&           (fd != STDOUT_FILENO) &&           (fd != STDERR_FILENO))            break;        fds[i] = fd;    }    for(j = 0; j < i; j++)        mtcp_sys_close(fds[j]);    return fd;}",2,"cwe119,cweother"
"generate_selfcert(){tstruct stat stb;t tif (stat(SECRETS_FILE, &stb) != 0)t{ttmode_t oldmask;ttFILE *f;ttuid_t uid = 0;ttgid_t gid = 0;#ifdef IPSEC_GROUPtt{tttchar buf[1024];tttstruct group group, *grp;tttif (getgrnam_r(IPSEC_GROUP, &group, buf, sizeof(buf), &grp) == 0 &&tgrp)ttt{ttttgid = grp->gr_gid;ttt}tt}#endif#ifdef IPSEC_USERtt{tttchar buf[1024];tttstruct passwd passwd, *pwp;tttif (getpwnam_r(IPSEC_USER, &passwd, buf, sizeof(buf), &pwp) == 0 &&tpwp)ttt{ttttuid = pwp->pw_uid;ttt}tt}#endifttignore_result(setegid(gid));ttignore_result(seteuid(uid));ttignore_result(system(IPSEC_SCRIPT "" scepclient --out pkcs1 --out cert-self --quiet""));ttignore_result(seteuid(0));ttignore_result(setegid(0));tt ttoldmask = umask(0066);ttf = fopen(SECRETS_FILE, ""w"");ttif (f)tt{tttfprintf(f, ""# /etc/ipsec.secrets - strongSwan IPsec secrets file"");tttfprintf(f, """");tttfprintf(f, "": RSA myKey.der"");tttfclose(f);tt}ttignore_result(chown(SECRETS_FILE, uid, gid));ttumask(oldmask);t}}",3,"cwe119,cwe120,cweother"
"int340x_thermal_get_trip_config(acpi_handle handle, char *name,tttt      int *temp){tunsigned long long r;tacpi_status status;tstatus = acpi_evaluate_integer(handle, name, NULL, &r);tif (ACPI_FAILURE(status))ttreturn -EIO;t*temp = DECI_KELVIN_TO_MILLICELSIUS(r);treturn 0;}",2,"cwe119,cwe120"
"""SQLGetAvailableDriversW (LPCWSTR lpszInfFile, LPWSTR lpszBuf, WORD cbBufMax,    WORD FAR * pcbBufOut){  BOOL retcode = FALSE;  char *_inf_u8 = NULL;  char *_buffer_u8 = NULL;  SQLCHAR *ptr;  SQLWCHAR *ptrW;  WORD len = 0, length;  _inf_u8 = (char *) dm_SQL_WtoU8 ((SQLWCHAR *) lpszInfFile, SQL_NTS);  if (_inf_u8 == NULL && lpszInfFile)    {      PUSH_ERROR (ODBC_ERROR_OUT_OF_MEM);      goto done;    }  if (cbBufMax > 0)    {      if ((_buffer_u8 = malloc (cbBufMax * UTF8_MAX_CHAR_LEN + 1)) == NULL)t{t  PUSH_ERROR (ODBC_ERROR_OUT_OF_MEM);t  goto done;t}    }  retcode =      SQLGetAvailableDrivers (_inf_u8, _buffer_u8,      cbBufMax * UTF8_MAX_CHAR_LEN, pcbBufOut);  if (retcode == TRUE)    {      length = 0;      for (ptr = _buffer_u8, ptrW = lpszBuf; *ptr;t  ptr += STRLEN (ptr) + 1, ptrW += WCSLEN (ptrW) + 1)t{t  dm_StrCopyOut2_U8toW (ptr, ptrW, cbBufMax - 1, &len);t  length += len;t}      *ptrW = L'0';      if (pcbBufOut)t*pcbBufOut = length + 1;    }done:  MEM_FREE (_inf_u8);  MEM_FREE (_buffer_u8);  return retcode;}""",2,"cwe120,cwe476"
"xdl_emit_common(xdfenv_t *xe, xdchange_t *xscr, xdemitcb_t *ecb,                           xdemitconf_t const *xecfg) {txdfile_t *xdf = &xe->xdf2;tconst char *rchg = xdf->rchg;tlong ix;t(void)xscr;t(void)xecfg;tfor (ix = 0; ix < xdf->nrec; ix++) {ttif (rchg[ix])tttcontinue;ttif (xdl_emit_record(xdf, ix, """", ecb))tttreturn -1;t}treturn 0;}",2,"cwe119,cwe120"
"empty_container(object *container, object *pl) {    int left = 0;    char name[MAX_BUF];    if (!container->inv)        return;    FOR_INV_PREPARE(container, inv) {        object *next;        if (QUERY_FLAG(inv, FLAG_INV_LOCKED)) {                         left++;            continue;        }        next = inv->below;        drop(pl, inv);        if (inv->below == next)                         left++;    } FOR_INV_FINISH();    esrv_update_item(UPD_WEIGHT, pl, container);    query_name(container, name, sizeof(name));    if (left)        draw_ext_info_format(NDI_UNIQUE, 0, pl, MSG_TYPE_COMMAND, MSG_TYPE_COMMAND_SUCCESS, ""You empty the %s except %d items."", name, left);    else        draw_ext_info_format(NDI_UNIQUE, 0, pl, MSG_TYPE_COMMAND, MSG_TYPE_COMMAND_SUCCESS, ""You empty the %s."", name);}",3,"cwe119,cwe120,cwe469"
"xtensa_literal_prefix (void){  char *name;  int len;     SKIP_WHITESPACE ();  len = strspn (input_line_pointer,tt""ABCDEFGHIJKLMNOPQRSTUVWXYZ""tt""abcdefghijklmnopqrstuvwxyz_/0123456789.$"");     name = xmalloc (len + 1);  gas_assert (name);  strncpy (name, input_line_pointer, len);  name[len] = 0;     input_line_pointer += len;  default_lit_sections.lit_prefix = name;     default_lit_sections.lit_seg = NULL;  default_lit_sections.lit4_seg = NULL;}",3,"cwe120,cwe476,cweother"
"check_no_nsec(dns_name_t *name, dns_dbnode_t *node, dns_db_t *db,t      dns_dbversion_t *ver){tdns_rdataset_t rdataset;tisc_result_t result;tdns_rdataset_init(&rdataset);tresult = dns_db_findrdataset(db, node, ver, dns_rdatatype_nsec,tttt     0, 0, &rdataset, NULL);tif (result != ISC_R_NOTFOUND) {ttchar namebuf[DNS_NAME_FORMATSIZE];ttdns_name_format(name, namebuf, sizeof(namebuf));ttfatal(""unexpected NSEC RRset at %s"", namebuf);t}tif (dns_rdataset_isassociated(&rdataset))ttdns_rdataset_disassociate(&rdataset);}",2,"cwe119,cwe120"
"qmonBrowserMessages(Widget w, XtPointer cld, XtPointer cad){   char *host = (char*)cld;   char filename[SGE_PATH_MAX];   lList *alp = NULL;   const char *default_cell = ctx->get_default_cell(ctx);   DENTER(GUI_LAYER, ""qmonBrowserMessages"");       sprintf(filename, ""%s/%s/spool/"", SGE_ROOT, default_cell);   if (!host || !strcmp(host , ""global""))      strcat(filename, ""qmaster"");   else      strcat(filename, host);   strcat(filename, ""/"");   strcat(filename, ERR_FILE);   alp = qmonReadFile(filename);   qmonMessageBox(w, alp, 0);   lFreeList(&alp);      DEXIT;}",3,"cwe119,cwe120,cwe469"
"main (int argc,      char *argv[]){  GError *error = NULL;  GOptionContext *context;  MetaLookupCache *cache;  MetaTree *tree;  char *tree_path;  struct stat statbuf;  int i;  context = g_option_context_new (""<tree file> <dir in tree> - list entries"");  g_option_context_add_main_entries (context, entries, GETTEXT_PACKAGE);  if (!g_option_context_parse (context, &argc, &argv, &error))    {      g_printerr (""option parsing failed: %s"", error->message);      return 1;    }  cache = meta_lookup_cache_new ();  for (i = 1; i < argc; i++)    {      if (g_lstat (argv[i], &statbuf) != 0)t{t  g_printerr (""can't stat %s"", argv[i]);t  return 1;t}      tree_path = NULL;      tree = meta_lookup_cache_lookup_path (cache, argv[i], statbuf.st_dev,ttttt    FALSE, &tree_path);      g_print (""tree: %s (exists: %d), tree path: %s"", meta_tree_get_filename (tree), meta_tree_exists (tree), tree_path);      if (pause)t{t  char buffer[1000];t  g_print (""Pausing, press enter"");t  fgets(buffer, sizeof(buffer), stdin);t}    }  return 0;}",2,"cwe119,cwe120"
"main(int argc, char** argv){  struct vink_backend_callbacks callbacks;  struct VINK_buffer buf;  struct vink_message *message;  int i;  while((i = getopt_long(argc, argv, """", long_options, 0)) != -1)    {      switch(i)        {        case 0:          break;        case '?':          fprintf(stderr, ""Try `%s --help' for more information."", argv[0]);          return EXIT_FAILURE;        }    }  if(print_help)    {      printf(""Usage: %s <SENDER> <RECIPIENT> [OPTION]...""             """"             ""      --help     display this help and exit""             ""      --version  display version information""             """"             ""Report bugs to <morten@rashbox.org>"", argv[0]);      return EXIT_SUCCESS;    }  if(print_version)    {      fprintf(stdout, ""%s"", PACKAGE_STRING);      return EXIT_SUCCESS;    }  if(optind + 2 != argc)    {      fprintf(stderr,              ""Usage: %1$s <SENDER> <RECIPIENT> [OPTION]...""              ""Try `%1$s --help' for more information."", argv[0]);      return EX_DATAERR;    }  openlog(""vink-maildrop"", LOG_PID | LOG_PERROR, LOG_USER);  if(-1 == vink_init(""/etc/vink.d/vink.conf"", VINK_CLIENT, VINK_API_VERSION))    errx(EXIT_FAILURE, ""vink_init failed: %s"", vink_last_error());  backend_init(&callbacks);  read_to_buffer(0, &buf);  message = vink_email_parse(&ARRAY_GET(&buf, 0), ARRAY_COUNT(&buf));  callbacks.email.message(message);  vink_message_free(message);  return EXIT_SUCCESS;}",2,"cwe120,cweother"
"skipthisfile(const char *path){tconst char *first, *last;tint i;t tif (skip && regexec(skip, path, 0, 0, 0) == 0)ttreturn 1;t tif (list_count == 0)ttreturn 0;tfor (i = 0; i < list_count; i++) {ttfirst = listarray[i];ttlast = first + strlen(first);tt ttif (*(last - 1) == '/') {t tttif (!strncmp(path + 1, first, last - first))ttttreturn 1;tt} else {tttif (!strcmp(path + 1, first))ttttreturn 1;tt}t}treturn 0;}",2,"cwe119,cwe120"
"get_variable(const char *var, EFI_GUID *guid, uint32_t *attributes,t     uint32_t *size, void *buf){tif (!kernel_efi_path)ttreturn -EINVAL;tint varfs_len = strlen(var) + 48 + strlen(kernel_efi_path);tchar *varfs = malloc(varfs_len);tuint32_t attr;tint fd;tstruct stat st;tsnprintf(varfs, varfs_len, ""%s/%s-%s"", kernel_efi_path,tt var, guid_to_str(guid));tfd = open(varfs, O_RDONLY);tfree(varfs);tif (fd < 0)ttreturn errno;ttif (fstat(fd, &st) < 0)ttreturn errno;tif (size)tt*size = st.st_size - sizeof(attr);tread(fd, &attr, sizeof(attr));tif (attributes)tt*attributes = attr;tif (buf)ttread(fd, buf, st.st_size - sizeof(attr));tclose(fd);treturn 0;}",2,"cwe120,cweother"
"search_handle_magnet(const char *url){tstruct magnet_resource *res;tuint n_searches = 0;tres = magnet_parse(url, NULL);tif (res) {ttGSList *sl;ttfor (sl = res->searches; sl != NULL; sl = g_slist_next(sl)) {tttconst char *query;ttt tttquery = sl->data;tttg_assert(query);tttif (ttttgcu_search_gui_new_search(query,tttttSEARCH_F_ENABLED | SEARCH_F_LITERAL)ttt) {ttttn_searches++;ttt}tt}ttif (res->sha1 && NULL == res->display_name) {tttchar urn_buf[64];tttsha1_to_urn_string_buf(res->sha1, urn_buf, sizeof urn_buf);tttif (ttttgcu_search_gui_new_search(urn_buf,tttttSEARCH_F_ENABLED | SEARCH_F_LITERAL)ttt) {ttttn_searches++;ttt}tt}ttmagnet_resource_free(&res);t}treturn n_searches;}",2,"cwe119,cwe120"
"rfc1035_spf_lookup(const char *mailfrom,tttconst char *tcpremoteip,tttconst char *tcpremotehost,tttconst char *helodomain,tttconst char *mydomain,tttchar *errmsg_buf,tttsize_t errmsg_buf_size){tsize_t lookup_cnt=0;tstruct rfc1035_spf_info info;tchar result;tif (!tcpremoteip) tcpremoteip="""";tif (!tcpremotehost) tcpremotehost="""";tif (!helodomain) helodomain="""";tif (!mydomain) mydomain="""";tif (errmsg_buf && errmsg_buf_size)tt*errmsg_buf=0;t tif (strchr(mailfrom, '@') == NULL)t{ttchar *buf=malloc(sizeof(""postmaster@"")+strlen(mailfrom));ttchar err_code;ttif (buf == NULL)tt{tttset_err_msg(errmsg_buf, errmsg_buf_size,tttt    strerror(errno));tttreturn SPF_ERROR;tt}tterr_code=rfc1035_spf_lookup(strcat(strcpy(buf, ""postmaster@""),tttttt   mailfrom),ttttt    tcpremoteip,ttttt    tcpremotehost,ttttt    helodomain,ttttt    mydomain,ttttt    errmsg_buf,ttttt    errmsg_buf_size);ttfree(buf);ttreturn err_code;t}tmemset(&info, 0, sizeof(info));tinfo.mailfrom=mailfrom;t tinfo.current_domain=strrchr(mailfrom, '@')+1;tinfo.tcpremoteip=tcpremoteip;tinfo.tcpremotehost=tcpremotehost;tinfo.errmsg_buf=errmsg_buf;tinfo.errmsg_buf_size=errmsg_buf_size;tinfo.helodomain=helodomain;tinfo.mydomain=mydomain;tinfo.lookup_cnt=&lookup_cnt;tresult=lookup(&info);tif (errmsg_buf[0] == 0)t{ttstatic const char errmsg[]=""Address %s the Sender Policy Framework"";ttchar *p=malloc(sizeof(errmsg)+strlen(mailfrom)+20);ttif (p)tttsprintf(p, errmsg, result == SPF_PASStttt? ""passes"":""does not pass"");ttset_err_msg(errmsg_buf, errmsg_buf_size,ttt    p ? p:strerror(errno));ttif (p) free(p);t}treturn result;}",3,"cwe120,cwe469,cweother"
"wordtris_who_won (Pos *pos, Player to_play, char **commp){tstatic char comment[32];tint i;t*commp = comment;tfor (i=0; i<WORDTRIS_LEN; i++)ttif (pos->board [2 * board_wid + i] != WORDTRIS_EMPTY tttt&& pos->state && ((Wordtris_state *)pos->state)->lives == 0)tt{tttsnprintf (comment, 32, ""Game over. Score: %d"", tttttpos->state ? ((Wordtris_state *)pos->state)->score: 0);tttreturn RESULT_WON;tt}tsnprintf (comment, 32, ""Score: %d;  Lives: %d"", tttttpos->state ? ((Wordtris_state *)pos->state)->score: 0,tttttpos->state ? ((Wordtris_state *)pos->state)->lives: total_lives);treturn RESULT_NOTYET;}",2,"cwe119,cwe120"
"load_firmware(struct octeon_device *oct){tint ret = 0;tconst struct firmware *fw;tchar fw_name[LIO_MAX_FW_FILENAME_LEN];tchar *tmp_fw_type;tif (strncmp(fw_type, LIO_FW_NAME_TYPE_NONE,tt    sizeof(LIO_FW_NAME_TYPE_NONE)) == 0) {ttdev_info(&oct->pci_dev->dev, ""Skipping firmware load"");ttreturn ret;t}tif (fw_type[0] == '0')tttmp_fw_type = LIO_FW_NAME_TYPE_NIC;telsetttmp_fw_type = fw_type;tsprintf(fw_name, ""%s%s%s_%s%s"", LIO_FW_DIR, LIO_FW_BASE_NAME,ttocteon_get_conf(oct)->card_name, tmp_fw_type,ttLIO_FW_NAME_SUFFIX);tret = request_firmware(&fw, fw_name, &oct->pci_dev->dev);tif (ret) {ttdev_err(&oct->pci_dev->dev, ""Request firmware failed. Could not find file %s.."",tttfw_name);ttreturn ret;t}tret = octeon_download_firmware(oct, fw->data, fw->size);trelease_firmware(fw);treturn ret;}",2,"cwe119,cwe120"
"c3745_init(c3745_t *router){      vm_instance_t *vm = router->vm;   char bus_name[128];   int i;       mips64_set_prid(CPU_MIPS64(vm->boot_cpu),MIPS_PRID_R7000);       if (c3745_init_gt96100(router) == -1)      return(-1);       for(i=1;i<=4;i++) {      snprintf(bus_name,sizeof(bus_name),""NM Slot %d"",i);      vm->pci_bus_pool[i] = pci_bus_create(bus_name,-1);             vm->slots_pci_bus[i] = vm->pci_bus_pool[i];             dev_ti2050b_init(vm->pci_bus[1],i,vm->slots_pci_bus[i]);   }   vm->elf_machine_id = C3745_ELF_MACHINE_ID;   return(0);}",2,"cwe119,cwe120"
"st_value( LDAP *ld, struct berval *value ){tchartt*ip = NULL, *name = NULL;tstruct bervaltid = { 0 };tcharttnamebuf[ MAXHOSTNAMELEN ];tif ( gethostname( namebuf, sizeof( namebuf ) ) == 0 ) {ttstruct hostentt*h;ttstruct in_addrtaddr;ttname = namebuf;tth = gethostbyname( name );ttif ( h != NULL ) {tttAC_MEMCPY( &addr, h->h_addr, sizeof( addr ) );tttip = inet_ntoa( addr );tt}t}#ifdef HAVE_CYRUS_SASLtif ( sasl_authz_id != NULL ) {ttber_str2bv( sasl_authz_id, 0, 0, &id );t} else if ( sasl_authc_id != NULL ) {ttber_str2bv( sasl_authc_id, 0, 0, &id );t} else #endif  tif ( binddn != NULL ) {ttber_str2bv( binddn, 0, 0, &id );t}tif ( ldap_create_session_tracking_value( ld,ttip, name, LDAP_CONTROL_X_SESSION_TRACKING_USERNAME,tt&id, &stValue ) )t{ttfprintf( stderr, _(""Session tracking control encoding error!"") );ttreturn -1;t}treturn 0;}",2,"cwe119,cwe120"
"string_check_length (STRING *str, int l){  if (str->buf == NULL)  {    if (l * 10 > 256)      str->max = l * 10;    else      str->max = 256;    str->buf = (char *) malloc (sizeof(char) * str->max);    if (str->buf == NULL)      return nerr_raise (NERR_NOMEM, ""Unable to allocate render buf of size %d"",t  str->max);      }  else if (str->len + l >= str->max)  {    do    {      str->max *= 2;    } while (str->len + l >= str->max);    str->buf = (char *) realloc (str->buf, sizeof(char) * str->max);    if (str->buf == NULL)      return nerr_raise (NERR_NOMEM, ""Unable to allocate STRING buf of size %d"",t  str->max);       }  return STATUS_OK;}",3,"cwe119,cwe120,cweother"
"""InitHyphob_ (RuntimeS *runtimeSP){intttmax_length;size_tttresidueI;intttscaleI;chartt*residue_nameP;charttresidue_nameA[RESNAMESIZE];doubletthydrophobicity;/* The maximal residue name length: */max_length = RESNAMESIZE - 1;/* Hydrophobicity scale index: */scaleI = runtimeSP->hydrophobicity_scaleI;/* Scan the general purpose sequence: */for (residueI = 0; residueI < runtimeSP->residuesN; residueI++)t{t/* Pointer to the current residue name: */tresidue_nameP = runtimeSP->sequenceP + residueI * max_length;t/* Copy the residue name: */tstrncpy (residue_nameA, residue_nameP, max_length);tresidue_nameA[max_length] = '0';t/* The corresponding hydrophobicity: */thydrophobicity = Hydrophobicity_ (residue_nameA, scaleI, 0);t/* Store the hydrophobicity value: */t*(runtimeSP->hydrophobicityP + residueI) = hydrophobicity;t}/* Scan the reference sequence: */for (residueI = 0; residueI < runtimeSP->reference_residuesN; residueI++)t{t/* Pointer to the current residue name: */tresidue_nameP = runtimeSP->reference_sequenceP + residueI * max_length;t/* Copy the residue name: */tstrncpy (residue_nameA, residue_nameP, max_length);tresidue_nameA[max_length] = '0';t/* The corresponding hydrophobicity: */thydrophobicity = Hydrophobicity_ (residue_nameA, scaleI, 0);t/* Store the hydrophobicity value: */t*(runtimeSP->reference_hydrophobicityP + residueI) = hydrophobicity;t}}""",2,"cwe119,cwe120"
"dump_abs_db(FILE *fp){tint realm;tchar b1[16];tif (!no_output) {ttfprintf(fp, ""#%s"", kern_db->signature);ttfprintf(fp,""%-10s """"%-10s """"%-10s """"%-10s """"%-10s """"""tt       , ""Realm"", ""BytesTo"", ""PktsTo"", ""BytesFrom"", ""PktsFrom"");ttfprintf(fp,""%-10s """"%-10s """"%-10s """"%-10s """"%-10s """"""tt       , """", ""BPSTo"", ""PPSTo"", ""BPSFrom"", ""PPSFrom"");t}tfor (realm=0; realm<256; realm++) {ttint i;ttunsigned long long *val;ttdoublett   *rate;ttif (!(rmap[realm>>5] & (1<<(realm&0x1f))))tttcontinue;ttval = &kern_db->val[realm*4];ttrate = &kern_db->rate[realm*4];ttif (!dump_zeros &&tt    !val[0] && !rate[0] &&tt    !val[1] && !rate[1] &&tt    !val[2] && !rate[2] &&tt    !val[3] && !rate[3])tttcontinue;ttif (hist_db) {tttmemcpy(&hist_db->val[realm*4], val, sizeof(*val)*4);tt}ttif (no_output)tttcontinue;ttfprintf(fp, ""%-10s"", rtnl_rtrealm_n2a(realm, b1, sizeof(b1)));ttfor (i = 0; i < 4; i++)tttformat_count(fp, val[i]);ttfprintf(fp, ""%-10s"", """");ttfor (i = 0; i < 4; i++)tttformat_rate(fp, rate[i]);ttfprintf(fp, """");t}}",2,"cwe119,cwe120"
"emit_tputd_trmsg(struct tedputp_t *tedp, struct tfarg_t *tfap){  word32 *ap, *bp; struct tfrec_t *tfrp; struct expr_t *lhsxp; char s1[RECLEN], s2[IDLEN]; lhsxp = tfap->arg.axp; if (tfap->anp->ntyp >= NONWIRE_ST) strcpy(s1, ""procedural""); else  {   if (lhsxp->x_multfi) strcpy(s1, ""continuous fi>1"");   else strcpy(s1, ""continuous fi=1"");  } tfrp = tedp->tedtfrp; if (lhsxp->x_stren)  __st_regab_tostr(s2, (byte *) tedp->tedwp, lhsxp->szu.xclen); else  {    ap = tedp->tedwp;   bp = &(ap[wlen_(lhsxp->szu.xclen)]);   __regab_tostr(s2, ap, bp, lhsxp->szu.xclen, BHEX, FALSE);  } __evtr_resume_msg(); __tr_msg(""tf_ arg %d at %s in %s strdelputp %s assign value %s"",  tedp->tedpnum, __bld_lineloc(__wrks1, tfrp->tffnam_ind, tfrp->tflin_cnt),  __msg2_blditree(__wrks2, __inst_ptr), s1, s2);}",2,"cwe119,cwe120"
"connect_to_server(const char *hostname, int port, int *fd){    struct addrinfo hint, *addrs, *a;    char portbuf[32];    int err, s;    kadm5_ret_t code;         (void) snprintf(portbuf, sizeof(portbuf), ""%d"", port);    memset(&hint, 0, sizeof(hint));    hint.ai_socktype = SOCK_STREAM;    hint.ai_flags = AI_ADDRCONFIG;#ifdef AI_NUMERICSERV    hint.ai_flags |= AI_NUMERICSERV;#endif    err = getaddrinfo(hostname, portbuf, &hint, &addrs);    if (err != 0)        return KADM5_CANT_RESOLVE;         for (a = addrs; a != NULL; a = a->ai_next) {        s = socket(a->ai_family, a->ai_socktype, 0);        if (s == -1) {            code = KADM5_FAILURE;            goto cleanup;        }        err = connect(s, a->ai_addr, a->ai_addrlen);        if (err == 0) {            *fd = s;            code = 0;            goto cleanup;        }        close(s);    }         code = KADM5_RPC_ERROR;cleanup:    freeaddrinfo(addrs);    return code;}",2,"cwe119,cwe120"
"mlx4_en_u64_to_mac(unsigned char dst_mac[ETH_ALEN + 2], u64 src_mac){tint i;tfor (i = ETH_ALEN - 1; i >= 0; --i) {ttdst_mac[i] = src_mac & 0xff;ttsrc_mac >>= 8;t}tmemset(&dst_mac[ETH_ALEN], 0, 2);}",2,"cwe119,cwe120"
"sge_infotext_build_test_msgstr(dstring* buffer, char* text) {   int h;   char app_text[2];   app_text[1] = 0;      sge_dstring_copy_string(buffer,"""");   for (h=0; h < strlen(text) ; h++) {      app_text[0] = text[h];      sge_dstring_append(buffer,app_text);      if (text[h] != '%'  &&          text[h] != '' ) {          if (h>0) {             if ( text[h-1] == '' ) {                continue;             }             if ( text[h-1] == '%' ) {                continue;             }          }          if (text[h] != ' ') {             sge_dstring_append(buffer,""."");          }      }   }   return (char*) sge_dstring_get_string(buffer);}",2,"cwe119,cwe120"
"ompcbe_ddsche_write_setmt(csbe_context *cx, Hmdf_context *hcx, int mt_no){    Func_table *fpt;    ASSERT_SCHEDULER_MODULE;    fpt = search_func_table(hcx->hmdf->block->module->entry);    if (!opt_direct_scheduler) {tif ((opt_frame || opt_recursive) && opt_c_dynamic_scheduler) {t    if(fpt->rec_flg) {            csbe_printf(cx,                         ""%s(/*mtg_id*/%d, /*cl_no*/%d, /*pc_no*/%d, /*mt_no*/%d, %s);"",                         SCHE_FUNC_NAME_SETMT,                        hcx->mtg_id, hcx->cl_no, hcx->pc_no, mt_no,                        LOCAL_FRAME_POINTER_NAME);t    } else {            csbe_printf(cx,                         ""%s(/*mtg_id*/%d, /*cl_no*/%d, /*pc_no*/%d, /*mt_no*/%d, NULL);"",                         SCHE_FUNC_NAME_SETMT,                        hcx->mtg_id, hcx->cl_no, hcx->pc_no, mt_no);t    }t}         else {            csbe_printf(cx,                         ""%s(/*mtg_id*/%d, /*cl_no*/%d, /*pc_no*/%d, /*mt_no*/%d);"",                         SCHE_FUNC_NAME_SETMT,                        hcx->mtg_id, hcx->cl_no, hcx->pc_no, mt_no);t}    } else {        char name[64];        ddsche_make_setmt_module_name(name,                                      hcx->mtg_id,                                      hcx->cl_no,                                      hcx->pc_no);        csbe_printf(cx,                    ""%s = %d;"",                    SET_MT_VAR_NAME,                    mt_no);tif ((opt_frame || (opt_recursive && fpt->rec_flg)) && opt_c_dynamic_scheduler)            csbe_printf(cx,                         ""%s(&%s, %s);"", name,                        SET_MT_VAR_NAME, LOCAL_FRAME_POINTER_NAME);        else            csbe_printf(cx,                         ""%s(&%s);"", name,                        SET_MT_VAR_NAME);    }}",2,"cwe119,cwe120"
"unit_can_do_action_now(const struct unit *punit){  time_t dt;  if (!punit) {    return FALSE;  }  if (game.server.unitwaittime <= 0) {    return TRUE;  }  if (punit->server.action_turn != game.info.turn - 1) {    return TRUE;  }  dt = time(NULL) - punit->server.action_timestamp;  if (dt < game.server.unitwaittime) {    char buf[64];    format_time_duration(game.server.unitwaittime - dt, buf, sizeof(buf));    notify_player(unit_owner(punit), unit_tile(punit), E_BAD_COMMAND,                  ftc_server, _(""Your unit may not move for another %s ""                                ""this turn. See /help unitwaittime.""), buf);    return FALSE;  }  return TRUE;}",2,"cwe119,cwe120"
"Cmd_Exec(const char *cmd, const char **error){tinttfds[2];t tinttstatus;t tBuffert*buf;t tssize_ttrcnt;tProcStufftps;t*error = NULL;tbuf = Buf_Init(0);t tif (pipe(fds) == -1) {tt*error = ""Couldn't create pipe for ""%s"""";ttreturn (buf);t}t tfcntl(fds[0], F_SETFD, fcntl(fds[0], F_GETFD) | FD_CLOEXEC);tps.in = STDIN_FILENO;tps.out = fds[1];tps.err = STDERR_FILENO;tps.merge_errors = 0;tps.pgroup = 0;tps.searchpath = 0;t tps.argv = emalloc(4 * sizeof(char *));tps.argv[0] = strdup(commandShell->name);tps.argv[1] = strdup(""-c"");tps.argv[2] = strdup(cmd);tps.argv[3] = NULL;tps.argv_free = 1;t tif ((ps.child_pid = vfork()) == -1) {tt*error = ""Couldn't exec ""%s"""";ttreturn (buf);t} else if (ps.child_pid == 0) {  tt ttProc_Exec(&ps);tt t}tfree(ps.argv[2]);tfree(ps.argv[1]);tfree(ps.argv[0]);tfree(ps.argv);tclose(fds[1]);  tdo {ttchartresult[BUFSIZ];ttrcnt = read(fds[0], result, sizeof(result));ttif (rcnt != -1)tttBuf_AddBytes(buf, (size_t)rcnt, (Byte *)result);t} while (rcnt > 0 || (rcnt == -1 && errno == EINTR));tif (rcnt == -1)tt*error = ""Error reading shell's output for ""%s"""";t tclose(fds[0]);tstatus = ProcWait(&ps);tif (status)tt*error = """"%s"" returned non-zero status"";tBuf_StripNewlines(buf);treturn (buf);}",2,"cwe469,cweother"
"P_hash(const EVP_MD *evp_md,tt   const unsigned char *secret, unsigned int secret_len,tt   const unsigned char *seed,   unsigned int seed_len,tt   unsigned char *out, unsigned int out_len){tHMAC_CTX ctx_a, ctx_out;tunsigned char a[HMAC_MAX_MD_CBLOCK];tunsigned int size;tHMAC_CTX_init(&ctx_a);tHMAC_CTX_init(&ctx_out);tHMAC_Init_ex(&ctx_a, secret, secret_len, evp_md, NULL);tHMAC_Init_ex(&ctx_out, secret, secret_len, evp_md, NULL);tsize = HMAC_size(&ctx_out);t tHMAC_Update(&ctx_a, seed, seed_len);tHMAC_Final(&ctx_a, a, NULL);twhile (1) {tt ttHMAC_Update(&ctx_out, a, size);ttHMAC_Update(&ctx_out, seed, seed_len);tt ttif (out_len < size) {tttHMAC_Final(&ctx_out, a, NULL);tttmemcpy(out, a, out_len);tttbreak;tt}tt ttHMAC_Final(&ctx_out, out, NULL);ttHMAC_Init_ex(&ctx_out, NULL, 0, NULL, NULL);ttout += size;ttout_len -= size;tt ttHMAC_Init_ex(&ctx_a, NULL, 0, NULL, NULL);ttHMAC_Update(&ctx_a, a, size);ttHMAC_Final(&ctx_a, a, NULL);t}tHMAC_CTX_cleanup(&ctx_a);tHMAC_CTX_cleanup(&ctx_out);tmemset(a, 0, sizeof(a));}",2,"cwe119,cwe120"
"_popup_center_title_item_3button_cb(void *data, Evas_Object *obj __UNUSED__,                                    void *event_info __UNUSED__){   char buf[256];   unsigned int i;   Evas_Object *popup, *icon1, *btn1, *btn2, *btn3;   popup = elm_popup_add(data);   evas_object_size_hint_weight_set(popup, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);   icon1 = elm_icon_add(popup);   elm_object_part_text_set(popup, ""title,text"", ""Title"");   snprintf(buf, sizeof(buf), ""%s/images/logo_small.png"",            elm_app_data_dir_get());   elm_image_file_set(icon1, buf, NULL);   for (i = 0; i < 10; i++)     {        snprintf(buf, sizeof(buf), ""Item%u"", i+1);        if (i == 3)          elm_popup_item_append(popup, buf, icon1, _item_selected_cb, NULL);        else          elm_popup_item_append(popup, buf, NULL, _item_selected_cb, NULL);     }   btn1 = elm_button_add(popup);   elm_object_text_set(btn1, ""OK"");   elm_object_part_content_set(popup, ""button1"", btn1);   btn2 = elm_button_add(popup);   elm_object_text_set(btn2, ""Cancel"");   elm_object_part_content_set(popup, ""button2"", btn2);   btn3 = elm_button_add(popup);   elm_object_text_set(btn3, ""Close"");   elm_object_part_content_set(popup, ""button3"", btn3);   evas_object_smart_callback_add(btn1, ""clicked"", _response_cb, popup);   evas_object_smart_callback_add(btn2, ""clicked"", _response_cb, popup);   evas_object_smart_callback_add(btn3, ""clicked"", _response_cb, popup);   evas_object_show(popup);}",2,"cwe119,cwe120"
"chirp_client_open(struct chirp_client * c, const char *path, INT64_T flags, INT64_T mode, struct chirp_stat * info, time_t stoptime){tINT64_T result;tchar fstr[256];tchar safepath[CHIRP_LINE_MAX];turl_encode(path, safepath, sizeof(safepath));tfstr[0] = 0;tif(flags & O_WRONLY) {ttstrcat(fstr, ""w"");t} else if(flags & O_RDWR) {ttstrcat(fstr, ""rw"");t} else {ttstrcat(fstr, ""r"");t}tif(flags & O_CREAT)ttstrcat(fstr, ""c"");tif(flags & O_TRUNC)ttstrcat(fstr, ""t"");tif(flags & O_APPEND)ttstrcat(fstr, ""a"");tif(flags & O_EXCL)ttstrcat(fstr, ""x"");#ifdef O_SYNCtif(flags & O_SYNC)ttstrcat(fstr, ""s"");#endiftresult = simple_command(c, stoptime, ""open %s %s %lld"", safepath, fstr, mode);tif(result >= 0) {ttif(get_stat_result(c, info, stoptime) >= 0) {tttreturn result;tt} else {tttc->broken = 1;ttterrno = ECONNRESET;tttreturn -1;tt}t} else {ttreturn result;t}}",2,"cwe119,cwe120"
"_cdb_make_add(struct cdb_make *cdbmp, unsigned hval,              const void *key, unsigned klen,              const void *val, unsigned vlen){  unsigned char rlen[8];  struct cdb_rl *rl;  unsigned i;  if (klen > 0xffffffff - (cdbmp->cdb_dpos + 8) ||      vlen > 0xffffffff - (cdbmp->cdb_dpos + klen + 8))    return errno = ENOMEM, -1;  i = hval & 255;  rl = cdbmp->cdb_rec[i];  if (!rl || rl->cnt >= sizeof(rl->rec)/sizeof(rl->rec[0])) {    rl = (struct cdb_rl*)malloc(sizeof(struct cdb_rl));    if (!rl)      return errno = ENOMEM, -1;    rl->cnt = 0;    rl->next = cdbmp->cdb_rec[i];    cdbmp->cdb_rec[i] = rl;  }  i = rl->cnt++;  rl->rec[i].hval = hval;  rl->rec[i].rpos = cdbmp->cdb_dpos;  ++cdbmp->cdb_rcnt;  cdb_pack(klen, rlen);  cdb_pack(vlen, rlen + 4);  if (_cdb_make_write(cdbmp, rlen, 8) < 0 ||      _cdb_make_write(cdbmp, key, klen) < 0 ||      _cdb_make_write(cdbmp, val, vlen) < 0)    return -1;  return 0;}",2,"cwe119,cwe120"
"vlog_knownIssue(const char *ticket, const char *pattern, va_list ap){    char buf[2048];    UBool firstForTicket;    UBool firstForWhere;    if(NO_KNOWN) return FALSE;    if(pattern==NULL) pattern="""";    vsprintf(buf, pattern, ap);    knownList = udbg_knownIssue_open(knownList, ticket, gTestName, buf,                                     &firstForTicket, &firstForWhere);    if(firstForTicket || firstForWhere) {      log_info(""(Known issue #%s) %s"", ticket, buf);    } else {      log_verbose(""(Known issue #%s) %s"", ticket, buf);    }    return TRUE;}",3,"cwe119,cwe120,cweother"
"joy_keys (){  int             status, tmp;  static int      lastbutton, button;  if (read (joystickdevice[joystick], &js_data, JS_RETURN) <= 0)    {      perror (""Joystick"");      joystickplayer[joystick] = -2;      gamemode = MENU;      change_menu ();      return;    }  button = lastbutton;  lastbutton = js_data.buttons + IsPressedEnter ();  if (joypos == 0)    {      if ((button == 0x00 || lastbutton != 0x00))treturn;      joypos++;      for (tmp = 0; js_data.x > 0xff; tmp++, js_data.x = js_data.x >> 1);      js_data.x = tmp;      for (tmp = 0; js_data.y > 0xff; tmp++, js_data.y = js_data.y >> 1);      js_data.y = tmp;             status = ioctl (joystickdevice[joystick], JS_SET_CAL, &js_data);      if (status == -1)t{t  perror (""Joystick"");t}      return;    }  if ((button == 0x00 || lastbutton != 0x00))    return;  calibrated[joystick] = 1;  center[joystick][0] = js_data.x;  center[joystick][1] = js_data.y;  gamemode = MENU;  change_menu ();}",2,"cwe120,cweother"
"netlink_parse_info(int (*filter) (struct sockaddr_nl *, struct nlmsghdr *),tt   nl_handle_t *nl, struct nlmsghdr *n){tint status;tint ret = 0;tint error;twhile (1) {ttchar buf[4096];ttstruct iovec iov = { buf, sizeof buf };ttstruct sockaddr_nl snl;ttstruct msghdr msg =tt    { (void *) &snl, sizeof snl, &iov, 1, NULL, 0, 0 };ttstruct nlmsghdr *h;ttstatus = recvmsg(nl->fd, &msg, 0);ttif (status < 0) {tttif (errno == EINTR)ttttcontinue;tttif (errno == EWOULDBLOCK || errno == EAGAIN)ttttbreak;tttlog_message(LOG_INFO, ""Netlink: Received message overrun (%m)"");tttcontinue;tt}ttif (status == 0) {tttlog_message(LOG_INFO, ""Netlink: EOF"");tttreturn -1;tt}ttif (msg.msg_namelen != sizeof snl) {tttlog_message(LOG_INFO,ttt       ""Netlink: Sender address length error: length %d"",ttt       msg.msg_namelen);tttreturn -1;tt}ttfor (h = (struct nlmsghdr *) buf; NLMSG_OK(h, status);tt     h = NLMSG_NEXT(h, status)) {ttt tttif (h->nlmsg_type == NLMSG_DONE)ttttreturn ret;ttt tttif (h->nlmsg_type == NLMSG_ERROR) {ttttstruct nlmsgerr *err = (struct nlmsgerr *) NLMSG_DATA(h);tttt ttttif (err->error == 0) {tttttif (!(h->nlmsg_flags & NLM_F_MULTI))ttttttreturn 0;tttttcontinue;tttt}ttttif (h->nlmsg_len < NLMSG_LENGTH(sizeof (struct nlmsgerr))) {tttttlog_message(LOG_INFO,ttttt       ""Netlink: error: message truncated"");tttttreturn -1;tttt}ttttif (n && (err->error == -EEXIST) &&tttt    ((n->nlmsg_type == RTM_NEWROUTE) ||tttt     (n->nlmsg_type == RTM_NEWADDR)))tttttreturn 0;ttttlog_message(LOG_INFO,tttt       ""Netlink: error: %s, type=(%u), seq=%u, pid=%d"",tttt       strerror(-err->error),tttt       err->msg.nlmsg_type,tttt       err->msg.nlmsg_seq, err->msg.nlmsg_pid);ttttreturn -1;ttt}ttt tttif (nl != &nl_cmd && h->nlmsg_pid == nl_cmd.snl.nl_pid)ttttcontinue;ttterror = (*filter) (&snl, h);tttif (error < 0) {ttttlog_message(LOG_INFO, ""Netlink: filter function error"");ttttret = error;ttt}tt}tt ttif (msg.msg_flags & MSG_TRUNC) {tttlog_message(LOG_INFO, ""Netlink: error: message truncated"");tttcontinue;tt}ttif (status) {tttlog_message(LOG_INFO, ""Netlink: error: data remnant size %d"",ttt       status);tttreturn -1;tt}t}treturn ret;}",2,"cwe119,cwe120"
"load_script (char *filename, script_t * scriptlist){  script_t *scriptbuf;  int scriptfp;  struct stat filestat;  scriptfp = open (filename, O_NONBLOCK + O_RDONLY);  if (scriptfp == -1)    {tttt       die_with_message (NULL, NULL, g_err_msg[E_FILE_OPEN_FAIL], filename);    }  fstat (scriptfp, &filestat);  scriptbuf = (script_t *) xmalloc (sizeof (script_t));  scriptbuf->name = (char *) xmalloc (strlen (filename) + 1);  scriptbuf->buf = (char *) xmalloc (filestat.st_size + 1);  memset (scriptbuf->name, 0, strlen (filename) + 1);  memcpy (scriptbuf->name, filename, strlen (filename));  memset (scriptbuf->buf, 0, filestat.st_size + 1);  read (scriptfp, scriptbuf->buf, filestat.st_size);  scriptbuf->size = filestat.st_size;  scriptbuf->uid = filestat.st_uid;  scriptbuf->gid = filestat.st_gid;  scriptbuf->curpos = 0;  scriptbuf->next = NULL;     if (scriptlist != NULL)    {      while (scriptlist->next)tscriptlist = scriptlist->next;      scriptlist->next = scriptbuf;    }     if (memcmp (scriptbuf->buf, ""#!"", 2) == 0)    {      while ((scriptbuf->curpos < scriptbuf->size) &&t     ((char) scriptbuf->buf[scriptbuf->curpos] != ''))t{t  (scriptbuf->curpos)++;t}      (scriptbuf->curpos)++;    }     if (scriptlist == NULL)    {      if (strstr (scriptbuf->buf + scriptbuf->curpos, open_tag) == NULL)t{t  open_tag[1] = '?';t  close_tag[0] = '?';t}    }  close (scriptfp);  return (scriptbuf);}",2,"cwe120,cweother"
"nm_act_request_set_shared (NMActRequest *req, gboolean shared){tNMActRequestPrivate *priv = NM_ACT_REQUEST_GET_PRIVATE (req);tGSList *list, *iter;tg_return_if_fail (NM_IS_ACT_REQUEST (req));tNM_ACT_REQUEST_GET_PRIVATE (req)->shared = shared;t tlist = g_slist_copy (priv->share_rules);tif (!shared)ttlist = g_slist_reverse (list);t tfor (iter = list; iter; iter = g_slist_next (iter)) {ttShareRule *rule = (ShareRule *) iter->data;ttchar *envp[1] = { NULL };ttchar **argv;ttchar *cmd;ttcmd = g_strdup_printf (""%s --table %s %s %s"",tt                       IPTABLES_PATH,tt                       rule->table,tt                       shared ? ""--insert"" : ""--delete"",tt                       rule->rule);ttif (!cmd)tttcontinue;ttargv = g_strsplit (cmd, "" "", 0);ttif (argv && argv[0]) {tttint status;tttGError *error = NULL;tttnm_log_info (LOGD_SHARING, ""Executing: %s"", cmd);tttif (!g_spawn_sync (""/"", argv, envp, G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_STDERR_TO_DEV_NULL,ttt                   share_child_setup, NULL, NULL, NULL, &status, &error)) {ttttnm_log_warn (LOGD_SHARING, ""Error executing command: (%d) %s"",tttt             error ? error->code : -1,tttt             (error && error->message) ? error->message : ""(unknown)"");ttttg_clear_error (&error);ttt} else if (WEXITSTATUS (status)) {ttttnm_log_warn (LOGD_SHARING, ""** Command returned exit status %d."",tttt             WEXITSTATUS (status));ttt}tt}ttg_free (cmd);ttif (argv)tttg_strfreev (argv);t}tg_slist_free (list);t tif (!shared)ttclear_share_rules (req);}",2,"cwe119,cwe120"
"ajStrRemoveDupchar(AjPStr* Pstr){    char filter[256] = {'0'};tt     char *cp;    char *cq;    AjPStr thys;    if(!*Pstr)        *Pstr = ajStrNewResLenC("""", 1, 0);    else if((*Pstr)->Use > 1)        ajStrGetuniqueStr(Pstr);    thys = *Pstr;    cp = thys->Ptr;    while(*cp && !filter[(ajint)*cp])        filter[(ajint)*cp++] = 1;    cq = cp;    while(*cp)    {        if(!filter[(ajint)*cp])        {            filter[(ajint)*cp] = 1;            *cq++ = *cp;        }        else        {            --thys->Len;        }                cp++;    }    *cq = '0';    if(!thys->Len)        return ajFalse;    return ajTrue;}",2,"cwe119,cwe120"
"getDateString(char *str){tint retval;tchar *Month[12] = { ""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"",tt""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec""t};tstruct tm *T = NULL;ttime_t Tval = 0;tTval = time(NULL);tT = localtime(&Tval);tif(T->tm_mday < 10)ttretval = sprintf(str, ""%s0%d"", Month[T->tm_mon], T->tm_mday);telsettretval = sprintf(str, ""%s%d"", Month[T->tm_mon], T->tm_mday);tif(retval <= 4)ttreturn 0;telsettreturn 1;}",3,"cwe119,cwe120,cweother"
"HT_store( HashTable table, const char *key, int keylen, HashSum hash, void *pObj ){  HashNode *pNode, node;  int cmp;  DEBUG( MAIN, (""HT_store( %p, %p, %d, 0x%08lX, %p )"",                table, key, keylen, hash, pObj) );  assert( table != NULL );  assert( key   != NULL );  AssertValidPtr( table );  CHANGE_STATE(table);  if( hash == 0 ) {    if( keylen )      HASH_DATA( hash, keylen, key );    else      HASH_STR_LEN( hash, key, keylen );  }  CHECK_AUTOGROW( table );  pNode = &table->root[hash & table->bmask];  DEBUG( MAIN, (""key=[%s] len=%d hash=0x%08lX bucket=%lu/%d"",                key, keylen, hash, (hash & table->bmask) + 1U, 1<<table->size) );  while( *pNode ) {    DEBUG( MAIN, (""pNode=%p *pNode=%p (key=[%s] len=%d hash=0x%08lX)"",                  pNode, *pNode, (*pNode)->key, (*pNode)->keylen, (*pNode)->hash) );    if( ENTRY_FOUND_HKL( *pNode ) ) {      DEBUG( MAIN, (""key [%s] already in hash, can't store"", key) );      return 0;    }    DEBUG( MAIN, (""cmp: %d"", cmp) );    if( cmp < 0 ) {      DEBUG( MAIN, (""postition to insert new element found"") );      break;    }    DEBUG( MAIN, (""advancing to next hash element"") );    pNode = &(*pNode)->next;  }  AllocF( HashNode, node, HN_SIZE_FIX + keylen + TERMINATOR_LENGTH );  node->next   = *pNode;  node->pObj   = pObj;  node->hash   = hash;  node->keylen = keylen;  memcpy( node->key, (const void *) key, keylen );#ifndef NO_TERMINATED_KEYS  node->key[keylen] = '0';#endif  *pNode = node;  DEBUG( MAIN, (""successfully stored [%s] as element #%d into hash table"",                key, table->count+1) );  return ++table->count;}",3,"cwe120,cwe469,cweother"
"_err(int syslog_level, const char *fmt, va_list ap){  char buf[ERROR_BUFLEN];  assert(err_prog);  vsnprintf(buf, ERROR_BUFLEN, fmt, ap);  if (err_flags & ERROR_STDOUT)    fprintf(stdout, ""%s: %s"", err_prog, buf);  if (err_flags & ERROR_STDERR)    fprintf(stderr, ""%s: %s"", err_prog, buf);  if (err_flags & ERROR_SYSLOG)    syslog(syslog_level, ""%s"", buf);}",3,"cwe119,cwe120,cweother"
"dnpds40_do_cmd(struct dnpds40_ctx *ctx,ttt  struct dnpds40_cmd *cmd,ttt  uint8_t *data, int len){tint ret;tif ((ret = send_data(ctx->dev, ctx->endp_down,ttt     (uint8_t*)cmd, sizeof(*cmd))))ttreturn ret;tif (data && len) ttif ((ret = send_data(ctx->dev, ctx->endp_down,tttt     data, len)))tttreturn ret;treturn 0;}",3,"cwe119,cwe120,cweother"
"pulse_new(void){   Pulse *conn;   Eina_Iterator *it;   const char *prev = NULL, *buf = NULL;   time_t t = 0;   char *home, h[4096];   const Eina_File_Direct_Info *info;   conn = calloc(1, sizeof(Pulse));   EINA_SAFETY_ON_NULL_RETURN_VAL(conn, NULL);   home = getenv(""PULSE_RUNTIME_PATH"");   if (!home)     {        home = getenv(""HOME"");        snprintf(h, sizeof(h), ""%s/.pulse"", home);        home = h;     }   it = eina_file_direct_ls(home);   EINA_ITERATOR_FOREACH(it, info)     {        const char *rt = NULL;        rt = strrchr(info->path + info->name_start, '-');        if (rt)          {             if (!strcmp(rt + 1, ""runtime""))               {                  struct stat st;                  buf = eina_stringshare_printf(""%s/native"", info->path);                  if (stat(buf, &st))                    {                       eina_stringshare_del(buf);                       buf = NULL;                       continue;                    }                  if (!t)                    {                       t = st.st_atime;                       prev = buf;                       buf = NULL;                       continue;                    }                  if (t > st.st_atime)                    {                       eina_stringshare_del(buf);                       buf = NULL;                       continue;                    }                  eina_stringshare_del(prev);                  prev = buf;                  t = st.st_atime;                  buf = NULL;               }          }     }   eina_iterator_free(it);   if (!prev)     {        struct stat st;        buf = eina_stringshare_add(STATEDIR ""/run/pulse/native"");        if (stat(buf, &st))          {             INF(""could not locate local socket '%s'!"", buf);             free(conn);             return NULL;          }        conn->socket = buf;     }   else conn->socket = prev;   conn->con = ecore_event_handler_add(ECORE_CON_EVENT_SERVER_ADD, (Ecore_Event_Handler_Cb)con, conn);   conn->tag_handlers = eina_hash_int32_new(NULL);   conn->tag_cbs = eina_hash_int32_new(NULL);   return conn;}",4,"cwe119,cwe120,cwe476,cweother"
"mod_load(char *config){tchar *p, *conf;tint context = 0;tchar *args[50];tint count = 0;tint i = 0;tt tprefix = """";tnumb = 0;tt tconf = strdup(config);tp = conf;twhile(*p != 0){ttif(context == 0 && *p != ' ' && *p != 't'){tttcontext = 1;tttargs[count] = p;tttcount++;tttif(count == 50) break;tt}ttttelse if(context == 1 && ( *p == ' ' || *p == 't')){tttcontext = 0;ttt*p = 0;tt}ttttp++;t}tt ti = 0;twhile(i < count){ttif(strcmp(""prefix"", args[i]) == 0){ttti ++;tttif(i < count) prefix = strdup(args[i]);tt}ttelse if(strcmp(""init"", args[i]) == 0){ttti++;tttif(i < count) numb = atoi(args[i]);tt}tti++;t}t tfree(conf);}",3,"cwe119,cwe120,cweother"
"""smiley_readline(char *ptr, int maxlen, FILE *fp){tint n;tint c;tfor (n = 1; n < maxlen; n++) {ttc = fgetc(fp);ttif (c != EOF) {tttif (c == 'r')t/* get rid of r */ttttcontinue;ttt*ptr = (char)c;tttif (c == '')ttttbreak;tttptr++;tt} else {tttif (n == 1)ttttreturn (0);t/* EOF, no data */tttelsettttbreak;t/* EOF, w/ data */tt}t}t*ptr = 0;treturn (n);}""",2,"cwe120,cweother"
"reg_vpi_release(register struct net_t *np){ register struct qcval_t *assgn_qcp, *frc_qcp; char s3[RECLEN]; strcpy(__wrks1, """");     if (np->frc_assgn_allocated) frc_qcp = &(np->nu2.qcval[2*__inum]); else frc_qcp = NULL; if (frc_qcp == NULL || !frc_qcp->qc_active)  {   __vpi_err(2101, vpiNotice,   ""attempted vpi_put_value release of reg %s in %s failed - never forced"",    np->nsym->synam, __msg2_blditree(__wrks2, __inst_ptr));   goto done;  } frc_qcp->qc_active = FALSE;  __force_active = FALSE;   assgn_qcp = &(np->nu2.qcval[2*__inum + 1]); if (assgn_qcp->qc_active)  {            __do_qc_store(np, assgn_qcp, TRUE);   __assign_active = TRUE;   strcpy(__wrks1, "" reactivating assign"");  } if (__debug_flg && __ev_tracing)  {   __tr_msg("":: vpi_put_value%s release of reg %s in %s now %s"", __wrks1,    np->nsym->synam, __msg2_blditree(s3, __inst_ptr),    __to_timstr(__wrks2, &__simtime));  }  done: if (__num_vpi_rel_cbs > 0) __find_call_rel_cbs(np, -1); if (__vpi_rel_cb_always) __cb_all_rfs(np, -1, FALSE);}",2,"cwe119,cwe120"
"recursive_roll(object *op, int dir, object *pusher) {    char name[MAX_BUF];    query_name(op, name, MAX_BUF);    if (!roll_ob(op, dir, pusher)) {        draw_ext_info_format(NDI_UNIQUE, 0, pusher, MSG_TYPE_COMMAND, MSG_TYPE_COMMAND_FAILURE,                             ""You fail to push the %s."",                             name);        return;    }    (void)move_ob(pusher, dir, pusher);    draw_ext_info_format(NDI_BLACK, 0, pusher, MSG_TYPE_COMMAND, MSG_TYPE_COMMAND_SUCCESS,                         ""You move the %s."",                         name);    return;}",2,"cwe119,cwe120"
"cmd_dump(char *tag, char *name, int uid_start) {    int r = 0;    char mailboxname[MAX_MAILBOX_BUFFER];    struct mailbox *mailbox = NULL;         if (!imapd_userisadmin)tr = IMAP_PERMISSION_DENIED;    if (!r) r = (*imapd_namespace.mboxname_tointernal)(&imapd_namespace, name,tttttt       imapd_userid, mailboxname);        if (!r) r = mailbox_open_irl(mailboxname, &mailbox);    if (!r) r = dump_mailbox(tag, mailbox, uid_start, MAILBOX_MINOR_VERSION,ttt     imapd_in, imapd_out, imapd_authstate);    if (r) {tprot_printf(imapd_out, ""%s NO %sr"", tag, error_message(r));    } else {tprot_printf(imapd_out, ""%s OK %sr"", tag,tt    error_message(IMAP_OK_COMPLETED));    }    if (mailbox) mailbox_close(&mailbox);}",2,"cwe119,cwe120"
"glusterd_brick_statedump (glusterd_volinfo_t *volinfo,                          glusterd_brickinfo_t *brickinfo,                          char *options, int option_cnt){        int                     ret = -1;        xlator_t                *this = NULL;        glusterd_conf_t         *conf = NULL;        char                    pidfile_path[PATH_MAX] = {0,};        char                    path[PATH_MAX] = {0,};        char                    dumpoptions_path[PATH_MAX] = {0,};        FILE                    *pidfile = NULL;        pid_t                   pid = -1;        this = THIS;        GF_ASSERT (this);        conf = this->private;        GF_ASSERT (conf);        if (uuid_is_null (brickinfo->uuid)) {                ret = glusterd_resolve_brick (brickinfo);                if (ret) {                        gf_log (""glusterd"", GF_LOG_ERROR,                                ""Cannot resolve brick %s:%s"",                                brickinfo->hostname, brickinfo->path);                        goto out;                }        }        if (uuid_compare (brickinfo->uuid, conf->uuid)) {                ret = 0;                goto out;        }        GLUSTERD_GET_VOLUME_DIR (path, volinfo, conf);        GLUSTERD_GET_BRICK_PIDFILE (pidfile_path, path, brickinfo->hostname,                                    brickinfo->path);        pidfile = fopen (pidfile_path, ""r"");        if (!pidfile) {                gf_log ("""", GF_LOG_ERROR, ""Unable to open pidfile: %s"",                        pidfile_path);                ret = -1;                goto out;        }        ret = fscanf (pidfile, ""%d"", &pid);        if (ret <= 0) {                gf_log ("""", GF_LOG_ERROR, ""Unable to get pid of brick process"");                ret = -1;                goto out;        }        snprintf (dumpoptions_path, sizeof (dumpoptions_path),                  ""/tmp/glusterdump.%d.options"", pid);        glusterd_set_dump_options (dumpoptions_path, options, option_cnt);        gf_log ("""", GF_LOG_INFO, ""Performing statedump on brick with pid %d"",                pid);        kill (pid, SIGUSR1);        sleep (1);        unlink (dumpoptions_path);        ret = 0;out:        if (pidfile)                fclose (pidfile);        return ret;}",2,"cwe469,cwe476"
"lk_ssdp_discover(char **host, uint16_t * port){    int sock;    size_t ret;    unsigned int socklen;    struct sockaddr_in sockname;    struct sockaddr clientsock;    struct hostent *hostname;    char data[] =        ""M-SEARCH * HTTP/1.1r""        ""Host: 239.255.255.250:1900r""        ""Man: ""ssdp:discover""r""        ""ST: urn:empeg-com:protocol2r"" ""MX: 3r"" ""r"";    char buffer[RESPONSE_BUFFER_LEN];    unsigned int len = RESPONSE_BUFFER_LEN;    fd_set fds;    struct timeval timeout;    hostname = gethostbyname(SSDP_MULTICAST);    hostname->h_addrtype = AF_INET;    if((sock = socket(PF_INET, SOCK_DGRAM, 0)) == -1) {        lk_errors_set(E_SOCKET);                return -1;    }    memset((char *)&sockname, 0, sizeof(struct sockaddr_in));    sockname.sin_family = AF_INET;    sockname.sin_port = htons(SSDP_PORT);    sockname.sin_addr.s_addr = *((unsigned long *)(hostname->h_addr_list[0]));    ret = sendto(sock, data, strlen(data), 0, (struct sockaddr *)&sockname,                 sizeof(struct sockaddr_in));    if(ret != strlen(data)) {        lk_errors_set(E_SENDTO);                return -1;    }         FD_ZERO(&fds);    FD_SET(sock, &fds);    timeout.tv_sec = 3;    timeout.tv_usec = 0;    if(select(sock + 1, &fds, NULL, NULL, &timeout) < 0) {        lk_errors_set(E_SELECT);        return -1;    }    if(FD_ISSET(sock, &fds)) {        socklen = sizeof(clientsock);        if((len = recvfrom(sock, buffer, len, MSG_PEEK,                           &clientsock, &socklen)) == (size_t) - 1) {            lk_errors_set(E_RECVFROM);              return -1;        }        buffer[len-1] = '0';        close(sock);                 if(strncmp(buffer, ""HTTP/1.1 200 OK"", 12) != 0) {            lk_errors_set(E_SSDPPARSE);             return -1;        }        if(get_host_from_ssdp(buffer, host, port) == -1) {            lk_errors_set(E_SSDPPARSE);             return -1;        }        return 0;    } else {        lk_errors_set(E_NOSSDP);                return -1;    }}",3,"cwe119,cwe120,cweother"
"parse_location(unsigned logopt, struct host **hosts,tt   const char *list, unsigned int options){tchar *str, *p, *delim;tunsigned int empty = 1;tif (!list)ttreturn 0;tstr = strdup(list);tif (!str)ttreturn 0;tp = str;twhile (p && *p) {ttchar *next = NULL;ttint weight = 0;ttp += strspn(p, "" t,"");ttdelim = seek_delim(p);ttif (delim) {tttif (*delim == '(') {ttttchar *w = delim + 1;tttt*delim = '0';ttttdelim = strchr(w, ')');ttttif (delim) {ttttt*delim = '0';tttttweight = atoi(w);tttt}ttttelse {ttttt tttttfree_host_list(hosts);tttttfree(str);tttttreturn 0;tttt}ttttdelim++;ttt}tttif (*delim == ':') {ttttchar *path;tttt*delim = '0';ttttpath = delim + 1;tttt ttttnext = path;ttttwhile (*next && strncmp(next, "":/"", 2))tttttnext++;tttt ttttif (*next == ':') {tttttwhile (*next &&ttttt      (*next != ' ' && *next != 't'))ttttttnext--;ttttt*next++ = '0';tttt}ttttif (p != delim) {tttttif (!add_host_addrs(hosts, p, weight, options)) {ttttttif (empty) {tttttttp = next;tttttttcontinue;tttttt}ttttt}tttttif (!add_path(*hosts, path, strlen(path))) {ttttttfree_host_list(hosts);ttttttfree(str);ttttttreturn 0;ttttt}tttt} else {tttttif (!add_local_path(hosts, path)) {ttttttp = next;ttttttcontinue;ttttt}tttt}ttt} else if (*delim != '0') {tttt*delim = '0';ttttnext = delim + 1;ttttif (!add_host_addrs(hosts, p, weight, options)) {tttttp = next;tttttcontinue;tttt}ttttempty = 0;ttt}tt} else {ttt tttfree_host_list(hosts);tttfree(str);tttreturn 0;tt}ttp = next;t}tfree(str);treturn 1;}",2,"cwe469,cweother"
"copy_word(char **dest, char **src, int max, char term){tchar *cp1 = *src;tchar *cp2 = *dest;twhile(max-- && !isspace((int)*cp1) && *cp1 != term)tt*cp2++ = *cp1++;t*cp2 = 0;t*src = cp1;t*dest = cp2;}",3,"cwe119,cwe120,cweother"
"change_endianness(u_int32_t *s, unsigned int n){tunsigned inttti;tunion {ttu_int32_tttui;ttunsigned chartc[4];t} swapper;tunsigned chartc;tfor(i=0; i<n; i++){ttswapper.ui= *s;ttc= swapper.c[3];ttswapper.c[3]= swapper.c[0];ttswapper.c[0]= c;ttc= swapper.c[2];ttswapper.c[2]= swapper.c[1];ttswapper.c[1]= c;t}}",2,"cwe119,cwe120"
"sendto_realops_flags(unsigned int flags, int level, const char *pattern, ...){  dlink_node *ptr = NULL;  char nbuf[IRCD_BUFSIZE];  va_list args;  va_start(args, pattern);  vsnprintf(nbuf, IRCD_BUFSIZE, pattern, args);  va_end(args);  DLINK_FOREACH(ptr, oper_list.head)  {    struct Client *client_p = ptr->data;    assert(client_p->umodes & UMODE_OPER);         if (((level == L_ADMIN) && !IsAdmin(client_p)) ||t((level == L_OPER) && IsAdmin(client_p)))      continue;    if (client_p->umodes & flags)      sendto_one(client_p, "":%s NOTICE %s :*** Notice -- %s"",                 me.name, client_p->name, nbuf);  }}",3,"cwe119,cwe120,cweother"
"__ecereProp_FindInFilesDialog_Set_replaceMode(struct __ecereNameSpace__ecere__com__Instance * this, unsigned int value){struct FindInFilesDialog * __ecerePointer_FindInFilesDialog = (struct FindInFilesDialog *)(this ? (((char *)this) + __ecereClass_FindInFilesDialog->offset) : 0);if(value != __ecerePointer_FindInFilesDialog->replaceMode){struct __ecereNameSpace__ecere__sys__Size __simpleStruct2;struct __ecereNameSpace__ecere__sys__Size __simpleStruct1;struct __ecereNameSpace__ecere__sys__Size __simpleStruct0;int h = value ? 236 : 208;__ecereProp___ecereNameSpace__ecere__gui__Window_Set_text(__ecerePointer_FindInFilesDialog->find, value ? __ecereNameSpace__ecere__GetTranslatedString(__thisModule, ""Replace"", (((void *)0))) : __ecereNameSpace__ecere__GetTranslatedString(__thisModule, ""Find"", (((void *)0))));__ecereProp___ecereNameSpace__ecere__gui__Window_Set_hotKey(__ecerePointer_FindInFilesDialog->find, value ? 0x40021 : 0x40013);__ecereProp___ecereNameSpace__ecere__gui__Window_Set_visible(__ecerePointer_FindInFilesDialog->llreplaceWith, value);__ecereProp___ecereNameSpace__ecere__gui__Window_Set_text(this, value ? __ecereNameSpace__ecere__GetTranslatedString(__thisModule, ""Replace In Files"", (((void *)0))) : __ecereNameSpace__ecere__GetTranslatedString(__thisModule, ""Find In Files"", (((void *)0))));__ecereProp___ecereNameSpace__ecere__gui__Window_Set_minClientSize(this, (__ecereProp___ecereNameSpace__ecere__gui__Window_Get_minClientSize(this, &__simpleStruct0), __simpleStruct0.h = h, &__simpleStruct0));__ecereProp___ecereNameSpace__ecere__gui__Window_Set_maxClientSize(this, (__ecereProp___ecereNameSpace__ecere__gui__Window_Get_maxClientSize(this, &__simpleStruct1), __simpleStruct1.h = h, &__simpleStruct1));__ecereProp___ecereNameSpace__ecere__gui__Window_Set_size(this, (__ecereProp___ecereNameSpace__ecere__gui__Window_Get_size(this, &__simpleStruct2), __simpleStruct2.h = h, &__simpleStruct2));__ecerePointer_FindInFilesDialog->replaceMode = value;}__ecereNameSpace__ecere__com__eInstance_FireSelfWatchers(this, __ecereProp_FindInFilesDialog_replaceMode), __ecereNameSpace__ecere__com__eInstance_FireSelfWatchers(this, __ecerePropM_FindInFilesDialog_replaceMode);}",2,"cwe476,cweother"
"tstamp ( time_t last, FILE *f ){  time_t now ;  char tbuf [ MAXTSTAMP ] ;#ifdef ENABLE_NLS  gsize written = 0 ;  char *message ;#endif  now = time ( 0 ) ;  strftime ( tbuf, MAXTSTAMP,  ( now - last > 600 ) ? ""%c"" : ""%H:%M:%S"",t     localtime( &now ) ) ;#ifdef ENABLE_NLS  if ( use_utf8 ) {    if ( g_utf8_validate ( tbuf, -1, NULL ) ) {      fputs ( tbuf, f ) ;    } else {      message = g_locale_to_utf8 ( tbuf, -1, NULL, &written, NULL ) ;      if ( message ) {tfputs ( message, f ) ;tg_free ( message ) ;      }    }  }  else fputs ( tbuf, f ) ;#else  fputs ( tbuf, f ) ;#endif  return now ;}",3,"cwe119,cwe120,cweother"
"ossl_seed(struct SessionHandle *data){  char *buf = data->state.buffer;    int nread=0;   #ifndef RANDOM_FILE     if(data->set.ssl.random_file)#define RANDOM_FILE """"  #endif  {         nread += RAND_load_file((data->set.str[STRING_SSL_RANDOM_FILE]?                             data->set.str[STRING_SSL_RANDOM_FILE]:                             RANDOM_FILE),                            RAND_LOAD_LENGTH);    if(seed_enough(nread))      return nread;  }#if defined(HAVE_RAND_EGD)      #ifndef EGD_SOCKET     if(data->set.str[STRING_SSL_EGDSOCKET])#define EGD_SOCKET """"  #endif  {         int ret = RAND_egd(data->set.str[STRING_SSL_EGDSOCKET]?                       data->set.str[STRING_SSL_EGDSOCKET]:EGD_SOCKET);    if(-1 != ret) {      nread += ret;      if(seed_enough(nread))        return nread;    }  }#endif     do {    unsigned char randb[64];    int len = sizeof(randb);    RAND_bytes(randb, len);    RAND_add(randb, len, (len >> 1));  } while(!RAND_status());     buf[0]=0;    RAND_file_name(buf, BUFSIZE);  if(buf[0]) {         nread += RAND_load_file(buf, RAND_LOAD_LENGTH);    if(seed_enough(nread))      return nread;  }  infof(data, ""libcurl is now using a weak random seed!"");  return nread;}",2,"cwe119,cwe120"
"ef_cb_efreet_config_dirs(void){    Eina_List *tmp, *l;    int ret = 1;    unsigned int i;    unsigned int ok;    char dirs[128], *val;    char *vals[] = {""/var/tmp/a"", ""/tmp/b"", ""/usr/local/share"", ""/etc"", NULL};    char *def_vals[] = {""/etc/xdg"", NULL};    dirs[0] = '0';    for (i = 0; vals[i]; i++)    {        if (i > 0) strcat(dirs, "":"");        strcat(dirs, vals[i]);    }    efreet_shutdown();    setenv(""XDG_CONFIG_DIRS"", dirs, 1);    efreet_init();    ok = 0;    tmp = efreet_config_dirs_get();    for (i = 0; vals[i]; i++)    {        char *found;        found = eina_list_search_unsorted(tmp, EINA_COMPARE_CB(strcmp), vals[i]);        if (!ecore_file_exists(vals[i]) && found)        {            printf(""efreet_data_dirs_get() includes non-existing dir (%s) when ""                   ""%s set"", vals[i], dirs);            ret = 0;            continue;        }        if (ecore_file_exists(vals[i]) && !found)        {            printf(""efreet_data_dirs_get() is missing dir (%s) when ""                   ""%s set"", vals[i], dirs);            ret = 0;            continue;        }        if (ecore_file_exists(vals[i]) && found)            ok++;    }    if (eina_list_count(tmp) != ok)    {        printf(""efreet_data_dirs_get() returned more values then it ""               ""should have given %s as input"", dirs);        ret = 0;    }    efreet_shutdown();    unsetenv(""XDG_CONFIG_DIRS"");    efreet_init();    i = 0;    tmp = efreet_config_dirs_get();    EINA_LIST_FOREACH(tmp, l, val)    {        if (!def_vals[i])        {            printf(""efreet_config_dirs_get() returned more values then it ""                    ""should have given %s as input"", dirs);            ret = 0;            break;        }        if (strcmp(val, def_vals[i]))        {            printf(""efreet_config_dirs_get() returned incorrect value (%s) when ""                    ""XDG_CONFIG_DIRS= is set"", val);            ret = 0;        }        i++;    }    return ret;}",2,"cwe119,cwe120"
"""define_dollar_label (long label){  long *i;  for (i = dollar_labels; i < dollar_labels + dollar_label_count; ++i)    if (*i == label)      {t++dollar_label_instances[i - dollar_labels];tdollar_label_defines[i - dollar_labels] = 1;treturn;      }  /* If we get to here, we don't have label listed yet.  */  if (dollar_labels == NULL)    {      dollar_labels = (long *) xmalloc (DOLLAR_LABEL_BUMP_BY * sizeof (long));      dollar_label_instances = (long *) xmalloc (DOLLAR_LABEL_BUMP_BY * sizeof (long));      dollar_label_defines = (char *) xmalloc (DOLLAR_LABEL_BUMP_BY);      dollar_label_max = DOLLAR_LABEL_BUMP_BY;      dollar_label_count = 0;    }  else if (dollar_label_count == dollar_label_max)    {      dollar_label_max += DOLLAR_LABEL_BUMP_BY;      dollar_labels = (long *) xrealloc ((char *) dollar_labels,ttttt dollar_label_max * sizeof (long));      dollar_label_instances = (long *) xrealloc ((char *) dollar_label_instances,ttttt  dollar_label_max * sizeof (long));      dollar_label_defines = (char *) xrealloc (dollar_label_defines, dollar_label_max);    }tttt/* if we needed to grow  */  dollar_labels[dollar_label_count] = label;  dollar_label_instances[dollar_label_count] = 1;  dollar_label_defines[dollar_label_count] = 1;  ++dollar_label_count;}""",2,"cwe119,cwe120"
"create_levelfile(int lev, char *errbuf){    int fd;    const char *fq_lock;    if (errbuf) *errbuf = '0';    set_levelfile_name(lock, lev);    fq_lock = fqname(lock, LEVELPREFIX, 0);#if defined(MICRO) || defined(WIN32)     # ifdef HOLD_LOCKFILE_OPEN    if (lev == 0)            fd = open_levelfile_exclusively(fq_lock, lev,                                            O_WRONLY |O_CREAT | O_TRUNC | O_BINARY);    else# endif            fd = open(fq_lock, O_WRONLY |O_CREAT | O_TRUNC | O_BINARY, FCMASK);#else# ifdef MAC    fd = maccreat(fq_lock, LEVL_TYPE);# else    fd = creat(fq_lock, FCMASK);# endif#endif      if (fd >= 0)            level_info[lev].flags |= LFILE_EXISTS;    else if (errbuf)t             sprintf(errbuf,                    ""Cannot create file ""%s"" for level %d (errno %d)."",                    lock, lev, errno);    return fd;}",2,"cwe120,cweother"
"lips2p_image_out(gx_device_printer * pdev, FILE * prn_stream, int x, int y, int width, int height){    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;    int Len;    char raw_str[32];tt     char comp_str[32];tt     move_cap(pdev, prn_stream, x, y);    Len = lips_mode3format_encode(lprn->TmpBuf, lprn->CompBuf, width / 8 * height);    gs_sprintf(raw_str, ""%c%d;%d;%d.r"", LIPS_CSI,            width / 8 * height, width / 8, (int)pdev->x_pixels_per_inch);    gs_sprintf(comp_str, ""%c%d;%d;%d;9;%d.r"", LIPS_CSI,            Len, width / 8, (int)pdev->x_pixels_per_inch, height);    if (Len < width / 8 * height - strlen(comp_str) + strlen(raw_str)) {        fprintf(prn_stream, ""%s"", comp_str);        fwrite(lprn->CompBuf, 1, Len, prn_stream);    } else {                 fprintf(prn_stream, ""%s"", raw_str);        fwrite(lprn->TmpBuf, 1, width / 8 * height, prn_stream);    }    if (lprn->ShowBubble)        draw_bubble(prn_stream, width, height);}",2,"cwe119,cwe120"
"gplotCreate(const char  *rootname,            l_int32      outformat,            const char  *title,            const char  *xlabel,            const char  *ylabel){char   *newroot;char    buf[L_BUF_SIZE];GPLOT  *gplot;    PROCNAME(""gplotCreate"");    if (!rootname)        return (GPLOT *)ERROR_PTR(""rootname not defined"", procName, NULL);    if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&        outformat != GPLOT_EPS && outformat != GPLOT_X11 &&        outformat != GPLOT_LATEX)        return (GPLOT *)ERROR_PTR(""outformat invalid"", procName, NULL);    if ((gplot = (GPLOT *)CALLOC(1, sizeof(GPLOT))) == NULL)        return (GPLOT *)ERROR_PTR(""gplot not made"", procName, NULL);    gplot->cmddata = sarrayCreate(0);    gplot->datanames = sarrayCreate(0);    gplot->plotdata = sarrayCreate(0);    gplot->plottitles = sarrayCreate(0);    gplot->plotstyles = numaCreate(0);             newroot = genPathname(rootname, NULL);    gplot->rootname = newroot;    gplot->outformat = outformat;    snprintf(buf, L_BUF_SIZE, ""%s.cmd"", newroot);    gplot->cmdname = stringNew(buf);    if (outformat == GPLOT_PNG)        snprintf(buf, L_BUF_SIZE, ""%s.png"", newroot);    else if (outformat == GPLOT_PS)        snprintf(buf, L_BUF_SIZE, ""%s.ps"", newroot);    else if (outformat == GPLOT_EPS)        snprintf(buf, L_BUF_SIZE, ""%s.eps"", newroot);    else if (outformat == GPLOT_LATEX)        snprintf(buf, L_BUF_SIZE, ""%s.tex"", newroot);    else           buf[0] = '0';    gplot->outname = stringNew(buf);    if (title) gplot->title = stringNew(title);    if (xlabel) gplot->xlabel = stringNew(xlabel);    if (ylabel) gplot->ylabel = stringNew(ylabel);    return gplot;}",2,"cwe119,cwe120"
"""itoc(int num){    register int  val;    register char *p;    char tmp[12];    val = ABS(num);    tmp[11] = '0';    p = &tmp[11];    do    {        p--;        *p = digits[val % 10];        val /= 10;    } while(val > 0);    if (num < 0)    {        p--;        *p = '-';    }    while(*p != '0')        *(output_ptr++) = *(p++);    return;}""",2,"cwe119,cwe120"
"amdlibGetInsCfgKeyword(amdlibINS_CFG   *insCfg,                                         char            *keywName,                                        char    keywValue[amdlibKEYW_VAL_LEN+1],                                        amdlibERROR_MSG errMsg){    int i;    char name[amdlibKEYW_NAME_LEN+1];    char currentName[amdlibKEYW_NAME_LEN+1];    strcpy(name, keywName);    amdlibStripBlanks(name);         for (i = 0; i < insCfg->nbKeywords; i++)    {        strcpy(currentName, insCfg->keywords[i].name);        amdlibStripBlanks(currentName);        if (strcmp(currentName, name) == 0)        {                         strcpy((char *)keywValue, insCfg->keywords[i].value);            return amdlibSUCCESS;        }    }    amdlibSetErrMsg(""Keyword %s has not been found in input list of keywords"",                    keywName);    return amdlibFAILURE;}",2,"cwe119,cwe120"
"get_lastlog(int fd, uid_t uid, struct lastlog *ll) {    loff_t pos;    if (fd == -1) return -1;    pos = (long)uid * sizeof(*ll);    if (lseek(fd, pos, L_SET) != pos) return -1;    if (read(fd, ll, sizeof(*ll)) != sizeof(*ll)) return -1;    return 0;}",2,"cwe120,cweother"
"change_process_title_init(char **argv){tchar *process_title_end;tchar **newargv;tint i, argc;t tfor(argc = 0; argv[argc]; argc++) {t}t tnewargv = malloc(argc * sizeof(char *));tfor(i = 0; i < argc; i++) {ttnewargv[i] = strdup(argv[i]);t}t tprocess_title = argv[0];tprocess_title_end = argv[argc - 1] + strlen(argv[argc - 1]);tprocess_title_length = process_title_end - process_title;t tfor(i = 0; i < argc; i++) {ttargv[i] = newargv[i];t}tfree(newargv);}",2,"cwe120,cweother"
"he_verbatim(struct he_s *hedit){  int key;  tio_goto_line(hx_lines - 1);  tio_return();  tio_right(60);  tio_clear_to_eol();  tio_printf(""verbatim"");  he_set_cursor(hedit);restart:  if ((key = tio_mgetch(0, 0)) == (int)HXKEY_ERROR) {    if (window_changed) {      tio_ungetch('v' & 0x1f);      tio_ungetch(HXKEY_ERROR);      tio_goto_line(hx_lines - 1);      tio_return();      tio_right(60);      tio_clear_to_eol();      return (int)HXKEY_NONE;    } else      goto restart;  }  tio_goto_line(hx_lines - 1);  tio_return();  tio_right(60);  tio_clear_to_eol();  return key < 0x100 ? key : (int)HXKEY_NONE;}",2,"cwe119,cwe120"
"MAPread(const char *name){    FILEt*F;    intti;    PAIRt*mp;    chart*p;    charttbuff[BUFSIZ];    if (MAPdata != NULL)tMAPfree();         if ((F = fopen(name, ""r"")) == NULL) {tfprintf(stderr, ""Can't open %s, %s"", name, strerror(errno));texit(1);    }    for (i = 0; fgets(buff, sizeof buff, F) != NULL; i++)tcontinue;    mp = MAPdata = xmalloc((i + 1) * sizeof(PAIR));         fseeko(F, 0, SEEK_SET);    while (fgets(buff, sizeof buff, F) != NULL) {tif ((p = strchr(buff, '')) != NULL)t    *p = '0';tif (buff[0] == '0'         || buff[0] == '#'t || (p = strchr(buff, ':')) == NULL)t    continue;t*p++ = '0';tmp->First = buff[0];tmp->Key = xstrdup(buff);tmp->Value = xstrdup(p);tmp++;    }    fclose(F);    MAPend = mp;}",3,"cwe119,cwe120,cweother"
"sendto_common_channels_local(struct Client *user, int touser,                             const char *pattern, ...){  va_list args;  dlink_node *uptr;  dlink_node *cptr;  struct Channel *chptr;  struct Membership *ms;  struct Client *target_p;  char buffer[IRCD_BUFSIZE];  int len;  va_start(args, pattern);  len = send_format(buffer, IRCD_BUFSIZE, pattern, args);  va_end(args);  ++current_serial;  DLINK_FOREACH(cptr, user->channel.head)  {    chptr = ((struct Membership *) cptr->data)->chptr;    assert(chptr != NULL);    DLINK_FOREACH(uptr, chptr->members.head)    {      ms = uptr->data;      target_p = ms->client_p;      assert(target_p != NULL);      if (!MyConnect(target_p) || target_p == user || IsDefunct(target_p) ||          target_p->localClient->serial == current_serial)        continue;      target_p->localClient->serial = current_serial;      send_message(target_p, buffer, len);    }  }  if (touser && MyConnect(user) && !IsDead(user) &&      user->localClient->serial != current_serial)    send_message(user, buffer, len);}",2,"cwe119,cwe120"
"ft245r_cmd(PROGRAMMER * pgm, const unsigned char *cmd,                      unsigned char *res) {    int i,buf_pos;    unsigned char buf[128];    buf_pos = 0;    for (i=0; i<4; i++) {        buf_pos += set_data(pgm, buf+buf_pos, cmd[i]);    }    buf[buf_pos] = 0;    buf_pos++;    ft245r_send (pgm, buf, buf_pos);    ft245r_recv (pgm, buf, buf_pos);    res[0] = extract_data(pgm, buf, 0);    res[1] = extract_data(pgm, buf, 1);    res[2] = extract_data(pgm, buf, 2);    res[3] = extract_data(pgm, buf, 3);    return 0;}",2,"cwe119,cwe120"
"troff_ok(int charset, wchar_t *string) {    wchar_t test[2];    while (*string) {ttest[0] = *string;ttest[1] = 0;tif (!cvt_ok(charset, test) && !troffchar(*string))t    return FALSE;tstring++;    }    return TRUE;}",2,"cwe119,cwe120"
"ghw_read_sleb128 (struct ghw_handler *h, int32_t *res){  int32_t r = 0;  unsigned int off = 0;  while (1)    {      int v = fgetc (h->stream);      if (v == EOF)treturn -1;      r |= ((int32_t)(v & 0x7f)) << off;      off += 7;      if ((v & 0x80) == 0)t{t  if ((v & 0x40) && off < 32)t    r |= -1 << off;t  break;t}    }  *res = r;  return 0;}",2,"cwe120,cweother"
"daemon_getpid(const char *name){tchar *pidfile = NULL;tchar buf[BUFSIZ];tssize_t bytes;tint pid_fd;tint pid = 0;t tif (!name)ttreturn set_errno(EINVAL);t tif (daemon_construct_pidfile(name, &pidfile) == -1)ttreturn -1;t tpid_fd = open(pidfile, O_RDONLY);tmem_release(pidfile);tif (pid_fd == -1)ttreturn -1;t tbytes = read(pid_fd, buf, BUFSIZ);tclose(pid_fd);tif (bytes == -1)ttreturn -1;tif (sscanf(buf, ""%d"", &pid) != 1)ttreturn -1;treturn (pid_t)pid;}",3,"cwe119,cwe120,cweother"
"autoclass_influence_values_report( clsf_DS clsf, search_DS search, int num_atts_to_list,                                        char *results_file_ptr, int header_information_p,                                        FILE *influence_report_fp, shortstr report_mode,                                        clsf_DS test_clsf,                                        unsigned int order_attributes_by_influence_p,                                        unsigned int comment_data_headers_p,                                        int_list sigma_contours_att_list){  char blank = ' ';  int report_class_number, single_class_p = FALSE;  char class_number_type[5] = ""clsf"";  if (eqstring (report_mode, ""text"") == TRUE)    fprintf( influence_report_fp,            ""%6cI N F L U E N C E   V A L U E S   R E P O R T   ""            ""%6c order attributes by influence values = %s""            ""%6c============================================="", blank, blank,            (order_attributes_by_influence_p == TRUE) ? ""true"" : ""false"",            blank);  influence_values_header( clsf, search, results_file_ptr, TRUE, influence_report_fp,                          report_mode, test_clsf, comment_data_headers_p);  if (eqstring (report_mode, ""text"") == TRUE)    fprintf( influence_report_fp, ""f"");    for (report_class_number=0; report_class_number < clsf->n_classes;       report_class_number++) {        autoclass_class_influence_values_report      ( clsf, search, class_number_type,        map_class_num_report_to_clsf( clsf, report_class_number), num_atts_to_list,        header_information_p, results_file_ptr, single_class_p, influence_report_fp,        report_mode, test_clsf, order_attributes_by_influence_p, comment_data_headers_p,        sigma_contours_att_list);    if ((eqstring (report_mode, ""text"") == TRUE) &&        (report_class_number < (clsf->n_classes - 1)))      fprintf( influence_report_fp, ""f"");  }}",2,"cwe119,cwe120"
"static_generate (double *input, const char **wyckoff, int start, int n_positions, double *positions){int i;char token[GAMGI_ENGINE_STRING];char *token_a, *token_b, *token_c;for (i = 0; i < n_positions; i++)  {  strcpy (token, wyckoff[start + i]);     token_a = strtok (token, "","");  positions[0] = static_parser (token_a, input);  token_b = strtok (NULL, "","");  positions[1] = static_parser (token_b, input);  token_c = strtok (NULL, "","");  positions[2] = static_parser (token_c, input);     gamgi_math_vector_fmod (positions, positions);  positions += 3;  }}",2,"cwe119,cwe120"
"e_config_profile_save(void){   Eet_File *ef;   char buf[4096], buf2[4096];   int ok = 0;       e_user_dir_concat_static(buf, ""config/profile.cfg"");   e_user_dir_concat_static(buf2, ""config/profile.cfg.tmp"");   ef = eet_open(buf2, EET_FILE_MODE_WRITE);   if (ef)     {        ok = eet_write(ef, ""config"", _e_config_profile,                       strlen(_e_config_profile), 0);        if (_e_config_eet_close_handle(ef, buf2))          {             Eina_Bool ret = EINA_TRUE;             if (_e_config_revisions > 0)               {                  int i;                  char bsrc[4096], bdst[4096];                  for (i = _e_config_revisions; i > 1; i--)                    {                       e_user_dir_snprintf(bsrc, sizeof(bsrc), ""config/profile.%i.cfg"", i - 1);                       e_user_dir_snprintf(bdst, sizeof(bdst), ""config/profile.%i.cfg"", i);                       if ((ecore_file_exists(bsrc)) &&                           (ecore_file_size(bsrc)))                         {                            ret = ecore_file_mv(bsrc, bdst);                            if (!ret)                              {                                 _e_config_mv_error(bsrc, bdst);                                 break;                              }                         }                    }                  if (ret)                    {                       e_user_dir_snprintf(bsrc, sizeof(bsrc), ""config/profile.cfg"");                       e_user_dir_snprintf(bdst, sizeof(bdst), ""config/profile.1.cfg"");                       ret = ecore_file_mv(bsrc, bdst);                      }               }             ret = ecore_file_mv(buf2, buf);             if (!ret) _e_config_mv_error(buf2, buf);          }        ecore_file_unlink(buf2);     }   return ok;}",2,"cwe119,cwe120"
"main(int argc, char **argv){tchar *device = ""/dev/video0"";tunsigned cnt = 0;tunsigned bufsz;tunsigned char buf[2048 * 1024];tint fh, sz, i;ttime_t t;tif (argc > 1) device = argv[1];tsrand(time(NULL));tfor (;;) {ttfor (bufsz = 4; bufsz <= 2048 * 1024; bufsz *= 2) {tttfor (i = 0; i < 8; i++) {ttttcnt++;ttttfh = open(device, O_RDONLY);ttttprintf(""%06u/%d/%07u: "", cnt, i, bufsz);ttttif (fh == -1) {tttttfprintf(stderr, ""cannot open %s"", device);tttttreturn -1;tttt}ttttif ((sz = read(fh, buf, bufsz)) != bufsz) {tttttprintf(""read %d, expected %u"", sz, bufsz);tttttioctl(fh, VIDIOC_LOG_STATUS, 0);tttttreturn -1;tttt}ttttif (buf[0] != 0 || buf[1] != 0 || buf[2] != 1) {tttttprintf(""garbage at start of buffer (%02x %02x %02x)"",tttttttbuf[0], buf[1], buf[2]);ttttt tttttreturn -1;tttt}ttttelse {tttttt = time(NULL);tttttprintf(""%s"", ctime(&t));tttt}ttttclose(fh);ttt}tt}ttfor (i = 0; i < 80; i++) {tttbufsz = (rand() % sizeof(buf)) + 1;tttif (bufsz < 3) bufsz = 3;tttcnt++;tttfh = open(device, O_RDONLY);tttprintf(""%06u/%d/%07u: "", cnt, i, bufsz);tttif (fh == -1) {ttttfprintf(stderr, ""cannot open %s"", device);ttttreturn -1;ttt}tttif ((sz = read(fh, buf, bufsz)) != bufsz) {ttttprintf(""read %d, expected %u"", sz, bufsz);ttttioctl(fh, VIDIOC_LOG_STATUS, 0);ttttreturn -1;ttt}tttif (buf[0] != 0 || buf[1] != 0 || buf[2] != 1) {ttttprintf(""garbage at start of buffer (%02x %02x %02x)"",ttttttbuf[0], buf[1], buf[2]);tttt ttttreturn -1;ttt}tttelse {ttttt = time(NULL);ttttprintf(""%s"", ctime(&t));ttt}tttclose(fh);tt}t}treturn 0;}",3,"cwe119,cwe120,cweother"
"nap_sleep(int ms, int split) {tint i, input = got_user_input;tint gd = got_local_pointer_input;tfor (i=0; i<split; i++) {ttusleep(ms * 1000 / split);ttif (! use_threads && i != split - 1) {tttrfbPE(-1);tt}ttif (input != got_user_input) {tttbreak;tt}ttif (gd != got_local_pointer_input) {tttbreak;tt}t}}",3,"cwe119,cwe120,cweother"
"static_cylinder (FILE *fp, gamgi_bool lights, float *color,double length, double radius, gamgi_bool *error){char string[GAMGI_ENGINE_LINE];gamgi_io_file_fprintf (fp, ""<Shape>"", error);gamgi_io_file_fprintf (fp, ""<Appearance>"", error);if (lights == TRUE)  sprintf (string, ""<Material shininess=""%.*f"" diffuseColor=""%.*f %.*f %.*f""/>"",  GAMGI_MATH_DECIMAL_SHININESS, gamgi->light->shininess,  GAMGI_MATH_DECIMAL_COLOR, color[0],  GAMGI_MATH_DECIMAL_COLOR, color[1],  GAMGI_MATH_DECIMAL_COLOR, color[2]);else  sprintf (string, ""<Material emissiveColor=""%.*f %.*f %.*f""/>"",  GAMGI_MATH_DECIMAL_COLOR, color[0],  GAMGI_MATH_DECIMAL_COLOR, color[1],  GAMGI_MATH_DECIMAL_COLOR, color[2]);gamgi_io_file_fprintf (fp, string, error);gamgi_io_file_fprintf (fp, ""</Appearance>"", error);sprintf (string, ""<Cylinder height=""%.*f"" radius=""%.*f"" top=""false"" bottom=""false""/>"",gamgi->gamgi->length, length, gamgi->gamgi->length, radius);gamgi_io_file_fprintf (fp, string, error);gamgi_io_file_fprintf (fp, ""</Shape>"", error);}",2,"cwe119,cwe120"
"""tdb_new_database(struct tdb_context *tdb, int hash_size){tstruct tdb_header *newdb;tint size, ret = -1;t/* We make it up in memory, then write it out if not internal */tsize = sizeof(struct tdb_header) + (hash_size+1)*sizeof(tdb_off_t);tif (!(newdb = (struct tdb_header *)calloc(size, 1)))ttreturn TDB_ERRCODE(TDB_ERR_OOM, -1);t/* Fill in the header */tnewdb->version = TDB_VERSION;tnewdb->hash_size = hash_size;tif (tdb->flags & TDB_INTERNAL) {tttdb->map_size = size;tttdb->map_ptr = (char *)newdb;ttmemcpy(&tdb->header, newdb, sizeof(tdb->header));tt/* Convert the `ondisk' version if asked. */ttCONVERT(*newdb);ttreturn 0;t}tif (lseek(tdb->fd, 0, SEEK_SET) == -1)ttgoto fail;tif (ftruncate(tdb->fd, 0) == -1)ttgoto fail;t/* This creates an endian-converted header, as if read from disk */tCONVERT(*newdb);tmemcpy(&tdb->header, newdb, sizeof(tdb->header));t/* Don't endian-convert the magic food! */tmemcpy(newdb->magic_food, TDB_MAGIC_FOOD, strlen(TDB_MAGIC_FOOD)+1);tif (write(tdb->fd, newdb, size) != size) {ttret = -1;t} else {ttret = 0;t}  fail:tSAFE_FREE(newdb);treturn ret;}""",3,"cwe120,cwe476,cweother"
"proc_reg_read(struct file *file, char __user *buf, size_t count, loff_t *ppos){tssize_t (*read)(struct file *, char __user *, size_t, loff_t *);tstruct proc_dir_entry *pde = PDE(file_inode(file));tssize_t rv = -EIO;tif (use_pde(pde)) {ttread = pde->proc_fops->read;ttif (read)tttrv = read(file, buf, count, ppos);ttunuse_pde(pde);t}treturn rv;}",2,"cwe120,cweother"
"dialout(struct ast_channel *chan, struct ast_vm_user *vmu, char *num, char *outgoing_context) {tint cmd = 0;tchar destination[80] = """";tint retries = 0;tif (!num) {ttast_verb(3, ""Destination number will be entered manually"");ttwhile (retries < 3 && cmd != 't') {tttdestination[1] = '0';tttdestination[0] = cmd = ast_play_and_wait(chan, ""vm-enter-num-to-call"");tttif (!cmd)ttttdestination[0] = cmd = ast_play_and_wait(chan, ""vm-then-pound"");tttif (!cmd)ttttdestination[0] = cmd = ast_play_and_wait(chan, ""vm-star-cancel"");tttif (!cmd) {ttttcmd = ast_waitfordigit(chan, 6000);ttttif (cmd)tttttdestination[0] = cmd;ttt}tttif (!cmd) {ttttretries++;ttt} else {ttttif (cmd < 0)tttttreturn 0;ttttif (cmd == '*') {tttttast_verb(3, ""User hit '*' to cancel outgoing call"");tttttreturn 0;tttt}ttttif ((cmd = ast_readstring(chan, destination + strlen(destination), sizeof(destination) - 1, 6000, 10000, ""#"")) < 0) tttttretries++;ttttelsetttttcmd = 't';ttt}tttast_test_suite_event_notify(""USERPRESS"", ""Message: User pressed %crDTMF: %c"", cmd, cmd);tt}ttif (retries >= 3) {tttreturn 0;tt}ttt} else {ttast_verb(3, ""Destination number is CID number '%s'"", num);ttast_copy_string(destination, num, sizeof(destination));t}tif (!ast_strlen_zero(destination)) {ttif (destination[strlen(destination) -1 ] == '*')tttreturn 0; ttast_verb(3, ""Placing outgoing call to extension '%s' in context '%s' from context '%s'"", destination, outgoing_context, ast_channel_context(chan));ttast_channel_exten_set(chan, destination);ttast_channel_context_set(chan, outgoing_context);ttast_channel_priority_set(chan, 0);ttreturn 9;t}treturn 0;}",2,"cwe119,cwe120"
"Tddli_TransmitData(BYTE * pTransmitBuf, UINT32 TransmitBufLen, BYTE * pReceiveBuf,tt   UINT32 * pReceiveBufLen){tint sizeResult;tif (TransmitBufLen > TDDL_TXBUF_SIZE) {ttLogError(""buffer size handed to TDDL is too large! (%u bytes)"", TransmitBufLen);ttreturn TDDLERR(TDDL_E_FAIL);t}tmemcpy(txBuffer, pTransmitBuf, TransmitBufLen);tLogDebug(""Calling write to driver"");tif (use_in_socket) {ttTddli_Close();ttif (Tddli_Open())tttreturn TDDLERR(TDDL_E_IOERROR);t}tswitch (opened_device->transmit) {ttcase TDDL_UNDEF:ttt ttcase TDDL_TRANSMIT_IOCTL:ttterrno = 0;tttif ((sizeResult = ioctl(opened_device->fd, TPMIOC_TRANSMIT, txBuffer)) != -1) {ttttopened_device->transmit = TDDL_TRANSMIT_IOCTL;ttttbreak;ttt}tttLogWarn(""ioctl: (%d) %s"", errno, strerror(errno));tttLogInfo(""Falling back to Read/Write device support."");ttt ttcase TDDL_TRANSMIT_RW:tttif ((sizeResult = write(opened_device->fd,tttttttxBuffer,ttttttTransmitBufLen)) == (int)TransmitBufLen) {ttttopened_device->transmit = TDDL_TRANSMIT_RW;ttttsizeResult = read(opened_device->fd, txBuffer,tttttt  TDDL_TXBUF_SIZE);ttttbreak;ttt} else {ttttif (sizeResult == -1) {tttttLogError(""write to device %s failed: %s"",tttttt opened_device->path,tttttt strerror(errno));tttt} else {tttttLogError(""wrote %d bytes to %s (tried ""tttttt ""to write %d)"", sizeResult,tttttt opened_device->path,tttttt TransmitBufLen);tttt}ttt}ttt ttdefault:tttreturn TDDLERR(TDDL_E_IOERROR);t}tif (sizeResult < 0) {ttLogError(""read from device %s failed: %s"", opened_device->path, strerror(errno));ttreturn TDDLERR(TDDL_E_IOERROR);t} else if (sizeResult == 0) {ttLogError(""Zero bytes read from device %s"", opened_device->path);ttreturn TDDLERR(TDDL_E_IOERROR);t}tif ((unsigned)sizeResult > *pReceiveBufLen) {ttLogError(""read %d bytes from device %s, (only room for %d)"", sizeResult,ttttopened_device->path, *pReceiveBufLen);ttreturn TDDLERR(TDDL_E_INSUFFICIENT_BUFFER);t}t*pReceiveBufLen = sizeResult;tmemcpy(pReceiveBuf, txBuffer, *pReceiveBufLen);treturn TSS_SUCCESS;}",3,"cwe120,cwe469,cweother"
"dumpTimestamp(ArchiveHandle *AH, const char *msg, time_t tim){tcharttbuf[256];t tif (strftime(buf, sizeof(buf),#ifndef WIN32tttt ""%Y-%m-%d %H:%M:%S %Z"",#elsetttt ""%Y-%m-%d %H:%M:%S"",#endiftttt localtime(&tim)) != 0)ttahprintf(AH, ""-- %s %s"", msg, buf);}",2,"cwe119,cwe120"
"fs_mhash_get(fs_mhash *mh, const fs_rid rid, fs_index_node *val){    if (!mh->locked) flock(mh->fd, LOCK_SH);    int ret = fs_mhash_get_intl(mh, rid, val);    if (!mh->locked) flock(mh->fd, LOCK_UN);    return ret;}",2,"cwe120,cweother"
"read_if_info(struct stats_net_dev *st_net_dev, int nbr){tFILE *fp;tstruct stats_net_dev *st_net_dev_i;tchar filename[128], duplex[32];tint dev, n;ttfor (dev = 0; dev < nbr; dev++) {ttttst_net_dev_i = st_net_dev + dev;tttt ttsprintf(filename, IF_DUPLEX, st_net_dev_i->interface);ttttif ((fp = fopen(filename, ""r"")) == NULL)ttt tttcontinue;ttttn = fscanf(fp, ""%s"", duplex);ttttfclose(fp);ttttif (n != 1)ttt tttcontinue;ttttif (!strcmp(duplex, K_DUPLEX_FULL)) {tttst_net_dev_i->duplex = C_DUPLEX_FULL;tt}ttelse if (!strcmp(duplex, K_DUPLEX_HALF)) {tttst_net_dev_i->duplex = C_DUPLEX_HALF;tt}ttelsetttcontinue;tttt ttsprintf(filename, IF_SPEED, st_net_dev_i->interface);ttttif ((fp = fopen(filename, ""r"")) == NULL)ttt tttcontinue;ttttfscanf(fp, ""%u"", &st_net_dev_i->speed);ttttfclose(fp);t}}",4,"cwe119,cwe120,cwe476,cweother"
"PBE_CreateContext(SECOidTag hashAlgorithm, PBEBitGenID bitGenPurpose,tSECItem *pwitem, SECItem *salt, unsigned int bitsNeeded,tunsigned int iterations){    SECItem *context = NULL;    SECItem mechItem;    CK_PBE_PARAMS pbe_params;    CK_MECHANISM_TYPE mechanism = CKM_INVALID_MECHANISM;    PK11SlotInfo *slot;    PK11SymKey *symKey = NULL;    unsigned char ivData[8];             switch (bitGenPurpose) {    case pbeBitGenIntegrityKey:tswitch (hashAlgorithm) {tcase SEC_OID_SHA1:t    mechanism = CKM_PBA_SHA1_WITH_SHA1_HMAC;t    break;tcase SEC_OID_MD2:t    mechanism = CKM_NETSCAPE_PBE_MD2_HMAC_KEY_GEN;t    break;tcase SEC_OID_MD5:t    mechanism = CKM_NETSCAPE_PBE_MD5_HMAC_KEY_GEN;t    break;tdefault:t    break;t}tbreak;    case pbeBitGenCipherIV:tif (bitsNeeded > 64) {t    break;t}tif (hashAlgorithm != SEC_OID_SHA1) {t    break;t}tmechanism = CKM_PBE_SHA1_DES3_EDE_CBC;tbreak;    case pbeBitGenCipherKey:tif (hashAlgorithm != SEC_OID_SHA1) {t    break;t}tswitch (bitsNeeded) {tcase 40:t    mechanism = CKM_PBE_SHA1_RC4_40;t    break;tcase 128:t    mechanism = CKM_PBE_SHA1_RC4_128;t    break;tdefault:t    break;t}    case pbeBitGenIDNull:tbreak;    }    if (mechanism == CKM_INVALID_MECHANISM) {t t    return NULL;    }     pbe_params.pInitVector = ivData;    pbe_params.pPassword = pwitem->data;    pbe_params.ulPasswordLen = pwitem->len;    pbe_params.pSalt = salt->data;    pbe_params.ulSaltLen = salt->len;    pbe_params.ulIteration = iterations;    mechItem.data = (unsigned char *) &pbe_params;    mechItem.len = sizeof(pbe_params);    slot = PK11_GetInternalSlot();    symKey = PK11_RawPBEKeyGen(slot,mechanism,ttttt&mechItem, pwitem, PR_FALSE, NULL);    PK11_FreeSlot(slot);    if (symKey != NULL) {tif (bitGenPurpose == pbeBitGenCipherIV) {t     t    SECItem ivItem;t    ivItem.data = ivData;t    ivItem.len = bitsNeeded/8;t    context = SECITEM_DupItem(&ivItem);t} else {t    SECItem *keyData;t    PK11_ExtractKeyValue(symKey);t    keyData = PK11_GetKeyData(symKey);t     t    if (keyData) {t    tcontext = SECITEM_DupItem(keyData);t    }t}tPK11_FreeSymKey(symKey);    }    return (PBEBitGenContext *)context;}",2,"cwe119,cwe120"
"drv_D4D_receive_ACK(){    char ret[1];    while (drv_generic_serial_read(ret, sizeof(ret)) != 1)tusleep(1);tt     if (ret[0] == 0x15) {terror(""NAK!"");    } else if (ret[0] != 6) {terror(""no ACK!"");    }}",3,"cwe119,cwe120,cweother"
"_pgsql_drv_token_type(struct _pgsql_drv_storage *s, PGresult *result, int column){  int found_type = -1;  char *type_str;  char query[1024];  PGresult *select_res;  if (result == NULL)  {    memset((void *)query, 0, sizeof(query));    snprintf(query, sizeof(query),      ""SELECT typname FROM pg_type WHERE typelem IN""        "" (SELECT atttypid FROM pg_attribute WHERE attname='token' AND attrelid IN""          "" (SELECT oid FROM pg_class WHERE relname='dspam_token_data'));"");    select_res = PQexec(s->dbh,query);    if ( !select_res || (PQresultStatus(select_res) != PGRES_TUPLES_OK && PQresultStatus(select_res) != PGRES_NONFATAL_ERROR) )    {      _pgsql_drv_query_error (PQresultErrorMessage(select_res), query);      if (select_res) PQclear(select_res);      return -1;    }    if ( PQntuples(select_res) != 1 )    {      if (select_res) PQclear(select_res);      return -1;    }    type_str = PQgetvalue(select_res, 0, 0);    if (strncasecmp(type_str, ""_numeric"", 8) == 0) {      found_type = 0;    } else if (strncasecmp(type_str, ""_int8"", 5) == 0) {      found_type = 1;    } else {      LOGDEBUG (""_pgsql_drv_token_type: Failed to get type of dspam_token_data.token from system tables"");      if (select_res) PQclear(select_res);      return -1;    }    if (select_res) PQclear(select_res);  }  else  {    int col_type = PQftype(result, column);    if (col_type == NUMERICOID) {      found_type = 0;    } else if (col_type == BIGINTOID) {      found_type = 1;    } else {      LOGDEBUG (""_pgsql_drv_token_type: Failed to get type of dspam_token_data.token from result set"");      return -1;    }  }  return found_type;}",2,"cwe119,cwe120"
"""eina_file_mmap_faulty(void *addr, long page_size){   Eina_File_Map *m;   Eina_File *f;   Eina_Iterator *itf;   Eina_Iterator *itm;   /* NOTE: I actually don't know if other thread are running, I will try to take the lock.      It may be possible that if other thread are not running and they were in the middle of      accessing an Eina_File this lock are still taken and we will result as a deadlock. */   eina_lock_take(&_eina_file_lock_cache);   itf = eina_hash_iterator_data_new(_eina_file_cache);   EINA_ITERATOR_FOREACH(itf, f)     {        Eina_Bool faulty = EINA_FALSE;        eina_lock_take(&f->lock);        if (f->global_map)          {             if ((unsigned char *) addr < (((unsigned char *)f->global_map) + f->length) &&                 (((unsigned char *) addr) + page_size) >= (unsigned char *) f->global_map)               {                  f->global_faulty = EINA_TRUE;                  faulty = EINA_TRUE;               }          }        if (!faulty)          {             itm = eina_hash_iterator_data_new(f->map);             EINA_ITERATOR_FOREACH(itm, m)               {                  if ((unsigned char *) addr < (((unsigned char *)m->map) + m->length) &&                      (((unsigned char *) addr) + page_size) >= (unsigned char *) m->map)                    {                       m->faulty = EINA_TRUE;                       faulty = EINA_TRUE;                       break;                    }               }             eina_iterator_free(itm);          }        eina_lock_release(&f->lock);        if (faulty) break;     }   eina_iterator_free(itf);   eina_lock_release(&_eina_file_lock_cache);}""",2,"cwe119,cwe120"
"sdl_tick(int gt, int delta) {    static Uint32 frames    = 0;    static int    last_net  = 0;    static Uint32 last_info = 0;    static int    stall     = 0;    render_real_time = SDL_GetTicks();    render_game_time = gt;    handle_events();    const char *intermission = infon->get_intermission();                            if (show_scores)        intermission = ""Scores"";        if (strlen(intermission) > 0) {        int y = max(video_height() / 2 - 150, 20);        video_rect(0, 0, video_width(), video_height() - 16, 0, 0, 0, 0);        video_hline(0, video_width(), y + 20, 0x80, 0x80, 0x80, 0x80);        video_write((video_width() - strlen(intermission) * 7) / 2,                     y,                     intermission);        draw_scores(video_width() / 2, y + 30);             } else {        draw_world();        infon->each_creature(draw_creature, NULL);        draw_player_row();    }    draw_scroller();         if (render_real_time / 1000 % 60 < 5)         video_draw(video_width() - 190, 20, sprite_get(SPRITE_LOGO));         if (render_real_time >= last_info + 1000) {        char buf[128];        int traffic = infon->get_traffic();        snprintf(buf, sizeof(buf), ""%s - %d fps - %d byte/s"", infon->version, frames, traffic - last_net);        video_set_title(buf);        stall     = traffic > last_net ? 0 : stall + 1;        last_net  = traffic;        last_info = render_real_time;        frames    = 0;    }    if (stall > 2)         video_write(4, 4, ""connection stalled?"");    if (send_events)        video_write(video_width() - 148, 4, ""Input forwarding enabled"");    if (infon->is_demo() && (render_real_time % 1000) < 500)        video_write(4, video_height() - 48, ""Replay"");    video_flip();    frames++;#ifdef WIN32    Sleep(20);#else    usleep(4000);#endif}",3,"cwe119,cwe120,cweother"
"linkprio(struct ael_extension *exten, struct ael_priority *prio, struct ael_extension *mother_exten){tchar *p1, *p2;ttif (!exten->plist) {ttexten->plist = prio;ttexten->plist_last = prio;t} else {ttexten->plist_last->next = prio;ttexten->plist_last = prio;t}tif( !prio->exten )ttprio->exten = exten;  t tif (prio->appargs && ((mother_exten && mother_exten->has_switch) || exten->has_switch) ) {ttwhile ((p1 = strstr(prio->appargs, ""${EXTEN}""))) {tttp2 = malloc(strlen(prio->appargs)+5);ttt*p1 = 0;tttstrcpy(p2, prio->appargs);tttstrcat(p2, ""${~~EXTEN~~}"");tttif (*(p1+8))ttttstrcat(p2, p1+8);tttfree(prio->appargs);tttprio->appargs = p2;tt}ttwhile ((p1 = strstr(prio->appargs, ""${EXTEN:""))) {tttp2 = malloc(strlen(prio->appargs)+5);ttt*p1 = 0;tttstrcpy(p2, prio->appargs);tttstrcat(p2, ""${~~EXTEN~~:"");tttif (*(p1+8))ttttstrcat(p2, p1+8);tttfree(prio->appargs);tttprio->appargs = p2;tt}t}}",2,"cwe120,cwe469"
"hdhomerun_device_get_tuner_vstatus(struct hdhomerun_device_t *hd, char **pvstatus_str, struct hdhomerun_tuner_vstatus_t *vstatus){tif (!hd->cs) {tthdhomerun_debug_printf(hd->dbg, ""hdhomerun_device_get_tuner_vstatus: device not set"");ttreturn -1;t}tmemset(vstatus, 0, sizeof(struct hdhomerun_tuner_vstatus_t));tchar var_name[32];thdhomerun_sprintf(var_name, var_name + sizeof(var_name), ""/tuner%u/vstatus"", hd->tuner);tchar *vstatus_str;tint ret = hdhomerun_control_get(hd->cs, var_name, &vstatus_str, NULL);tif (ret <= 0) {ttreturn ret;t}tif (pvstatus_str) {tt*pvstatus_str = vstatus_str;t}tif (vstatus) {ttchar *vch = strstr(vstatus_str, ""vch="");ttif (vch) {tttsscanf(vch + 4, ""%31s"", vstatus->vchannel);tt}ttchar *name = strstr(vstatus_str, ""name="");ttif (name) {tttsscanf(name + 5, ""%31s"", vstatus->name);tt}ttchar *auth = strstr(vstatus_str, ""auth="");ttif (auth) {tttsscanf(auth + 5, ""%31s"", vstatus->auth);tt}ttchar *cci = strstr(vstatus_str, ""cci="");ttif (cci) {tttsscanf(cci + 4, ""%31s"", vstatus->cci);tt}ttchar *cgms = strstr(vstatus_str, ""cgms="");ttif (cgms) {tttsscanf(cgms + 5, ""%31s"", vstatus->cgms);tt}ttif (strncmp(vstatus->auth, ""not-subscribed"", 14) == 0) {tttvstatus->not_subscribed = TRUE;tt}ttif (strncmp(vstatus->auth, ""error"", 5) == 0) {tttvstatus->not_available = TRUE;tt}ttif (strncmp(vstatus->auth, ""dialog"", 6) == 0) {tttvstatus->not_available = TRUE;tt}ttif (strncmp(vstatus->cci, ""protected"", 9) == 0) {tttvstatus->copy_protected = TRUE;tt}ttif (strncmp(vstatus->cgms, ""protected"", 9) == 0) {tttvstatus->copy_protected = TRUE;tt}t}treturn 1;}",2,"cwe119,cwe120"
"lang_memory_region_alias (const char * alias, const char * region_name){  lang_memory_region_name * n;  lang_memory_region_type * r;  lang_memory_region_type * region;     if (strcmp (region_name, DEFAULT_MEMORY_REGION) == 0      || strcmp (alias, DEFAULT_MEMORY_REGION) == 0)    einfo (_(""%F%P:%S: error: alias for default memory region""), NULL);     region = NULL;  for (r = lang_memory_region_list; r != NULL; r = r->next)    for (n = &r->name_list; n != NULL; n = n->next)      {        if (region == NULL && strcmp (n->name, region_name) == 0)          region = r;        if (strcmp (n->name, alias) == 0)          einfo (_(""%F%P:%S: error: redefinition of memory region ""                   ""alias `%s'""),                 NULL, alias);      }     if (region == NULL)    einfo (_(""%F%P:%S: error: memory region `%s' ""             ""for alias `%s' does not exist""),           NULL, region_name, alias);     n = (lang_memory_region_name *) stat_alloc (sizeof (lang_memory_region_name));  n->name = xstrdup (alias);  n->next = region->name_list.next;  region->name_list.next = n;}",2,"cwe469,cwe476"
"ft_in3270(Boolean ignored _is_unused){tif (!IN_3270 && ft_state != FT_NONE)ttft_complete(get_message(""ftNot3270""));}",2,"cwe119,cwe120"
"get_int_lsb_first (FILE *f, unsigned int sz, unsigned int *val){    int ch, i;    *val = 0;    for (i = 0; i < sz; i++) {tch = fgetc(f);tif (feof(f))t    return FALSE;t*val |= (ch << 8*i);    }    return TRUE;}",2,"cwe120,cweother"
"unsignal_pipe(struct pthread_timer *timer){tssize_t res;tunsigned long buffer;tif (!timer->pipe_signaled) {ttreturn;t}tres = read(timer->pipe[PIPE_READ], &buffer, sizeof(buffer));tif (-1 == res) {ttast_log(LOG_ERROR, ""Error reading from pipe: %s"",ttttstrerror(errno));t} else {tttimer->pipe_signaled = false;t}}",2,"cwe120,cweother"
"match(struct cdb_make *cdbmp, unsigned pos, const char *key, unsigned klen){  int len;  unsigned rlen;  if (lseek(cdbmp->cdb_fd, pos, SEEK_SET) < 0)    return 1;  if (read(cdbmp->cdb_fd, cdbmp->cdb_buf, 8) != 8)    return 1;  if (cdb_unpack(cdbmp->cdb_buf) != klen)    return 0;     rlen = cdb_unpack(cdbmp->cdb_buf + 4);  if (rlen > cdbmp->cdb_dpos - pos - klen - 8)    return errno = EPROTO, 1;t   rlen += klen + 8;  while(klen) {    len = klen > sizeof(cdbmp->cdb_buf) ? sizeof(cdbmp->cdb_buf) : klen;    len = read(cdbmp->cdb_fd, cdbmp->cdb_buf, len);    if (len <= 0)      return 1;    if (memcmp(cdbmp->cdb_buf, key, len) != 0)      return 0;    key += len;    klen -= len;  }  return rlen;}",2,"cwe120,cweother"
"""mkpdirs(char *path) {tstruct stat sbuf;tchar *pp = path;tmode_t mode = 0700;tt/* Default directory mode */tif (*pp == '/')ttpp++;ttt/* Skip root directory */tfor (;pp != NULL && *pp != '000';) {ttif ((pp = strchr(pp, '/')) != NULL) {ttt*pp = '000';tttif (stat(path,&sbuf) != 0) {ttttif (mkdir(path, mode) != 0)tttttreturn 1;ttt} elsettttmode = sbuf.st_mode;ttt*pp = '/';tttpp++;tt}t}treturn 0;}""",2,"cwe119,cwe120"
"parse_rcfile2(const char *filename, rckeys2 *keys) {    chart*p;    charttemp[128];    chart*tokens = "" :t"";    FILEt*fp;    inttti,key;    chart*family = NULL;    fp = fopen(filename, ""r"");    if (fp) {        while (fgets(temp, 128, fp)) {            key = 0;            while (key >= 0 && keys[key].label) {                if ((p = strstr(temp, keys[key].label))) {                    p += strlen(keys[key].label);                    p += strspn(p, tokens);                    if ((i = strcspn(p, ""#""))) p[i] = 0;                    free(*keys[key].var);                    *keys[key].var = strdup(p);                    key = -1;                } else key++;            }        }        fclose(fp);    }    free(family);}",4,"cwe119,cwe120,cwe476,cweother"
"ijs_server_parse_float (const char *value, int size, double *result){  char buf[256];  char *tail;  if (size + 1 > sizeof(buf))    return IJS_EBUF;  memcpy (buf, value, size);  buf[size] = 0;  *result = strtod (buf, &tail);  if (tail == buf)    return IJS_ESYNTAX;  return 0;}",3,"cwe119,cwe120,cweother"
"nfs3svc_mkdir (rpcsvc_request_t *req){        char                    name[NFS_PATH_MAX];        struct nfs3_fh          dirfh = {{0}, };        mkdir3args              args;        int                     ret = RPCSVC_ACTOR_ERROR;        if (!req)                return ret;        nfs3_prep_mkdir3args (&args, &dirfh, name);        if (xdr_to_mkdir3args (req->msg[0], &args) <= 0) {                gf_log (GF_NFS3, GF_LOG_ERROR, ""Error decoding args"");                rpcsvc_request_seterr (req, GARBAGE_ARGS);                goto rpcerr;        }        ret = nfs3_mkdir (req, &dirfh, name, &args.attributes);        if ((ret < 0) && (ret != RPCSVC_ACTOR_IGNORE)) {                gf_log (GF_NFS3, GF_LOG_ERROR, ""MKDIR procedure failed"");                rpcsvc_request_seterr (req, SYSTEM_ERR);                ret = RPCSVC_ACTOR_ERROR;        }rpcerr:        return ret;}",2,"cwe119,cwe120"
"pp_list_find(struct grecs_list *list, struct file_data *dptr){tstruct grecs_list_entry *ep;ttfor (ep = list->head; !dptr->found && ep; ep = ep->next) {ttconst char *dir = ep->data;ttsize_t size = strlen (dir) + 1 + dptr->namelen + 1;ttif (size > dptr->buflen) {tttdptr->buflen = size;tttdptr->buf = grecs_realloc(dptr->buf, dptr->buflen);tt}ttstrcpy(dptr->buf, dir);ttstrcat(dptr->buf, ""/"");ttstrcat(dptr->buf, dptr->name);ttdptr->found = access(dptr->buf, F_OK) == 0;t}treturn dptr->found;}",2,"cwe120,cweother"
"exit_local_server(struct Client *client_p, struct Client *source_p, struct Client *from,tt  const char *comment){tstatic char comment1[(HOSTLEN * 2) + 2];tstatic char newcomment[BUFSIZE];tunsigned long long int sendb, recvb;trb_dlinkDelete(&source_p->localClient->tnode, &serv_list);trb_dlinkFindDestroy(source_p, &global_serv_list);tunset_chcap_usage_counts(source_p);tsendb = source_p->localClient->sendB;trecvb = source_p->localClient->receiveB;t trb_snprintf(newcomment, sizeof(newcomment), ""by %s: %s"",tt    from == source_p ? me.name : from->name, comment);#if 0tttt tif(!IsIOError(source_p))ttsendto_one(source_p, ""SQUIT %s :%s"", use_id(source_p), newcomment);#endiftif(client_p != NULL && source_p != client_p && !IsIOError(source_p))t{ttsendto_one(source_p, ""ERROR :Closing Link: 127.0.0.1 %s (%s)"",ttt   source_p->name, comment);t}tif(source_p->servptr && source_p->servptr->serv)ttrb_dlinkDelete(&source_p->lnode, &source_p->servptr->serv->servers);telsetts_assert(0);tclose_connection(source_p);tif(source_p->localClient->event != NULL)ttrb_event_delete(source_p->localClient->event);tif(source_p->servptr)ttstrcpy(comment1, source_p->servptr->name);telsettstrcpy(comment1, ""<Unknown>"");tstrcat(comment1, "" "");tstrcat(comment1, source_p->name);tif(source_p->serv != NULL)ttremove_dependents(client_p, source_p, IsClient(from) ? newcomment : comment,tttt  comment1);tsendto_realops_flags(UMODE_ALL, L_ALL, ""%s was connected""ttt     "" for %ld seconds.  %llu/%llu send/recv."",ttt     source_p->name,ttt     (long int)(rb_current_time() - source_p->localClient->firsttime),ttt     sendb, recvb);tilog(L_SERVER, ""%s was connected for %ld seconds.  %llu/%llu send/recv."",t     source_p->name, (long int)(rb_current_time() - source_p->localClient->firsttime),t     sendb, recvb);tif(has_id(source_p))ttdel_from_hash(HASH_ID, source_p->id, source_p);tdel_from_hash(HASH_CLIENT, source_p->name, source_p);tremove_client_from_list(source_p);tSetDead(source_p);trb_dlinkAddAlloc(source_p, &dead_list);treturn 0;}",2,"cwe119,cwe120"
"seed_from_urandom(uint32_t *seed) {         char data[sizeof(uint32_t)];    int ok;#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)    int urandom;    urandom = open(""/dev/urandom"", O_RDONLY);    if (urandom == -1)        return 1;    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);    close(urandom);#else    FILE *urandom;    urandom = fopen(""/dev/urandom"", ""rb"");    if (!urandom)        return 1;    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);    fclose(urandom);#endif    if (!ok)        return 1;    *seed = buf_to_uint32(data);    return 0;}",3,"cwe119,cwe120,cweother"
"get_rdev(const char *nodename){    static char buf[PATH_MAX];    static char link[PATH_MAX];    int name_offset;    int i, major, minor, orig_errno;    name_offset = snprintf(buf, sizeof(buf), ""%s/dev/.node/"", getenv(""UMOCKDEV_DIR""));    buf[sizeof(buf) - 1] = 0;         strncpy(buf + name_offset, nodename, sizeof(buf) - name_offset - 1);    for (i = name_offset; i < sizeof(buf); ++i)tif (buf[i] == '/')t    buf[i] = '_';         orig_errno = errno;    if (readlink(buf, link, sizeof(link)) < 0) {tDBG(""get_rdev %s: cannot read link %s: %m"", nodename, buf);terrno = orig_errno;treturn (dev_t) 0;    }    errno = orig_errno;    if (sscanf(link, ""%i:%i"", &major, &minor) != 2) {tDBG(""get_rdev %s: cannot decode major/minor from '%s'"", nodename, link);treturn (dev_t) 0;    }    DBG(""get_rdev %s: got major/minor %i:%i"", nodename, major, minor);    return makedev(major, minor);}",3,"cwe119,cwe120,cweother"
"main(int argc,char *argv[]){     std::ios::sync_with_stdio(false);     #ifdef FORMATDIR    char env[BUFF_SIZE];    snprintf(env, BUFF_SIZE, ""BABEL_LIBDIR=%s"", FORMATDIR);    putenv(env);  #endif  if (argc != 1)    {      cout << ""Usage: conversion"" << endl;      cout << "" Unit tests for OBConversion "" << endl;      return(-1);    }  cout << ""# Unit tests for OBConversion "";     cout << ""1..9"";  cout << ""ok 1"";    OBMol obMol;  OBConversion obConversion;  obConversion.SetInAndOutFormats(""smi"", ""mdl"");  cout << ""ok 2"";  obConversion.ReadString(&obMol, ""C1=CC=CS1"");  cout << ""ok 3"";  if (obMol.NumAtoms() == 5) {    cout << ""ok 4"";  } else {    cout << ""not ok 4"";  }  obMol.AddHydrogens();  if (obMol.NumAtoms() == 9) {    cout << ""ok 5"";  } else {    cout << ""not ok 5"";  }  if ( (obConversion.WriteString(&obMol)).length() > 0)    cout << ""ok 6"";  else    cout << ""not ok 6"";     obConversion.WriteFile(&obMol, ""test.mdl"");  ifstream ifs(""test.mdl"");  if (ifs.good())    cout << ""ok 7"";  else    cout << ""not ok 7"";                                                                                                                                   obConversion.ReadString(&obMol, """");  obConversion.Read(&obMol);  cout << ""ok 8"";  return(0);}",2,"cwe119,cwe120"
"_path_get_uint64(const char *sysfs_path, uint64_t *value, const char *attr){tchar path[PATH_MAX];tif (snprintf(path, sizeof(path), ""%s/%s"",tt     sysfs_path, attr) < 0)ttreturn 0;treturn _read_uint64(path, value);}",2,"cwe119,cwe120"
"storeImagesAndTables(VimosImageSet *imageSet, char *imageList, char extname[],                     int ccdT, int sphT, int ifuT, int extT, int winT,                     int objT){  char inImaName[80];  int nImaInSet, numImages, nChar;  VimosImage *tmpImage;  VimosSingleImage *lastOneImage, *oneImage;  VimosTable *tmpCcdTable;  VimosIfuTable *tmpIfuTab;  VimosExtractionTable *tmpExtTab;  VimosWindowTable *tmpWinTab;  VimosObjectTable *tmpObjTab;  FILE *ifp = NULL;    if ((ifp = fopen(imageList,""r"")) == NULL)    {     printf(""Can't open file %s. "", imageList);     abort();    }  lastOneImage = NULL;  nImaInSet = 0;  while(fgets(inImaName,MAXFILES,ifp) != NULL) numImages++;   if(ifp) rewind(ifp);  while(fgets(inImaName,MAXFILES,ifp) != NULL)  {    nChar = strlen(inImaName);    if(inImaName[nChar-1] == '') inImaName[nChar-1] = '0';    if(inImaName[nChar-2] == ' ') inImaName[nChar-2] = '0';    oneImage = newSingleImage();    tmpImage = openOldFitsFile(inImaName, 0, 1);         oneImage->theImage = openFitsImageExtension(tmpImage->fptr, extname);    oneImage->imageName = inImaName;         if (ccdT == 1)      {       tmpCcdTable = newCcdTable();       readFitsCcdTable(tmpCcdTable, oneImage->theImage->fptr);       oneImage->ccdTable = tmpCcdTable;      }              if (ifuT == 1)      {       tmpIfuTab = newIfuTable();       readFitsIfuTable(tmpIfuTab, oneImage->theImage->fptr);       oneImage->ifuTable = tmpIfuTab;      }    if (extT == 1)      {       tmpExtTab = newExtractionTable();       readFitsExtractionTable(tmpExtTab, oneImage->theImage->fptr);       oneImage->extractionTable = tmpExtTab;      }    if (winT == 1)      {       tmpWinTab = newWindowTable();       readFitsWindowTable(tmpWinTab, oneImage->theImage->fptr);       oneImage->windowTable = tmpWinTab;      }    if (objT == 1)      {       tmpObjTab = newObjectTable();       readFitsObjectTable(tmpObjTab, oneImage->theImage->fptr);       oneImage->objectTable = tmpObjTab;      }         if (lastOneImage == NULL)      {               imageSet->images = oneImage;      }    else      {               lastOneImage->next = oneImage;       oneImage->prev = lastOneImage;      }         lastOneImage = oneImage;    nImaInSet++;  }  if (ifp) fclose(ifp);  deleteIfuTable(tmpIfuTab);  deleteCcdTable(tmpCcdTable);        deleteExtractionTable(tmpExtTab);  deleteWindowTable(tmpWinTab);  deleteObjectTable(tmpObjTab);  deleteSingleImage(lastOneImage);  deleteImage(tmpImage);  return;}",3,"cwe119,cwe120,cweother"
"poly_asssub_linexpr_array_det(bool assign,tttt    ap_manager_t* man,tttt    bool destructive,tttt    pk_t* pa,tttt    ap_dim_t* tdim, ap_linexpr0_t** texpr,tttt    size_t size){  size_t i;  ap_dim_t* tdim2;  numint_t** tvec;  size_t nbcols;  matrix_t* mat;  pk_t* po;  pk_internal_t* pk = (pk_internal_t*)man->internal;  po = destructive ? pa : poly_alloc(pa->intdim,pa->realdim);  if (!assign) poly_dual(pa);     poly_obtain_F_dual(man,pa,""of the argument"",assign);  if (pk->exn){    pk->exn = AP_EXC_NONE;    man->result.flag_best = man->result.flag_exact = false;    poly_set_top(pk,po);    goto _poly_asssub_linexpr_array_det_exit;  }     if (!pa->C && !pa->F){    man->result.flag_best = man->result.flag_exact = true;    poly_set_bottom(pk,po);    return po;  }     nbcols = pk->dec + pa->intdim + pa->realdim;  tvec = (numint_t**)malloc(size*sizeof(numint_t*));  for (i=0; i<size; i++){    tvec[i] = vector_alloc(nbcols);    itv_linexpr_set_ap_linexpr0(pk->itv,tttt&pk->poly_itv_linexpr,tttttexpr[i]);    vector_set_itv_linexpr(pk,ttt   tvec[i],ttt   &pk->poly_itv_linexpr,ttt   pa->intdim+pa->realdim,1);  }     tdim2 = (ap_dim_t*)malloc(size*sizeof(ap_dim_t));  memcpy(tdim2,tdim,size*sizeof(ap_dim_t));  pk_asssub_isort(tdim2,tvec,size);     mat =    assign ?    matrix_assign_variables(pk, pa->F, tdim2, tvec, size) :    matrix_substitute_variables(pk, pa->F, tdim2, tvec, size);     for (i=0; i<size; i++){    vector_free(tvec[i],nbcols);  }  free(tvec);  free(tdim2);     if (destructive){    poly_clear(po);  }  po->F = mat;  po->status = 0; _poly_asssub_linexpr_array_det_exit:  if (!assign){    poly_dual(pa);    if (!destructive) poly_dual(po);  }  assert(poly_check(pk,po));  return po;}",2,"cwe120,cweother"
"""abiview_TextDisplay(AjPGraph graphs, ajint nstart, ajint nstop,ttttconst AjPStr nseq, float tmax, float scale){    ajint i;    ajint colres;    char res[2];    res[1] = '0';    for(i=nstart;i<nstop-1;i++)    {t*res = ajStrGetCharPos(nseq,i);tcolres = abiview_getResColour(*res);tajGraphAddTextScaleC(graphs,(float)i+(float)1.,tmax+(float)30.,ttt    colres, scale, res);    }    return;}""",2,"cwe119,cwe120"
"static_m (GtkWidget *widget, void *data){gamgi_window *window = GAMGI_CAST_WINDOW data;GtkWidget *dialog = window->dialog0;GtkWidget *combo;GtkWidget *entry;char token[GAMGI_ENGINE_TOKEN];const char *name;double charge, radius;int n, l, m;combo = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""combo_n"");n = gtk_combo_box_get_active (GTK_COMBO_BOX (combo)) + 1;combo = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""combo_l"");l = gtk_combo_box_get_active (GTK_COMBO_BOX (combo));combo = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""combo_m"");m = gtk_combo_box_get_active (GTK_COMBO_BOX (combo)) - 5; entry = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""entry_orbital"");gamgi_chem_orbital_name (n, l, m, token);gtk_entry_set_text (GTK_ENTRY (entry), token); static_style (NULL, window); entry = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""entry_charge"");name = gtk_entry_get_text (GTK_ENTRY (entry));if (gamgi_io_token_double_scan (name, &charge,1.0, GAMGI_CHEM_ATOM_MAX) == FALSE) radius = 0.0;else radius = gamgi_chem_orbital_radius (n, l, m, charge);entry = (GtkWidget *) g_object_get_data (G_OBJECT (dialog), ""entry_radius"");if (radius > 0.0)  {  sprintf (token, ""%.*f"", gamgi->gamgi->length, radius);  gtk_entry_set_text (GTK_ENTRY (entry), token);  }else gtk_entry_set_text (GTK_ENTRY (entry), """");}",2,"cwe119,cwe120"
"pot2surf_select_pot_file(GtkWidget *widget _U_, gpointer data _U_){  GtkFileFilter *filter_pot = gtk_file_filter_new();  GtkFileFilter *filter_none = gtk_file_filter_new();  GtkWidget* file_chooser =     gtk_file_chooser_dialog_new(""Select a .pot file"", GTK_WINDOW(convert_window),ttttGTK_FILE_CHOOSER_ACTION_OPEN,ttttGTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, ttttGTK_STOCK_OK, GTK_RESPONSE_ACCEPT, NULL);  gchar *directory = visu_ui_getLastOpenDirectory();  if (directory)    gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(file_chooser), directory);  gtk_file_filter_add_pattern(filter_pot, ""*.pot"");  gtk_file_filter_add_pattern(filter_pot, ""*.dat"");  gtk_file_filter_set_name(filter_pot, ""Potential files (*.pot, *.dat)"");    gtk_file_chooser_add_filter (GTK_FILE_CHOOSER(file_chooser), filter_pot);  gtk_file_filter_add_pattern(filter_none, ""*"");  gtk_file_filter_set_name(filter_none, ""All files"");    gtk_file_chooser_add_filter (GTK_FILE_CHOOSER(file_chooser), filter_none);  while(1)    {      switch(gtk_dialog_run(GTK_DIALOG(file_chooser)))t{t  float pot_min, pot_max;t  char float_to_string[128];t  gchar *selected_file;t  GString *other_files;tcase GTK_RESPONSE_ACCEPT:t  selected_file = t    gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(file_chooser));t  t  if(pot2surf_quick_parse(selected_file, &pot_min, &pot_max))t    {t      sprintf(float_to_string, ""%f"", pot_min);t      gtk_entry_set_text(GTK_ENTRY(pot2surf_potmin), float_to_string);t      sprintf(float_to_string, ""%f"", pot_max);t      gtk_entry_set_text(GTK_ENTRY(pot2surf_potmax), float_to_string);t      gtk_entry_set_text(GTK_ENTRY(pot2surf_entry_source_pot_file), selected_file);t      other_files = g_string_new(selected_file);t      if(g_str_has_suffix(other_files->str, "".pot""))tt g_string_erase(other_files, other_files->len-4, -1);t      g_string_append(other_files, "".surf"");t      gtk_entry_set_text(GTK_ENTRY(pot2surf_entry_target_surf_file), other_files->str);t      g_string_free(other_files, TRUE);t      directory = (char*)gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER (file_chooser));t      visu_ui_setLastOpenDirectory(directory, VISU_UI_DIR_SURFACE);t      g_free(directory);t      gtk_list_store_clear(pot2surf_list_store);t      gtk_widget_destroy(file_chooser);t      return;t    }t  else break;tcase GTK_RESPONSE_HELP:t  break;tcase GTK_RESPONSE_CANCEL:tdefault:t  directory = (char*)gtk_file_chooser_get_current_folder(GTK_FILE_CHOOSER (file_chooser));t  visu_ui_setLastOpenDirectory(directory, VISU_UI_DIR_SURFACE);t  g_free(directory);t  gtk_widget_destroy (file_chooser);t  return;t}    }}",2,"cwe119,cwe120"
"main (int argc ATTRIBUTE_UNUSED, char **argv){  int opt;     unlock_std_streams ();  while ((opt = getopt_long (argc, argv, ""hlpv"", options, NULL)) != -1)    {      switch (opt)t{tcase 'h':t  print_usage ();t  break;tcase 'v':t  print_version ();t  break;tcase 'l':t  flag_dump_contents = 1;t  break;tcase 'p':t  flag_dump_positions = 1;t  break;tdefault:t  fprintf (stderr, ""unknown flag `%c'"", opt);t}    }  while (argv[optind])    dump_file (argv[optind++]);  return 0;}",2,"cwe120,cweother"
"main_scaf(int argc, char *argv[]){tint c, n_threads = 1;trld_t *e;tfmscafopt_t opt;topt.min_supp = 5; opt.pr_links = 0; opt.a_thres = 20.; opt.p_thres = 1e-20;twhile ((c = getopt(argc, argv, ""m:t:Pea:p:"")) >= 0) {ttswitch (c) {tttcase 't': n_threads = atoi(optarg); break;tttcase 'm': opt.min_supp = atoi(optarg); break;tttcase 'P': opt.pr_links = 1; break;tttcase 'a': opt.a_thres = atof(optarg); break;tttcase 'p': opt.p_thres = atof(optarg); break;tt}t}tif (optind + 4 > argc) {ttfprintf(stderr, ""Usage:   fermi scaf <in.fmd> <in.remapped.mag> <avg> <std>"");ttfprintf(stderr, ""Options: -t INT     number of threads [1]"");ttfprintf(stderr, ""         -m INT     minimum number of supporting reads [%d]"", opt.min_supp);ttfprintf(stderr, ""         -P         print the links between unitigs"");ttreturn 1;t}topt.avg = atof(argv[optind+2]); opt.std = atof(argv[optind+3]);te = rld_restore(argv[optind]);tmag_scaf_core(e, argv[optind+1], &opt, n_threads);trld_destroy(e);treturn 0;}",2,"cwe120,cweother"
"FcPatternObjectInsertElt (FcPattern *p, FcObject object){    inttt    i;    FcPatternElt   *e;    i = FcPatternObjectPosition (p, object);    if (i < 0)    {ti = -i - 1;t tif (p->num + 1 >= p->size)t{t    int s = p->size + 16;t    if (p->size)t    {ttFcPatternElt *e0 = FcPatternElts(p);tte = (FcPatternElt *) realloc (e0, s * sizeof (FcPatternElt));ttif (!e)  tt{tt    e = malloc(s * sizeof (FcPatternElt));tt    if (e)tttmemcpy(e, e0, p->num * sizeof (FcPatternElt));tt}t    }t    elsette = (FcPatternElt *) malloc (s * sizeof (FcPatternElt));t    if (!e)ttreturn FcFalse;t    p->elts_offset = FcPtrToOffset (p, e);t    while (p->size < s)t    {tte[p->size].object = 0;tte[p->size].values = NULL;ttp->size++;t    }t}tte = FcPatternElts(p);t tmemmove (e + i + 1,tt e + i,tt sizeof (FcPatternElt) *tt (p->num - i));ttt tp->num++;tte[i].object = object;te[i].values = NULL;    }    return FcPatternElts(p) + i;}",2,"cwe120,cweother"
"hijack_sync_init_msg(struct conn_info *ci){tint len, msg_len;tchar buf[128];tstruct tcp_spec ts;tt tneed_read = ntohl(ci->dst.next_d_seq) - ntohl(ci->src.next_seq);tneed_write = ntohl(ci->dst.next_seq) - ntohl(ci->src.next_d_seq);tprintf(""user have to type %d chars and print %d chars to synchronize connection"", need_read, need_write);tctrl_c_prompt();ttif (need_read <= 0) { ttreturn;t}tif (need_write <= 0) { ttreturn;t}tlen = need_write - need_read;tmsg_len = sprintf(buf, suggest_sync_msg(1), need_read);tif (len >= msg_len) {ttlen = msg_len;ttmemset(&ts, 0, sizeof(ts));ttts.saddr = ci->dst_addr;ttts.daddr = ci->src_addr;ttts.sport = ci->dst_port;ttts.dport = ci->src_port;ttts.src_mac = ci->src.dst_mac;ttts.dst_mac = ci->src.src_mac;ttts.seq = ci->src.next_d_seq;ttts.ack_seq = ci->src.next_seq;ttts.window = ci->dst.window ? ci->dst.window : htons(242);ttts.id = htons(ntohs(ci->dst.id) + 1);ttts.ack = 1;ttts.psh = 1;ttts.rst = 0;ttts.data = buf;ttts.data_len = len;ttneed_write -= len;#if 0ttprintf(""write send/src seq = %u, ack = %u"", ntohl(ts.seq), ntohl(ts.ack_seq));ttprintf(""           dst seq = %u, ack = %u"", ntohl(ci->dst.next_seq), ntohl(ci->dst.next_d_seq));#endifttsend_tcp_packet(&ts);t} else {tt t}}",3,"cwe119,cwe120,cweother"
"esl_hxp_FitComplete(double *x, int n, ESL_HYPEREXP *h){  struct hyperexp_data data;  int     status;  double *p   = NULL;  double *u   = NULL;  double *wrk = NULL;  double  tol;  int     np;  double  fx;  int     i;  tol = 1e-6;     np = 0;  if (! h->fixmix) np += h->K-1;     for (i = 0; i < h->K; i++)           if (! h->fixlambda[i]) np++;t  ESL_ALLOC(p,   sizeof(double) * np);  ESL_ALLOC(u,   sizeof(double) * np);  ESL_ALLOC(wrk, sizeof(double) * np * 4);     data.x   = x;  data.n   = n;  data.h   = h;     hyperexp_pack_paramvector(p, np, h);     for (i = 0; i < np; i++) u[i] = 1.0;     status = esl_min_ConjugateGradientDescent(p, u, np, ttttt    &hyperexp_complete_func, ttttt    &hyperexp_complete_gradient,ttttt    (void *) (&data), tol, wrk, &fx);  if (status != eslOK) goto ERROR;     hyperexp_unpack_paramvector(p, np, h);    free(p);  free(u);  free(wrk);  esl_hyperexp_SortComponents(h);  return eslOK; ERROR:  if (p   != NULL) free(p);  if (u   != NULL) free(u);  if (wrk != NULL) free(wrk);  return status;}",2,"cwe120,cweother"
"""quoteValue(MprBuf *buf, cchar *str){    cchar   *cp;    mprPutCharToBuf(buf, ''');    for (cp = str; *cp; cp++) {        if (*cp == ''') {            mprPutCharToBuf(buf, '');        }        mprPutCharToBuf(buf, *cp);    }    mprPutCharToBuf(buf, ''');}""",2,"cwe119,cwe120"
"spawn_redraw_process(void){    char buff[1024];    pid_t pid;    LIST *commands = NULL;    PAD *pad;    if (redraw_pid)treturn;    for (pad = pad_list(); pad != NULL; pad = pad->next) {tITEM *list, *d_win;tint b0, t0, l0, r0;tdouble b, t, l, r;tlist = find_item(pad, ""list"");tif (!list || !list->list)t    continue;td_win = find_item(pad, ""d_win"");tif (!d_win || !d_win->list || !d_win->list->value)t    continue;tif (sscanf(d_win->list->value, ""%d %d %d %d"", &t0, &b0, &l0, &r0) !=t    4)t    continue;tcommands = list_copy(list->list, commands);tsprintf(buff, ""d.frame -s %s"", pad->name);tcommands = list_push(buff, commands);tb = 100.0 - 100.0 * b0 / (screen_bottom - screen_top);tt = 100.0 - 100.0 * t0 / (screen_bottom - screen_top);tl = 100.0 * l0 / (screen_right - screen_left);tr = 100.0 * r0 / (screen_right - screen_left);tsprintf(buff, ""d.frame -c %s at=%f,%f,%f,%f"", pad->name, b, t, l, r);tcommands = list_push(buff, commands);    }    if (!commands)treturn;    pid = fork();    if (pid < 0) {tperror(""Monitor: fork"");treturn;    }    if (pid != 0) {tt tset_busy(1);tredraw_pid = pid;tlist_free(commands);treturn;    }         sprintf(buff, ""MONITOR_OVERRIDE=%s"", monitor_name);    putenv(buff);    close(0);    open(""/dev/null"", O_RDONLY);    close(1);    open(""/dev/null"", O_WRONLY);    close(2);    open(""/dev/null"", O_WRONLY);    for (; commands; commands = commands->next)tsystem(commands->value);    exit(0);}",3,"cwe119,cwe120,cweother"
"ip_address_checkout (const char *section_name,                     struct config_keyvalue *kv,                     void *arg){  bmc_config_state_data_t *state_data;  fiid_obj_t obj_cmd_rs = NULL;  char ip_address_str[BMC_MAXIPADDRLEN + 1];  uint8_t ip_address_bytes[4];  config_err_t rv = CONFIG_ERR_FATAL_ERROR;  config_err_t ret;  uint8_t channel_number;  assert (section_name);  assert (kv);  assert (arg);    state_data = (bmc_config_state_data_t *)arg;  if (!(obj_cmd_rs = fiid_obj_create (tmpl_cmd_get_lan_configuration_parameters_ip_address_rs)))    {      pstdout_fprintf (state_data->pstate,                       stderr,                       ""fiid_obj_create: %s"",                       strerror (errno));      goto cleanup;    }  if ((ret = get_lan_channel_number (state_data,tttt     section_name,tttt     &channel_number)) != CONFIG_ERR_SUCCESS)    {      rv = ret;      goto cleanup;    }  if (ipmi_cmd_get_lan_configuration_parameters_ip_address (state_data->ipmi_ctx,                                                            channel_number,                                                            IPMI_GET_LAN_PARAMETER,                                                            IPMI_LAN_CONFIGURATION_PARAMETERS_NO_SET_SELECTOR,                                                            IPMI_LAN_CONFIGURATION_PARAMETERS_NO_BLOCK_SELECTOR,                                                            obj_cmd_rs) < 0)    {      if (state_data->prog_data->args->config_args.common.debug)        pstdout_fprintf (state_data->pstate,                         stderr,                         ""ipmi_cmd_get_lan_configuration_parameters_ip_address: %s"",                         ipmi_ctx_errormsg (state_data->ipmi_ctx));      if (config_is_config_param_non_fatal_error (state_data->ipmi_ctx,                                                  obj_cmd_rs,                                                  &ret))        rv = ret;      goto cleanup;    }  if (fiid_obj_get_data (obj_cmd_rs,                         ""ip_address"",                         ip_address_bytes,                         4) < 0)    {      pstdout_fprintf (state_data->pstate,                       stderr,                       ""fiid_obj_get_data: 'ip_address': %s"",                       fiid_obj_errormsg (obj_cmd_rs));      goto cleanup;    }  memset (ip_address_str, '0', BMC_MAXIPADDRLEN+1);  snprintf (ip_address_str,            BMC_MAXIPADDRLEN,            ""%u.%u.%u.%u"",            ip_address_bytes[0],            ip_address_bytes[1],            ip_address_bytes[2],            ip_address_bytes[3]);  if (config_section_update_keyvalue_output (state_data->pstate,                                             kv,                                             ip_address_str) < 0)    return (CONFIG_ERR_FATAL_ERROR);  rv = CONFIG_ERR_SUCCESS; cleanup:  fiid_obj_destroy (obj_cmd_rs);  return (rv);}",2,"cwe119,cwe120"
"file_unlink(int x){tint i,j,k,y;tchar buf[100];tchar bufn[100];tstats[_STAT_UNLINK].best=(double)999999.9;tstats[_STAT_UNLINK].worst=(double)0.0;tfor(i=0;i<x;i++)t{t  sprintf(buf,""fileop_L1_%d"",i);t  junk=chdir(buf);t  for(j=0;j<x;j++)t  {t    sprintf(buf,""fileop_L1_%d_L2_%d"",i,j);t    junk=chdir(buf);t    for(k=0;k<x;k++)t    {t      sprintf(buf,""fileop_file_%d_%d_%d"",i,j,k);t      sprintf(bufn,""fileop_file_%d_%d_%dL"",i,j,k);t      stats[_STAT_UNLINK].starttime=time_so_far();t      y=unlink(bufn);t      if(y < 0)t      {t        printf(""Unlink failed"");t        exit(1);t      }t      stats[_STAT_UNLINK].endtime=time_so_far();t      stats[_STAT_UNLINK].speed=stats[_STAT_UNLINK].endtime-stats[_STAT_UNLINK].starttime;t      if(stats[_STAT_UNLINK].speed < (double)0.0)ttstats[_STAT_UNLINK].speed=(double)0.0;t      stats[_STAT_UNLINK].total_time+=stats[_STAT_UNLINK].speed;t      stats[_STAT_UNLINK].counter++;t      if(stats[_STAT_UNLINK].speed < stats[_STAT_UNLINK].best)tt stats[_STAT_UNLINK].best=stats[_STAT_UNLINK].speed;t      if(stats[_STAT_UNLINK].speed > stats[_STAT_UNLINK].worst)tt stats[_STAT_UNLINK].worst=stats[_STAT_UNLINK].speed;t    }t    junk=chdir("".."");t  }t  junk=chdir("".."");t}}",2,"cwe119,cwe120"
"arch_prepare_optimized_kprobe(struct optimized_kprobe *op,tttt  struct kprobe *__unused){tu8 *buf;tint ret;tlong rel;tif (!can_optimize((unsigned long)op->kp.addr))ttreturn -EILSEQ;top->optinsn.insn = get_optinsn_slot();tif (!op->optinsn.insn)ttreturn -ENOMEM;t trel = (long)op->optinsn.insn - (long)op->kp.addr + RELATIVEJUMP_SIZE;tif (abs(rel) > 0x7fffffff) {tt__arch_remove_optimized_kprobe(op, 0);ttreturn -ERANGE;t}tbuf = (u8 *)op->optinsn.insn;t tret = copy_optimized_instructions(buf + TMPL_END_IDX, op->kp.addr);tif (ret < 0) {tt__arch_remove_optimized_kprobe(op, 0);ttreturn ret;t}top->optinsn.size = ret;t tmemcpy(buf, &optprobe_template_entry, TMPL_END_IDX);t tsynthesize_set_arg1(buf + TMPL_MOVE_IDX, (unsigned long)op);t tsynthesize_relcall(buf + TMPL_CALL_IDX, optimized_callback);t tsynthesize_reljump(buf + TMPL_END_IDX + op->optinsn.size,ttt   (u8 *)op->kp.addr + op->optinsn.size);tflush_icache_range((unsigned long) buf,ttt   (unsigned long) buf + TMPL_END_IDX +ttt   op->optinsn.size + RELATIVEJUMP_SIZE);treturn 0;}",2,"cwe120,cwe469"
"mono_method_get_name_full (MonoMethod *method, gboolean signature, MonoTypeNameFormat format){tchar *res;tchar wrapper [64];tchar *klass_desc;tchar *inst_desc = NULL;tif (format == MONO_TYPE_NAME_FORMAT_IL)ttklass_desc = mono_type_full_name (&method->klass->byval_arg);telsettklass_desc = mono_type_get_name_full (&method->klass->byval_arg, format);tif (method->is_inflated && ((MonoMethodInflated*)method)->context.method_inst) {ttGString *str = g_string_new ("""");ttif (format == MONO_TYPE_NAME_FORMAT_IL)tttg_string_append (str, ""<"");ttelsetttg_string_append (str, ""["");ttginst_get_desc (str, ((MonoMethodInflated*)method)->context.method_inst);ttif (format == MONO_TYPE_NAME_FORMAT_IL)tttg_string_append_c (str, '>');ttelsetttg_string_append_c (str, ']');ttinst_desc = str->str;ttg_string_free (str, FALSE);t} else if (method->is_generic) {ttMonoGenericContainer *container = mono_method_get_generic_container (method);ttGString *str = g_string_new ("""");ttif (format == MONO_TYPE_NAME_FORMAT_IL)tttg_string_append (str, ""<"");ttelsetttg_string_append (str, ""["");ttginst_get_desc (str, container->context.method_inst);ttif (format == MONO_TYPE_NAME_FORMAT_IL)tttg_string_append_c (str, '>');ttelsetttg_string_append_c (str, ']');ttinst_desc = str->str;ttg_string_free (str, FALSE);t}tif (method->wrapper_type != MONO_WRAPPER_NONE)ttsprintf (wrapper, ""(wrapper %s) "", wrapper_type_to_str (method->wrapper_type));telsettstrcpy (wrapper, """");tif (signature) {ttchar *tmpsig = mono_signature_get_desc (mono_method_signature (method), TRUE);ttif (method->wrapper_type != MONO_WRAPPER_NONE)tttsprintf (wrapper, ""(wrapper %s) "", wrapper_type_to_str (method->wrapper_type));ttelsetttstrcpy (wrapper, """");ttres = g_strdup_printf (""%s%s:%s%s (%s)"", wrapper, klass_desc, ttttttt   method->name, inst_desc ? inst_desc : """", tmpsig);ttg_free (tmpsig);t} else {ttres = g_strdup_printf (""%s%s:%s%s"", wrapper, klass_desc,ttttttt   method->name, inst_desc ? inst_desc : """");t}tg_free (klass_desc);tg_free (inst_desc);treturn res;}",2,"cwe119,cwe120"
"absFileRead(io_func* io, off_t location, size_t size, void *buffer) {tAbstractFile* file;tfile = (AbstractFile*) io->data;tfile->seek(file, location);tif(file->read(file, buffer, size) == size) {ttreturn TRUE;t} else {ttreturn FALSE;t}}",2,"cwe120,cweother"
"do_decode (FILE *in, FILE *out, bool ignore_garbage){  char inbuf[B64BLOCKSIZE];  char outbuf[BLOCKSIZE];  size_t sum;  struct base64_decode_context ctx;  base64_decode_ctx_init (&ctx);  do    {      bool ok;      size_t n;      unsigned int k;      sum = 0;      do        {          n = fread (inbuf + sum, 1, B64BLOCKSIZE - sum, in);          if (ignore_garbage)            {              size_t i;              for (i = 0; n > 0 && i < n;)                if (isbase64 (inbuf[sum + i]) || inbuf[sum + i] == '=')                  i++;                else                  memmove (inbuf + sum + i, inbuf + sum + i + 1, --n - i);            }          sum += n;          if (ferror (in))            error (EXIT_FAILURE, errno, _(""read error""));        }      while (sum < B64BLOCKSIZE && !feof (in));             for (k = 0; k < 1 + !!feof (in); k++)        {          if (k == 1 && ctx.i == 0)            break;          n = BLOCKSIZE;          ok = base64_decode_ctx (&ctx, inbuf, (k == 0 ? sum : 0), outbuf, &n);          if (fwrite (outbuf, 1, n, out) < n)            error (EXIT_FAILURE, errno, _(""write error""));          if (!ok)            error (EXIT_FAILURE, 0, _(""invalid input""));        }    }  while (!feof (in));}",2,"cwe119,cwe120"
"do_udp(char *dest,char **errm,int todo){tint r = 0;tchar em[RXRSZ];tchar sb[2];tsb[0] = sb[1] = todo; ttodo++;tif((r = txrx_udp_socket(dest,em,sb,2)) >= 2) {ttif(em[0] == todo && em[1] == todo)tttreturn(1);t} else if(r < 0) {ttif(errm != NULL) {tttif((*errm = (char *)malloc(strlen(em)+1)) != NULL)ttttstrcpy(*errm,em);tt}ttreturn(-r);t}treturn(0);}",2,"cwe119,cwe120"
"writeCheckPoint (int offsetAdjust){  char offsetString[16], *writePointer ;  off_t offset ;  int writeBytes, writeReturn, mainFd ;t        mainFd = getMainEndPointFd() ;  offset = lseek (mainFd, 0, SEEK_CUR) ;  if (offset < 0)    syslog (LOG_ERR, ""ME tell(mainFd): %m"") ;  else    {      snprintf (offsetString, sizeof(offsetString), ""%ld"",tt      (long)(offset - offsetAdjust) ) ;      if ( lseek (mainFd, 0, SEEK_SET) != 0 )tsyslog (LOG_ERR, ""ME seek(mainFd, 0, 0): %m"") ;      elset{t  writeBytes = strlen (offsetString) ;t  writePointer = offsetString ;t  dot    { t      writeReturn = write (mainFd, writePointer, writeBytes) ;t      if (writeReturn < 0)tt{tt  syslog (LOG_ERR,""ME write input checkpoint: %m"") ;tt  break ;tt}t      writePointer += writeReturn ;t      writeBytes -= writeReturn ;t    } while (writeBytes) ;t  if ( lseek (mainFd, offset, SEEK_SET) != offset )t    die (""ME seek(mainFd, %ld, SEEK_SET): %s"", (long)offset,tt strerror(errno) ) ;t}    }}",2,"cwe119,cwe120"
"tops_preinput_proc(int x){tchartc;tchartbuf[80];tintti,cntx;        if (debug == 2) { printf("" Entered static void tops_preinput_proc..."");}tcntx=read(ttyfd, &buf, 80);tfor (i=0; i < cntx; i++)t{ttc=buf[i];ttif (c==exit_char)tt{tttct_reset_term();tttprintf(""Control returned to local host."");tttclose(sockfd);tttexit(1);tt}t}tif (write(sockfd, buf, cntx) < 0)t{ttif (errno == ENOTCONN)tttprintf(""Control returned to local host."");ttelsetttperror(""terminal input data message"");ttct_reset_term();ttexit(-1);t}}",3,"cwe119,cwe120,cweother"
"my_strtod(const char *str, char **end, int *error){  char buf[DTOA_BUFF_SIZE];  double res;  DBUG_ASSERT(end != NULL && ((str != NULL && *end != NULL) ||                              (str == NULL && *end == NULL)) &&              error != NULL);  res= my_strtod_int(str, end, error, buf, sizeof(buf));  return (*error == 0) ? res : (res < 0 ? -DBL_MAX : DBL_MAX);}",2,"cwe119,cwe120"
"log_config(void){tchar tmp_str[128];tdebug2(""ArchiveDir        = %s"", slurmdbd_conf->archive_dir);tdebug2(""ArchiveScript     = %s"", slurmdbd_conf->archive_script);tdebug2(""AuthInfo          = %s"", slurmdbd_conf->auth_info);tdebug2(""AuthType          = %s"", slurmdbd_conf->auth_type);tdebug2(""DbdAddr           = %s"", slurmdbd_conf->dbd_addr);tdebug2(""DbdBackupHost     = %s"", slurmdbd_conf->dbd_backup);tdebug2(""DbdHost           = %s"", slurmdbd_conf->dbd_host);tdebug2(""DbdPort           = %u"", slurmdbd_conf->dbd_port);tdebug2(""DebugLevel        = %u"", slurmdbd_conf->debug_level);tdebug2(""DefaultQOS        = %s"", slurmdbd_conf->default_qos);tdebug2(""LogFile           = %s"", slurmdbd_conf->log_file);tdebug2(""MessageTimeout    = %u"", slurmdbd_conf->msg_timeout);tdebug2(""PidFile           = %s"", slurmdbd_conf->pid_file);tdebug2(""PluginDir         = %s"", slurmdbd_conf->plugindir);tprivate_data_string(slurmdbd_conf->private_data,ttt    tmp_str, sizeof(tmp_str));tdebug2(""PrivateData       = %s"", tmp_str);tif (slurmdbd_conf->purge_event != NO_VAL)ttslurmdb_purge_string(slurmdbd_conf->purge_event,tttt     tmp_str, sizeof(tmp_str), 1);telsettsprintf(tmp_str, ""NONE"");tdebug2(""PurgeEventAfter   = %s"", tmp_str);tif (slurmdbd_conf->purge_job != NO_VAL)ttslurmdb_purge_string(slurmdbd_conf->purge_job,tttt     tmp_str, sizeof(tmp_str), 1);telsettsprintf(tmp_str, ""NONE"");tdebug2(""PurgeJobAfter     = %s"", tmp_str);tif (slurmdbd_conf->purge_step != NO_VAL)ttslurmdb_purge_string(slurmdbd_conf->purge_step,tttt     tmp_str, sizeof(tmp_str), 1);telsettsprintf(tmp_str, ""NONE"");tdebug2(""PurgeStepAfter    = %s"", tmp_str);tif (slurmdbd_conf->purge_suspend != NO_VAL)ttslurmdb_purge_string(slurmdbd_conf->purge_suspend,tttt     tmp_str, sizeof(tmp_str), 1);telsettsprintf(tmp_str, ""NONE"");tdebug2(""PurgeSuspendAfter     = %s"", tmp_str);tdebug2(""SlurmUser         = %s(%u)"",t       slurmdbd_conf->slurm_user_name, slurmdbd_conf->slurm_user_id);tdebug2(""StorageBackupHost = %s"", slurmdbd_conf->storage_backup_host);tdebug2(""StorageHost       = %s"", slurmdbd_conf->storage_host);tdebug2(""StorageLoc        = %s"", slurmdbd_conf->storage_loc);tdebug2(""StoragePass       = %s"", slurmdbd_conf->storage_pass);tdebug2(""StoragePort       = %u"", slurmdbd_conf->storage_port);tdebug2(""StorageType       = %s"", slurmdbd_conf->storage_type);tdebug2(""StorageUser       = %s"", slurmdbd_conf->storage_user);tdebug2(""TrackWCKey        = %u"", slurmdbd_conf->track_wckey);tdebug2(""TrackSlurmctldDown= %u"", slurmdbd_conf->track_ctld);}",2,"cwe119,cwe120"
"check_special_handling(char *s){tchar local[BUFSIZE];tstrcpy(local, s);tif ((local[0] == '*') && (!whitespace(local[1]))) {ttsprintf(s, ""* %s"", &local[1]);ttreturn;t}        if ((local[0] == '<') && (!whitespace(local[1]))) {                sprintf(s, ""< %s"", &local[1]);                return;        }}",2,"cwe119,cwe120"
"set_combobox_subcat(GtkWidget *widget, int choice){ttGtkCellRenderer *renderer;tGtkWidget *vbox;tchar *subcat_lists[16];ttprintf(""*** %s(): "",__PRETTY_FUNCTION__);tsubcat_lists[0] = ""---""; tsubcat_lists[1] = _(""- Please choose -|Hotel|Motel|B&B|Hostel|Camping"");tsubcat_lists[2] = _(""- Please choose -|Bank / Exchange / ATM|Post Office|Real Estate Agency|Travel Agency|Other"");tsubcat_lists[3] = _(""- Please choose -|Parking|Gas Station|Repair Shop|Rental|Sharing|Dealer|Radar - Speed Trap|My Car"");tsubcat_lists[4] = _(""- Please choose -|Cinema|Theatre|Concert Hall|Opera|Casino"");tsubcat_lists[5] = _(""- Please choose -|Pharmacy|Hospital|Doctor"");tsubcat_lists[6] = _(""- Please choose -|Cafe|Pub|Lounge Bar|Club|Dancing|Internet Cafe|Wifi Hot Spot"");tsubcat_lists[7] = _(""- Please choose -|Church|Mosque|Synagogue|Temple|Cemetery"");tsubcat_lists[8] = _(""- Please choose -|Bus|Metro|Tram|Taxi|Train Station|Bike|Port|Airport"");tsubcat_lists[9] = _(""- Please choose -|Local Food|European|Asian|American|African|Pizza|Fast Food|Take Away|Barbecue|Italian|Mexican|Indian|Japanese|French"");tsubcat_lists[10] = _(""- Please choose -|Wifi Hotspot|ATM-Money Dispenser|Post Office/Letter Box|Laundry|Hairdresser|Other"");tsubcat_lists[11] = _(""- Please choose -|Tourist Info|Monument|Museum|Zoo|Viewpoint|Relief Map|Other"");tsubcat_lists[12] = _(""- Please choose -|Supermarket|Shopping Center|Clothes|Shoes|Food|Baker|Butcher|DoItYourself|Other"");tsubcat_lists[13] = _(""- Please choose -|Arena/Stadium|Swimming Pool|Freeclimbing|Ice Skating|Golf|Geo Cache|Other"");tsubcat_lists[14] = _(""- Please choose -|Friend|Other Cool Place"");tsubcat_lists[15] = _(""- Please choose -|Traditional|Multi|Virtual|Letterbox Hybrid|Event|Unknown|Project Ape|Webcam|Cache In Trash Out|Earthcache|Mega-Event|GPS Adventures|Wherigo|Other"");t tvbox = lookup_widget(widget, ""vbox28"");tlist_store = create_combobox_list_store(subcat_lists[choice]);tttif((!combobox_subcat || new_dialog ) && choice)t{ttcombobox_subcat = gtk_combo_box_new_with_model (GTK_TREE_MODEL(list_store));ttgtk_widget_show (combobox_subcat);ttgtk_box_pack_start (GTK_BOX (vbox),combobox_subcat, FALSE, TRUE, 0);ttrenderer = gtk_cell_renderer_text_new();ttgtk_cell_layout_pack_start(GTK_CELL_LAYOUT(combobox_subcat), renderer, TRUE);ttgtk_cell_layout_set_attributes(GTK_CELL_LAYOUT(combobox_subcat), renderer, ""text"", 0, NULL);ttg_signal_connect ((gpointer) combobox_subcat, ""changed"",tttttG_CALLBACK (on_combobox_subcat_changed),tttttNULL);ttgtk_combo_box_set_active(GTK_COMBO_BOX(combobox_subcat), 0);ttprintf(""reorder"");ttgtk_box_reorder_child(GTK_BOX(vbox),combobox_subcat,6);ttnew_dialog = FALSE;t}telse if (choice)t{ttgtk_combo_box_set_model(GTK_COMBO_BOX(combobox_subcat), GTK_TREE_MODEL(list_store));ttgtk_combo_box_set_active(GTK_COMBO_BOX(combobox_subcat), 0);t}t}",2,"cwe119,cwe120"
"__ecereMethod___ecereNameSpace__ecere__sys__BufferedFile_Write(struct __ecereNameSpace__ecere__com__Instance * this, unsigned char * buffer, unsigned int size, unsigned int count){unsigned int __simpleStruct0, __simpleStruct1;struct __ecereNameSpace__ecere__sys__BufferedFile * __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile = (struct __ecereNameSpace__ecere__sys__BufferedFile *)(this ? (((char *)this) + 40) : 0);unsigned int result;unsigned int numBytes;unsigned int bytesToBuffer;unsigned int missing;((unsigned int (*)(struct __ecereNameSpace__ecere__com__Instance *, int pos, int mode))__extension__ ({struct __ecereNameSpace__ecere__com__Instance * __internal_ClassInst = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->handle;__internal_ClassInst ? __internal_ClassInst->_vTbl : __ecereClass___ecereNameSpace__ecere__sys__File->_vTbl;})[__ecereVMethodID___ecereNameSpace__ecere__sys__File_Seek])(__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->handle, __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->pos, 0);result = ((int (*)(struct __ecereNameSpace__ecere__com__Instance *, void *  buffer, unsigned int size, unsigned int count))__extension__ ({struct __ecereNameSpace__ecere__com__Instance * __internal_ClassInst = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->handle;__internal_ClassInst ? __internal_ClassInst->_vTbl : __ecereClass___ecereNameSpace__ecere__sys__File->_vTbl;})[__ecereVMethodID___ecereNameSpace__ecere__sys__File_Write])(__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->handle, buffer, size, count);numBytes = result * size;bytesToBuffer = (__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferSize > __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferPos) ? (__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferSize - __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferPos) : 0;missing = numBytes - bytesToBuffer;__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->pos += numBytes;__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->fileSize = (__simpleStruct0 = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->fileSize, __simpleStruct1 = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->pos, (__simpleStruct0 > __simpleStruct1) ? __simpleStruct0 : __simpleStruct1);if(bytesToBuffer < numBytes && __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferCount >= __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferPos && numBytes < __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferSize && missing < __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferPos){memcpy(__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->buffer, __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->buffer + missing, __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferPos - missing);__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferPos -= missing;__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferCount -= missing;bytesToBuffer += missing;}if(bytesToBuffer >= numBytes){unsigned int __simpleStruct0, __simpleStruct1;bytesToBuffer = numBytes;memcpy(__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->buffer + __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferPos, buffer, bytesToBuffer);__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferPos += bytesToBuffer;__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferCount = (__simpleStruct0 = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferCount, __simpleStruct1 = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferPos, (__simpleStruct0 > __simpleStruct1) ? __simpleStruct0 : __simpleStruct1);}else{unsigned int __simpleStruct0;bytesToBuffer = (__simpleStruct0 = __ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferSize, (numBytes < __simpleStruct0) ? numBytes : __simpleStruct0);memcpy(__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->buffer, buffer + numBytes - bytesToBuffer, bytesToBuffer);__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferPos = bytesToBuffer;__ecerePointer___ecereNameSpace__ecere__sys__BufferedFile->bufferCount = bytesToBuffer;}return result;}",2,"cwe120,cwe476"
"ScreenSave( ClientData cl,Tcl_Interp *interp,int argc,char **argv ){   unsigned char *buffer;   FILE *fp;   char fname[256];   int  i,nx,ny,ox,oy,viewp[4];   if ( argc < 2 ) {      strcpy( fname, ""elmerpost.ppm"" );   } else {      strncpy( fname,argv[1], 256 );   }   if ( !(fp = fopen( fname, ""wb"" ) ) ) {#if defined(WIN32) || defined(win32)      sprintf( interp->result,        ""screensave: can't open [%s] for writing!"", argv[1] );#else      sprintf( interp->result,         ""screensave: can't open [%s] for writing:%s"",               argv[1], strerror(errno) );#endif      return TCL_ERROR;   }   glGetIntegerv( GL_VIEWPORT, viewp );   ox = viewp[0];   oy = viewp[1];   nx = viewp[2]+1;   ny = viewp[3]+1;   if ( !(buffer = (unsigned char *)malloc( nx*ny*3 ) ) )   {      fclose( fp );#if defined(WIN32) || defined(win32)      sprintf( interp->result,            ""screensave: can't allocate enough memory!"" );#else      sprintf( interp->result,        ""screensave: can't allocate enough memory:%s"",            strerror(errno) );#endif      return TCL_ERROR;   }   fprintf( stderr, ""screensave: reading pixels..."" );   glReadBuffer( GL_FRONT );   glReadPixels( ox,oy,nx,ny, GL_RGB, GL_UNSIGNED_BYTE, buffer );   fprintf( stderr, ""writing file [%s]..."", fname  );   fprintf( fp, ""P6%d %d255"", nx, ny );   for( i=ny-1; i>=0; i-- )      if ( fwrite( &buffer[i*nx*3], 1, 3*nx, fp  ) != 3*nx ) {         fclose( fp );         free( buffer );#if defined(WIN32) || defined(win32)         sprintf( interp->result,           ""screensave: error writing to [%s]!"", argv[1] );#else         sprintf( interp->result,           ""screensave: error writing to [%s]:%s"",               argv[1], strerror(errno) );#endif         return TCL_ERROR;      }   fclose( fp );   free( buffer );   fprintf( stderr, ""done...[ok]"" );   return TCL_OK;}",3,"cwe119,cwe120,cweother"
"proc_getent(const char *ent){tFILE *fp;tchar *proc, *p, *value = NULL;tsize_t i;tif (!exists(""/proc/cmdline""))ttreturn NULL;tif (!(fp = fopen(""/proc/cmdline"", ""r""))) {tteerror(""failed to open `/proc/cmdline': %s"", strerror(errno));ttreturn NULL;t}tproc = NULL;ti = 0;tif (rc_getline(&proc, &i, fp) == -1 || proc == NULL)tteerror(""rc_getline: %s"", strerror(errno));tif (*proc && (p = strstr(proc, ent))) {tti = p - proc;ttif (i == '0' || proc[i - 1] == ' ') {tttp += strlen(ent);tttif (*p == '=')ttttp++;tttvalue = xstrdup(strsep(&p, "" ""));tt}t} elsetterrno = ENOENT;tfclose(fp);tfree(proc);treturn value;}",2,"cwe469,cwe476"
"set_power_restore_policy (ipmi_chassis_state_data_t *state_data){  fiid_obj_t obj_cmd_rs = NULL;  uint64_t val = 0;  int rv = -1;  struct ipmi_chassis_arguments *args;  args = state_data->prog_data->args;  if (!(obj_cmd_rs = fiid_obj_create (tmpl_cmd_set_power_restore_policy_rs)))    {      pstdout_fprintf (state_data->pstate,                       stderr,                       ""fiid_obj_create: %s"",                       strerror (errno));      goto cleanup;    }  if (ipmi_cmd_set_power_restore_policy (state_data->ipmi_ctx,                                         args->set_power_restore_policy_arg,                                         obj_cmd_rs) < 0)    {      pstdout_fprintf (state_data->pstate,                       stderr,                       ""ipmi_cmd_set_power_restore_policy: %s"",                       ipmi_ctx_errormsg (state_data->ipmi_ctx));      goto cleanup;    }  if (args->set_power_restore_policy_arg == IPMI_POWER_RESTORE_POLICY_NO_CHANGE)    {      char policy_supported[100];      memset (policy_supported, 0, sizeof (policy_supported));      if (FIID_OBJ_GET (obj_cmd_rs, ""powered_off_after_ac_mains_returns"", &val) < 0)        {          pstdout_fprintf (state_data->pstate,                           stderr,                           ""FIID_OBJ_GET: 'powered_off_after_ac_mains_returns': %s"",                           fiid_obj_errormsg (obj_cmd_rs));          goto cleanup;        }      if (val)        strcat (policy_supported, ""always-off "");      if (FIID_OBJ_GET (obj_cmd_rs, ""always_powering_up_after_ac_mains_returns"", &val) < 0)        {          pstdout_fprintf (state_data->pstate,                           stderr,                           ""FIID_OBJ_GET: 'always_powering_up_after_ac_mains_returns': %s"",                           fiid_obj_errormsg (obj_cmd_rs));          goto cleanup;        }      if (val)        strcat (policy_supported, ""always-on "");      if (FIID_OBJ_GET (obj_cmd_rs, ""restoring_power_to_state_when_ac_mains_was_lost"", &val) < 0)        {          pstdout_fprintf (state_data->pstate,                           stderr,                           ""FIID_OBJ_GET: 'restoring_power_to_state_when_ac_mains_was_lost': %s"",                           fiid_obj_errormsg (obj_cmd_rs));          goto cleanup;        }      if (val)        strcat (policy_supported, ""Restore"");      pstdout_printf (state_data->pstate,                      ""Policies supported          : %s"",                      policy_supported);    }  rv = 0; cleanup:  fiid_obj_destroy (obj_cmd_rs);  return (rv);}",2,"cwe119,cwe120"
"my_ber_scanf_value(BerElement *ber, Slapi_Value **value, PRBool *deleted){tstruct berval *attrval = NULL;tber_len_t len = -1;tber_tag_t tag;tCSN *csn = NULL;tchar csnstring[CSN_STRSIZE + 1];tCSNType csntype;tchar *lasti;tPR_ASSERT(ber && value && deleted);tif (NULL == ber && NULL == value)t{ttslapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name, ""my_ber_scanf_value BAD 1"");ttgoto loser;t}t*value = NULL;t tif (ber_scanf(ber, ""{O"", &attrval) == LBER_ERROR)t{ttslapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name, ""my_ber_scanf_value BAD 2"");ttgoto loser;t}t tif ((*value = slapi_value_new_berval(attrval)) == NULL)t{ttslapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name, ""my_ber_scanf_value BAD 3"");ttgoto loser;t}         if (ber_peek_tag(ber, &len) == LBER_BOOLEAN)    {        if (ber_scanf(ber, ""b"", deleted) == LBER_ERROR)tt{tttslapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name, ""my_ber_scanf_value BAD 4"");tttgoto loser;tt}    }            else      {        *deleted = PR_FALSE;    }t     for (tag = ber_first_element(ber, &len, &lasti);tttag != LBER_ERROR && tag != LBER_END_OF_SEQORSET;tttag = ber_next_element(ber, &len, lasti))t{ttber_int_t csntype_tmp;tt ttlen = CSN_STRSIZE;ttif (ber_scanf(ber, ""{es}"", &csntype_tmp, csnstring, &len) == LBER_ERROR)tt{tttslapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name, ""my_ber_scanf_value BAD 7 - bval is %s"", attrval->bv_val);tttgoto loser;tt}ttswitch (csntype_tmp)tt{ttcase CSN_TYPE_VALUE_UPDATED_ON_WIRE:tttcsntype = CSN_TYPE_VALUE_UPDATED;tttbreak;ttcase CSN_TYPE_VALUE_DELETED_ON_WIRE:tttcsntype = CSN_TYPE_VALUE_DELETED;tttbreak;ttcase CSN_TYPE_VALUE_DISTINGUISHED_ON_WIRE:tttcsntype = CSN_TYPE_VALUE_DISTINGUISHED;tttbreak;ttdefault:tttslapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name, ""Error: preposterous CSN type ""tttt""%d received during total update."", csntype_tmp);tttgoto loser;tt}ttcsn = csn_new_by_string(csnstring);ttif (csn == NULL)tt{tttslapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name, ""my_ber_scanf_value BAD 8"");tttgoto loser;tt}ttvalue_add_csn(*value, csntype, csn);        csn_free (&csn);t}tif (ber_scanf(ber, ""}"") == LBER_ERROR)  t{ttslapi_log_error(SLAPI_LOG_FATAL, repl_plugin_name, ""my_ber_scanf_value BAD 10"");ttgoto loser;t}t    if (attrval)        ber_bvfree(attrval); treturn 0;loser:t tif (csn)        csn_free (&csn);    if (attrval)        ber_bvfree(attrval);     if (value)    {        slapi_value_free (value);    }   treturn -1;}",3,"cwe119,cwe120,cwe469"
"launch_crack(const char *dict_filename, const char *zip_filename){    struct zc_pwdict *pwdict;    struct zc_validation_data vdata[VDATA_ALLOC];    size_t vdata_size;    char pw[PW_BUF_LEN];    int err;    vdata_size = fill_validation_data(ctx, zip_filename,                                      vdata, VDATA_ALLOC);    if (vdata_size == 0)        return EXIT_FAILURE;    err = zc_pwdict_new_from_filename(ctx, dict_filename, &pwdict);    if (err != 0)        return EXIT_FAILURE;    err = zc_pwdict_open(pwdict);    if (err != 0) {        zc_pwdict_unref(pwdict);        return EXIT_FAILURE;    }    do {        err = zc_pwdict_read_one_pw(pwdict, pw, PW_BUF_LEN);        if (err == 0 && zc_crk_test_one_pw(pw, vdata, vdata_size)) {            if (zc_file_test_password(zip_filename, pw)) {                printf(""Password is: %s"", pw);                break;            }        }    } while (err == 0);    zc_pwdict_close(pwdict);    zc_pwdict_unref(pwdict);    return 0;}",2,"cwe119,cwe120"
"""ldns_str2rdf_nsec3_salt(ldns_rdf **rd, const char *salt_str){tuint8_t salt_length;tint c;tint salt_length_str;tuint8_t *salt;tuint8_t *data;tif(rd == NULL) {ttreturn LDNS_STATUS_NULL;t}tsalt_length_str = (int)strlen(salt_str);tif (salt_length_str == 1 && salt_str[0] == '-') {ttsalt_length_str = 0;t} else if (salt_length_str % 2 != 0) {ttreturn LDNS_STATUS_INVALID_HEX;t}tif (salt_length_str > 512) {ttreturn LDNS_STATUS_INVALID_HEX;t}tsalt = LDNS_XMALLOC(uint8_t, salt_length_str / 2);        if(!salt) {                return LDNS_STATUS_MEM_ERR;        }tfor (c = 0; c < salt_length_str; c += 2) {ttif (isxdigit((int) salt_str[c]) && isxdigit((int) salt_str[c+1])) {tttsalt[c/2] = (uint8_t) ldns_hexdigit_to_int(salt_str[c]) * 16 +ttttt  ldns_hexdigit_to_int(salt_str[c+1]);tt} else {tttLDNS_FREE(salt);tttreturn LDNS_STATUS_INVALID_HEX;tt}t}tsalt_length = (uint8_t) (salt_length_str / 2);tdata = LDNS_XMALLOC(uint8_t, 1 + salt_length);        if(!data) {t        LDNS_FREE(salt);                return LDNS_STATUS_MEM_ERR;        }tdata[0] = salt_length;tmemcpy(&data[1], salt, salt_length);t*rd = ldns_rdf_new_frm_data(LDNS_RDF_TYPE_NSEC3_SALT, 1 + salt_length, data);tLDNS_FREE(data);tLDNS_FREE(salt);treturn *rd?LDNS_STATUS_OK:LDNS_STATUS_MEM_ERR;}""",2,"cwe120,cweother"
"send_commands(FILE *stream, char *cmds, int from){  char *p = cmds;  while (*p)  {    while(*p && *p != ';')    {       if (*p == '$')       {          char snum[256];          sprintf(snum, ""%i"", from);          fputs(snum, stream);       }       else          fputc(*p, stream);       p++;    }    fputc('r', stream);    if (*p == ';')    {      wait_prompt(stream);      p++;    }  }}",2,"cwe119,cwe120"
"qp_create_one(ompi_common_ofacm_base_local_connection_context_t *context, int qp){    struct ibv_qp *my_qp;    struct ibv_qp_init_attr init_attr;    struct ibv_qp_attr attr;    size_t req_inline = context->init_attr[qp].cap.max_inline_data;    uint32_t init_mask = 0;         memcpy(&init_attr, &context->init_attr[qp], sizeof(init_attr));    my_qp = ibv_create_qp(context->ib_pd, &init_attr);    if (NULL == my_qp) {        OFACM_ERROR((""error creating qp errno says %s"", strerror(errno)));        return OMPI_ERROR;    }    context->qps[qp].lcl_qp = my_qp;    if (init_attr.cap.max_inline_data < req_inline) {        context->qps[qp].ib_inline_max = init_attr.cap.max_inline_data;        opal_show_help(""help-mpi-common-ofacm-cpc-base.txt"",                       ""inline truncated"", true, ompi_process_info.nodename,                       req_inline, init_attr.cap.max_inline_data);    } else {        context->qps[qp].ib_inline_max = req_inline;    }         memcpy(&attr, &context->attr[qp], sizeof(attr));    attr.qp_state        = IBV_QPS_INIT;    attr.qp_access_flags = IBV_ACCESS_REMOTE_WRITE | IBV_ACCESS_REMOTE_READ;    init_mask = IBV_QP_STATE |                IBV_QP_PKEY_INDEX |                IBV_QP_PORT |                IBV_QP_ACCESS_FLAGS;         if (NULL != context->custom_init_attr_mask) {        init_mask |= context->custom_init_attr_mask[qp];    }    if (ibv_modify_qp(context->qps[qp].lcl_qp,                      &attr, init_mask)) {        OFACM_ERROR((""Error modifying qp to INIT errno says %s"", strerror(errno)));        return OMPI_ERROR;    }         context->qps[qp].lcl_psn = lrand48() & 0xffffff;    return OMPI_SUCCESS;}",2,"cwe120,cweother"
"FcGetDefaultLang (void){    static chartlang_local [128] = {0};    char        *ctype;    char        *territory;    char        *after;    int         lang_len, territory_len;    if (lang_local [0])treturn (FcChar8 *) lang_local;    ctype = setlocale (LC_CTYPE, NULL);         if (!ctype || !strcmp (ctype, ""C""))    {tctype = getenv (""LC_ALL"");tif (!ctype)t{t    ctype = getenv (""LC_CTYPE"");t    if (!ctype)ttctype = getenv (""LANG"");t}    }         if (ctype && *ctype != '0')    {tterritory = strchr (ctype, '_');tif (territory)t{t    lang_len = territory - ctype;t    territory = territory + 1;t    after = strchr (territory, '.');t    if (!after)t    {ttafter = strchr (territory, '@');ttif (!after)tt    after = territory + strlen (territory);t    }t    territory_len = after - territory;t    if (lang_len + 1 + territory_len + 1 <= (int) sizeof (lang_local))t    {ttstrncpy (lang_local, ctype, lang_len);ttlang_local[lang_len] = '-';ttstrncpy (lang_local + lang_len + 1, territory, territory_len);ttlang_local[lang_len + 1 + territory_len] = '0';t    }t}telset{t    after = strchr (ctype, '.');t    if (!after)t    {ttafter = strchr (ctype, '@');ttif (!after)tt    after = ctype + strlen (ctype);t    }t    lang_len = after - ctype;t    if (lang_len + 1 <= (int) sizeof (lang_local))t    {ttstrncpy (lang_local, ctype, lang_len);ttlang_local[lang_len] = '0';t    }t}    }         if (!lang_local [0])tstrcpy (lang_local, ""en"");    return (FcChar8 *) lang_local;}",4,"cwe119,cwe120,cwe476,cweother"
"handle_tunnel_input (Tunnel *tunnel, int fd, int events){  unsigned char buf[10240];  ssize_t n, m;  if (events & POLLIN)    {      n = tunnel_read (tunnel, buf, sizeof buf);      if (n <= 0)t{log_annoying (""handle_tunnel_input: tunnel_read() = %d"", n);t  if (n == -1 && errno != EAGAIN)t    log_error (""handle_tunnel_input: tunnel_read() error: %s"",tt       strerror (errno));t  return n;t}#ifdef DEBUG_MODE      log_annoying (""read %d bytes from tunnel:"", n);      if (debug_level >= 5)tdump_buf (debug_file, buf, (size_t)n);#endif             m = write_all (fd ? fd : 1, buf, (size_t)n);      log_annoying (""write_all (%d, %p, %d) = %d"", fd ? fd : 1, buf, n, m);      return m;    }  else if (events & POLLHUP)    log_error (""handle_device_input: POLLHUP"");  else if (events & POLLERR)    log_error (""handle_device_input: PULLERR"");  else if (events & POLLNVAL)    log_error (""handle_device_input: PULLINVAL"");  else    log_error (""handle_device_input: none of the above"");  errno = EIO;  return -1;}",2,"cwe119,cwe120"
"_gsasl_digest_md5_server_start (Gsasl_session * sctx, void **mech_data){  _Gsasl_digest_md5_server_state *state;  char nonce[NONCE_ENTROPY_BYTES];  char *p;  int rc;  rc = gsasl_nonce (nonce, NONCE_ENTROPY_BYTES);  if (rc != GSASL_OK)    return rc;  rc = gsasl_base64_to (nonce, NONCE_ENTROPY_BYTES, &p, NULL);  if (rc != GSASL_OK)    return rc;  state = calloc (1, sizeof (*state));  if (state == NULL)    {      free (p);      return GSASL_MALLOC_ERROR;    }  state->challenge.qops = DIGEST_MD5_QOP_AUTH;  state->challenge.ciphers = 0;  state->challenge.nonce = p;  state->challenge.utf8 = 1;  *mech_data = state;  return GSASL_OK;}",2,"cwe119,cwe120"
"starter_dbg(debug_t group, level_t level, char *fmt, ...){tchar buffer[8192];tchar *current = buffer, *next;tva_list args;tif (level <= current_loglevel)t{ttif (log_to_stderr)tt{tttva_start(args, fmt);tttvfprintf(stderr, fmt, args);tttva_end(args);tttfprintf(stderr, """");tt}ttif (log_to_syslog)tt{ttt tttva_start(args, fmt);tttvsnprintf(buffer, sizeof(buffer), fmt, args);tttva_end(args);ttt tttwhile (current)ttt{ttttnext = strchr(current, '');ttttif (next)tttt{ttttt*(next++) = '0';tttt}ttttsyslog(LOG_INFO, ""%s"", current);ttttcurrent = next;ttt}tt}t}}",3,"cwe119,cwe120,cweother"
"sc92031_ethtool_nway_reset(struct net_device *dev){tint err = 0;tstruct sc92031_priv *priv = netdev_priv(dev);tvoid __iomem *port_base = priv->port_base;tu16 bmcr;tspin_lock_bh(&priv->lock);tbmcr = _sc92031_mii_read(port_base, MII_BMCR);tif (!(bmcr & BMCR_ANENABLE)) {tterr = -EINVAL;ttgoto out;t}t_sc92031_mii_write(port_base, MII_BMCR, bmcr | BMCR_ANRESTART);out:t_sc92031_mii_scan(port_base);tmmiowb();tspin_unlock_bh(&priv->lock);treturn err;}",2,"cwe119,cwe120"
"dump_template_parms (tree info, int primary, int flags){  tree args = info ? TI_ARGS (info) : NULL_TREE;  if (primary && flags & TFF_TEMPLATE_NAME)    return;  flags &= ~(TFF_CLASS_KEY_OR_ENUM | TFF_TEMPLATE_NAME);  pp_template_argument_list_start (cxx_pp);     if (args && !primary)    {      int len, ix;      if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args))targs = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);            len = TREE_VEC_LENGTH (args);      for (ix = 0; ix != len; ix++)        {          tree arg = TREE_VEC_ELT (args, ix);          if (ix)            pp_separate_with_comma (cxx_pp);                    if (!arg)            pp_identifier (cxx_pp, ""<template parameter error>"");          else            dump_template_argument (arg, flags);        }    }  else if (primary)    {      tree tpl = TI_TEMPLATE (info);      tree parms = DECL_TEMPLATE_PARMS (tpl);      int len, ix;      parms = TREE_CODE (parms) == TREE_LIST ? TREE_VALUE (parms) : NULL_TREE;      len = parms ? TREE_VEC_LENGTH (parms) : 0;      for (ix = 0; ix != len; ix++)        {          tree parm = TREE_VALUE (TREE_VEC_ELT (parms, ix));          if (ix)            pp_separate_with_comma (cxx_pp);          dump_decl (parm, flags & ~TFF_DECL_SPECIFIERS);        }    }  pp_template_argument_list_end (cxx_pp);}",2,"cwe476,cweother"
"sip_filter_stars_in_field(const sip_t* sip, const tan_t* tan,ttttttt   const double* xyz, const double* radec,ttttttt   int N, double** p_xy, int* inds, int* p_Ngood) {tint i, Ngood;tint W, H;tdouble* xy = NULL;tanbool allocd = FALSE;ttassert(sip || tan);tassert(xyz || radec);tassert(p_Ngood);tNgood = 0;tif (!inds) {ttinds = malloc(N * sizeof(int));ttallocd = TRUE;t}tif (p_xy)ttxy = malloc(N * 2 * sizeof(double));tif (sip) {ttW = sip->wcstan.imagew;ttH = sip->wcstan.imageh;t} else {ttW = tan->imagew;ttH = tan->imageh;t}tfor (i=0; i<N; i++) {ttdouble x, y;ttif (xyz) {tttif (sip) {ttttif (!sip_xyzarr2pixelxy(sip, xyz + i*3, &x, &y))tttttcontinue;ttt} else {ttttif (!tan_xyzarr2pixelxy(tan, xyz + i*3, &x, &y))tttttcontinue;ttt}tt} else {tttif (sip) {ttttif (!sip_radec2pixelxy(sip, radec[i*2], radec[i*2+1], &x, &y))tttttcontinue;ttt} else {ttttif (!tan_radec2pixelxy(tan, radec[i*2], radec[i*2+1], &x, &y))tttttcontinue;ttt}tt}tt ttif ((x < 0) || (y < 0) || (x >= W) || (y >= H))tttcontinue;ttinds[Ngood] = i;ttif (xy) {tttxy[Ngood * 2 + 0] = x;tttxy[Ngood * 2 + 1] = y;tt}ttNgood++;t}tif (allocd)ttinds = realloc(inds, Ngood * sizeof(int));tif (xy)ttxy = realloc(xy, Ngood * 2 * sizeof(double));tif (p_xy)tt*p_xy = xy;t*p_Ngood = Ngood;ttreturn inds;}",2,"cwe120,cweother"
"""gfs_output_solid_force_read (GtsObject ** o, GtsFile * fp){  GfsOutputSolidForce * l = GFS_OUTPUT_SOLID_FORCE (*o);  (* GTS_OBJECT_CLASS (gfs_output_solid_force_class ())->parent_class->read) (o, fp);  if (fp->type == GTS_ERROR)    return;  if (fp->type != '') {    if (!l->weight)      l->weight = gfs_function_new (gfs_function_class (), 0.);    gfs_function_read (l->weight, gfs_object_simulation (l), fp);  }}""",2,"cwe120,cweother"
"writerc (){  FILE *fp;  char *pcomm[4] = { ""lpr-P"", ""lp-d"", ""kprinter -d"",""gtklp -d""};  char *ori[2] = { ""portrait"", ""landscape"" };  char *epso[4] = { ""None"",""EPSI"",""TIFFm"",""TIFFc"" };  gchar *filename;  filename = g_malloc (PATH_MAX + 1);  filename =    strncat (strncpy (filename, g_get_home_dir (), PATH_MAX), ""/.chemtoolrc"",t     PATH_MAX);  fp = fopen (filename, ""w"");  if (!fp)    {      g_free (filename);      return 1;    }  else    {      fprintf (fp, ""datadir %s"", datadir);      fprintf (fp, ""extension %s"", datamask);      fprintf (fp, ""papersize %s"", paper[papersize]);      fprintf (fp, ""orientation %s"", ori[orient]);      fprintf (fp, ""printscale %f"", printscale);      fprintf (fp, ""printcommand %s"", pcomm[printcmd]);      fprintf (fp, ""printer %s"", queuename);      fprintf (fp, ""bondlength %6.4f"", bondlen_mm);      fprintf (fp, ""double_separation %d"", db_dist);      fprintf (fp, ""epsoption %s"", epso[epsoption]);      fprintf (fp, ""whiteout %d"", use_whiteout);      fprintf (fp, ""intlchars %d"", use_intlchars);      fprintf (fp, ""background (%d,%d,%d)"", bgred,bggreen,bgblue);      fclose (fp);      g_free (filename);      return 0;    }}",3,"cwe119,cwe120,cweother"
"locate_haproxy(char *buffer, size_t buffer_size){tchar *end = NULL;tint len;tlen = readlink(""/proc/self/exe"", buffer, buffer_size - 1);tif (len == -1)ttgoto fail;tbuffer[len] = 0;tend = strrchr(buffer, '/');tif (end == NULL)ttgoto fail;tif (strcmp(end + strlen(end) - 16, ""-systemd-wrapper"") == 0) {ttend[strlen(end) - 16] = '0';ttreturn;t}tend[1] = '0';tstrncpy(end + 1, ""haproxy"", buffer + buffer_size - (end + 1));tbuffer[buffer_size - 1] = '0';treturn; fail:tstrncpy(buffer, ""/usr/sbin/haproxy"", buffer_size);tbuffer[buffer_size - 1] = '0';treturn;}",2,"cwe120,cweother"
"rmdir_path(struct autofs_point *ap, const char *path, dev_t dev){tint len = strlen(path);tchar buf[PATH_MAX];tchar *cp;tint first = 1;tstruct stat st;tstruct statfs fs;tstrcpy(buf, path);tcp = buf + len;tdo {tt*cp = '0';tt ttmemset(&st, 0, sizeof(st));ttif (lstat(buf, &st) != 0) {tttcrit(ap->logopt, ""lstat of %s failed"", buf);tttreturn -1;tt}tt ttif (st.st_dev != dev)tttreturn 0;ttif (statfs(buf, &fs) != 0) {ttterror(ap->logopt, ""could not stat fs of %s"", buf);tttreturn -1;tt}ttif (fs.f_type != (__SWORD_TYPE) AUTOFS_SUPER_MAGIC) {tttcrit(ap->logopt, ""attempt to remove directory from a ""ttt     ""non-autofs filesystem!"");tttcrit(ap->logopt,ttt     ""requestor dev == %llu, ""%s"" owner dev == %llu"",ttt     dev, buf, st.st_dev);tttreturn -1;tt}ttt     tt ttif (rmdir(buf) == -1) {tttif (first && errno == ENOTDIR) {tttt ttttif (S_ISLNK(st.st_mode)) {tttttif (unlink(buf) == -1)ttttttreturn -1;tttt} else {tttttcrit(ap->logopt,ttttt   ""file ""%s"" is neither a directory""ttttt   "" nor a symbolic link. mode %d"",ttttt   buf, st.st_mode);tttttreturn -1;tttt}ttt}ttt tttreturn -1;tt}ttfirst = 0;t} while ((cp = strrchr(buf, '/')) != NULL && cp != buf);treturn 0;}",2,"cwe119,cwe120"
"fetch_indices(struct walker *walker, struct alt_base *repo){tunsigned char sha1[20];tchar *url;tstruct strbuf buffer = STRBUF_INIT;tchar *data;tint i = 0;tint ret = 0;tstruct active_request_slot *slot;tstruct slot_results results;tif (repo->got_indices)ttreturn 0;tif (walker->get_verbosely)ttfprintf(stderr, ""Getting pack list for %s"", repo->base);turl = xmalloc(strlen(repo->base) + 21);tsprintf(url, ""%s/objects/info/packs"", repo->base);tslot = get_active_slot();tslot->results = &results;tcurl_easy_setopt(slot->curl, CURLOPT_FILE, &buffer);tcurl_easy_setopt(slot->curl, CURLOPT_WRITEFUNCTION, fwrite_buffer);tcurl_easy_setopt(slot->curl, CURLOPT_URL, url);tcurl_easy_setopt(slot->curl, CURLOPT_HTTPHEADER, NULL);tif (start_active_slot(slot)) {ttrun_active_slot(slot);ttif (results.curl_result != CURLE_OK) {tttif (missing_target(&results)) {ttttrepo->got_indices = 1;ttttgoto cleanup;ttt} else {ttttrepo->got_indices = 0;ttttret = error(""%s"", curl_errorstr);ttttgoto cleanup;ttt}tt}t} else {ttrepo->got_indices = 0;ttret = error(""Unable to start request"");ttgoto cleanup;t}tdata = buffer.buf;twhile (i < buffer.len) {ttswitch (data[i]) {ttcase 'P':ttti++;tttif (i + 52 <= buffer.len &&ttt    !prefixcmp(data + i, "" pack-"") &&ttt    !prefixcmp(data + i + 46, "".pack"")) {ttttget_sha1_hex(data + i + 6, sha1);ttttsetup_index(walker, repo, sha1);tttti += 51;ttttbreak;ttt}ttdefault:tttwhile (i < buffer.len && data[i] != '')tttti++;tt}tti++;t}trepo->got_indices = 1;cleanup:tstrbuf_release(&buffer);tfree(url);treturn ret;}",2,"cwe119,cwe120"
"list_quote_commands(struct Client *source_p){tint i;tint j = 0;tconst char *names[4];tsendto_one_notice(source_p, "":Available QUOTE SET commands:"");tnames[0] = names[1] = names[2] = names[3] = """";tfor (i = 0; set_cmd_table[i].handler; i++)t{ttnames[j++] = set_cmd_table[i].name;ttif(j > 3)tt{tttsendto_one_notice(source_p, "":%s %s %s %s"",tttt   names[0], names[1], names[2], names[3]);tttj = 0;tttnames[0] = names[1] = names[2] = names[3] = """";tt}t}tif(j)ttsendto_one_notice(source_p, "":%s %s %s %s"",ttt   names[0], names[1], names[2], names[3]);}",2,"cwe119,cwe120"
"logc_format_variable(const char *name, sb_trie_t *global, sb_trie_t *local,    sb_slist_t *foreach_var){         const char *value = blogc_get_variable(name, global, local);    if (value != NULL)        return sb_strdup(value);         if (0 == strcmp(name, ""FOREACH_ITEM"")) {        if (foreach_var != NULL && foreach_var->data != NULL) {            return sb_strdup(foreach_var->data);        }        return NULL;    }    char *var = sb_strdup(name);    size_t i;    size_t last = strlen(var);    long int len = -1;         for (i = last - 1; i > 0 && var[i] >= '0' && var[i] <= '9'; i--);    if (var[i] == '_' && (i + 1) < last) {                    len = strtol(var + i + 1, NULL, 10);        if (errno != 0) {            fprintf(stderr, ""warning: invalid variable size for '%s' (%s), ""                ""ignoring."", var, strerror(errno));            len = -1;        }        else {            var[i] = '0';        }    }    bool must_format = false;    if (sb_str_ends_with(var, ""_FORMATTED"")) {        var[strlen(var) - 10] = '0';        must_format = true;    }    if ((0 == strcmp(var, ""FOREACH_ITEM"")) &&        (foreach_var != NULL && foreach_var->data != NULL))        value = foreach_var->data;    else        value = blogc_get_variable(var, global, local);    free(var);    if (value == NULL)        return NULL;    char *rv = NULL;    if (must_format) {        if (sb_str_starts_with(name, ""DATE_"")) {            rv = blogc_format_date(value, global, local);        }        else {            fprintf(stderr, ""warning: no formatter found for '%s', ""                ""ignoring."", var);            rv = sb_strdup(value);        }    }    else {        rv = sb_strdup(value);    }    if (len > 0) {        char *tmp = sb_strndup(rv, len);        free(rv);        rv = tmp;    }    return rv;}",2,"cwe469,cweother"
"__ide_port_unregister_devices(ide_hwif_t *hwif){tide_drive_t *drive;tint i;tide_port_for_each_present_dev(i, drive, hwif) {ttdevice_unregister(&drive->gendev);ttwait_for_completion(&drive->gendev_rel_comp);t}}",2,"cwe476,cweother"
"shared_getaddr(int id, char **address) { int i;   char segname[10];   if (NULL == shared_gt) return(SHARED_NOTINIT);           if (NULL == shared_lt) return(SHARED_NOTINIT);            strcpy(segname,""h"");   sprintf(segname+1,""%d"", id);    if (smem_open(segname,0,&i)) return(SHARED_BADARG);    *address = ((char *)(((DAL_SHM_SEGHEAD *)(shared_lt[i].p + 1)) + 1));     return(SHARED_OK); }",2,"cwe119,cwe120"
"convdays( char *cop ){tchar *stra;tchar alt[8];tint i, ish, fim, iw;tiw = weekn;tif ( iw == 6)ttish = 0;telsettish = 1 + iw;tfim = 7 - ish;t tfor(i=0; i < fim; i++) {ttalt[i] = cop[i+ish];t}tif ( ish > 0 ) {ttfor(i=0; i < ish; i++) {tttalt[i+fim] = cop[i];tt}t}talt[7] = 0;  ttstra = strdup( alt );treturn stra;}",3,"cwe119,cwe120,cweother"
"sshv2_send_command (gftp_request * request, char type, char *command,                     size_t len){  char buf[34000];  guint32 clen;  int ret;  if (len > 33995)    {      request->logging_function (gftp_logging_error, request,                             _(""Error: Message size %d too big""), len);      gftp_disconnect (request);      return (GFTP_EFATAL);    }  clen = htonl (len + 1);  memcpy (buf, &clen, 4);  buf[4] = type;  memcpy (&buf[5], command, len);  buf[len + 5] = '0';#ifdef DEBUG  printf (""rSending to FD %d: "", request->datafd);  for (clen=0; clen<len + 5; clen++)    printf (""%x "", buf[clen] & 0xff);  printf ("""");#endif  sshv2_log_command (request, gftp_logging_send, type, buf + 5, len);  if ((ret = gftp_fd_write (request, buf, len + 5, request->datafd)) < 0)    return (ret);  return (0);}",2,"cwe119,cwe120"
"""ajStrIsCharsetCaseC(const AjPStr str, const char* txt){    char filter[256] = {'0'};tt/* should make all zero */    const char* cp;    const char* cq = txt;    if(!str)treturn ajFalse;    if(!str->Len)treturn ajFalse;    while (*cq)    {        filter[tolower((int)*cq)] = 1;        filter[toupper((int)*cq++)] = 1;    }    cp = str->Ptr;    while(*cp)      if(!filter[(int)*cp++])t    return ajFalse;    return ajTrue;}""",2,"cwe119,cwe120"
"transfer_file_data(struct connection *conn) {  char buf[IOBUF_SIZE];  int n = read(conn->endpoint.fd, buf, conn->cl < (int64_t) sizeof(buf) ?               (int) conn->cl : (int) sizeof(buf));  if (n <= 0) {    close_local_endpoint(conn);  } else if (n > 0) {    conn->cl -= n;    ns_send(conn->ns_conn, buf, n);    if (conn->cl <= 0) {      close_local_endpoint(conn);    }  }}",3,"cwe119,cwe120,cweother"
"AcpiDbFindNameInNamespace (    char                    *NameArg){    char                    AcpiName[5] = ""____"";    char                    *AcpiNamePtr = AcpiName;    if (ACPI_STRLEN (NameArg) > 4)    {        AcpiOsPrintf (""Name must be no longer than 4 characters"");        return (AE_OK);    }         AcpiUtStrupr (NameArg);    while (*NameArg)    {        *AcpiNamePtr = *NameArg;        AcpiNamePtr++;        NameArg++;    }         (void) AcpiWalkNamespace (ACPI_TYPE_ANY, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,                        AcpiDbWalkAndMatchName, NULL, AcpiName, NULL);    AcpiDbSetOutputDestination (ACPI_DB_CONSOLE_OUTPUT);    return (AE_OK);}",2,"cwe119,cwe120"
"stk_randbase(int argc, char *argv[]){tgzFile fp;tkseq_t *seq;tint l;tif (argc == 1) {ttfprintf(stderr, ""Usage: seqtk randbase <in.fa>"");ttreturn 1;t}tfp = (strcmp(argv[1], ""-"") == 0)? gzdopen(fileno(stdin), ""r"") : gzopen(argv[1], ""r"");tseq = kseq_init(fp);twhile ((l = kseq_read(seq)) >= 0) {ttint i;ttprintf("">%s"", seq->name.s);ttfor (i = 0; i < l; ++i) {tttint c, b, a, j, k, m;tttb = seq->seq.s[i];tttc = seq_nt16_table[b];ttta = bitcnt_table[c];tttif (a == 2) {ttttm = (drand48() < 0.5);ttttfor (j = k = 0; j < 4; ++j) {tttttif ((1<<j & c) == 0) continue;tttttif (k == m) break;ttttt++k;tttt}ttttseq->seq.s[i] = islower(b)? ""acgt""[j] : ""ACGT""[j];ttt}tttif (i%60 == 0) putchar('');tttputchar(seq->seq.s[i]);tt}ttputchar('');t}tkseq_destroy(seq);tgzclose(fp);treturn 0;}",2,"cwe469,cweother"
"calc_diff(struct work *work, int known){tstruct cgminer_pool_stats *pool_stats = &(work->pool->cgminer_pool_stats);tdouble difficulty;tif (opt_scrypt) {ttuint64_t *data64, d64;ttchar rtarget[32];ttswab256(rtarget, work->target);ttdata64 = (uint64_t *)(rtarget + 2);ttd64 = be64toh(*data64);ttif (unlikely(!d64))tttd64 = 1;ttwork->work_difficulty = diffone / d64;t} else if (!known) {ttdouble targ = 0;ttint i;ttfor (i = 31; i >= 0; i--) {ttttarg *= 256;ttttarg += work->target[i];tt}ttwork->work_difficulty = DIFFEXACTONE / (targ ? : DIFFEXACTONE);t} elsettwork->work_difficulty = known;tdifficulty = work->work_difficulty;tpool_stats->last_diff = difficulty;tsuffix_string((uint64_t)difficulty, work->pool->diff, 0);tif (difficulty == pool_stats->min_diff)ttpool_stats->min_diff_count++;telse if (difficulty < pool_stats->min_diff || pool_stats->min_diff == 0) {ttpool_stats->min_diff = difficulty;ttpool_stats->min_diff_count = 1;t}tif (difficulty == pool_stats->max_diff)ttpool_stats->max_diff_count++;telse if (difficulty > pool_stats->max_diff) {ttpool_stats->max_diff = difficulty;ttpool_stats->max_diff_count = 1;t}}",2,"cwe119,cwe120"
"dialog(int s,SWC_MSG *msg){    int size;    size = write(s,msg,sizeof(*msg));    if (size < 0) {tperror(""write"");texit(1);    }    if (size != sizeof(*msg)) {tfprintf(stderr,""bad write: %d != %d"",size,sizeof(*msg));texit(1);    }    size = read(s,msg,sizeof(*msg));    if (size < 0) {tperror(""read"");texit(1);    }    if (size != sizeof(*msg)) {tfprintf(stderr,""bad read: %d != %d"",size,sizeof(*msg));texit(1);    }}",2,"cwe120,cweother"
"gtkui_make_menu(GtkAccelGroup **accel_group,                GtkWidget **menu_bar,                GtkActionEntry *menu_data,                guint menu_data_size){  *accel_group = NULL;  *menu_bar = NULL;  GError *error = NULL;  char ui_file[ PATH_MAX ];  ui_manager_menu = gtk_ui_manager_new();     GtkActionGroup *menu_action_group = gtk_action_group_new( ""MenuActionGroup"" );  gtk_action_group_add_actions( menu_action_group, menu_data, menu_data_size,                                NULL );  gtk_ui_manager_insert_action_group( ui_manager_menu, menu_action_group, 0 );  g_object_unref( menu_action_group );     if( utils_find_file_path( ""menu_data.ui"", ui_file, UTILS_AUXILIARY_GTK ) ) {    fprintf( stderr, ""%s: Error getting path for menu_data.ui"",                     fuse_progname );    return TRUE;  }  guint ui_menu_id = gtk_ui_manager_add_ui_from_file( ui_manager_menu, ui_file,                                                      &error );  if( error ) {    g_error_free( error );    return TRUE;  }  else if( !ui_menu_id ) return TRUE;  *accel_group = gtk_ui_manager_get_accel_group( ui_manager_menu );  *menu_bar = gtk_ui_manager_get_widget( ui_manager_menu, ""/MainMenu"" );  g_signal_connect( G_OBJECT( *menu_bar ), ""deactivate"",tt    G_CALLBACK( gtkui_menu_deactivate ), NULL );     ui_menu_activate( UI_MENU_ITEM_AY_LOGGING, 0 );  ui_menu_activate( UI_MENU_ITEM_FILE_MOVIE_RECORDING, 0 );  ui_menu_activate( UI_MENU_ITEM_MACHINE_PROFILER, 0 );  ui_menu_activate( UI_MENU_ITEM_RECORDING, 0 );  ui_menu_activate( UI_MENU_ITEM_RECORDING_ROLLBACK, 0 );  ui_menu_activate( UI_MENU_ITEM_TAPE_RECORDING, 0 );  return FALSE;}",2,"cwe119,cwe120"
"gl841_slow_back_home (Genesys_Device * dev, SANE_Bool wait_until_home){  Genesys_Register_Set local_reg[GENESYS_GL841_MAX_REGS+1];  SANE_Status status;  uint8_t val;  DBG (DBG_proc, ""gl841_slow_back_home (wait_until_home = %d)"",       wait_until_home);  if (dev->model->is_sheetfed == SANE_TRUE)    {      DBG (DBG_proc, ""gl841_slow_back_home: there is no ""home""-concept for sheet fed"");      DBG (DBG_proc, ""gl841_slow_back_home: finished"");      return SANE_STATUS_GOOD;    }    memset (local_reg, 0, sizeof (local_reg));  val = 0;  status = sanei_genesys_get_status (dev, &val);  if (status != SANE_STATUS_GOOD)    {      DBG (DBG_error,t   ""gl841_slow_back_home: failed to read home sensor: %s"",t   sane_strstatus (status));      return status;    }  dev->scanhead_position_in_steps = 0;  if (val & REG41_HOMESNR)t     {      DBG (DBG_info,t   ""gl841_slow_back_home: already at home, completed"");      dev->scanhead_position_in_steps = 0;      return SANE_STATUS_GOOD;    }  status = gl841_stop_action (dev);  if (status != SANE_STATUS_GOOD)    {      DBG (DBG_error,t   ""gl841_slow_back_home: failed to stop motor: %s"",t   sane_strstatus (status));      return SANE_STATUS_IO_ERROR;    }  memcpy (local_reg, dev->reg, (GENESYS_GL841_MAX_REGS+1) * sizeof (Genesys_Register_Set));  gl841_init_optical_regs_off(local_reg);  gl841_init_motor_regs(dev,local_reg,ttt65536,MOTOR_ACTION_GO_HOME,0);  status =    gl841_bulk_write_register (dev, local_reg, GENESYS_GL841_MAX_REGS);  if (status != SANE_STATUS_GOOD)    {      DBG (DBG_error,t   ""gl841_slow_back_home: failed to bulk write registers: %s"",t   sane_strstatus (status));      return status;    }  status = gl841_start_action (dev);  if (status != SANE_STATUS_GOOD)    {      DBG (DBG_error,t   ""gl841_slow_back_home: failed to start motor: %s"",t   sane_strstatus (status));      gl841_stop_action (dev);             gl841_bulk_write_register (dev, dev->reg, GENESYS_GL841_MAX_REGS);      return status;    }  if (wait_until_home)    {      int loop = 0;      while (loop < 300)tt t{t  status = sanei_genesys_get_status (dev, &val);t  if (status != SANE_STATUS_GOOD)t    {t      DBG (DBG_error,tt   ""gl841_slow_back_home: failed to read home sensor: %s"",tt   sane_strstatus (status));t      return status;t    }t  if (val & 0x08)t t    {t      DBG (DBG_info,tt   ""gl841_slow_back_home: reached home position"");t      DBG (DBG_proc, ""gl841_slow_back_home: finished"");t      return SANE_STATUS_GOOD;t    }t  usleep (100000);t t  ++loop;t}             gl841_stop_action (dev);      DBG (DBG_error,t   ""gl841_slow_back_home: timeout while waiting for scanhead to go home"");      return SANE_STATUS_IO_ERROR;    }  DBG (DBG_info, ""gl841_slow_back_home: scanhead is still moving"");  DBG (DBG_proc, ""gl841_slow_back_home: finished"");  return SANE_STATUS_GOOD;}",2,"cwe120,cweother"
"_nrrdEncodingRaw_write(FILE *file, const void *data, size_t elementNum,                       const Nrrd *nrrd, NrrdIoState *nio) {  static const char me[]=""_nrrdEncodingRaw_write"";  int fd, dio;  size_t ret, bsize;  const char *data_c;  size_t elementSize, maxChunkSize, remainderValue, chunkSize;  size_t retTmp;  char stmp[3][AIR_STRLEN_SMALL];  bsize = nrrdElementSize(nrrd)*elementNum;  if (nio->format->usesDIO) {    fd = fileno(file);    dio = airDioTest(fd, data, bsize);  } else {    fd = -1;    dio = airNoDio_format;  }  if (airNoDio_okay == dio) {    if (2 <= nrrdStateVerboseIO) {      fprintf(stderr, ""with direct I/O ... "");    }    ret = airDioWrite(fd, data, bsize);    if (ret != bsize) {      biffAddf(NRRD, ""%s: airDioWrite wrote only %s of %s bytes ""               ""(%g%% of expected)"", me,               airSprintSize_t(stmp[0], ret),               airSprintSize_t(stmp[1], bsize),               100.0*AIR_CAST(double, ret)/AIR_CAST(double, bsize));      return 1;    }  } else {    if (2 <= nrrdStateVerboseIO) {      if (AIR_DIO && nio->format->usesDIO) {        fprintf(stderr, ""with fread(), not DIO: %s ..."", airNoDioErr(dio));      }    }         ret = 0;    data_c = AIR_CAST(const char *, data);    elementSize = nrrdElementSize(nrrd);    maxChunkSize = 1024 * 1024 * 1024 / elementSize;    while(ret < elementNum) {      remainderValue = elementNum-ret;      if (remainderValue < maxChunkSize) {        chunkSize = remainderValue;      } else {        chunkSize = maxChunkSize;      }      retTmp =        fwrite(&(data_c[ret*elementSize]), elementSize, chunkSize, file);      ret += retTmp;      if (retTmp != chunkSize) {        biffAddf(NRRD, ""%s: fwrite wrote only %s %s-sized things, not %s ""                 ""(%g%% of expected)"", me,                 airSprintSize_t(stmp[0], ret),                 airSprintSize_t(stmp[1], nrrdElementSize(nrrd)),                 airSprintSize_t(stmp[2], elementNum),                 100.0*AIR_CAST(double, ret)/AIR_CAST(double, elementNum));        return 1;      }    }    fflush(file);       }  return 0;}",2,"cwe119,cwe120"
"adsi_begin_download(struct ast_channel *chan, char *service, unsigned char *fdn, unsigned char *sec, int version){tint bytes = 0;tunsigned char buf[256];tchar ack[2];t t tbytes += adsi_download_connect(buf + bytes, service, fdn, sec, version);tif (adsi_transmit_message_full(chan, buf, bytes, ADSI_MSG_DOWNLOAD, 0)) {ttreturn -1;t}tif (ast_readstring(chan, ack, 1, 10000, 10000, """")) {ttreturn -1;t}tif (ack[0] == 'B') {ttreturn 0;t}tast_debug(1, ""Download was denied by CPE"");treturn -1;}",2,"cwe119,cwe120"
"s5c73m3_load_fw(struct v4l2_subdev *sd){tstruct s5c73m3 *state = sensor_sd_to_s5c73m3(sd);tstruct i2c_client *client = state->i2c_client;tconst struct firmware *fw;tint ret;tchar fw_name[20];tsnprintf(fw_name, sizeof(fw_name), ""SlimISP_%.2s.bin"",tttttttstate->fw_file_version);tret = request_firmware(&fw, fw_name, &client->dev);tif (ret < 0) {ttv4l2_err(sd, ""Firmware request failed (%s)"", fw_name);ttreturn -EINVAL;t}tv4l2_info(sd, ""Loading firmware (%s, %zu B)"", fw_name, fw->size);tret = s5c73m3_spi_write(state, fw->data, fw->size, 64);tif (ret >= 0)ttstate->isp_ready = 1;telsettv4l2_err(sd, ""SPI write failed"");trelease_firmware(fw);treturn ret;}",2,"cwe119,cwe120"
"gt_compreads_decompress_benchmark(GtHcrDecoder *hcrd,                                             unsigned long amount,                                             GtTimer *timer,                                             GtError *err) {  char qual[BUFSIZ] = {0},       seq[BUFSIZ] = {0};  int had_err = 0;  unsigned long rand,                max_rand = gt_hcr_decoder_num_of_reads(hcrd) - 1,                count;  GtStr *timer_comment = gt_str_new_cstr(""extracting "");  GtStr *desc = gt_str_new();  gt_str_append_ulong(timer_comment, amount);  gt_str_append_cstr(timer_comment, "" reads of "");  gt_str_append_ulong(timer_comment, max_rand + 1);  gt_str_append_cstr(timer_comment, ""!"");  if (timer == NULL) {    timer = gt_timer_new_with_progress_description(""extract random reads"");    gt_timer_start(timer);  }  else {    gt_timer_show_progress(timer, ""extract random reads"", stdout);  }  gt_log_log(""%s"",gt_str_get(timer_comment));  for (count = 0; count < amount; count++) {    if (!had_err) {      rand = gt_rand_max(max_rand);      gt_log_log(""get read: %lu"", rand);      had_err = gt_hcr_decoder_decode(hcrd, rand, seq, qual, desc, err);      gt_log_log(""%s"",gt_str_get(desc));      gt_log_log(""%s"",seq);      gt_log_log(""%s"",qual);    }  }  gt_str_delete(timer_comment);  gt_str_delete(desc);  if (!gt_showtime_enabled())    gt_timer_delete(timer);  return had_err;}",2,"cwe119,cwe120"
"""ascii_enforce(char *dst, size_t size, const char *src){tconst char *s = src;tchar *d = dst;tg_assert(0 == size || NULL != dst);tg_assert(NULL != src);tg_assert(size <= INT_MAX);t/** TODO: Add overlap check */tif (size > 0) {ttuchar c;ttfor (/* NOTHING */; --size > 0 && '0' != (c = *s); s++, size)ttt*d++ = isascii(c) ? c : '_';tt*d = '0';t} twhile ('0' != *s++)ttd++;treturn d - dst;}""",2,"cwe119,cwe120"
"ath_pci_probe(struct pci_device *pdev){tvoid *mem;tstruct ath_softc *sc;tstruct net80211_device *dev;tu8 csz;tu16 subsysid;tu32 val;tint ret = 0;tchar hw_name[64];tadjust_pci_device(pdev);t tpci_read_config_byte(pdev, PCI_CACHE_LINE_SIZE, &csz);tif (csz == 0) {tt ttcsz =16;ttpci_write_config_byte(pdev, PCI_CACHE_LINE_SIZE, csz);t}t tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0xa8);t tpci_read_config_dword(pdev, 0x40, &val);tif ((val & 0x0000ff00) != 0)ttpci_write_config_dword(pdev, 0x40, val & 0xffff00ff);tmem = ioremap(pdev->membase, 0x10000);tif (!mem) {ttDBG(""ath9K: PCI memory map error"") ;ttret = -EIO;ttgoto err_iomap;t}tdev = net80211_alloc(sizeof(struct ath_softc));tif (!dev) {ttDBG(""ath9k: No memory for net80211_device"");ttret = -ENOMEM;ttgoto err_alloc_hw;t}tpci_set_drvdata(pdev, dev);tdev->netdev->dev = (struct device *)pdev;tsc = dev->priv;tsc->dev = dev;tsc->pdev = pdev;tsc->mem = mem;t tsc->sc_flags |= SC_OP_INVALID;tsc->irq = pdev->irq;tpci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &subsysid);tret = ath9k_init_device(pdev->device, sc, subsysid, &ath_pci_bus_ops);tif (ret) {ttDBG(""ath9k: Failed to initialize device"");ttgoto err_init;t}tath9k_hw_name(sc->sc_ah, hw_name, sizeof(hw_name));tDBG(""ath9k: %s mem=0x%lx, irq=%d"",tt   hw_name, (unsigned long)mem, pdev->irq);treturn 0;err_init:tnet80211_free(dev);err_alloc_hw:tiounmap(mem);err_iomap:treturn ret;}",2,"cwe119,cwe120"
"uild_eof_action()t{tint i;tchar action_text[MAXLINE];tfor ( i = 1; i <= scon_stk_ptr; ++i )tt{ttif ( sceof[scon_stk[i]] )tttformat_pinpoint_message(tttt""multiple <<EOF>> rules for start condition %s"",ttttscname[scon_stk[i]] );ttelsettt{tttsceof[scon_stk[i]] = true;tttif (previous_continued_action  )ttttadd_action(""YY_RULE_SETUP"");tttsnprintf( action_text, sizeof(action_text), ""case YY_STATE_EOF(%s):"",ttttscname[scon_stk[i]] );tttadd_action( action_text );ttt}tt}tline_directive_out( (FILE *) 0, 1 );t t--num_rules;t++num_eof_rules;t}",3,"cwe119,cwe120,cweother"
"""compareStrings(char *str1, char *str2){  char *s1 = str1, *s2 = str2;  while (*s1 != '0' && *s2 != '0') {    if (IsoToLowerCase(*s1) < IsoToLowerCase(*s2)) return -1;    if (IsoToLowerCase(*s1) > IsoToLowerCase(*s2)) return 1;    s1++;    s2++;  }  return IsoToLowerCase(*s2) - IsoToLowerCase(*s1);}""",2,"cwe119,cwe120"
"Init(int rows, int columns) {    _rowCount = rows;    _columnCount = columns;    _blockRowCount = (int)ceil((double)rows / (double)BlockSize);    _blockColumnCount = (int)ceil((double)columns / (double)BlockSize);        values = (double***)malloc(_blockRowCount * sizeof(double***));    for (int row = 0; row < _blockRowCount; ++row) {        values[row] = (double**)malloc(_blockColumnCount * sizeof(double**));        for (int column = 0; column < _blockColumnCount; ++column) {            values[row][column] = (double*)malloc(BlockSize * BlockSize * sizeof(double));            for (int i = 0; i < BlockSize * BlockSize; ++i) {                values[row][column][i] = 0.0;            }        }    }}",2,"cwe120,cweother"
"check_tcl_part(char *nick, char *uhost, struct userrec *u,                           char *chname, char *text){  struct flag_record fr = { FR_GLOBAL | FR_CHAN, 0, 0, 0, 0, 0 };  char args[1024];  simple_sprintf(args, ""%s %s!%s"", chname, nick, uhost);  get_user_flagrec(u, &fr, chname);  Tcl_SetVar(interp, ""_p1"", nick, 0);  Tcl_SetVar(interp, ""_p2"", uhost, 0);  Tcl_SetVar(interp, ""_p3"", u ? u->handle : ""*"", 0);  Tcl_SetVar(interp, ""_p4"", chname, 0);  Tcl_SetVar(interp, ""_p5"", text ? text : """", 0);  check_tcl_bind(H_part, args, &fr, "" $_p1 $_p2 $_p3 $_p4 $_p5"",                 MATCH_MASK | BIND_USE_ATTR | BIND_STACKABLE);}",2,"cwe119,cwe120"
"write_to_log(int count, float elapsed, int bytes, float ttime, int code, int failed){  int     fd;   char    entry[512];#ifdef  HAVE_LOCALTIME_R  struct  tm keepsake;#endif    struct  tm *tmp;    time_t  now;  size_t  len;  char    date[65];  now = time(NULL);#ifdef HAVE_LOCALTIME_R  tmp = (struct tm *)localtime_r(&now, &keepsake);#else  tmp = localtime(&now);#endif     setlocale(LC_TIME, ""C"");  len = strftime(date, sizeof date, ""%Y-%m-%d %H:%M:%S"", tmp);     if(my.shlog){     printf( ""FILE: %s"", my.logfile );     puts(""You can disable this annoying message by editing"");    puts(""the .siegerc file in your home directory; change"");    puts(""the directive 'show-logfile' to false."" );  }  if(!file_exists(my.logfile)){    if(!create_logfile(my.logfile)){      NOTIFY(ERROR, ""unable to create log file"");      return;    }  }     snprintf(    entry, sizeof entry,     ""%s,%7d,%11.2f,%12u,%11.2f,%12.2f,%12.2f,%12.2f,%8d,%8d"",     date, count, elapsed, bytes, ttime / count, count / elapsed, bytes / elapsed,     ttime / elapsed, code, failed   );     if((fd = open( my.logfile, O_WRONLY | O_APPEND, 0644 )) < 0){    NOTIFY(ERROR, ""Unable to write to file"");    return;  }  write(fd, entry, strlen(entry));  close(fd);   return;}",3,"cwe119,cwe120,cweother"
"qla4xxx_copy_fwddb_param(struct scsi_qla_host *ha,tttt     struct dev_db_entry *fw_ddb_entry,tttt     struct iscsi_cls_session *cls_sess,tttt     struct iscsi_cls_conn *cls_conn){tint buflen = 0;tstruct iscsi_session *sess;tstruct ddb_entry *ddb_entry;tstruct ql4_chap_table chap_tbl;tstruct iscsi_conn *conn;tchar ip_addr[DDB_IPADDR_LEN];tuint16_t options = 0;tsess = cls_sess->dd_data;tddb_entry = sess->dd_data;tconn = cls_conn->dd_data;tmemset(&chap_tbl, 0, sizeof(chap_tbl));tddb_entry->chap_tbl_idx = le16_to_cpu(fw_ddb_entry->chap_tbl_idx);tqla4xxx_copy_to_sess_conn_params(conn, sess, fw_ddb_entry);tsess->def_taskmgmt_tmo = le16_to_cpu(fw_ddb_entry->def_timeout);tconn->persistent_port = le16_to_cpu(fw_ddb_entry->port);tmemset(ip_addr, 0, sizeof(ip_addr));toptions = le16_to_cpu(fw_ddb_entry->options);tif (options & DDB_OPT_IPV6_DEVICE) {ttiscsi_set_param(cls_conn, ISCSI_PARAM_PORTAL_TYPE, ""ipv6"", 4);ttmemset(ip_addr, 0, sizeof(ip_addr));ttsprintf(ip_addr, ""%pI6"", fw_ddb_entry->ip_addr);t} else {ttiscsi_set_param(cls_conn, ISCSI_PARAM_PORTAL_TYPE, ""ipv4"", 4);ttsprintf(ip_addr, ""%pI4"", fw_ddb_entry->ip_addr);t}tiscsi_set_param(cls_conn, ISCSI_PARAM_PERSISTENT_ADDRESS,ttt(char *)ip_addr, buflen);tiscsi_set_param(cls_conn, ISCSI_PARAM_TARGET_NAME,ttt(char *)fw_ddb_entry->iscsi_name, buflen);tiscsi_set_param(cls_conn, ISCSI_PARAM_INITIATOR_NAME,ttt(char *)ha->name_string, buflen);tif (ddb_entry->chap_tbl_idx != INVALID_ENTRY) {ttif (!qla4xxx_get_uni_chap_at_index(ha, chap_tbl.name,tttttt   chap_tbl.secret,tttttt   ddb_entry->chap_tbl_idx)) {tttiscsi_set_param(cls_conn, ISCSI_PARAM_USERNAME,ttttt(char *)chap_tbl.name,tttttstrlen((char *)chap_tbl.name));tttiscsi_set_param(cls_conn, ISCSI_PARAM_PASSWORD,ttttt(char *)chap_tbl.secret,tttttchap_tbl.secret_len);tt}t}}",2,"cwe119,cwe120"
"gst_tcp_read_buffer (GstElement * this, int socket, GstPoll * fdset,    GstBuffer ** buf){  int ret;  ssize_t bytes_read;  int readsize;  *buf = NULL;        if ((ret = gst_poll_wait (fdset, GST_CLOCK_TIME_NONE)) <= 0) {    if (ret == -1 && errno == EBUSY)      goto cancelled;    else      goto select_error;  }     if (ioctl (socket, FIONREAD, &readsize) < 0)    goto ioctl_error;  if (readsize == 0)    goto got_eos;     *buf = gst_buffer_new_and_alloc (readsize);  bytes_read = read (socket, GST_BUFFER_DATA (*buf), readsize);  if (bytes_read < 0)    goto read_error;  if (bytes_read < readsize)         goto short_read;  GST_LOG_OBJECT (this, ""returning buffer of size %d"", GST_BUFFER_SIZE (*buf));  return GST_FLOW_OK;   select_error:  {    GST_ELEMENT_ERROR (this, RESOURCE, READ, (NULL),        (""select failed: %s"", g_strerror (errno)));    return GST_FLOW_ERROR;  }cancelled:  {    GST_DEBUG_OBJECT (this, ""Select was cancelled"");    return GST_FLOW_WRONG_STATE;  }ioctl_error:  {    GST_ELEMENT_ERROR (this, RESOURCE, READ, (NULL),        (""ioctl failed: %s"", g_strerror (errno)));    return GST_FLOW_ERROR;  }got_eos:  {    GST_DEBUG_OBJECT (this, ""Got EOS on socket stream"");    return GST_FLOW_UNEXPECTED;  }read_error:  {    GST_ELEMENT_ERROR (this, RESOURCE, READ, (NULL),        (""read failed: %s"", g_strerror (errno)));    gst_buffer_unref (*buf);    *buf = NULL;    return GST_FLOW_ERROR;  }short_read:  {    GST_ELEMENT_ERROR (this, RESOURCE, READ, (NULL),        (""short read: wanted %d bytes, got %"" G_GSSIZE_FORMAT, readsize,            bytes_read));    gst_buffer_unref (*buf);    *buf = NULL;    return GST_FLOW_ERROR;  }}",2,"cwe120,cweother"
"chk_rep_in_fullpth(struct spcpth_t *pthp){ register int32 pei, pei2; struct pathel_t *pep1, *pep2; char s1[RECLEN], s2[RECLEN];   for (pei = 0; pei <= pthp->last_pein; pei++)  {   pep1 = &(pthp->peins[pei]);   for (pei2 = pei + 1; pei2 <= pthp->last_pein; pei2++)    {     pep2 = &(pthp->peins[pei2]);     if (pep1->penp != pep2->penp) continue;            if (pep1->pthi1 == pep2->pthi1 && pep1->pthi2 == pep2->pthi2)      {       __gferr(1059,  pthp->pthsym->syfnam_ind, pthp->pthsym->sylin_cnt,        ""full path input element %s repeated in one path"",         pthel_tostr(s1, pep1));       continue;      }            if (pth_overlap(pep1, pep2))      {       __gferr(1079,  pthp->pthsym->syfnam_ind, pthp->pthsym->sylin_cnt,        ""path path input element %s overlaps %s in one path"",        pthel_tostr(s1, pep1), pthel_tostr(s2, pep2));      }      }   }   for (pei = 0; pei <= pthp->last_peout; pei++)  {   pep1 = &(pthp->peins[pei]);   for (pei2 = pei + 1; pei2 <= pthp->last_pein; pei2++)    {     pep2 = &(pthp->peouts[pei2]);     if (pep1->penp != pep2->penp) continue;            if (pep1->pthi1 == pep2->pthi1 && pep1->pthi2 == pep2->pthi2)      {       __gferr(1059, pthp->pthsym->syfnam_ind, pthp->pthsym->sylin_cnt,        ""full path output element %s repeated in one path"",         pthel_tostr(s1, pep1));       pthp->pth_gone = TRUE;       continue;      }           if (pth_overlap(pep1, pep2))      {       __gferr(1079,  pthp->pthsym->syfnam_ind, pthp->pthsym->sylin_cnt,        ""path output element %s overlaps %s in one path"",        pthel_tostr(s1, pep1), pthel_tostr(s2, pep2));       pthp->pth_gone = TRUE;      }    }  }}",2,"cwe119,cwe120"
"""TableAddInstrs(SplineFont *sf, uint32 tag,int replace,tuint8 *instrs,int icnt) {    struct ttf_table *tab;    for ( tab=sf->ttf_tables; tab!=NULL && tab->tag!=tag; tab=tab->next );    if ( tab==NULL )tfor ( tab=sf->ttf_tab_saved; tab!=NULL && tab->tag!=tag; tab=tab->next );    if ( replace && tab!=NULL ) {tfree(tab->data);ttab->data = NULL;ttab->len = tab->maxlen = 0;    }    if ( icnt==0 )return;    if ( tab==NULL ) {ttab = chunkalloc(sizeof( struct ttf_table ));ttab->tag = tag;tif ( tag==CHR('p','r','e','p') || tag==CHR('f','p','g','m') ||tttag==CHR('c','v','t',' ') || tag==CHR('m','a','x','p') ) {t    tab->next = sf->ttf_tables;t    sf->ttf_tables = tab;t} else {t    tab->next = sf->ttf_tab_saved;t    sf->ttf_tab_saved = tab;t}    }    if ( tab->data==NULL ) {ttab->data = galloc(icnt);tmemcpy(tab->data,instrs,icnt);ttab->len = icnt;    } else {tuint8 *newi = galloc(icnt+tab->len);tmemcpy(newi,tab->data,tab->len);tmemcpy(newi+tab->len,instrs,icnt);tfree(tab->data);ttab->data = newi;ttab->len += icnt;    }    tab->maxlen = tab->len;}""",2,"cwe120,cweother"
"mgmt_user_confirm_request(uint16_t len, const void *buf){tconst struct mgmt_ev_user_confirm_request *ev = buf;tchar str[18];tif (len < sizeof(*ev)) {ttprintf(""* Malformed User Confirmation Request control"");ttreturn;t}tba2str(&ev->addr.bdaddr, str);tprintf(""@ User Confirmation Request: %s (%d) hint %d value %d"",tttstr, ev->addr.type, ev->confirm_hint, ev->value);tbuf += sizeof(*ev);tlen -= sizeof(*ev);tpacket_hexdump(buf, len);}",2,"cwe119,cwe120"
"send_telnet_data(struct connectdata *conn,                                 char *buffer, ssize_t nread){  unsigned char outbuf[2];  ssize_t bytes_written, total_written;  int out_count;  CURLcode rc = CURLE_OK;  while(rc == CURLE_OK && nread--) {    outbuf[0] = *buffer++;    out_count = 1;    if(outbuf[0] == CURL_IAC)      outbuf[out_count++] = CURL_IAC;    total_written = 0;    do {             struct pollfd pfd[1];      pfd[0].fd = conn->sock[FIRSTSOCKET];      pfd[0].events = POLLOUT;      switch (Curl_poll(pfd, 1, -1)) {        case -1:                             case 0:                                rc = CURLE_SEND_ERROR;          break;        default:                               bytes_written = 0;          rc = Curl_write(conn, conn->sock[FIRSTSOCKET], outbuf+total_written,                          out_count-total_written, &bytes_written);          total_written += bytes_written;          break;      }         } while(rc == CURLE_OK && total_written < out_count);  }  return rc;}",2,"cwe119,cwe120"
"P7ReadNullModel(char *rndfile, float *null, float *ret_p1){  FILE *fp;  char *s;  int   x;  int   type = 0;   if ((fp = fopen(rndfile, ""r"")) == NULL)    Die(""Failed to open null model file %s"", rndfile);  if ((s = Getword(fp, sqdARG_STRING)) == NULL) goto FAILURE;  s2upper(s);  if      (strcmp(s, ""NUCLEIC"") == 0) type = hmmNUCLEIC;  else if (strcmp(s, ""AMINO"")   == 0) type = hmmAMINO;  else    goto FAILURE;tttt   if (Alphabet_type == 0)     SetAlphabet(type);  else if (Alphabet_type != type)    Die(""Alphabet type conflict; null model in %s is inappropriate"", rndfile);tttt   for (x = 0; x < Alphabet_size; x++) {    if ((s = Getword(fp, sqdARG_FLOAT)) == NULL) goto FAILURE;    null[x] = atof(s);  }  if ((s = Getword(fp, sqdARG_FLOAT)) == NULL) goto FAILURE;  *ret_p1 = atof(s);  fclose(fp);  return;FAILURE:  fclose(fp);  Die(""%s is not in HMMER null model file format"", rndfile);}",2,"cwe469,cweother"
"""krb5int_libdefault_string(krb5_context context, const krb5_data *realm,                          const char *option, char **ret_value){    profile_t profile;    const char *names[5];    char **nameval = NULL;    krb5_error_code retval;    char realmstr[1024];    if (realm->length > sizeof(realmstr)-1)        return(EINVAL);    strncpy(realmstr, realm->data, realm->length);    realmstr[realm->length] = '0';    if (!context || (context->magic != KV5M_CONTEXT))        return KV5M_CONTEXT;    profile = context->profile;    names[0] = KRB5_CONF_LIBDEFAULTS;    /*     * Try number one:     *     * [libdefaults]     *          REALM = {     *                  option = <boolean>     *          }     */    names[1] = realmstr;    names[2] = option;    names[3] = 0;    retval = profile_get_values(profile, names, &nameval);    if (retval == 0 && nameval && nameval[0])        goto goodbye;    /*     * Try number two:     *     * [libdefaults]     *          option = <boolean>     */    names[1] = option;    names[2] = 0;    retval = profile_get_values(profile, names, &nameval);    if (retval == 0 && nameval && nameval[0])        goto goodbye;goodbye:    if (!nameval)        return(ENOENT);    if (!nameval[0]) {        retval = ENOENT;    } else {        *ret_value = strdup(nameval[0]);        if (!*ret_value)            retval = ENOMEM;    }    profile_free_list(nameval);    return retval;}""",2,"cwe119,cwe120"
"non_ascii_error_message (lexical_context_ty lcontext,                         const char *file_name, size_t line_number){  char buffer[21];  char *errmsg;  if (line_number == (size_t)(-1))    buffer[0] = '0';  else    sprintf (buffer, "":%ld"", (long) line_number);  switch (lcontext)    {    case lc_outside:      errmsg =        xasprintf (_(""Non-ASCII character at %s%s.""), file_name, buffer);      break;    case lc_comment:      errmsg =        xasprintf (_(""Non-ASCII comment at or before %s%s.""),                   file_name, buffer);      break;    case lc_string:      errmsg =        xasprintf (_(""Non-ASCII string at %s%s.""), file_name, buffer);      break;    default:      abort ();    }  return errmsg;}",2,"cwe119,cwe120"
nartifact_exist(){    int a = 0;    int n = SIZE(artiexist);    while(n > 1)tif(artiexist[--n]) a++;    return a;},2,"cwe119,cwe120"
"update_catalog(struct work_queue *q, struct link *master, int force_update ){tstruct work_queue_stats s;tchar addrport[WORK_QUEUE_LINE_MAX];tstatic time_t last_update_time = 0;tif(!force_update) {ttif(time(0) - last_update_time < WORK_QUEUE_CATALOG_MASTER_UPDATE_INTERVAL) return;t}tif(!q->catalog_host) {ttq->catalog_host = strdup(CATALOG_HOST);t}tif(!q->catalog_port) {ttq->catalog_port = CATALOG_PORT;t}twork_queue_get_stats(q, &s);tstruct work_queue_resources r;tmemset(&r, 0, sizeof(r));twork_queue_get_resources(q,&r);tdebug(D_WQ,""Updating catalog with resource information -- cores:%d memory:%d disk:%d"", r.cores.total,r.memory.total,r.disk.total);  tchar * worker_summary = work_queue_get_worker_summary(q);tif(master) {ttint port;ttlink_address_remote(master, addrport, &port);ttsprintf(addrport, ""%s:%d"", addrport, port);t} else {ttsprintf(addrport, ""127.0.0.1:-1"");  t}tadvertise_master_to_catalog(q->catalog_host, q->catalog_port, q->name, addrport, &s, &r, worker_summary);tfree(worker_summary);tlast_update_time = time(0);}",3,"cwe119,cwe120,cwe469"
"username_commit (const char *section_name,                 const struct config_keyvalue *kv,                 void *arg){  bmc_config_state_data_t *state_data;  uint8_t userid;  fiid_obj_t obj_cmd_rs = NULL;  fiid_obj_t obj_get_user_name_cmd_rs = NULL;  config_err_t rv = CONFIG_ERR_FATAL_ERROR;  assert (section_name);  assert (kv);  assert (arg);    state_data = (bmc_config_state_data_t *)arg;  userid = atoi (section_name + strlen (""User""));     if (userid == 1)    {             if (same (kv->value_input, ""NULL"")          || same (kv->value_input, ""anonymous""))        return (CONFIG_ERR_SUCCESS);      else        return (CONFIG_ERR_NON_FATAL_ERROR_READ_ONLY);    }  if (!(obj_cmd_rs = fiid_obj_create (tmpl_cmd_set_user_name_rs)))    {      pstdout_fprintf (state_data->pstate,                       stderr,                       ""fiid_obj_create: %s"",                       strerror (errno));      goto cleanup;    }  if (ipmi_cmd_set_user_name (state_data->ipmi_ctx,                              userid,                              kv->value_input,                              strlen (kv->value_input),                              obj_cmd_rs) < 0)    {      config_err_t ret;      if (state_data->prog_data->args->config_args.common.debug)        pstdout_fprintf (state_data->pstate,                         stderr,                         ""ipmi_cmd_set_user_name: %s"",                         ipmi_ctx_errormsg (state_data->ipmi_ctx));             if (ipmi_ctx_errnum (state_data->ipmi_ctx) == IPMI_ERR_BAD_COMPLETION_CODE          && (ipmi_check_completion_code (obj_cmd_rs,                                          IPMI_COMP_CODE_INVALID_DATA_FIELD_IN_REQUEST) == 1))        {t  char username[IPMI_MAX_USER_NAME_LENGTH+1];t  memset (username, '0', IPMI_MAX_USER_NAME_LENGTH+1);t  if (!(obj_get_user_name_cmd_rs = fiid_obj_create (tmpl_cmd_get_user_name_rs)))t    {t      pstdout_fprintf (state_data->pstate,ttt       stderr,ttt       ""fiid_obj_create: %s"",ttt       strerror (errno));t      goto cleanup;t    }t  if (ipmi_cmd_get_user_name (state_data->ipmi_ctx,tttt      userid,tttt      obj_get_user_name_cmd_rs) < 0)t    {t      if (state_data->prog_data->args->config_args.common.debug)ttpstdout_fprintf (state_data->pstate,tttt stderr,tttt ""ipmi_cmd_get_user_name: %s"",tttt ipmi_ctx_errormsg (state_data->ipmi_ctx));t      goto error_out;t    }t  if (fiid_obj_get_data (obj_get_user_name_cmd_rs,tttt ""user_name"",tttt username,tttt IPMI_MAX_USER_NAME_LENGTH) < 0)t    {t      pstdout_fprintf (state_data->pstate,ttt       stderr,ttt       ""fiid_obj_get_data: 'user_name': %s"",ttt       fiid_obj_errormsg (obj_get_user_name_cmd_rs));t      goto cleanup;t    }t  t  if (!strcmp(username, kv->value_input))t    goto out;        }    error_out:      if (config_is_non_fatal_error (state_data->ipmi_ctx,                                     obj_cmd_rs,                                     &ret))        rv = ret;      goto cleanup;    } out:  rv = CONFIG_ERR_SUCCESS; cleanup:  fiid_obj_destroy (obj_cmd_rs);  fiid_obj_destroy (obj_get_user_name_cmd_rs);  return (rv);}",3,"cwe119,cwe120,cweother"
"mark_addressof (rtx *rtl, void *data){  if (!*rtl)    return 0;  if (GET_CODE (*rtl) == ADDRESSOF      && REG_P (XEXP (*rtl, 0)))    ((char *)data)[REGNO (XEXP (*rtl, 0))] = 1;  return 0;}",2,"cwe119,cwe120"
"send_dir(request *r) {  char *file;  int fildes;  char *ptr;  int i;     file = malloc(strlen(r->file) +   7 + longest_ext + 1);  sprintf(file, ""%s/index.%n"", r->file, &i);  ptr = file + i;   i = 0;     while(i < mimetypes) {    strcpy(ptr, EXT(i++));    fildes = open(file, O_RDONLY);    if(fildes != -1) {       close(fildes);             free(r->file);      r->file = file;      file_stuff(r);      send_file(r);      return;    }  }     free(file);  send_dirlist(r);}",2,"cwe120,cweother"
"annotation_set_tofile(const char *int_mboxname __attribute__((unused)),tttt struct annotate_st_entry_list *entry,tttt struct storedata *sdata,tttt struct mailbox_annotation_rock *mbrock __attribute__((unused)),tttt void *rock){    const char *filename = (const char *) rock;    char path[MAX_MAILBOX_PATH+1];    FILE *f;         if (!sdata->isadmin) return IMAP_PERMISSION_DENIED;    snprintf(path, sizeof(path), ""%s/msg/%s"", config_dir, filename);         if (!strcmp(entry->shared.value, ""NIL""))treturn unlink(path);    else if ((f = fopen(path, ""w""))) {tfprintf(f, ""%s"", entry->shared.value);treturn fclose(f);    }    return IMAP_IOERROR;}",4,"cwe119,cwe120,cwe476,cweother"
"do_stack_time(struct image_file_list *imfl, struct ccd_frame *ofr,tttint (* progress)(char *msg, void *data), void *data){tint i;tGList *gl;tstruct image_file *imf;tdouble expsum = 0.0;tdouble exptime = 0.0;tdouble jd, v;tchar lb[128];tchar date[64];tgl = imfl->imlist;ti=0;twhile (gl != NULL) {ttimf = gl->data;ttgl = g_list_next(gl);ttif (imf->flags & IMG_SKIP)tttcontinue;ttif (i >= COMB_MAX) {tttd1_printf(""reached stacking limit"");tttbreak;tt}tti++;ttjd = frame_jdate(imf->fr);ttif (jd == 0) {tttif (progress) {tttt(*progress)(""stack_time: bad time, skipping frame"",ttttt    data);ttt}tttcontinue;tt}ttif (fits_get_double(imf->fr, P_STR(FN_EXPTIME), &v) > 0) {tttd1_printf(""stack time: using exptime = %.3f from %s"",tttt  v, P_STR(FN_EXPTIME));tt} else {tttv = 0.0;tttif (progress) {tttt(*progress)(""stack_time: bad exptime, skipping frame"",ttttt    data);ttt}tttcontinue;tt}ttexpsum += v;ttexptime += (jd + v /2/24/3600) * v;t}tif (expsum == 0)ttreturn 0;tif (progress) {ttsnprintf(lb, 79, ""eqivalent exp: %.1fs, center at jd:%.7f"",ttt expsum, exptime/expsum);tt(*progress)(lb, data);t}tsprintf(lb, ""%20.3f / EXPOSURE TIME IN SECONDS"", expsum);tfits_add_keyword(ofr, P_STR(FN_EXPTIME), lb);tsprintf(lb, ""%20.8f / JULIAN DATE OF EXPOSURE START (UTC)"",ttexptime/expsum - expsum/2/24/3600);tfits_add_keyword(ofr, P_STR(FN_JDATE), lb);tdate_time_from_jdate(exptime/expsum - expsum/2/24/3600, date, 63);tfits_add_keyword(ofr, P_STR(FN_DATE_OBS), date);tfits_delete_keyword(ofr, P_STR(FN_MJD));tfits_delete_keyword(ofr, P_STR(FN_TIME_OBS));treturn 0;}",2,"cwe119,cwe120"
"execute_file(char *name, int newsock, int verbose){    intt        i,c, t;    pid_t       pid;    int         pty;    struct stattstb;    chartptyname[] = ""/dev/ptyCP"";    intt        gotpty =0;    char       *line;    char       *argv[2] = {name, NULL};    char       *env[2] = {NULL};    if (verbose) DNETLOG((LOG_INFO, ""About to exec %s"", name));    dnet_accept(newsock, 0, NULL, 0);#ifdef DNETUSE_DEVPTS    if (openpty(&pty, &t,NULL, NULL, NULL) != 0)    {tDNETLOG((LOG_ERR, ""No ptys available for object execution""));texit(-1);    }#else    for (c='p'; c <= 'z'; c++)    {tline = ptyname;tline[strlen(""/dev/pty"")] = c;tline[strlen(""/dev/ptyC"")] = '0';tif (stat(line,&stb) < 0)t    break;tfor (i=0; i < 16; i++)t{t    line[strlen(""/dev/ptyC"")]= ""0123456789abcdef""[i];t    if ( (pty=open(line,O_RDWR)) > 0)t    {ttgotpty = 1;ttbreak;t    }t}tif (gotpty) break;    }    if (!gotpty)    {tDNETLOG((LOG_ERR, ""No ptys available for connection""));treturn;    }    line[strlen(""/dev/"")] = 't';    if ( (t=open(line,O_RDWR)) < 0)    {tDNETLOG((LOG_ERR, ""Error connecting to physical terminal: %m""));treturn;    }#endif    if ( ( pid=fork() ) < 0)    {tDNETLOG((LOG_ERR, ""Error forking""));treturn;    }    if (pid)       {tclose(t);  t tcopy(pty, newsock, pid);treturn ;    }    setsid();    close(pty); close(newsock);    if (t != 0) dup2 (t,0);    if (t != 1) dup2 (t,1);    if (t != 2) dup2 (t,2);    if (t > 2) close(t);    putenv(""TERM=vt100"");    execve(name, argv, env);    DNETLOG((LOG_ERR, ""Error executing command""));    return;}",3,"cwe119,cwe120,cweother"
"save_xfile(xfile *xf, char *sname, char *pfx, int verb) {tFILE *fp;tchar *cp, *fname;tsize_t len;tif (sname != NULL) {ttfname = sname;t} else {ttif ((cp = strrchr(xf->name, '/')) == NULLtt && (cp = strrchr(xf->name, '')) == NULL)tttcp = xf->name;ttelsetttcp++;ttlen = strlen(pfx) + strlen(cp) + 1;ttif ((fname = malloc(len)) == NULL)ttterror(""malloc fname %d bytes failed"",len);ttstrcpy(fname, pfx);ttstrcat(fname, cp);t} t #if !defined(O_CREAT) && !defined(_O_CREAT)# error ""Need to #include fcntl.h!""#endif#if defined(O_BINARY) || defined(_O_BINARY)tif ((fp = fopen(fname,""wb"")) == NULL)#elsetif ((fp = fopen(fname,""w"")) == NULL)#endiftterror(""Can't open file '%s' for writing"",fname);tif ((fwrite(xf->buf, 1, xf->len, fp)) != xf->len)tterror(""Failed to write file '%s'"",fname);tif (fclose(fp))tterror(""Failed to close file '%s' after writing"",fname);tif (verb) printf(""Wrote '%s' %ld bytes"",fname, xf->len);tif (sname == NULL)ttfree(fname);}",2,"cwe120,cweother"
"dirserv_add_own_fingerprint(const char *nickname, crypto_pk_t *pk){  char fp[FINGERPRINT_LEN+1];  if (crypto_pk_get_fingerprint(pk, fp, 0)<0) {    log_err(LD_BUG, ""Error computing fingerprint"");    return -1;  }  if (!fingerprint_list)    fingerprint_list = authdir_config_new();  add_fingerprint_to_dir(nickname, fp, fingerprint_list);  return 0;}",2,"cwe119,cwe120"
"wr_data(PLStream *pls, void *buf, size_t buf_size){#ifdef BUFFERED_FILE    plio_fwrite(buf, buf_size, 1, pls->plbufFile);#else    if ((pls->plbuf_top + buf_size) >= pls->plbuf_buffer_size) {         t         pls->plbuf_buffer_size += pls->plbuf_buffer_grow *tt((pls->plbuf_top + buf_size - pls->plbuf_buffer_size) / tttpls->plbuf_buffer_grow + 1);twhile (pls->plbuf_top + buf_size >= pls->plbuf_buffer_size);        if ((pls->plbuf_buffer = realloc(pls->plbuf_buffer, pls->plbuf_buffer_size)) == NULL)             plexit(""plbuf wr_data:  Plot buffer grow failed"");    }     memcpy((U_CHAR *)pls->plbuf_buffer + pls->plbuf_top, buf, buf_size);    pls->plbuf_top += buf_size;#endif}",3,"cwe119,cwe120,cweother"
"write_user_access( void ){tint RetCode = 0;tFILE *fp;tchar Time[SHORT_STRING_SIZE] = """";ttime_t _Time = time(NULL);tNoName = 1;tstrftime(Time,SHORT_STRING_SIZE,""%c"",localtime(&_Time));tif (AllEntries == NULL)t{ttprint_msg(PRT_ERR,""Error: file ""%s"": there are no user data!"",userfile(),strerror(errno));ttreturn -1;t}tif ((fp = fopen(userfile(), ""w"")) == NULL)t{ttprint_msg(PRT_ERR,""Can't open ""%s"" (%s)"",userfile(),strerror(errno));ttreturn -1;t}tfprintf(fp,""%s"",""###############################################################################"");tfprintf(fp,""%s"",""#"");tfprintf(fp,""%s %s %s on %s"",""#"",""Generated by isdnlog"",VERSION,Time);tfprintf(fp,""%s"",""#"");tfprintf(fp,""%s"",""###############################################################################"");twrite_entry(fp,AllEntries);tfclose(fp);treturn RetCode;}",3,"cwe119,cwe120,cweother"
"push_refs_with_export(struct transport *transport,ttstruct ref *remote_refs, int flags){tstruct ref *ref;tstruct child_process *helper, exporter;tstruct helper_data *data = transport->data;tchar *export_marks = NULL, *import_marks = NULL;tstruct string_list revlist_args = STRING_LIST_INIT_NODUP;tstruct strbuf buf = STRBUF_INIT;thelper = get_helper(transport);twrite_constant(helper->in, ""export"");trecvline(data, &buf);tif (debug)ttfprintf(stderr, ""Debug: Got export_marks '%s'"", buf.buf);tif (buf.len) {ttstruct strbuf arg = STRBUF_INIT;ttstrbuf_addstr(&arg, ""--export-marks="");ttstrbuf_addbuf(&arg, &buf);ttexport_marks = strbuf_detach(&arg, NULL);t}trecvline(data, &buf);tif (debug)ttfprintf(stderr, ""Debug: Got import_marks '%s'"", buf.buf);tif (buf.len) {ttstruct strbuf arg = STRBUF_INIT;ttstrbuf_addstr(&arg, ""--import-marks="");ttstrbuf_addbuf(&arg, &buf);ttimport_marks = strbuf_detach(&arg, NULL);t}tstrbuf_reset(&buf);tfor (ref = remote_refs; ref; ref = ref->next) {ttchar *private;ttunsigned char sha1[20];ttif (!data->refspecs)tttcontinue;ttprivate = apply_refspecs(data->refspecs, data->refspec_nr, ref->name);ttif (private && !get_sha1(private, sha1)) {tttstrbuf_addf(&buf, ""^%s"", private);tttstring_list_append(&revlist_args, strbuf_detach(&buf, NULL));tt}ttstring_list_append(&revlist_args, ref->name);t}tif (get_exporter(transport, &exporter,ttt export_marks, import_marks, &revlist_args))ttdie(""Couldn't run fast-export"");tdata->no_disconnect_req = 1;tfinish_command(&exporter);tdisconnect_helper(transport);treturn 0;}",2,"cwe119,cwe120"
"parse_dep_file(void *map, size_t len){tchar *m = map;tchar *end = m + len;tchar *p;tchar s[PATH_MAX];tp = strchr(m, ':');tif (!p) {ttfprintf(stderr, ""fixdep: parse error"");ttexit(1);t}tmemcpy(s, m, p-m); s[p-m] = 0;tprintf(""deps_%s := "", target);tm = p+1;tclear_config();twhile (m < end) {ttwhile (m < end && (*m == ' ' || *m == '' || *m == ''))tttm++;ttp = m;ttwhile (p < end && *p != ' ') p++;ttif (p == end) {tttdo p--; while (!isalnum(*p));tttp++;tt}ttmemcpy(s, m, p-m); s[p-m] = 0;ttif (strrcmp(s, ""include/linux/autoconf.h"") &&tt    strrcmp(s, ""arch/um/include/uml-config.h"") &&tt    strrcmp(s, "".ver"")) {tttprintf(""  %s "", s);tttdo_config_file(s);tt}ttm = p + 1;t}tprintf(""%s: $(deps_%s)"", target, target);tprintf(""$(deps_%s):"", target);}",2,"cwe119,cwe120"
"dialandactivatesub(struct skinny_subchannel *sub, char exten[AST_MAX_EXTENSION]){tif (sub->line->getforward) {ttstruct skinny_line *l = sub->line;ttstruct skinny_device *d = l->device;tt ttSKINNY_DEBUG(DEBUG_SUB, 3, ""Sub %d - Set callforward to %s"", sub->callid, exten);ttset_callforwards(l, sub->exten, l->getforward);tttransmit_start_tone(d, SKINNY_DIALTONE, l->instance, sub->callid);tttransmit_lamp_indication(d, STIMULUS_FORWARDALL, 1, SKINNY_LAMP_ON);tttransmit_displaynotify(d, ""CFwd enabled"", 10);tttransmit_cfwdstate(d, l);ttast_safe_sleep(sub->owner, 500);ttast_indicate(sub->owner, -1);ttast_safe_sleep(sub->owner, 1000);ttl->getforward = 0;ttdumpsub(sub, 0);t} else {ttSKINNY_DEBUG(DEBUG_SUB, 3, ""Sub %d - Dial %s and Activate"", sub->callid, exten);ttast_copy_string(sub->exten, exten, sizeof(sub->exten));ttactivatesub(sub, SUBSTATE_DIALING);t}}",2,"cwe119,cwe120"
"""parse_escape_seq(int *c){tunsigned short num = 0;tint tmp_c = fgetc(global.src);tif(!isdigit(tmp_c))ttexit(lex);twhile(isdigit((char)tmp_c))t{ttnum *= 10;ttnum += tmp_c - '0';ttif(num > 255)tttexit(lex);tttmp_c = fgetc(global.src);t}tif(num == 0 || tmp_c == EOF || ''' != tmp_c)ttexit(lex);t*c = (char) num;}""",2,"cwe120,cweother"
"get_output_charset (struct binding *domainbinding){     if (domainbinding != NULL && domainbinding->codeset != NULL)    return domainbinding->codeset;  else    {             static char *output_charset_cache;      static int output_charset_cached;      if (!output_charset_cached)t{t  const char *value = getenv (""OUTPUT_CHARSET"");t  if (value != NULL && value[0] != '0')t    {t      size_t len = strlen (value) + 1;t      char *value_copy = (char *) malloc (len);t      if (value_copy != NULL)ttmemcpy (value_copy, value, len);t      output_charset_cache = value_copy;t    }t  output_charset_cached = 1;t}      if (output_charset_cache != NULL)treturn output_charset_cache;      elset{# ifdef _LIBCt  return _NL_CURRENT (LC_CTYPE, CODESET);# else#  if HAVE_ICONVt  return locale_charset ();#  endif# endift}    }}",2,"cwe120,cweother"
"gap_gve_png_drawable_encode_png(GimpDrawable *drawable, gint32 png_interlaced, gint32 *PNG_size,                               gint32 png_compression,                               void *app0_buffer, gint32 app0_length){  guchar *buffer;  guchar *PNG_data;  size_t totalsize = 0;  gint32 image_id;  gboolean l_pngSaveOk;  char *l_tmpname;    l_tmpname = gimp_temp_name(""tmp.png"");  image_id = gimp_drawable_get_image(drawable->drawable_id);    l_pngSaveOk = p_save_as_tmp_png_file(l_tmpname                       , image_id                       , drawable->drawable_id                       , png_interlaced                       , png_compression                       );  if (l_pngSaveOk)  {    gint32 fileSize;    gint32 bytesRead;        fileSize = gap_file_get_filesize(l_tmpname);        totalsize = app0_length + fileSize;    buffer = g_malloc(totalsize);    PNG_data = buffer;    if(app0_length > 0)    {      memcpy(buffer, app0_buffer, app0_length);      PNG_data = buffer + app0_length;        bytesRead = gap_file_load_file_segment(l_tmpname                      ,PNG_data                      ,0                                   ,fileSize                            );      if (bytesRead != fileSize)      {        g_free(buffer);        buffer = NULL;        totalsize = 0;        printf(""gap_gve_png_drawable_encode_png: read error: bytesRead:%d (expected: %d) file:%s""               ,(int)bytesRead               ,(int)fileSize               ,l_tmpname               );      }    }      }  if(g_file_test(l_tmpname, G_FILE_TEST_EXISTS))  {    g_remove(l_tmpname);  }     g_free (l_tmpname);  *PNG_size = totalsize;  return buffer;  }",2,"cwe120,cweother"
"ay_irc_got_topic(const char *channel, const char *topic,tirc_message_prefix *prefix, irc_account *ia){tConversation *ecr;tif ((ecr = ay_conversation_find_by_name(ia->data, channel))) {ttchar buf[BUF_LEN];ttchar *msg = strip_color((unsigned char *)topic);ttg_snprintf(buf, BUF_LEN, ""Topic: %s"", msg);ttay_conversation_display_notification(ecr, msg, IRC_TOPIC);ttif (msg) {tttfree(msg);tttmsg = NULL;tt}t}}",2,"cwe119,cwe120"
"dupargv (argv)     char **argv;{  int argc;  char **copy;    if (argv == NULL)    return NULL;       for (argc = 0; argv[argc] != NULL; argc++);  copy = (char **) malloc ((argc + 1) * sizeof (char *));  if (copy == NULL)    return NULL;       for (argc = 0; argv[argc] != NULL; argc++)    {      int len = strlen (argv[argc]);      copy[argc] = malloc (sizeof (char *) * (len + 1));      if (copy[argc] == NULL)t{t  freeargv (copy);t  return NULL;t}      strcpy (copy[argc], argv[argc]);    }  copy[argc] = NULL;  return copy;}",2,"cwe120,cweother"
"write_charstrings(gs_fapi_font * a_fapi_font, WRF_output * a_output){    long length;    long buffer_size;    int i, count = a_fapi_font->get_word(a_fapi_font,                                         gs_fapi_font_feature_CharStrings_count,                                         0);    char NameBuf[256];    if (count <= 0)        return;    WRF_wstring(a_output, ""2 index /CharStrings "");    WRF_wint(a_output, count);    WRF_wstring(a_output, "" dict dup begin"");    for (i = 0; i < count; i++) {        length =            a_fapi_font->get_charstring_name(a_fapi_font, i,                                             (byte *) & NameBuf, 256);        if (length > 0) {            length = a_fapi_font->get_charstring(a_fapi_font, i, 0, 0);            WRF_wbyte(a_output, '/');            WRF_wstring(a_output, (const char *)&NameBuf);            WRF_wbyte(a_output, ' ');            WRF_wint(a_output, length);            WRF_wstring(a_output, "" RD "");                         buffer_size = a_output->m_limit - a_output->m_count;            if (buffer_size >= length) {                a_fapi_font->get_charstring(a_fapi_font, i, a_output->m_pos,                                            (ushort) length);                WRF_wtext(a_output, a_output->m_pos, length);            } else                a_output->m_count += length;            WRF_wstring(a_output, "" ND"");        }    }    WRF_wstring(a_output, "" end"");}",2,"cwe119,cwe120"
"read_rhs(struct csa *csa){            int i, f, v, type;      double rhs;      char name[255+1], *flag;             csa->work3 = flag = xcalloc(1+csa->P->m, sizeof(char));      memset(&flag[1], 0, csa->P->m);             v = 0;loop: if (indicator(csa, 0)) goto done;             if (csa->deck)      {  read_field(csa);         if (csa->field[0] != '0')            error(csa, ""field 1 must be blank"");      }      else         csa->fldno++;             read_field(csa), patch_name(csa, csa->field);      if (csa->field[0] == '0')      {            if (v == 0)         {  warning(csa, ""missing RHS vector name in field 2"");            goto blnk;         }      }      else if (v != 0 && strcmp(csa->field, name) == 0)      {            xassert(v != 0);      }      elseblnk: {            if (v != 0)            error(csa, ""multiple RHS vectors not supported"");         v++;         strcpy(name, csa->field);      }             for (f = 3; f <= 5; f += 2)      {            read_field(csa), patch_name(csa, csa->field);         if (csa->field[0] == '0')         {  if (f == 3)               error(csa, ""missing row name in field 3"");            else            {                  skip_field(csa);               continue;            }         }         i = glp_find_row(csa->P, csa->field);         if (i == 0)            error(csa, ""row `%s' not found"", csa->field);         if (flag[i])            error(csa, ""duplicate right-hand side for row `%s'"",               csa->field);                   rhs = read_number(csa);         if (fabs(rhs) < csa->parm->tol_mps) rhs = 0.0;         type = csa->P->row[i]->type;         if (type == GLP_FR)         {  if (i == csa->obj_row)               glp_set_obj_coef(csa->P, 0, rhs);            else if (rhs != 0.0)               warning(csa, ""non-zero right-hand side for free row `%s'""                  "" ignored"", csa->P->row[i]->name);         }         else            glp_set_row_bnds(csa->P, i, type, rhs, rhs);         flag[i] = 1;      }      goto loop;done:        xfree(flag);      csa->work3 = NULL;      return;}",2,"cwe119,cwe120"
"ARoundFlash(Width,X,Y)int Width,X,Y;{    struct p *Path, *NewPath;    struct p Pair;         if (CDDesc.dControl == DCONTROLCDTO) {        if (CDDesc.dFirstPass)            return (PSUCCEEDED);        Pair.pX = SCALE(X);        Pair.pY = SCALE(Y);        Pair.pSucc = NULL;        if (CDDesc.dRoot)            GenWire(CDDesc.dRootFileDesc,SCALE(Width),&Pair);        else             GenWire(CDDesc.dSymbolFileDesc,SCALE(Width),&Pair);    }    elif (CDDesc.dControl == DCONTROLCDOPEN Or            CDDesc.dControl == DCONTROLPCIF) {        if (CDDesc.dFirstPass And CDDesc.dControl == DCONTROLPCIF)            return (PSUCCEEDED);        if ((NewPath = Path = alloc(p)) != NULL)            return (AMallocFailed());        NewPath->pX = X;        NewPath->pY = Y;        NewPath->pSucc = NULL;        if (Not CDMakeWire(CDDesc.dSymbolDesc,CurrentLayer,Width,Path,            &CDDesc.dPointer))            return (PFAILED);        while(CDDesc.dPrptyList != NULL) {            struct prpty PrptyCopy;            if (Not CDAddProperty(CDDesc.dSymbolDesc,CDDesc.dPointer,                CDDesc.dPrptyList->prpty_Value,                CDDesc.dPrptyList->prpty_String))                return (PFAILED);                         PrptyCopy = *CDDesc.dPrptyList;            free(CDDesc.dPrptyList->prpty_String);            afree(CDDesc.dPrptyList,prpty);            CDDesc.dPrptyList = PrptyCopy.prpty_Succ;        }    }    return (PSUCCEEDED);}",2,"cwe476,cweother"
"html_screenshot(const char *name, int mode){tint y, x;tint wid, hgt;tbyte a = TERM_WHITE;tbyte oa = TERM_WHITE;twchar_t c = L' ';tconst char *new_color_fmt = (mode == 0) ?ttttt""<font color=""#%02X%02X%02X"">""tttt t: ""[COLOR=""#%02X%02X%02X""]"";tconst char *change_color_fmt = (mode == 0) ?ttttt""</font><font color=""#%02X%02X%02X"">""ttttt: ""[/COLOR][COLOR=""#%02X%02X%02X""]"";tconst char *close_color_fmt = mode ==  0 ? ""</font>"" : ""[/COLOR]"";tang_file *fp;tchar buf[1024];tpath_build(buf, sizeof(buf), ANGBAND_DIR_USER, name);tfp = file_open(buf, MODE_WRITE, FTYPE_TEXT);t tif (!fp)t{ttplog_fmt(""Cannot write the '%s' file!"", buf);ttreturn;t}t tTerm_get_size(&wid, &hgt);tif (mode == 0)t{ttfile_putf(fp, ""<!DOCTYPE html><html><head>"");ttfile_putf(fp, ""  <meta='generator' content='%s'>"", buildid);ttfile_putf(fp, ""  <title>%s</title>"", name);ttfile_putf(fp, ""</head>"");ttfile_putf(fp, ""<body style='color: #fff; background: #000;'>"");ttfile_putf(fp, ""<pre>"");t}telse t{ttfile_putf(fp, ""[CODE][TT][BC=black][COLOR=white]"");t}t tfor (y = 0; y < hgt; y++)t{ttfor (x = 0; x < wid; x++)tt{ttt ttt(void)(Term_what(x, y, &a, &c));ttt tttif (oa != a && c != L' ')ttt{tttt ttttif (oa == TERM_WHITE)tttt{tttttfile_putf(fp, new_color_fmt,ttttt        angband_color_table[a][1],ttttt        angband_color_table[a][2],ttttt        angband_color_table[a][3]);tttt}tttt ttttelse if (a == TERM_WHITE)tttt{tttttfile_putf(fp, close_color_fmt);tttt}tttt ttttelsetttt{tttttfile_putf(fp, change_color_fmt,ttttt        angband_color_table[a][1],ttttt        angband_color_table[a][2],ttttt        angband_color_table[a][3]);tttt}tttt ttttoa = a;ttt}ttt tttif (mode == 0) write_html_escape_char(fp, c);tttelsettt{ttttchar mbseq[MB_LEN_MAX+1] = {0};ttttwctomb(mbseq, c);ttttfile_putf(fp, ""%s"", mbseq);ttt}tt}tt ttfile_putf(fp, """");t}t tif (oa != TERM_WHITE) file_putf(fp, close_color_fmt);tif (mode == 0)t{ttfile_putf(fp, ""</pre>"");ttfile_putf(fp, ""</body>"");ttfile_putf(fp, ""</html>"");t}telse t{ttfile_putf(fp, ""[/COLOR][/BC][/TT][/CODE]"");t}t tfile_close(fp);}",2,"cwe119,cwe120"
"ccf_create_gray_dither_table(    int row,    int total_rows,    int total_columns,    cct_cube cube){  cct_8_8_dither_table answer;  int matrix[4][4];  double max;  if(!lf_check_rows_columns(total_rows, total_columns)) return 0;  if (cube->u.grayscale.value_count < 2) return 0;  lf_create_dither_matrix(matrix, total_rows, total_columns);  max = total_rows * total_columns - 1;  answer = (cct_8_8_dither_table)    calloc(1, sizeof(struct ccs_8_8_dither_table));  answer->column_count = total_columns;  lf_calculate_dither_table(    cube->u.grayscale.brightnesses,    cube->u.grayscale.value_count,    max,    total_columns,    matrix[row],    answer->pixel_values,    cube->u.grayscale.pixel_values);  return answer;}",2,"cwe119,cwe120"
"underflow_up2 (void){  mpfr_t x, y, z, z0, eps;  mpfr_exp_t n;  int inex;  int rnd;  n = 1 - mpfr_get_emin ();  MPFR_ASSERTN (n > 1);  if (n > ULONG_MAX)    return;  mpfr_init2 (eps, 2);  mpfr_set_ui_2exp (eps, 1, -1, MPFR_RNDN);     mpfr_div_ui (eps, eps, n, MPFR_RNDZ);         mpfr_init2 (x, sizeof (unsigned long) * CHAR_BIT + 1);  inex = mpfr_ui_sub (x, 1, eps, MPFR_RNDN);  MPFR_ASSERTN (inex == 0);     inex = mpfr_div_2ui (x, x, 1, MPFR_RNDN);     MPFR_ASSERTN (inex == 0);  mpfr_init2 (y, sizeof (unsigned long) * CHAR_BIT);  inex = mpfr_set_ui (y, n, MPFR_RNDN);  MPFR_ASSERTN (inex == 0);     mpfr_inits2 (64, z, z0, (mpfr_ptr) 0);  RND_LOOP (rnd)    {      unsigned int ufinex = MPFR_FLAGS_UNDERFLOW | MPFR_FLAGS_INEXACT;      int expected_inex;      char sy[256];      mpfr_set_ui (z0, 0, MPFR_RNDN);      expected_inex = rnd == MPFR_RNDN || rnd == MPFR_RNDU || rnd == MPFR_RNDA ?        (mpfr_nextabove (z0), 1) : -1;      sprintf (sy, ""%lu"", (unsigned long) n);      mpfr_clear_flags ();      inex = mpfr_pow (z, x, y, (mpfr_rnd_t) rnd);      cmpres (0, x, sy, (mpfr_rnd_t) rnd, z0, expected_inex, z, inex, ufinex,              ""underflow_up2"", ""mpfr_pow"");      test_others (NULL, sy, (mpfr_rnd_t) rnd, x, y, z, inex, ufinex,                   ""underflow_up2"");    }  mpfr_clears (x, y, z, z0, eps, (mpfr_ptr) 0);}",2,"cwe119,cwe120"
"winterp(char *path, char *exe, char *flags, char *game)r{r    sprintf(tmp, LaunchingTemplate, path, exe);rr    setenv(""GARGLK_INI"", path, FALSE);rr    char *args[4] = {NULL, NULL, NULL, NULL};rr    if (strstr(flags, ""-""))r    {r        args[0] = exe;r        args[1] = flags;r        args[2] = game;r    }r    elser    {r        args[0] = exe;r        args[1] = buf;r    }rr    if (!winexec(tmp, args))r    {r        winmsg(""Could not start 'terp.Sorry."");r        return FALSE;r    }rr    return TRUE;r}",3,"cwe119,cwe120,cweother"
string_hash (const void *x){  const char *s = (const char *) x;  size_t h = 0;  for (; *s; s++)    h = *s + ((h << 9) | (h >> (SIZE_BITS - 9)));  return h;},3,"cwe119,cwe120,cweother"
"APar_ExtractAAC_Artwork(short this_atom_num, char* pic_output_prefix, short artwork_count) {    char *base_outpath = (char *) malloc(sizeof(char) * MAXPATHLEN + 1);    memset(base_outpath, 0, MAXPATHLEN + 1);    strcpy(base_outpath, pic_output_prefix);    strcat(base_outpath, ""_artwork"");    sprintf(base_outpath, ""%s_%d"", base_outpath, artwork_count);    char* art_payload = (char*) malloc(sizeof(char) * (parsedAtoms[this_atom_num].AtomicLength - 16) + 1);    memset(art_payload, 0, (parsedAtoms[this_atom_num].AtomicLength - 16) + 1);    fseeko(source_file, parsedAtoms[this_atom_num].AtomicStart + 16, SEEK_SET);    fread(art_payload, 1, parsedAtoms[this_atom_num].AtomicLength - 16, source_file);    const char* suffix = (char *) malloc(sizeof(char) * 5);    if (memcmp(art_payload, ""x89x50x4Ex47x0Dx0Ax1Ax0A"", 8) == 0) {        suffix = "".png"";    }    else if (memcmp(art_payload, ""xFFxD8xFFxE0"", 4) == 0 || memcmp(art_payload, ""xFFxD8xFFxE1"", 4) == 0) {        suffix = "".jpg"";    }    strcat(base_outpath, suffix);    FILE *outfile = APar_OpenFile(base_outpath, ""wb"");    if (outfile != NULL) {        fwrite(art_payload, (size_t) (parsedAtoms[this_atom_num].AtomicLength - 16), 1, outfile);        fclose(outfile);        fprintf(stdout, ""Extracted artwork to file: "");        APar_fprintf_UTF8_data(base_outpath);        fprintf(stdout, """");    }    free(art_payload);    return base_outpath;}",2,"cwe120,cweother"
"camellia_setkey_dec( camellia_context *ctx, const unsigned char *key, unsigned int keysize ){    int idx;    size_t i;    camellia_context cty;    uint32_t *RK;    uint32_t *SK;    int ret;    switch( keysize )    {        case 128: ctx->nr = 3; idx = 0; break;        case 192:        case 256: ctx->nr = 4; idx = 1; break;        default : return( POLARSSL_ERR_CAMELLIA_INVALID_KEY_LENGTH );    }    RK = ctx->rk;    ret = camellia_setkey_enc(&cty, key, keysize);    if( ret != 0 )        return( ret );    SK = cty.rk + 24 * 2 + 8 * idx * 2;    *RK++ = *SK++;    *RK++ = *SK++;    *RK++ = *SK++;    *RK++ = *SK++;    for (i = 22 + 8 * idx, SK -= 6; i > 0; i--, SK -= 4)    {        *RK++ = *SK++;        *RK++ = *SK++;    }    SK -= 2;    *RK++ = *SK++;    *RK++ = *SK++;    *RK++ = *SK++;    *RK++ = *SK++;    memset( &cty, 0, sizeof( camellia_context ) );    return( 0 );}",2,"cwe119,cwe120"
"cli_cmd_volume_status_parse (const char **words, int wordcount,                             dict_t **options){        dict_t *dict            = NULL;        int     ret             = -1;        int     cmd             = 0;        GF_ASSERT (options);        dict = dict_new ();        if (!dict)                goto out;        switch (wordcount) {        case 2:                cmd = GF_CLI_STATUS_ALL;                ret = 0;                break;        case 3:                if (!strcmp (words[2], ""all"")) {                        cmd = GF_CLI_STATUS_ALL;                        ret = 0;                } else if (!strcmp (words[2], ""detail"")) {                        cmd = GF_CLI_STATUS_ALL_DETAIL;                        ret = 0;                } else {                        cmd = GF_CLI_STATUS_VOL;                        ret = dict_set_str (dict, ""volname"", (char *)words[2]);                }                break;        case 4:                if (!strcmp (words[2], ""all"") &&                    !strcmp (words[3], ""detail"")) {                        cmd = GF_CLI_STATUS_ALL_DETAIL;                        ret = 0;                } else if (!strcmp (words[3], ""detail"")) {                        cmd = GF_CLI_STATUS_VOL_DETAIL;                        ret = dict_set_str (dict, ""volname"", (char *)words[2]);                } else {                        cmd = GF_CLI_STATUS_BRICK;                        ret = dict_set_str (dict, ""volname"", (char *)words[2]);                        if (ret)                                goto out;                        ret = dict_set_str (dict, ""brick"", (char *)words[3]);                }                break;        case 5:                if (strcmp (words[4], ""detail""))                        goto out;                cmd = GF_CLI_STATUS_BRICK_DETAIL;                ret = dict_set_str (dict, ""volname"", (char *)words[2]);                if (ret)                        goto out;                ret = dict_set_str (dict, ""brick"", (char *)words[3]);                break;        default:                goto out;        }        if (ret)                goto out;        ret = dict_set_int32 (dict, ""cmd"", cmd);        if (ret)                goto out;        *options = dict; out:        if (ret && dict)                dict_destroy (dict);        return ret;}",4,"cwe119,cwe120,cwe476,cwe469"
"report_operspy(struct Client *source_p, const char *token, const char *arg){t tif(MyClient(source_p))ttsendto_match_servs(source_p, ""*"", CAP_ENCAP, NOCAPS,tttt   ""ENCAP * OPERSPY %s %s"", token, arg ? arg : """");tsendto_realops_flags(UMODE_OPERSPY,ttt     ConfigFileEntry.operspy_admin_only ? L_ADMIN : L_ALL,ttt     ""OPERSPY %s %s %s"", get_oper_name(source_p), token, arg ? arg : """");tilog(L_OPERSPY, ""OPERSPY %s %s %s"", get_oper_name(source_p), token, arg ? arg : """");}",2,"cwe119,cwe120"
"flickcurl_activity_userPhotos(flickcurl* fc, const char* timeframe,                              int per_page, int page){  xmlDocPtr doc = NULL;  xmlXPathContextPtr xpathCtx = NULL;   flickcurl_activity** activities = NULL;  char page_str[10];  char per_page_str[10];  flickcurl_init_params(fc, 0);  if(timeframe) {    flickcurl_add_param(fc, ""timeframe"", timeframe);  }  if(page >= 0) {    sprintf(page_str, ""%d"", page);    flickcurl_add_param(fc, ""page"", page_str);  }  if(per_page >= 0) {    sprintf(per_page_str, ""%d"", per_page);    flickcurl_add_param(fc, ""per_page"", per_page_str);  }  flickcurl_end_params(fc);  if(flickcurl_prepare(fc, ""flickr.activity.userPhotos""))    goto tidy;  doc = flickcurl_invoke(fc);  if(!doc)    goto tidy;  xpathCtx = xmlXPathNewContext(doc);  if(!xpathCtx) {    flickcurl_error(fc, ""Failed to create XPath context for document"");    fc->failed = 1;    goto tidy;  }  activities = flickcurl_build_activities(fc, xpathCtx,                                        (const xmlChar*)""/rsp/items/item"", NULL);  tidy:  if(xpathCtx)    xmlXPathFreeContext(xpathCtx);  if(fc->failed)    activities = NULL;  return activities;}",2,"cwe119,cwe120"
"getlength(double *length, reslttype *reslt, boolean *hslngth){  long maxinput;  double valyew;  char tmp[100];  valyew = 0.0;  maxinput = 1;  do {    printf(""Enter the new branch length"");    printf(""OR enter U to leave the length unchanged"");    if (*hslngth)      printf(""OR enter R to remove the length from this branch: "");    getstryng(tmp);    if (tmp[0] == 'u' || tmp[0] == 'U'){      *reslt = quit;      break;    }    else if (tmp[0] == 'r' || tmp[0] == 'R') {      (*reslt) = remoov;      break;}    else if (sscanf(tmp,""%lf"",&valyew) == 1){      (*reslt) = valid;      break;    }    maxinput++;    if (maxinput == 100) {      printf(""ERROR: too many tries at choosing option"");      embExitBad();    }  } while (1);  (*length) = valyew;}",2,"cwe119,cwe120"
"pkey_dh_ctrl_str(EVP_PKEY_CTX *ctx,tttconst char *type, const char *value)t{tif (!strcmp(type, ""dh_paramgen_prime_len""))tt{ttint len;ttlen = atoi(value);ttreturn EVP_PKEY_CTX_set_dh_paramgen_prime_len(ctx, len);tt}tif (!strcmp(type, ""dh_paramgen_generator""))tt{ttint len;ttlen = atoi(value);ttreturn EVP_PKEY_CTX_set_dh_paramgen_generator(ctx, len);tt}treturn -2;t}",2,"cwe469,cweother"
"ANN_TrainFile(ANNetwork *ann, char *filename){tFILE *fin = fopen(filename, ""r"");tif ( fin == NULL )t{#ifdef VERBOSEtttprintf(""file : %s could not be opened for training"", filename);#endifttreturn -1;t}t tTrainingSet set;tfscanf(fin, ""%d %d "" REAL_NUM_FORMAT, &set.n_training_sets, &set.max_epoch, &set.desired_error);t tint n_input = ann->n_neurons[INPUT_LAYER];tint n_answers = ann->n_neurons[ann->n_layers - 1];t tint malloc_error = _AllocateSetVectors(&set, n_input, n_answers);tif ( malloc_error )t{#ifdef VERBOSEttprintf(""malloc_error could not allocate input and answers vectors for training from a""tttt""file...needed %u bytes"", sizeof(real_num) * set.n_training_sets * tttt(n_input + n_answers + 2 ));#endifttreturn -1;t}ttint training_set, neuron;tfor (training_set = 0; training_set < set.n_training_sets; training_set++)t{tttt ttfor (neuron = 0; neuron < n_input; neuron++)tt{tttfscanf(fin, REAL_NUM_FORMAT, set.inputs[training_set] + neuron);tt}tt ttfor (neuron = 0; neuron < n_answers; neuron++)tt{tttfscanf(fin, REAL_NUM_FORMAT, set.answers[training_set] + neuron);tt}t}t tint epoch = ANN_Train(ann, set);t tfor (training_set = 0; training_set < set.n_training_sets; training_set++)t{ttfree(set.inputs[training_set]);ttfree(set.answers[training_set]);t}tfree(set.inputs);tfree(set.answers);ttreturn epoch;}",2,"cwe120,cweother"
"Pcompile (char const *pattern, size_t size){#if !HAVE_LIBPCRE  error (EXIT_TROUBLE, 0, ""%s"",         _(""support for the -P option is not compiled into ""           ""this --disable-perl-regexp binary""));#else  int e;  char const *ep;  char *re = xnmalloc (4, size + 7);  int flags = PCRE_MULTILINE | (match_icase ? PCRE_CASELESS : 0);  char const *patlim = pattern + size;  char *n = re;  char const *p;  char const *pnul;# if defined HAVE_LANGINFO_CODESET  if (STREQ (nl_langinfo (CODESET), ""UTF-8""))    {             flags |= PCRE_UTF8;    }# endif  if (!map_pcre ())    error (EXIT_TROUBLE, 0, ""%s"",t   _(""The -P option is not supported: libpcre.so.3 is not available""));     if (memchr (pattern, '', size))    error (EXIT_TROUBLE, 0, _(""the -P option only supports a single pattern""));  *n = '0';  if (match_lines)    strcpy (n, ""^("");  if (match_words)    strcpy (n, ""b("");  n += strlen (n);     for (p = pattern; (pnul = memchr (p, '0', patlim - p)); p = pnul + 1)    {      memcpy (n, p, pnul - p);      n += pnul - p;      for (p = pnul; pattern < p && p[-1] == ''; p--)        continue;      n -= (pnul - p) & 1;      strcpy (n, ""000"");      n += 4;    }  memcpy (n, p, patlim - p);  n += patlim - p;  *n = '0';  if (match_words)    strcpy (n, "")b"");  if (match_lines)    strcpy (n, "")$"");  cre = pcre_compile (re, flags, &ep, &e, pcre_maketables ());  if (!cre)    error (EXIT_TROUBLE, 0, ""%s"", ep);  extra = pcre_study (cre, PCRE_STUDY_JIT_COMPILE, &ep);  if (ep)    error (EXIT_TROUBLE, 0, ""%s"", ep);# if PCRE_STUDY_JIT_COMPILE  if (pcre_fullinfo (cre, extra, PCRE_INFO_JIT, &e))    error (EXIT_TROUBLE, 0, _(""internal error (should never happen)""));  if (e)    {             jit_stack = pcre_jit_stack_alloc (32 * 1024, 512 * 1024);      if (!jit_stack)        error (EXIT_TROUBLE, 0,               _(""failed to allocate memory for the PCRE JIT stack""));      pcre_assign_jit_stack (extra, NULL, jit_stack);    }# endif  free (re);#endif  }",3,"cwe120,cwe476,cweother"
"add_network_security_ciphers(DBusMessageIter *dict,ttttttGSupplicantSSID *ssid){tunsigned int p_cipher, g_cipher, i;tchar *pairwise, *group;tchar *pair_ciphers[4];tchar *group_ciphers[5];tp_cipher = ssid->pairwise_cipher;tg_cipher = ssid->group_cipher;tif (p_cipher == 0 && g_cipher == 0)ttreturn;ti = 0;tif (p_cipher & G_SUPPLICANT_PAIRWISE_CCMP)ttpair_ciphers[i++] = ""CCMP"";tif (p_cipher & G_SUPPLICANT_PAIRWISE_TKIP)ttpair_ciphers[i++] = ""TKIP"";tif (p_cipher & G_SUPPLICANT_PAIRWISE_NONE)ttpair_ciphers[i++] = ""NONE"";tpair_ciphers[i] = NULL;ti = 0;tif (g_cipher & G_SUPPLICANT_GROUP_CCMP)ttgroup_ciphers[i++] = ""CCMP"";tif (g_cipher & G_SUPPLICANT_GROUP_TKIP)ttgroup_ciphers[i++] = ""TKIP"";tif (g_cipher & G_SUPPLICANT_GROUP_WEP104)ttgroup_ciphers[i++] = ""WEP104"";tif (g_cipher & G_SUPPLICANT_GROUP_WEP40)ttgroup_ciphers[i++] = ""WEP40"";tgroup_ciphers[i] = NULL;tpairwise = g_strjoinv("" "", pair_ciphers);tgroup = g_strjoinv("" "", group_ciphers);tSUPPLICANT_DBG(""cipher %s %s"", pairwise, group);tsupplicant_dbus_dict_append_basic(dict, ""pairwise"",ttttttDBUS_TYPE_STRING,tttttt&pairwise);tsupplicant_dbus_dict_append_basic(dict, ""group"",ttttttDBUS_TYPE_STRING,tttttt&group);tg_free(pairwise);tg_free(group);}",2,"cwe119,cwe120"
clear_simple_modes(channel_t *c){tsize_t i;tif (c == NULL)ttreturn;tc->modes = 0;tc->limit = 0;tif (c->key != NULL)ttfree(c->key);tc->key = NULL;tfor (i = 0; i < ignore_mode_list_size; i++)ttif (c->extmodes[i] != NULL)tt{tttfree(c->extmodes[i]);tttc->extmodes[i] = NULL;tt}},2,"cwe119,cwe120"
"client3_3_setxattr (call_frame_t *frame, xlator_t *this,                    void *data){        clnt_conf_t       *conf     = NULL;        clnt_args_t       *args     = NULL;        gfs3_setxattr_req  req      = {{0,},};        int                ret      = 0;        int                op_errno = ESTALE;        if (!frame || !this || !data)                goto unwind;        args = data;        if (!(args->loc && args->loc->inode))                goto unwind;        if (!uuid_is_null (args->loc->inode->gfid))                memcpy (req.gfid,  args->loc->inode->gfid, 16);        else                memcpy (req.gfid, args->loc->gfid, 16);        GF_ASSERT_AND_GOTO_WITH_ERROR (this->name,                                       !uuid_is_null (*((uuid_t*)req.gfid)),                                       unwind, op_errno, EINVAL);        if (args->xattr) {                GF_PROTOCOL_DICT_SERIALIZE (this, args->xattr,                                            (&req.dict.dict_val),                                            req.dict.dict_len,                                            op_errno, unwind);        }        req.flags = args->flags;        conf = this->private;        GF_PROTOCOL_DICT_SERIALIZE (this, args->xdata, (&req.xdata.xdata_val),                                    req.xdata.xdata_len, op_errno, unwind);        ret = client_submit_request (this, &req, frame, conf->fops,                                     GFS3_OP_SETXATTR, client3_3_setxattr_cbk,                                     NULL, NULL, 0, NULL, 0, NULL,                                     (xdrproc_t)xdr_gfs3_setxattr_req);        if (ret) {                gf_log (this->name, GF_LOG_WARNING, ""failed to send the fop"");        }        GF_FREE (req.dict.dict_val);        GF_FREE (req.xdata.xdata_val);        return 0;unwind:        CLIENT_STACK_UNWIND (setxattr, frame, -1, op_errno, NULL);        GF_FREE (req.dict.dict_val);        GF_FREE (req.xdata.xdata_val);        return 0;}",2,"cwe120,cwe476"
"hexToBin(PLArenaPool *pool, SECItem * destItem, const char * src, int len){    PRUint8 * dest;    destItem->data = NULL;     if (len <= 0 || (len & 1)) {tgoto loser;    }    len >>= 1;    if (!SECITEM_AllocItem(pool, destItem, len))tgoto loser;    dest = destItem->data;    for (; len > 0; len--, src += 2) {tPRInt16 bin = (x2b[(PRUint8)src[0]] << 4) | x2b[(PRUint8)src[1]]; tif (bin < 0)t    goto loser;t*dest++ = (PRUint8)bin;    }    return SECSuccess;loser:    if (!pool)    tSECITEM_FreeItem(destItem, PR_FALSE);    return SECFailure;}",2,"cwe119,cwe120"
"rfbSetClientColourMapBGR233(rfbClientPtr cl){    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];    rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;    uint16_t *rgb = (uint16_t *)(&buf[sz_rfbSetColourMapEntriesMsg]);    int i, len;    int r, g, b;    if (cl->format.bitsPerPixel != 8 ) {        rfbErr(""%s: client not 8 bits per pixel"",                ""rfbSetClientColourMapBGR233"");        rfbCloseClient(cl);        return FALSE;    }        scme->type = rfbSetColourMapEntries;    scme->firstColour = Swap16IfLE(0);    scme->nColours = Swap16IfLE(256);    len = sz_rfbSetColourMapEntriesMsg;    i = 0;    for (b = 0; b < 4; b++) {        for (g = 0; g < 8; g++) {            for (r = 0; r < 8; r++) {                rgb[i++] = Swap16IfLE(r * 65535 / 7);                rgb[i++] = Swap16IfLE(g * 65535 / 7);                rgb[i++] = Swap16IfLE(b * 65535 / 3);            }        }    }    len += 256 * 3 * 2;    if (rfbWriteExact(cl, buf, len) < 0) {        rfbLogPerror(""rfbSetClientColourMapBGR233: write"");        rfbCloseClient(cl);        return FALSE;    }    return TRUE;}",2,"cwe119,cwe120"
"SDP_IsDynamicPayload(GF_SDPMedia *media, char *payt){tu32 i;tGF_RTPMap *map;tchar buf[10];ti=0;twhile ((map = (GF_RTPMap*)gf_list_enum(media->RTPMaps, &i))) {ttsprintf(buf, ""%d"", map->PayloadType);ttif (!strcmp(payt, buf)) return 1;t}treturn 0;}",2,"cwe119,cwe120"
"TimeCounter2Int(const char *s){long d = 0, h = 0, m = 0;char output[CF_BUFSIZE];if (s == NULL)   {   return CF_NOINT;   }if (strchr(s, '-'))   {   if (sscanf(s, ""%ld-%ld:%ld"", &d, &h, &m) != 3)      {      snprintf(output, CF_BUFSIZE, ""Unable to parse TIME 'ps' field, expected dd-hh:mm, got '%s'"", s);      ReportError(output);      }   }else   {   if (sscanf(s, ""%ld:%ld"", &h, &m) != 2)      {      snprintf(output, CF_BUFSIZE, ""Unable to parse TIME 'ps' field, expected hH:mm, got '%s'"", s);      ReportError(output);      }   }return 60 * (m + 60 * (h + 24 * d));}",2,"cwe119,cwe120"
"xprintf(FILE* fp, ei_x_buff* x, const char* fmt, ...){    int r = 0;    va_list ap;    va_start(ap, fmt);    if (fp != NULL) {tr = vfprintf(fp, fmt, ap);    } else {t tchar tmpbuf[2000];tr = vsprintf(tmpbuf, fmt, ap);tei_x_append_buf(x, tmpbuf, strlen(tmpbuf));    }    va_end(ap);    return r;}",3,"cwe119,cwe120,cweother"
"init(){  int s, v;  char name[30];  for (s=0; s<4; s++)    for (v=0; v<13; v++)    {      sprintf(name, ""%c%c"", values[v], suits[s]);      cards[s][v] = get_picture(name);    }}",2,"cwe119,cwe120"
"is_module_loaded(char *module){tstatic char *fn = ""/proc/modules"";tchar buf[4096];tFILE *fp;tchar *s;tif ((fp = fopen_with_errmsg(fn, ""r"")) == NULL)ttreturn 0;twhile (fgets(buf,sizeof(buf),fp)) {tts = skip_nonwhitespace(buf);ttif (s) {tt   *s = 0;tt   if (strcmp(module,buf) == 0) {tt      fclose(fp);tt      return 1;tt   }tt}t}tfclose(fp);treturn 0;}",2,"cwe119,cwe120"
"print_table(void){    char buffer[BUF_SIZE];    int fd,size;    if ((fd = open(ATMARP_DUMP_DIR ""/"" ATMARP_DUMP_FILE,O_RDONLY)) < 0) {tperror(""open "" ATMARP_DUMP_DIR ""/"" ATMARP_DUMP_FILE);treturn 1;    }    while ((size = read(fd,buffer,BUF_SIZE))) {tif (size < 0) {t    perror(""read "" ATMARP_DUMP_DIR ""/"" ATMARP_DUMP_FILE);t    return 1;t}tif (write(1,buffer,size) < 0) {t    perror(""write stdout"");t    return 1;t}    }    return 0;}",3,"cwe119,cwe120,cweother"
"""ssl_process_accept_cb(rb_fde_t *F, int status, struct sockaddr *addr, rb_socklen_t len, void *data){tconn_t *conn = data;tchar buf[5 + RB_SSL_CERTFP_LEN];tif(status == RB_OK)t{ttif(rb_get_ssl_certfp(F, &buf[5]))tt{tttbuf[0] = 'F';tttint32_to_buf(&buf[1], conn->id);tttmod_cmd_write_queue(conn->ctl, buf, sizeof buf);tt}ttconn_mod_read_cb(conn->mod_fd, conn);ttconn_plain_read_cb(conn->plain_fd, conn);ttreturn;t}t/* ircd doesn't care about the reason for this */tclose_conn(conn, NO_WAIT, 0);treturn;}""",2,"cwe119,cwe120"
"coff_init(void){  if (state.objfile != named) {    strncpy(state.objfilename, state.basefilename, sizeof(state.objfilename));    strncat(state.objfilename, "".o"", sizeof(state.objfilename));    }  if (state.objfile == suppress) {    state.obj.enabled = false;    unlink(state.objfilename);  } else {    if (state.processor_chosen == 0) {      state.obj.enabled = false;    } else {      state.obj.object = gp_coffgen_init();      state.obj.object->filename = strdup(state.objfilename);      state.obj.object->processor = state.processor;      state.obj.object->class = state.device.class;      state.obj.object->isnew = state.obj.newcoff;      state.obj.enabled = true;    }  }    return;}",2,"cwe120,cweother"
"_open_default_oss_device (char **dev_path, int id, int blocking){tint fd;        char buf[80];t         if(id>0){          sprintf(buf,""/dev/sound/dsp%d"",id);          if(!(*dev_path = strdup(buf)))            return -1;        }else{          if(!(*dev_path = strdup(""/dev/sound/dsp"")))            return -1;        }#ifdef BROKEN_OSStfd = open(*dev_path, O_WRONLY | O_NONBLOCK);#elsetfd = open(*dev_path, O_WRONLY);#endif  t tif(fd < 0)t{tt ttfree(*dev_path);                if(id>0){                  sprintf(buf,""/dev/dsp%d"",id);                  if(!(*dev_path = strdup(buf)))                    return -1;                }else{                  if(!(*dev_path = strdup(""/dev/dsp"")))                    return -1;                }#ifdef BROKEN_OSSttfd = open(*dev_path, O_WRONLY | O_NONBLOCK);#elsettfd = open(*dev_path, O_WRONLY);#endif  t}#ifdef BROKEN_OSSt tif (fd >= 0 && blocking) {ttif (fcntl(fd, F_SETFL, 0) < 0) {  ttt tttclose(fd);tttfd = -1;tt}t}#endif  t tif(fd < 0)t{                 ttfree(*dev_path);tt*dev_path = NULL;t}treturn fd;}",4,"cwe119,cwe120,cwe476,cweother"
"client_cert_cb(ssl_handle ssl, X509 **x509, EVP_PKEY **pkey){tstruct tls_info *info=(struct tls_info *)SSL_get_app_data(ssl);tint i;tconst char *pem_cert;tsize_t pem_cert_size;tSTACK_OF(X509_NAME) *client_cas;tint cert_num=0;tint rc;tif (info->getpemclientcert4ca == NULL)ttreturn 0;trc=0;tclient_cas=SSL_get_client_CA_list(ssl);tif (info->loadpemclientcert4ca)tt(*info->loadpemclientcert4ca)(info->app_data);tfor (cert_num=0; (*info->getpemclientcert4ca)(cert_num, &pem_cert,tttttt      &pem_cert_size,tttttt      info->app_data);t     ++cert_num)t{ttBIO *certbio;ttint err;ttX509 *x;ttERR_clear_error();ttcertbio=BIO_new_mem_buf((void *)pem_cert, pem_cert_size);ttif (!certbio)tt{tttrc= -1;tttbreak;tt}ttx=PEM_read_bio_X509(certbio, x509, NULL, NULL);ttif (!x)tt{tttBIO_free(certbio);tttcontinue;tt}ttfor (i=0; client_cas && i<client_cas->stack.num; i++)tt{tttX509_NAME *cert=(X509_NAME *)client_cas->stack.data[i];tttif (X509_NAME_cmp(cert,ttttt  x->cert_info->issuer) == 0)ttttbreak;tt}ttif (!client_cas || i >= client_cas->stack.num)tt{tttBIO_free(certbio);tttcontinue;tt}ttwhile ((x=PEM_read_bio_X509(certbio, NULL,ttttt    NULL, 0)) != NULL)tt{tttif (SSL_CTX_add_extra_chain_cert(SSL_get_SSL_CTX(ssl),ttttttt x)ttt    != 1)ttt{ttttX509_free(x);ttttrc= -1;ttttbreak;ttt}tt}tterr = ERR_peek_last_error();ttif (rc || ERR_GET_LIB(err) != ERR_LIB_PEM ||tt    ERR_GET_REASON(err) != PEM_R_NO_START_LINE)tt{tttBIO_free(certbio);tttcontinue;tt}ttBIO_free(certbio);ttERR_clear_error();ttcertbio=BIO_new_mem_buf((void *)pem_cert, pem_cert_size);ttif (!certbio)tt{tttrc= -1;tttbreak;tt}ttif (!PEM_read_bio_PrivateKey(certbio, pkey, NULL, NULL))tt{tttBIO_free(certbio);tttcontinue;tt}ttBIO_free(certbio);ttrc=1;ttbreak;t}tERR_clear_error();t(*info->releasepemclientcert4ca)(info->app_data);treturn rc;}",2,"cwe120,cweother"
"get_creds(krb5_context context, const char *keytab_str,t  krb5_ccache *cache, const char *serverhost){    krb5_keytab keytab;    krb5_principal client;    krb5_error_code ret;    krb5_get_init_creds_opt *init_opts;    krb5_creds creds;    char *server;    char keytab_buf[256];    int aret;    if (keytab_str == NULL) {tret = krb5_kt_default_name (context, keytab_buf, sizeof(keytab_buf));tif (ret)t    krb5_err (context, 1, ret, ""krb5_kt_default_name"");tkeytab_str = keytab_buf;    }    ret = krb5_kt_resolve(context, keytab_str, &keytab);    if(ret)tkrb5_err(context, 1, ret, ""%s"", keytab_str);    ret = krb5_sname_to_principal (context, slave_str, IPROP_NAME,tttt   KRB5_NT_SRV_HST, &client);    if (ret) krb5_err(context, 1, ret, ""krb5_sname_to_principal"");    ret = krb5_get_init_creds_opt_alloc(context, &init_opts);    if (ret) krb5_err(context, 1, ret, ""krb5_get_init_creds_opt_alloc"");    aret = asprintf (&server, ""%s/%s"", IPROP_NAME, serverhost);    if (aret == -1 || server == NULL)tkrb5_errx (context, 1, ""malloc: no memory"");    ret = krb5_get_init_creds_keytab(context, &creds, client, keytab,tttt     0, server, init_opts);    free (server);    krb5_get_init_creds_opt_free(context, init_opts);    if(ret) krb5_err(context, 1, ret, ""krb5_get_init_creds"");    ret = krb5_kt_close(context, keytab);    if(ret) krb5_err(context, 1, ret, ""krb5_kt_close"");    ret = krb5_cc_new_unique(context, krb5_cc_type_memory, NULL, cache);    if(ret) krb5_err(context, 1, ret, ""krb5_cc_new_unique"");    ret = krb5_cc_initialize(context, *cache, client);    if(ret) krb5_err(context, 1, ret, ""krb5_cc_initialize"");    ret = krb5_cc_store_cred(context, *cache, &creds);    if(ret) krb5_err(context, 1, ret, ""krb5_cc_store_cred"");    krb5_free_cred_contents(context, &creds);    krb5_free_principal(context, client);}",2,"cwe119,cwe120"
"open_data_file (const char *file_name){  FILE *fp;  char *src_dir;  char default_srcdir[] = ""."";  src_dir = getenv (""srcdir"");  if (src_dir == NULL)    src_dir = default_srcdir;  pathname = (char *) malloc ((strlen (src_dir)) + strlen (file_name) + 2);  if (pathname == NULL)    {      printf (""Cannot allocate memory"");      exit (1);    }  sprintf (pathname, ""%s/%s"", src_dir, file_name);  fp = fopen (pathname, ""r"");  if (fp == NULL)    {      fprintf (stderr, ""Unable to open %s"", pathname);      exit (1);    }  return fp;}",2,"cwe120,cweother"
"phase1_getc (){  int c;  if (phase1_pushback_length)    c = phase1_pushback[--phase1_pushback_length];  else    {      c = getc (fp);      if (first_character)        {          first_character = 0;                     if (c == '#')            {              while (c != '' && c != EOF)                c = getc (fp);              if (c == '')                {                  line_number++;                  c = getc (fp);                }            }        }      if (c == EOF)        {          if (ferror (fp))            error (EXIT_FAILURE, errno, _(""error while reading ""%s""""),                   real_file_name);          return EOF;        }    }  if (c == '')    line_number++;  return c;}",2,"cwe120,cweother"
"chirp_client_lgetxattr(struct chirp_client * c, const char *path, const char *name, void *data, size_t size, time_t stoptime){tchar safepath[CHIRP_LINE_MAX];turl_encode(path, safepath, sizeof(safepath));tINT64_T result = send_command(c, stoptime, ""lgetxattr %s %s"", safepath, name);tif(result < 0)ttreturn result;tresult = get_result(c, stoptime);tif(result < 0) {ttif(errno == EINVAL)ttterrno = ENOATTR;ttreturn result;t} else if(result > (int) size) {ttlink_soak(c->link, result, stoptime);tterrno = ERANGE;ttreturn result;t}tif(!link_read(c->link, data, result, stoptime)) {ttreturn -1;t}treturn result;}",2,"cwe119,cwe120"
"do_detached_signature_verify(BODY *b, long msgno, char *section){    PKCS7   *p7 = NULL;    BIOt    *in = NULL;    PART    *p;    intt     result, modified_the_body = 0;    char     newSec[100];    char    *what_we_did;    dprint((9, ""do_detached_signature_verify(msgno=%ld type=%d subtype=%s section=%s)"", msgno, b->type, b->subtype ? b->subtype : ""NULL"", (section && *section) ? section : (section != NULL) ? ""Top"" : ""NULL""));    smime_init();    snprintf(newSec, sizeof(newSec), ""%s%s1"", section ? section : """", (section && *section) ? ""."" : """");    in = raw_part_to_bio(msgno, newSec);    if(in){tsnprintf(newSec, sizeof(newSec), ""%s%s2"", section ? section : """", (section && *section) ? ""."" : """");        p7 = get_pkcs7_from_part(msgno, newSec);        if(!p7)          goto end;    tresult = do_signature_verify(p7, in, NULL);        if(b->subtype)t  fs_give((void**) &b->subtype);        b->subtype = cpystr(OUR_PKCS7_ENCLOSURE_SUBTYPE);        b->encoding = ENC8BIT;    tif(b->description)t  fs_give ((void**) &b->description);   twhat_we_did = result ? t_(""This message was cryptographically signed."") :t    t    t    t_(""This message was cryptographically signed but the signature could not be verified."");tb->description = cpystr(what_we_did);    tb->sparep = p7;tp7 = NULL;    tp = b->nested.part;tt tif(p && p->next)t  mail_free_body_part(&p->next);  tBIO_free(in);tmodified_the_body = 1;    }end:    PKCS7_free(p7);    return modified_the_body;}",2,"cwe119,cwe120"
"read_conffiles(section **Section, char *groupfile){tstatic section *conf_dat = NULL;tstatic int read_again = 0;tauto char    s[6][BUFSIZ];tauto char **vars  = NULL;tauto char **files = NULL;tauto int    fileflag[6];tauto int    i = 0;tauto int      RetCode = -1;t*Section = NULL;tif (!read_again)t{t  sprintf(s[0], ""%s%c%s"", confdir(), C_SLASH, CONFFILE);t  sprintf(s[1], ""%s%c%s"", confdir(), C_SLASH, CALLERIDFILE);ttif (paranoia_check(s[0]))tttreturn -1;ttif (paranoia_check(s[1]))tttreturn -1;t  append_element(&files,s[0]);t  fileflag[i++] = MERGE_FILE;t  append_element(&files,s[1]);t  fileflag[i++] = APPEND_FILE;t  if (groupfile != NULL)t  {tt  strcpy(s[2],groupfile);tttappend_element(&files,s[2]);t  tfileflag[i++] = MERGE_FILE;tt}t  strcpy(s[3],expand_file(USERCONFFILE));ttappend_element(&files,s[3]);t  fileflag[i++] = MERGE_FILE;t}tsprintf(s[4],""%s|%s/%s|!%s"",CONF_SEC_MSN,CONF_SEC_NUM,CONF_ENT_NUM,CONF_ENT_SI);tappend_element(&vars,s[4]); tif ((RetCode = read_files(&conf_dat, files, fileflag, vars, C_OVERWRITE|C_NOT_UNIQUE|C_NO_WARN_FILE)) > 0)t{tt*Section = conf_dat;ttif (Set_Codes(conf_dat) != 0)tttreturn -1;t}telsett*Section = conf_dat;tif (!read_again)ttdelete_element(&files,0);tdelete_element(&vars,0);tread_again = 1;treturn RetCode;}",2,"cwe119,cwe120"
"read_token(void *link, void **bufp, size_t * sizep){tchar line[AUTH_LINE_MAX];ttime_t stoptime = time(0) + 3600;tint result;tif(link_readline(link, line, sizeof(line), stoptime)) {tt*sizep = atoi(line);tt*bufp = malloc(*sizep);ttif(*bufp) {tttresult = link_read(link, *bufp, *sizep, stoptime);tttif(result == (int) *sizep) {ttttreturn GLOBUS_SUCCESS;ttt}tttfree(*bufp);tt}t}treturn GLOBUS_GSS_ASSIST_TOKEN_EOF;}",3,"cwe119,cwe120,cweother"
"_errTotalLinf(double *retP, gageOptimSigContext *oscx,              unsigned int mmIdx[2], double mmErr[2]) {  static const char me[]=""_errTotalLinf"";  unsigned int ii, pi;  double *err, *sem, *rr, rho, sig, pid;  int outside;  err = AIR_CAST(double *, oscx->nerr->data);  sem = oscx->sampleErrMax;  rr = oscx->rhoRange;  for (pi=0; pi<=oscx->sampleNum-2; pi++) {    sem[pi] = 0;  }     for (ii=0; ii<oscx->trueImgNum-1; ii++) {         rho = AIR_AFFINE(0, ii, oscx->trueImgNum-1, rr[0], rr[1]);    if (_errSingle(err + ii, oscx, rho)) {      biffAddf(GAGE, ""%s: trouble at ii %u"", me, ii);      return 1;    }    sig = _SigOfRho(rho);    pid = gageStackWtoI(oscx->gctx, sig, &outside);    pi = AIR_CAST(unsigned int, pid);    if (outside || !(pi <= oscx->sampleNum-2)) {      biffAddf(GAGE, ""%s: ii %u -> rho %g -> sig %g -> pi %u-> OUTSIDE"",               me, ii, rho, sig, pi);      return 1;    }    sem[pi] = AIR_MAX(sem[pi], err[ii]);  }  mmIdx[0] = mmIdx[1] = 0;  mmErr[0] = mmErr[1] = sem[0];  for (pi=1; pi<=oscx->sampleNum-2; pi++) {    if (sem[pi] < mmErr[0]) {      mmIdx[0] = pi;      mmErr[0] = sem[pi];    }    if (sem[pi] > mmErr[1]) {      mmIdx[1] = pi;      mmErr[1] = sem[pi];    }  }     *retP = 1000*oscx->sampleNum*(mmErr[1] - mmErr[0])/(rr[1] - rr[0]);  if (0) {    static unsigned int call=0;    char fname[AIR_STRLEN_SMALL];    sprintf(fname, ""err-%04u.nrrd"", call);    nrrdSave(fname, oscx->nerr, NULL);    call++;  }  return 0;}",2,"cwe119,cwe120"
"cmd_fmt_merge_msg(int argc, const char **argv, const char *prefix){tconst char *inpath = NULL;tconst char *message = NULL;tstruct option options[] = {tt{ OPTION_INTEGER, 0, ""log"", &shortlog_len, ""n"",tt  ""populate log with at most <n> entries from shortlog"",tt  PARSE_OPT_OPTARG, NULL, DEFAULT_MERGE_LOG_LEN },tt{ OPTION_INTEGER, 0, ""summary"", &shortlog_len, ""n"",tt  ""alias for --log (deprecated)"",tt  PARSE_OPT_OPTARG | PARSE_OPT_HIDDEN, NULL,tt  DEFAULT_MERGE_LOG_LEN },ttOPT_STRING('m', ""message"", &message, ""text"",ttt""use <text> as start of message""),ttOPT_FILENAME('F', ""file"", &inpath, ""file to read from""),ttOPT_END()t};tFILE *in = stdin;tstruct strbuf input = STRBUF_INIT, output = STRBUF_INIT;tint ret;tgit_config(fmt_merge_msg_config, NULL);targc = parse_options(argc, argv, prefix, options, fmt_merge_msg_usage,ttt     0);tif (argc > 0)ttusage_with_options(fmt_merge_msg_usage, options);tif (message && !shortlog_len) {ttchar nl = '';ttwrite_in_full(STDOUT_FILENO, message, strlen(message));ttwrite_in_full(STDOUT_FILENO, &nl, 1);ttreturn 0;t}tif (shortlog_len < 0)ttdie(""Negative --log=%d"", shortlog_len);tif (inpath && strcmp(inpath, ""-"")) {ttin = fopen(inpath, ""r"");ttif (!in)tttdie_errno(""cannot open '%s'"", inpath);t}tif (strbuf_read(&input, fileno(in), 0) < 0)ttdie_errno(""could not read input file"");tif (message)ttstrbuf_addstr(&output, message);tret = fmt_merge_msg(&input, &output,ttt    message ? 0 : 1,ttt    shortlog_len);tif (ret)ttreturn ret;twrite_in_full(STDOUT_FILENO, output.buf, output.len);treturn 0;}",2,"cwe469,cweother"
"setup_data_read(struct file *file, char __user *user_buf,ttt       size_t count, loff_t *ppos){tstruct setup_data_node *node = file->private_data;tunsigned long remain;tloff_t pos = *ppos;tstruct page *pg;tvoid *p;tu64 pa;tif (pos < 0)ttreturn -EINVAL;tif (pos >= node->len)ttreturn 0;tif (count > node->len - pos)ttcount = node->len - pos;tpa = node->paddr + sizeof(struct setup_data) + pos;tpg = pfn_to_page((pa + count - 1) >> PAGE_SHIFT);tif (PageHighMem(pg)) {ttp = ioremap_cache(pa, count);ttif (!p)tttreturn -ENXIO;t} elsettp = __va(pa);tremain = copy_to_user(user_buf, p, count);tif (PageHighMem(pg))ttiounmap(p);tif (remain)ttreturn -EFAULT;t*ppos = pos + count;treturn count;}",2,"cwe119,cwe120"
"md5string(CTX ctx, knh_conv_t *conv, const char* buf, size_t len, kBytes *tobuf){tMD5_CTX md5_ctx;tunsigned char md5buf[MD5_DIGEST_LENGTH] = {0};tMD5_Init(&md5_ctx);tMD5_Update(&md5_ctx, (char*)buf, len);tMD5_Final(md5buf, &md5_ctx);t{ttchar dbuf[4];ttsize_t i;ttfor (i = 0; i< MD5_DIGEST_LENGTH; i++) {tttknh_snprintf(dbuf, sizeof(dbuf), ""%02x"", md5buf[i]);tttknh_Bytes_write2(ctx, tobuf, dbuf, 2);tt}t}treturn 1;}",2,"cwe119,cwe120"
"dw2_force_const_mem (rtx x){  splay_tree_node node;  const char *str;  tree decl;  if (! indirect_pool)    indirect_pool = splay_tree_new_ggc (splay_tree_compare_pointers);  if (GET_CODE (x) != SYMBOL_REF)    abort ();  str = (* targetm.strip_name_encoding) (XSTR (x, 0));  node = splay_tree_lookup (indirect_pool, (splay_tree_key) str);  if (node)    decl = (tree) node->value;  else    {      tree id;      if (USE_LINKONCE_INDIRECT)t{t  char *ref_name = alloca (strlen (str) + sizeof ""DW.ref."");t  sprintf (ref_name, ""DW.ref.%s"", str);t  id = get_identifier (ref_name);t  decl = build_decl (VAR_DECL, id, ptr_type_node);t  DECL_ARTIFICIAL (decl) = 1;t  TREE_PUBLIC (decl) = 1;t  DECL_INITIAL (decl) = decl;t  make_decl_one_only (decl);t}      elset{t  char label[32];t  ASM_GENERATE_INTERNAL_LABEL (label, ""LDFCM"", dw2_const_labelno);t  ++dw2_const_labelno;t  id = get_identifier (label);t  decl = build_decl (VAR_DECL, id, ptr_type_node);t  DECL_ARTIFICIAL (decl) = 1;t  TREE_STATIC (decl) = 1;t  DECL_INITIAL (decl) = decl;t}      id = maybe_get_identifier (str);      if (id)tTREE_SYMBOL_REFERENCED (id) = 1;      splay_tree_insert (indirect_pool, (splay_tree_key) str,ttt (splay_tree_value) decl);    }  return XEXP (DECL_RTL (decl), 0);}",2,"cwe119,cwe120"
"perform_callback_write_ckpt_header(){  char tmpDMTCPHeaderBuf[PATH_MAX];  char pattern[] = ""/dmtcp.XXXXXX"";  char *tmpStr;  char *tmpDMTCPHeaderFileName = tmpDMTCPHeaderBuf;  tmpDMTCPHeaderBuf[sizeof(tmpDMTCPHeaderBuf)-1] = '0';    tmpStr = getenv(""DMTCP_TMPDIR"");  if (tmpStr == NULL) tmpStr = getenv(""TMPDIR"");  if (tmpStr == NULL) tmpStr = ""/tmp"";  strncpy(tmpDMTCPHeaderBuf, tmpStr, sizeof(tmpDMTCPHeaderBuf)-sizeof(pattern));  strncpy(tmpDMTCPHeaderBuf+strlen(tmpDMTCPHeaderBuf), pattern,sizeof(pattern));  if (tmpDMTCPHeaderBuf[sizeof(tmpDMTCPHeaderBuf)-1] != '0') {    MTCP_PRINTF(""*** Path of DMTCP_TMPDIR or TMPDIR is too long.""                ""*** Increase size of tmpDMTCPHeaderBuf, and re-compile."");    mtcp_abort();  }  int tmpfd = -1;  if (callback_write_ckpt_header != NULL) {         tmpfd = mkstemp(tmpDMTCPHeaderFileName);    if (tmpfd < 0) {      MTCP_PRINTF(""error %d creating temp file: %s"", errno, strerror(errno));      mtcp_abort();    }    if (unlink(tmpDMTCPHeaderFileName) == -1) {      MTCP_PRINTF(""error %d unlinking temp file: %s"", errno, strerror(errno));    }         (*callback_write_ckpt_header)(tmpfd);  }  return tmpfd;}",3,"cwe119,cwe120,cweother"
"is_binary(const char *path){tint ip;tchar buf[32];tint i, c, size;tip = open(path, O_RDONLY);tif (ip < 0)ttdie(""cannot open file '%s' in read mode."", path);tsize = read(ip, buf, sizeof(buf));tclose(ip);tif (size < 0)ttreturn 1;tif (size >= 7 && locatestring(buf, ""!<arch>"", MATCH_AT_FIRST))ttreturn 1;tfor (i = 0; i < size; i++) {ttc = (unsigned char)buf[i];ttif (c == 0 || c > 127)tttreturn 1;t}treturn 0;}",3,"cwe119,cwe120,cweother"
"caml_md5_chan(value vchan, value len){  CAMLparam2 (vchan, len);  struct channel * chan = Channel(vchan);  struct MD5Context ctx;  value res;  intnat toread, read;  char buffer[4096];  Lock(chan);  caml_MD5Init(&ctx);  toread = Long_val(len);  if (toread < 0){    while (1){      read = caml_getblock (chan, buffer, sizeof(buffer));      if (read == 0) break;      caml_MD5Update (&ctx, (unsigned char *) buffer, read);    }  }else{    while (toread > 0) {      read = caml_getblock(chan, buffer,                           toread > sizeof(buffer) ? sizeof(buffer) : toread);      if (read == 0) caml_raise_end_of_file();      caml_MD5Update(&ctx, (unsigned char *) buffer, read);      toread -= read;    }  }  res = caml_alloc_string(16);  caml_MD5Final(&Byte_u(res, 0), &ctx);  Unlock(chan);  CAMLreturn (res);}",3,"cwe119,cwe120,cweother"
"pdf_add_resource(gx_device_pdf *pdev, cos_dict_t *pcd, const char *key, pdf_resource_t *pres){    if (pcd != 0) {        const cos_value_t *v = cos_dict_find(pcd, (const byte *)key, strlen(key));        cos_dict_t *list;        int code;        char buf[10 + (sizeof(long) * 8 / 3 + 1)], buf1[sizeof(pres->rname) + 1];        if (pdev->ForOPDFRead && !pres->global && pdev->accumulating_a_global_object) {            pres->global = true;            code = cos_dict_put_c_key_bool((cos_dict_t *)pres->object, ""/.Global"", true);            if (code < 0)                return code;        }        gs_sprintf(buf, ""%ld 0 R"", pres->object->id);        if (v != NULL) {            if (v->value_type != COS_VALUE_OBJECT &&                v->value_type != COS_VALUE_RESOURCE)                return_error(gs_error_unregistered);              list = (cos_dict_t *)v->contents.object;            if (list->cos_procs != &cos_dict_procs)                return_error(gs_error_unregistered);          } else {            list = cos_dict_alloc(pdev, ""pdf_add_resource"");            if (list == NULL)                return_error(gs_error_VMerror);            code = cos_dict_put_c_key_object((cos_dict_t *)pcd, key, (cos_object_t *)list);            if (code < 0)                return code;        }        buf1[0] = '/';        strcpy(buf1 + 1, pres->rname);        return cos_dict_put_string(list, (const byte *)buf1, strlen(buf1),                        (const byte *)buf, strlen(buf));    }    return 0;}",2,"cwe119,cwe120"
"mk_key_name(gchar *user, gchar *host, char type[128]){    gchar *key_name;        if( strstr(type, ""priv"") )      key_name = g_strdup_printf(""%s.%s.key"", user, host);    else      key_name = g_strdup_printf(""%s.%s.key.pub"", user, host);        return key_name;}",2,"cwe119,cwe120"
"load_do(const char *filename, Pixmap *p1, Pixmap *p2){  struct DiskObject *dobj;#ifdef AMIGAOS  char fn[256];  strncpy(fn, prefs.icondir, sizeof(fn)-1);  fn[sizeof(fn)-1]='0';  AddPart(fn,filename,sizeof(fn));#else  int rl=strlen(filename)+strlen(prefs.icondir)+2;#ifdef HAVE_ALLOCA  char *fn=alloca(rl);#else  char fn[1024];#endif  sprintf(fn, ""%s/%s"", prefs.icondir, filename);#endif  fn[strlen(fn)-5]=0;  if((dobj=GetDiskObject(fn))) {    *p1=image_to_pixmap_scr(scr, (struct Image *)dobj->do_Gadget.GadgetRender,ttt    dobj->do_Gadget.Width, dobj->do_Gadget.Height);    *p2=image_to_pixmap_scr(scr, (struct Image *)dobj->do_Gadget.SelectRender,ttt    dobj->do_Gadget.Width, dobj->do_Gadget.Height);    FreeDiskObject(dobj);  } else *p1=*p2=None;}",2,"cwe119,cwe120"
"_gssapi_verify_mic_arcfour(OM_uint32 * minor_status,ttt   const gsskrb5_ctx context_handle,ttt   krb5_context context,ttt   const gss_buffer_t message_buffer,ttt   const gss_buffer_t token_buffer,ttt   gss_qop_t * qop_state,ttt   krb5_keyblock *key,ttt   const char *type){    krb5_error_code ret;    uint32_t seq_number;    OM_uint32 omret;    u_char SND_SEQ[8], cksum_data[8], *p;    char k6_data[16];    int cmp;    if (qop_state)t*qop_state = 0;    p = token_buffer->value;    omret = _gsskrb5_verify_header (&p,tttt       token_buffer->length,tttt       type,tttt       GSS_KRB5_MECHANISM);    if (omret)treturn omret;    if (memcmp(p, ""x11x00"", 2) != 0)  treturn GSS_S_BAD_SIG;    p += 2;    if (memcmp (p, ""xffxffxffxff"", 4) != 0)treturn GSS_S_BAD_MIC;    p += 4;    ret = arcfour_mic_cksum(context,ttt    key, KRB5_KU_USAGE_SIGN,ttt    cksum_data, sizeof(cksum_data),ttt    p - 8, 8,ttt    message_buffer->value, message_buffer->length,ttt    NULL, 0);    if (ret) {t*minor_status = ret;treturn GSS_S_FAILURE;    }    ret = arcfour_mic_key(context, key,ttt  cksum_data, sizeof(cksum_data),ttt  k6_data, sizeof(k6_data));    if (ret) {t*minor_status = ret;treturn GSS_S_FAILURE;    }    cmp = ct_memcmp(cksum_data, p + 8, 8);    if (cmp) {t*minor_status = 0;treturn GSS_S_BAD_MIC;    }    {tEVP_CIPHER_CTX rc4_key;tEVP_CIPHER_CTX_init(&rc4_key);tEVP_CipherInit_ex(&rc4_key, EVP_rc4(), NULL, (void *)k6_data, NULL, 0);tEVP_Cipher(&rc4_key, SND_SEQ, p, 8);tEVP_CIPHER_CTX_cleanup(&rc4_key);tmemset(k6_data, 0, sizeof(k6_data));    }    _gsskrb5_decode_be_om_uint32(SND_SEQ, &seq_number);    if (context_handle->more_flags & LOCAL)tcmp = memcmp(&SND_SEQ[4], ""xffxffxffxff"", 4);    elsetcmp = memcmp(&SND_SEQ[4], ""x00x00x00x00"", 4);    memset(SND_SEQ, 0, sizeof(SND_SEQ));    if (cmp != 0) {t*minor_status = 0;treturn GSS_S_BAD_MIC;    }    HEIMDAL_MUTEX_lock(&context_handle->ctx_id_mutex);    omret = _gssapi_msg_order_check(context_handle->order, seq_number);    HEIMDAL_MUTEX_unlock(&context_handle->ctx_id_mutex);    if (omret)treturn omret;    *minor_status = 0;    return GSS_S_COMPLETE;}",2,"cwe119,cwe120"
"""getln(char *endp)r{r for(;lnlst<endp;lnlst++) if (*lnlst=='' || memcmp(lnlst,utfeol,3)==0) llp++;r return llp;r}""",2,"cwe119,cwe120"
"tcl_func_get_assert_coverage(  ClientData  d,         Tcl_Interp* tcl,       int         argc,      const char* argv[]   ) { PROFILE(TCL_FUNC_GET_ASSERT_COVERAGE);  int        retval = TCL_OK;     char*      inst_name;           char       str[4096];           func_unit* funit;               inst_name = strdup_safe( argv[2] );  if( (funit = tcl_func_get_funit( tcl, argv[1] )) != NULL ) {    char*     assert_mod;    str_link* cp_head;    str_link* cp_tail;    str_link* curr_cp;    curr_db = tcl_func_is_funit( tcl, argv[1] ) ? 1 : 0;    assertion_get_coverage( funit, inst_name, &assert_mod, &cp_head, &cp_tail );    curr_db = 0;    Tcl_SetVar( tcl, ""assert_cov_mod"", assert_mod, TCL_GLOBAL_ONLY );    free_safe( assert_mod, (strlen( assert_mod ) + 1) );    curr_cp = cp_head;    while( curr_cp != NULL ) {      snprintf( str, 4096, ""{%s} %d %d %d {%s}"", curr_cp->str, curr_cp->suppl, curr_cp->suppl2, curr_cp->suppl3, ((curr_cp->str2 != NULL) ? curr_cp->str2 : """") );      Tcl_SetVar( tcl, ""assert_cov_points"", str, (TCL_GLOBAL_ONLY | TCL_APPEND_VALUE | TCL_LIST_ELEMENT) );      curr_cp = curr_cp->next;    }         str_link_delete_list( cp_head );  }  free_safe( inst_name, (strlen( inst_name ) + 1) );  return( retval );}",2,"cwe119,cwe120"
"reporter_reportsettings( ReporterData *data ) {    int win, win_requested;    win = getsock_tcp_windowsize( data->info.transferID,                  (data->mThreadMode == kMode_Listener ? 0 : 1) );    win_requested = data->mTCPWin;    printf( ""%s"", separator_line );    if ( data->mThreadMode == kMode_Listener ) {        printf( server_port,                (isUDP( data ) ? ""UDP"" : ""TCP""),                 data->mPort );    } else {        printf( client_port,                data->mHost,                (isUDP( data ) ? ""UDP"" : ""TCP""),                data->mPort );    }    if ( data->mLocalhost != NULL ) {        printf( bind_address, data->mLocalhost );        if ( SockAddr_isMulticast( &data->connection.local ) ) {            printf( join_multicast, data->mLocalhost );        }    }    if ( isUDP( data ) ) {        printf( (data->mThreadMode == kMode_Listener ?                                    server_datagram_size : client_datagram_size),                data->mBufLen );        if ( SockAddr_isMulticast( &data->connection.peer ) ) {            printf( multicast_ttl, data->info.mTTL);        }    }    byte_snprintf( buffer, sizeof(buffer), win,                   toupper( data->info.mFormat));    printf( ""%s: %s"", (isUDP( data ) ?                                 udp_buffer_size : tcp_window_size), buffer );    if ( win_requested == 0 ) {        printf( "" %s"", window_default );    } else if ( win != win_requested ) {        byte_snprintf( buffer, sizeof(buffer), win_requested,                       toupper( data->info.mFormat));        printf( warn_window_requested, buffer );    }    printf( """" );    printf( ""%s"", separator_line );}",3,"cwe119,cwe120,cweother"
"transfer_cmd_params(int amount, int start, char * argv[], const char * class, GHashTable ** params_ht){tint i, len_tmp;tchar * delimit, * key, * value;tchar buffer[21];tif (amount < start) {ttreturn -1;t}tif ( strncmp(""ocf"", class, strlen(""ocf""))==0t    || strncmp(""stonith"", class, strlen(""stonith""))==0) {tt*params_ht = g_hash_table_new(g_str_hash, g_str_equal);ttfor (i=start; i<amount; i++) {tttdelimit = strchr(argv[i], '=');tttif (!delimit) {ttttcl_log(LOG_ERR, ""Parameter %s is invalid for ""ttttt""the OCF standard."", argv[i]);ttttgoto error_return;  ttt}tttlen_tmp = strnlen(delimit+1, MAX_PARAM_LEN) + 1;tttvalue = g_new(gchar, len_tmp);tttstrncpy(value, delimit+1, len_tmp);tttlen_tmp = strnlen(argv[i], MAX_PARAM_LEN) - strnlen(delimit, MAX_PARAM_LEN);tttkey = g_new(gchar, len_tmp+1);tttkey[len_tmp] = '0';tttstrncpy(key, argv[i], len_tmp);ttttttg_hash_table_insert(*params_ht, key, value);tt}t} else if ( strncmp(""lsb"", class, strlen(""lsb"")) == 0tt   || strncmp(""heartbeat"", class, strlen(""heartbeat"")) == 0 ) {tt tt*params_ht = g_hash_table_new(g_str_hash, g_str_equal);ttmemset(buffer, '0', 21);ttfor (i=start; i<amount; i++) {tttsnprintf(buffer, 20, ""%d"", i-start+1);tttg_hash_table_insert( *params_ht, g_strdup(buffer), ttttttg_strdup(argv[i]));ttt tt}t} else {ttfprintf(stderr, ""Not supported resource agent class."");ttreturn -1;t}treturn 0;error_return:tif (*params_ht) {ttg_hash_table_foreach(*params_ht, free_stritem_of_hashtable, NULL);ttg_hash_table_destroy(*params_ht);tt*params_ht = NULL;t}treturn -1;}",2,"cwe119,cwe120"
"int8out(PG_FUNCTION_ARGS){tint64ttval = PG_GETARG_INT64(0);tchart   *result;tinttttlen;tcharttbuf[MAXINT8LEN + 1];tif ((len = snprintf(buf, MAXINT8LEN, INT64_FORMAT, val)) < 0)ttelog(ERROR, ""could not format int8"");tresult = pstrdup(buf);tPG_RETURN_CSTRING(result);}",3,"cwe119,cwe120,cweother"
"parse_opts(int argc, char *argv[]){tstatic struct option long_options[] = {tt{""cfg"", required_argument, 0, 'c'},tt{""name"", required_argument, 0, 0},tt{""nousgn"", no_argument, 0, 1},tt{""lua"", required_argument, 0, 'l'},tt{""debug"", no_argument, 0, 'd'},tt{""strict"", no_argument, 0, 's'},tt{0, 0, 0, 0}t};twhile (1){ttint option_index = 0;ttint c = getopt_long (argc, argv, ""c:"", long_options, &option_index);ttif (c<0) return;ttswitch (c){ttcase 'c':tttcfg_file = optarg;tttbreak;ttcase 'l':tttlua_file = optarg;tttbreak;ttcase 'd':tttdebug = 1;tttbreak;ttcase 's':tttlua_strict = 1;tttbreak;ttcase 0:tttsv_name = (unsigned char*)optarg;tttbreak;ttcase 1:tttno_usgn = 1;tttbreak;ttdefault:tttreturn;tt}t}}",2,"cwe120,cweother"
"opt_preset(const char *opt, const char *arg){    FILE *f=NULL;    char filename[1000], tmp[1000], tmp2[1000], line[1000];    int i;    const char *base[2]= { getenv(""HOME""),                           FFMPEG_DATADIR,                         };    for(i=!base[0]; i<2 && !f; i++){        snprintf(filename, sizeof(filename), ""%s%s/%s.ffpreset"", base[i], i ? """" : ""/.ffmpeg"", arg);        f= fopen(filename, ""r"");        if(!f){            char *codec_name= *opt == 'v' ? video_codec_name :                              *opt == 'a' ? audio_codec_name :                                            subtitle_codec_name;            snprintf(filename, sizeof(filename), ""%s%s/%s-%s.ffpreset"", base[i],  i ? """" : ""/.ffmpeg"", codec_name, arg);            f= fopen(filename, ""r"");        }    }    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||              is_dos_path(arg))){        av_strlcpy(filename, arg, sizeof(filename));        f= fopen(filename, ""r"");    }    if(!f){        fprintf(stderr, ""File for preset '%s' not found"", arg);        av_exit(1);    }    while(!feof(f)){        int e= fscanf(f, ""%999[^]"", line) - 1;        if(line[0] == '#' && !e)            continue;        e|= sscanf(line, ""%999[^=]=%999[^]"", tmp, tmp2) - 2;        if(e){            fprintf(stderr, ""%s: Invalid syntax: '%s'"", filename, line);            av_exit(1);        }        if(!strcmp(tmp, ""acodec"")){            opt_audio_codec(tmp2);        }else if(!strcmp(tmp, ""vcodec"")){            opt_video_codec(tmp2);        }else if(!strcmp(tmp, ""scodec"")){            opt_subtitle_codec(tmp2);        }else if(opt_default(tmp, tmp2) < 0){            fprintf(stderr, ""%s: Invalid option or argument: '%s', parsed as '%s' = '%s'"", filename, line, tmp, tmp2);            av_exit(1);        }    }    fclose(f);    return 0;}",4,"cwe119,cwe120,cwe476,cweother"
"user_exists(G_CONST_RETURN gchar *username){         FILE *fp;    long conf_size;    int x, user_exists = 0;    char tempname[4096]="""";    char *check_buffer;         if((fp=fopen(GS_PASSWD,""r""))==NULL)    {t     }    else      {t    fseek(fp, 0, SEEK_END);t    conf_size = ftell(fp);t    rewind(fp);t    check_buffer = allocate(conf_size);t    if( conf_size > 1 )t    while(fgets(check_buffer, conf_size, fp)!=NULL)t    {ttfor(x=0; check_buffer[x]; x++)tt{tt    if(check_buffer[x]==':')tt    {tttsprintf(tempname, ""%s"", check_buffer);ttttempname[x]='0';tttif( ! strcmp(username, tempname) )ttt{ttt    user_exists = 1;ttt    break;ttt}tt    }tt    if( check_buffer[x]=='0' || check_buffer[x]=='' )tt    break;tt}t    }t    free(check_buffer);      }    fclose(fp);         if((fp=fopen(GS_SHADOW,""r""))==NULL)    {t     }    else      {t    fseek(fp, 0, SEEK_END);t    conf_size = ftell(fp);t    rewind(fp);t    check_buffer = allocate(conf_size);t    if( conf_size > 1 )t    while(fgets(check_buffer, conf_size, fp)!=NULL)t    {ttfor(x=0; check_buffer[x]; x++)tt{tt    if(check_buffer[x]==':')tt    {tttsprintf(tempname, ""%s"", check_buffer);ttttempname[x]='0';tttif( strstr(username, tempname) ttt&& strlen(username) == strlen(tempname) )ttt{ttt    user_exists = 1;ttt    break;ttt}tt    }tt    if( check_buffer[x]=='0' || check_buffer[x]=='' )tt    break;tt}t    }t    free(check_buffer);t    fclose(fp);      }    return user_exists;}",3,"cwe119,cwe120,cweother"
"qmonSubmitAskForAR(Widget w, XtPointer cld, XtPointer cad){   Boolean status = False;   lList *arl = NULL;   lListElem *cep = NULL;   int n, i;   StringConst *strs = NULL;   static char buf[BUFSIZ];   lList *alp = NULL;      DENTER(GUI_LAYER, ""qmonSubmitAskForAR"");      qmonMirrorMultiAnswer(AR_T, &alp);   if (alp) {      qmonMessageBox(w, alp, 0);      lFreeList(&alp);      DEXIT;      return;   }   arl = qmonMirrorList(SGE_AR_LIST);   n = lGetNumberOfElem(arl);   if (n>0) {      char name[BUFSIZ];      strs = (StringConst*)XtMalloc(sizeof(String)*n);       for (cep=lFirst(arl), i=0; i<n; cep=lNext(cep), i++) {        snprintf(name, BUFSIZ-1, sge_u32, lGetUlong(cep, AR_id));                  strs[i] = strdup(name);      }          strcpy(buf, """");             status = XmtAskForItem(w, NULL, ""@{Select an Advance Reservation}"",                        ""@{Available Advance Reservations}"",                         (String*) strs, n, False, buf, BUFSIZ, NULL);             if (status) {         XmtInputFieldSetString(submit_ar, buf);      }             for (i=0; i<n; i++) {         XtFree((char*)strs[i]);      }         XtFree((char*)strs);   }   else      qmonMessageShow(w, True,             ""@{Please submit an Advance Reservation first !}"");      DEXIT;}",3,"cwe119,cwe120,cweother"
"main(int argc, char** argv){   extern int optind;   extern int opterr;   extern char *optarg;   char c;   OPTIONS_T options;   int i;       if (argc <= 1)   {      usage();      return 0;   }       while ((c = getopt(argc, argv, ""?:v"")) != EOF)   {      switch(c)       {t case '?':t    usage();t    return 0;t case 'v':t    options.verbose = 1;t    return 0;      }      argc -= optind;      argv += optind;   }       for (i = 1; i < argc; i++)      if (argc > 0) t do_cfcheck(argv[i], &options);   return CF_NOERR;}",2,"cwe120,cweother"
"execute(const char *command){tpid_t childpid;tFLAG failed;tint status, code;tstruct sigaction act;tconst char *signame;tfailed = 1;txterm_title_set(1,command);tchildpid = fork();tif (childpid == -1)ttprintf(""EXEC: Cannot create new process (%s)"",tt  strerror(errno));telse if (childpid == 0) {tt #ifdef _POSIX_JOB_CONTROLtt ttchildpid = getpid();ttsetpgid(childpid,childpid);tttcsetpgrp(STDIN_FILENO,childpid);#endiftt ttact.sa_handler = SIG_DFL;ttact.sa_flags = 0;ttsigemptyset(&act.sa_mask);ttsigaction(SIGINT,&act,0);ttsigaction(SIGQUIT,&act,0);#ifdef _POSIX_JOB_CONTROLttsigaction(SIGTSTP,&act,0);ttsigaction(SIGTTIN,&act,0);ttsigaction(SIGTTOU,&act,0);#endiftt tt((const char **)shell_argv)[cmd_index] = command;ttexecv(shell_argv[0],shell_argv);ttprintf(""EXEC: Cannot execute shell %s (%s)"",tt  shell_argv[0],strerror(errno));ttexit(99);tt t}telse {tt #ifdef _POSIX_JOB_CONTROLtt ttsetpgid(childpid,childpid);tttcsetpgrp(STDIN_FILENO,childpid);#endifttfor (;  ;) {ttt tttwhile (waitpid(childpid,&status,WUNTRACED) < 0)tttt ;#ifdef _POSIX_JOB_CONTROLttt ttttcsetpgrp(STDIN_FILENO,clex_data.pid);#endiftttif (!WIFSTOPPED(status))ttttbreak;tttputs(tttt""r""tttt""r""tttt""EXEC: CLEX does not provide job controlr""tttt""EXEC: suspended command will be resumed shortlyr""tttt""r"");tttfflush(stdout);#ifdef _POSIX_JOB_CONTROLttt ttttcsetpgrp(STDIN_FILENO,childpid);#endiftttsleep (2);tttkill(-childpid,SIGCONT);tt}tttty_reset();ttif (WIFEXITED(status)) {tttcode = WEXITSTATUS(status);tttif (code == 0) {ttttfailed = 0;ttttfputs(""Command successful. "",stdout);ttt}tttelsettttprintf(""Exit code = %d. "",code);tt}ttelse {tttcode = WTERMSIG(status);tttprintf(""Abnormal termination, signal %d"",code);#ifdef HAVE_STRSIGNALtttsigname = strsignal(code);tttif (signame != 0)ttttprintf("" (%s)"",signame);#else#if HAVE_DECL_SYS_SIGLISTtttsigname = sys_siglist[code];tttif (signame != 0)ttttprintf("" (%s)"",signame);#endif#endif#ifdef WCOREDUMPtttif (WCOREDUMP(status))ttttfputs("", core image dumped"",stdout);#endiftttputchar('');tt}t}t txterm_title_set(0,command);tlist_directory();tppanel_file->other->expired = 1;ttty_press_enter();txterm_title_set(0,0);treturn failed;}",3,"cwe119,cwe120,cweother"
"vxml_parse_tree(vxml_parser_t *vp, xnode_t **root){tstruct vxml_uctx ctx;tstruct vxml_ops ops;tstruct vxml_ptree_ctx *ptx;tvxml_parser_check(vp);tZERO(&ops);tops.plain_start = vxml_ptree_start;tops.plain_end = vxml_ptree_end;tops.plain_text = vxml_ptree_text;tptx = vxml_ptree_ctx_alloc();tctx.ops = &ops;tctx.tokens = NULL;tctx.data = ptx;tvxml_parse_engine(vp, &ctx);tif (VXML_E_OK == vp->error) {ttg_assert(ptx->current != NULL);ttg_assert(0 == slist_length(ptx->stack));tt*root = ptx->current;ttptx->current = NULL;t}tvxml_ptree_ctx_free(ptx);treturn vp->error;}",3,"cwe119,cwe120,cwe469"
"HandleArticle(artBody)char *artBody;{   dSP;   ARTHEADERt*hp;   HVtt*hdr;   intttrc;   chartt*p;   static chartbuf[256];   chartt*argv[] = { NULL };   if (!PerlFilterActive || perl_filter_cv == NULL)     return NULL;       hdr = perl_get_hv(""hdr"", TRUE);   for (hp = ARTheaders; hp < ARTheadersENDOF; hp++)     {       if (hp->Found && hp->Value && strcmp (hp->Name,""Path"") != 0)         hv_store(hdr, (char *) hp->Name, strlen(hp->Name), newSVpv(hp->Value, 0), 0);     }       if (artBody != NULL)#if (PERL_VERSION < 7) || ((PERL_VERSION == 7) && (PERL_SUBVERSION < 1))     hv_store(hdr, (char *) ""__BODY__"", 8, newSVpv(artBody, 0), 0) ;#else     hv_store(hdr, ""__BODY__"", 8, newSVpvn_share(artBody, 0, 42), 0);#endif     if (pathForPerl != NULL)     {       char *p = strchr (pathForPerl,'') ;       *p = '0' ;       hv_store (hdr, (char *) ""Path"", 4, newSVpv(pathForPerl,0), 0) ;       *p = '' ;     }   ENTER ;   SAVETMPS ;   rc = perl_call_argv (""filter_art"", G_EVAL|G_SCALAR, argv);   SPAGAIN;   hv_undef(hdr);   buf [0] = '0' ;      if (SvTRUE(ERRSV))           {       syslog (L_ERROR,""Perl function filter_art died: %s"",               SvPV(ERRSV, PL_na)) ;       POPs ;       PerlFilter (FALSE) ;     }   else if (rc == 1)     {       p = POPp;       if (p != NULL && *p != '0')         {           strncpy(buf, p, sizeof(buf) - 1);           buf[sizeof(buf) - 1] = '0';         }     }    PUTBACK;   FREETMPS;   LEAVE;   if (buf[0] != '0')       return buf ;   return NULL;}",3,"cwe119,cwe120,cwe469"
"""fts_alloc (FTS *sp, const char *name, register size_t namelen){        register FTSENT *p;        size_t len;        /*         * The file name is a variable length array.  Allocate the FTSENT         * structure and the file name in one chunk.         */        len = sizeof(FTSENT) + namelen;        if ((p = malloc(len)) == NULL)                return (NULL);        /* Copy the name and guarantee NUL termination. */        memcpy(p->fts_name, name, namelen);        p->fts_name[namelen] = '0';        p->fts_namelen = namelen;        p->fts_fts = sp;        p->fts_path = sp->fts_path;        p->fts_errno = 0;        p->fts_dirp = NULL;        p->fts_flags = 0;        p->fts_instr = FTS_NOINSTR;        p->fts_number = 0;        p->fts_pointer = NULL;        return (p);}""",2,"cwe120,cweother"
"whlp_file_add_short(struct file *f, int data){    unsigned char s[2];    PUT_16BIT_LSB_FIRST(s, data);    whlp_file_add(f, s, 2);}",2,"cwe119,cwe120"
"""pkinit_libdefault_strings(krb5_context context, const krb5_data *realm,                          const char *option, char ***ret_value){    profile_t profile;    const char *names[5];    char **values = NULL;    krb5_error_code retval;    char realmstr[1024];    if (realm != NULL && realm->length > sizeof(realmstr)-1)        return EINVAL;    if (realm != NULL) {        strncpy(realmstr, realm->data, realm->length);        realmstr[realm->length] = '0';    }    if (!context || (context->magic != KV5M_CONTEXT))        return KV5M_CONTEXT;    profile = context->profile;    if (realm != NULL) {        /*         * Try number one:         *         * [libdefaults]         *        REALM = {         *                option = <value>         *        }         */        names[0] = KRB5_CONF_LIBDEFAULTS;        names[1] = realmstr;        names[2] = option;        names[3] = 0;        retval = profile_get_values(profile, names, &values);        if (retval == 0 && values != NULL && values[0] != NULL)            goto goodbye;        /*         * Try number two:         *         * [realms]         *      REALM = {         *              option = <value>         *      }         */        names[0] = KRB5_CONF_REALMS;        names[1] = realmstr;        names[2] = option;        names[3] = 0;        retval = profile_get_values(profile, names, &values);        if (retval == 0 && values != NULL && values[0] != NULL)            goto goodbye;    }    /*     * Try number three:     *     * [libdefaults]     *        option = <value>     */    names[0] = KRB5_CONF_LIBDEFAULTS;    names[1] = option;    names[2] = 0;    retval = profile_get_values(profile, names, &values);    if (retval == 0 && values != NULL && values[0] != NULL)        goto goodbye;goodbye:    if (values == NULL)        return ENOENT;    *ret_value = values;    return retval;}""",2,"cwe119,cwe120"
"variable_curvature_read (GtsObject ** o, GtsFile * fp){  GfsVariableCurvature * v = GFS_VARIABLE_CURVATURE (*o);  GfsDomain * domain;  (* GTS_OBJECT_CLASS (gfs_variable_curvature_class ())->parent_class->read) (o, fp);  if (fp->type == GTS_ERROR)    return;  if (fp->type != GTS_STRING) {    gts_file_error (fp, ""expecting a string (fraction or distance)"");    return;  }  domain = GFS_DOMAIN (gfs_object_simulation (*o));  if (!(v->f = gfs_variable_from_name (domain->variables, fp->token->str))) {    gts_file_error (fp, ""unknown variable `%s'"", fp->token->str);    return;  }  g_free (GFS_VARIABLE1 (v)->description);  GFS_VARIABLE1 (v)->description = NULL;  if (GFS_IS_VARIABLE_TRACER (v->f)) {    if (!GFS_IS_VARIABLE_TRACER_VOF (v->f)) {       gts_file_error (fp, ""variable `%s' is not a VOF tracer"", fp->token->str);       return;    }    GFS_VARIABLE1 (v)->description = g_strjoin ("" "", tttttt""Curvature of the interface defined by tracer"",ttttttv->f->name, NULL);    gts_file_next_token (fp);    if (fp->type == GTS_STRING) {      v->kmax = gfs_domain_get_or_add_variable (domain, fp->token->str, ""Maximum curvature"");      if (v->kmax) {tv->kmax->coarse_fine = curvature_coarse_fine;tv->kmax->fine_coarse = curvature_fine_coarse;tgts_file_next_token (fp);      }      else if (!GFS_IS_VARIABLE_POSITION (v)) {tgts_file_error (fp, ""`%s' is a reserved variable name"", fp->token->str);treturn;      }    }  }  else if (GFS_IS_VARIABLE_DISTANCE (v->f)) {    GFS_VARIABLE1 (v)->description = g_strjoin ("" "", tttttt""Curvature of the interface defined by distance"",ttttttv->f->name, NULL);     gts_file_next_token (fp);  }  else {    gts_file_error (fp, ""variable `%s' is neither a tracer nor a distance"", fp->token->str);    return;  }  GFS_VARIABLE1 (v)->units = -1.;  if (v->kmax)    v->kmax->units = -1.;}",2,"cwe120,cweother"
"jk_dump_buff(jk_logger_t *l,                  const char *file,                  int line, const char *funcname,                  int level, char *what, jk_msg_buf_t *msg){    int i = 0;    char lb[80];    char *current;    int j;    int len = msg->len;    if (l == NULL)        return;    if (l->level != JK_LOG_TRACE_LEVEL && len > 1024)        len = 1024;    jk_log(l, file, line, funcname, level,           ""%s pos=%d len=%d max=%d"",           what, msg->pos, msg->len, msg->maxlen);    for (i = 0; i < len; i += 16) {        current = &lb[0];        for (j = 0; j < 16; j++) {            unsigned char x = (msg->buf[i + j]);            if ((i + j) >= len)                x = 0;            *current++ = jk_HEX[x >> 4];            *current++ = jk_HEX[x & 0x0f];            *current++ = ' ';        }        *current++ = ' ';        *current++ = '-';        *current++ = ' ';        for (j = 0; j < 16; j++) {            unsigned char x = msg->buf[i + j];            if ((i + j) >= len)                x = 0;            if (x > 0x20 && x < 0x7F) {#ifdef USE_CHARSET_EBCDIC               *current = x;               jk_xlate_from_ascii(current, 1);               current++;#else              *current++ = x;#endif            }            else {                *current++ = '.';            }        }        *current++ = '0';            jk_log(l, file, line, funcname, level,                   ""%.4x    %s"", i, lb);    }}",2,"cwe119,cwe120"
"escape_string_for_mysql(CHARSET_INFO *charset_info,                               char *to, size_t to_length,                               const char *from, size_t length){  const char *to_start= to;  const char *end, *to_end=to_start + (to_length ? to_length-1 : 2*length);  my_bool overflow= FALSE;#ifdef USE_MB  my_bool use_mb_flag= use_mb(charset_info);#endif  for (end= from + length; from < end; from++)  {    char escape= 0;#ifdef USE_MB    int tmp_length;    if (use_mb_flag && (tmp_length= my_ismbchar(charset_info, from, end)))    {      if (to + tmp_length > to_end)      {        overflow= TRUE;        break;      }      while (tmp_length--)t*to++= *from++;      from--;      continue;    }         if (use_mb_flag && (tmp_length= my_mbcharlen(charset_info, *from)) > 1)      escape= *from;    else#endif    switch (*from) {    case 0:tttt       escape= '0';      break;    case '':tttt       escape= 'n';      break;    case 'r':      escape= 'r';      break;    case '':      escape= '';      break;    case ''':      escape= ''';      break;    case '""':tttt/* Better safe than sorry */      escape= '""';      break;    case '032':ttt       escape= 'Z';      break;    }    if (escape)    {      if (to + 2 > to_end)      {        overflow= TRUE;        break;      }      *to++= '';      *to++= escape;    }    else    {      if (to + 1 > to_end)      {        overflow= TRUE;        break;      }      *to++= *from;    }  }  *to= 0;  return overflow ? (size_t) -1 : (size_t) (to - to_start);}",2,"cwe119,cwe120"
"copy_file(const char *out_file_name, const char *in_file_name){    unsigned char buffer[EB_SIZE_PAGE];    size_t copied_length;    struct stat in_status;    int in_file = -1, out_file = -1;    ssize_t read_result;    struct utimbuf utim;         if (stat(in_file_name, &in_status) != 0 || !S_ISREG(in_status.st_mode)) {tfprintf(stderr, _(""%s: no such file: %s""), invoked_name,t    in_file_name);tgoto failed;    }         in_file = open(in_file_name, O_RDONLY | O_BINARY);    if (in_file < 0) {tfprintf(stderr, _(""%s: failed to open the file, %s: %s""),t    invoked_name, strerror(errno), in_file_name);tgoto failed;    }#ifdef O_CREAT    out_file = open(out_file_name, O_CREAT | O_TRUNC | O_WRONLY | O_BINARY,t0666 ^ get_umask());#else    out_file = creat(out_file_name, 0666 ^ get_umask());#endif    trap_file = out_file;    if (out_file < 0) {tfprintf(stderr, _(""%s: failed to open the file, %s: %s""),t    invoked_name, strerror(errno), out_file_name);tgoto failed;    }         copied_length = 0;    for (;;) {t tread_result = read(in_file, buffer, EB_SIZE_PAGE);tif (read_result == 0) {t    break;t} else if (read_result < 0) {t    fprintf(stderr, _(""%s: failed to read from the file, %s: %s""),ttinvoked_name, strerror(errno), in_file_name);t    goto failed;t}t tif (write(out_file, buffer, read_result) != read_result) {t    fprintf(stderr, _(""%s: failed to write to the file, %s: %s""),ttinvoked_name, strerror(errno), out_file_name);t    goto failed;t}tcopied_length += read_result;    }         close(in_file);    close(out_file);    trap_file = -1;         utim.actime = in_status.st_atime;    utim.modtime = in_status.st_mtime;    utime(out_file_name, &utim);    return 0;       failed:    if (0 <= in_file)tclose(in_file);    if (0 <= out_file)tclose(out_file);    return -1;}",3,"cwe119,cwe120,cweother"
"dump_sector(unsigned char *sector, int len){  int a, b, blen;  unsigned char buf[16];  a = 0;  while (a < len)    {      for (b = 0;b < 16;b++)t{t  if ((a + b) >= len)t    break;t  buf[b] = sector[a++];t  if (a >= len)t    {t      printf("""");t      return;t    }t  blen = b + 1;t}      printf(""%04x: "", a);      for (b = 0;b < 16;b++)t{t  if (b < blen)t    {t      printf(""%02x "", buf[b]);t    }t  elset    {t      printf(""   "");t    }t  if (b == 7)t    printf(""- "");t}      printf("" |  "");      for (b = 0;b < blen;b++)t{t  printf(""%c"", (isprint(buf[b])) ? buf[b] : '.');t  if (b == 7)t    printf("" - "");t}      printf("""");      if (blen  != 16)tbreak;    }  printf("""");}",2,"cwe119,cwe120"
"dlm_process_incoming_buffer(int nodeid, const void *base,ttttunsigned offset, unsigned len, unsigned limit){tunion {ttunsigned char __buf[DLM_INBUF_LEN];tt ttunion dlm_packet p;t} __tmp;tunion dlm_packet *p = &__tmp.p;tint ret = 0;tint err = 0;tuint16_t msglen;tuint32_t lockspace;twhile (len > sizeof(struct dlm_header)) {tt ttcopy_from_cb(p, base, offset, sizeof(struct dlm_header),ttt     limit);ttmsglen = le16_to_cpu(p->header.h_length);ttlockspace = p->header.h_lockspace;tterr = -EINVAL;ttif (msglen < sizeof(struct dlm_header))tttbreak;ttif (p->header.h_cmd == DLM_MSG) {tttif (msglen < sizeof(struct dlm_message))ttttbreak;tt} else {tttif (msglen < sizeof(struct dlm_rcom))ttttbreak;tt}tterr = -E2BIG;ttif (msglen > dlm_config.ci_buffer_size) {tttlog_print(""message size %d from %d too big, buf len %d"",tttt  msglen, nodeid, len);tttbreak;tt}tterr = 0;tt ttif (msglen > len)tttbreak;tt ttif (msglen > sizeof(__tmp) && p == &__tmp.p) {tttp = kmalloc(dlm_config.ci_buffer_size, GFP_NOFS);tttif (p == NULL)ttttreturn ret;tt}ttcopy_from_cb(p, base, offset, msglen, limit);ttBUG_ON(lockspace != p->header.h_lockspace);ttret += msglen;ttoffset += msglen;ttoffset &= (limit - 1);ttlen -= msglen;ttdlm_receive_buffer(p, nodeid);t}tif (p != &__tmp.p)ttkfree(p);treturn err ? err : ret;}",2,"cwe119,cwe120"
"quad_data_new(double x_or, double y_or, double xmax,ttt       double ymax, int rows, int cols, int n_points,ttt       int kmax) {    struct quaddata *data;    int i;    if (!(data = (struct quaddata *)malloc(sizeof(struct quaddata)))) {treturn NULL;    }    data->x_orig = x_or;    data->y_orig = y_or;    data->xmax = xmax;    data->ymax = ymax;    data->n_rows = rows;    data->n_cols = cols;    data->n_points = n_points;    data->points =t(struct triple *)malloc(sizeof(struct triple) * (kmax + 1));    if (!data->points)treturn NULL;    for (i = 0; i <= kmax; i++) {tdata->points[i].x = 0.;tdata->points[i].y = 0.;tdata->points[i].z = 0.;tdata->points[i].sm = 0.;    }    return data;}",2,"cwe120,cweother"
"nsc_ircc_net_open(struct net_device *dev){tstruct nsc_ircc_cb *self;tint iobase;tchar hwname[32];t__u8 bank;tttIRDA_ASSERT(dev != NULL, return -1;);tself = netdev_priv(dev);ttIRDA_ASSERT(self != NULL, return 0;);ttiobase = self->io.fir_base;ttif (request_irq(self->io.irq, nsc_ircc_interrupt, 0, dev->name, dev)) {ttnet_warn_ratelimited(""%s, unable to allocate irq=%d"",tttt     driver_name, self->io.irq);ttreturn -EAGAIN;t}t tif (request_dma(self->io.dma, dev->name)) {ttnet_warn_ratelimited(""%s, unable to allocate dma=%d"",tttt     driver_name, self->io.dma);ttfree_irq(self->io.irq, dev);ttreturn -EAGAIN;t}tt tbank = inb(iobase+BSR);tt tswitch_bank(iobase, BANK0);toutb(IER_LS_IE | IER_RXHDL_IE, iobase+IER);t toutb(bank, iobase+BSR);t tnetif_start_queue(dev);tt tsprintf(hwname, ""NSC-FIR @ 0x%03x"", self->io.fir_base);t tself->irlap = irlap_open(dev, &self->qos, hwname);treturn 0;}",2,"cwe119,cwe120"
"output_hex_charref(rb_econv_t *ec){    int ret;    unsigned char utfbuf[1024];    const unsigned char *utf;    size_t utf_len;    int utf_allocated = 0;    char charef_buf[16];    const unsigned char *p;    if (encoding_equal(ec->last_error.source_encoding, ""UTF-32BE"")) {        utf = ec->last_error.error_bytes_start;        utf_len = ec->last_error.error_bytes_len;    }    else {        utf = allocate_converted_string(ec->last_error.source_encoding, ""UTF-32BE"",                ec->last_error.error_bytes_start, ec->last_error.error_bytes_len,                utfbuf, sizeof(utfbuf),                &utf_len);        if (!utf)            return -1;        if (utf != utfbuf && utf != ec->last_error.error_bytes_start)            utf_allocated = 1;    }    if (utf_len % 4 != 0)        goto fail;    p = utf;    while (4 <= utf_len) {        unsigned int u = 0;        u += p[0] << 24;        u += p[1] << 16;        u += p[2] << 8;        u += p[3];        snprintf(charef_buf, sizeof(charef_buf), ""&#x%X;"", u);        ret = rb_econv_insert_output(ec, (unsigned char *)charef_buf, strlen(charef_buf), ""US-ASCII"");        if (ret == -1)            goto fail;        p += 4;        utf_len -= 4;    }    if (utf_allocated)        xfree((void *)utf);    return 0;  fail:    if (utf_allocated)        xfree((void *)utf);    return -1;}",2,"cwe119,cwe120"
"getauthline(struct sasl_cmd_t *sasl_cmd, char **line, int *linelen){    char buf[BUFSIZE];    int saslresult;    unsigned len;    char *str=(char *) buf;    int ret = STAT_CONT;    *line = NULL;    *linelen = 0;        do {tstr = prot_fgets(str, BUFSIZE, pin);tif (str == NULL) imtest_fatal(""prot layer failure"");tprintf(""S: %s"",str);    } while(str[0] == '*');               if (!strncasecmp(str, sasl_cmd->ok, strlen(sasl_cmd->ok))) {tif (sasl_cmd->parse_success) {t    str = sasl_cmd->parse_success(str);t    if (!str) return STAT_OK;t    ret = STAT_OK;t}telse {t    return STAT_OK;t}    }    else if (!strncasecmp(str, sasl_cmd->fail, strlen(sasl_cmd->fail))) {treturn STAT_NO;    }    else if (sasl_cmd->cont) {tstr += strlen(sasl_cmd->cont);      }    else {t tlen = atoi(str+1);tstr = prot_fgets(str, BUFSIZE, pin);tif (str == NULL || strlen(str) < len)t    imtest_fatal(""prot layer failure"");tprintf(""S: %s"", str);    }        if (*str != 'r') {t tchar *p = str + strlen(str) - 1;tif (p >= str && *p == '') *p-- = '0';tif (p >= str && *p == 'r') *p-- = '0';t tlen = strlen(str) + 1;t*line = malloc(len);tif ((*line) == NULL) {t    return STAT_NO;t}    t tsaslresult = sasl_decode64(str, strlen(str), tttt   *line, len, (unsigned *) linelen);tif (saslresult != SASL_OK) {t    printf(""base64 decoding error"");t    return STAT_NO;t}    } else {t t*line = NULL;t*linelen = 0;    }        return ret;}",3,"cwe119,cwe120,cweother"
"run_cc_and_maybe_debugger(  const char *cc_command,                                      int oldstdin,                                        const char *yukcmdstr,                                        const char *sourcefile,                                        const char *binaryname){#ifndef __DJGPP__     if (!compile_only&&!yukdebug&&!yukprofile&&!useickec)  {         ICK_SYSTEM(cc_command);      if(!cdebug) (void) unlink(sourcefile);  }  else if(!compile_only&&!useickec)  {           ICK_SYSTEM(cc_command);#ifdef HAVE_UNISTD_H    (void) dup2(oldstdin,0);  #endif    ICK_SYSTEM(yukcmdstr);    (void) unlink(sourcefile);    (void) unlink(binaryname);  }#else       if (!compile_only&&!useickec)  {              FILE* rsp;         const char* tempfn=""gcc @ickgcc.rsp"";         if(isenv(""TMP"")) tempfn=""gcc @/dev/env/TMP/ickgcc.rsp"";    if(isenv(""TEMP"")) tempfn=""gcc @/dev/env/TEMP/ickgcc.rsp"";    if(isenv(""TMPDIR"")) tempfn=""gcc @/dev/env/TMPDIR/ickgcc.rsp"";    if(isenv(""ICKTEMP"")) tempfn=""gcc @/dev/env/ICKTEMP/ickgcc.rsp"";    rsp=ick_debfopen(tempfn+5,""w"");    fprintf(rsp,""%s"",cc_command);    fclose(rsp);    ICK_SYSTEM(tempfn);    remove(tempfn+5);    if(yukdebug || yukprofile)    {      char buffer[BUFSIZ];#ifdef HAVE_UNISTD_H      dup2(oldstdin,0);  #endif       ick_snprintf_or_die(buffer, sizeof(buffer), ""%s"" EXEEXT,binaryname);      ICK_SYSTEM(yukcmdstr);      remove(sourcefile);      remove(buffer);    }    else if(!cdebug)    {      remove(sourcefile);    }  }#endif}",2,"cwe119,cwe120"
"""crypto_make_random_string_from_spec(char *tr_spec, int nbytes, int cflag){  int ch, i, n;  unsigned int r;  char chars[256];  Ds ds;  if (nbytes <= 0)treturn(NULL);t  n = 0;  for (ch = 041; ch < 0177; ch++) {tif (strtr_char(ch, tr_spec, cflag))t  chars[n++] = ch;  }  ds_init(&ds);  for (i = 0; i < nbytes; i++) {tif (crypto_random_uint(0, n - 1, &r) == -1)t  return(NULL);tds_appendc(&ds, (int) chars[r]);  }  ds_appendc(&ds, (int) '0');  return(ds_buf(&ds));}""",2,"cwe119,cwe120"
"cdf_put_vara_double(int ncid, int varid, const size_t start[],                         const size_t count[], const double *dp){  int status;  status = nc_put_vara_double(ncid, varid, start, count, dp);  if ( CDF_Debug || status != NC_NOERR )    Message(""ncid = %d varid = %d val0 = %f"", ncid, varid, *dp);  if ( status != NC_NOERR )    {      char name[256];      nc_inq_varname(ncid, varid, name);      Message(""varname = %s"", name);    }  if ( status != NC_NOERR ) Error(""%s"", nc_strerror(status));}",2,"cwe119,cwe120"
"enet_address_set_host (ENetAddress * address, const char * name){    struct hostent * hostEntry = NULL;#ifdef HAS_GETHOSTBYNAME_R    struct hostent hostData;    char buffer [2048];    int errnum;#if defined(linux) || defined(__GLIBC__) || defined(__GNU__) || (defined(__DragonFly__) && __DragonFly_version >= 200202)    gethostbyname_r (name, & hostData, buffer, sizeof (buffer), & hostEntry, & errnum);#else    hostEntry = gethostbyname_r (name, & hostData, buffer, sizeof (buffer), & errnum);#endif#else    hostEntry = gethostbyname (name);#endif    if (hostEntry == NULL ||        hostEntry -> h_addrtype != AF_INET)    {#ifdef HAS_INET_PTON        if (! inet_pton (AF_INET, name, & address -> host))#else        if (! inet_aton (name, (struct in_addr *) & address -> host))#endif            return -1;        return 0;    }    address -> host = * (enet_uint32 *) hostEntry -> h_addr_list [0];    return 0;}",2,"cwe119,cwe120"
"irplib_wcs_iso8601_from_string(int * pyear, int * pmonth,                                              int * pday, int * phour,                                              int * pminute, double * psecond,                                              const char * iso8601){         const char * iso8601format = ""%4d-%2d-%2dT%2d:%2d:%lf"";    cpl_ensure_code(pyear   != NULL, CPL_ERROR_NULL_INPUT);    cpl_ensure_code(pmonth  != NULL, CPL_ERROR_NULL_INPUT);    cpl_ensure_code(pday    != NULL, CPL_ERROR_NULL_INPUT);    cpl_ensure_code(phour   != NULL, CPL_ERROR_NULL_INPUT);    cpl_ensure_code(pminute != NULL, CPL_ERROR_NULL_INPUT);    cpl_ensure_code(psecond != NULL, CPL_ERROR_NULL_INPUT);    cpl_ensure_code(iso8601 != NULL, CPL_ERROR_NULL_INPUT);    cpl_error_ensure(sscanf(iso8601, iso8601format, pyear, pmonth,                            pday, phour, pminute, psecond) == 6,                     CPL_ERROR_ILLEGAL_INPUT, return cpl_error_get_code(),                     ""%s is not formatted as %s"", iso8601, iso8601format);    cpl_ensure_code(!irplib_wcs_is_iso8601(*pyear, *pmonth, *pday, *phour,                                           *pminute, *psecond),                    cpl_error_get_code());    return CPL_ERROR_NONE;}",2,"cwe120,cweother"
"pgsql_set_user_pwd(u08bits *usname, st_password_t pwd) {  int ret = -1;tchar statement[TURN_LONG_STRING_SIZE];tPGconn *pqc = get_pqdb_connection();tif(pqc) {t  snprintf(statement,sizeof(statement),""insert into turnusers_st values('%s','%s')"",usname,pwd);    PGresult *res = PQexec(pqc, statement);ttif(!res || (PQresultStatus(res) != PGRES_COMMAND_OK)) {tttif(res) {ttttPQclear(res);ttt}tt  snprintf(statement,sizeof(statement),""update turnusers_st set password='%s' where name='%s'"",pwd,usname);tttres = PQexec(pqc, statement);tttif(!res || (PQresultStatus(res) != PGRES_COMMAND_OK)) {ttttTURN_LOG_FUNC(TURN_LOG_LEVEL_ERROR, ""Error inserting/updating user information: %s"",PQerrorMessage(pqc));ttt} else {ttt  ret = 0;ttt}tt}ttif(res) {tttPQclear(res);tt}t}  return ret;}",2,"cwe119,cwe120"
"updateApm( void ){  size_t n;  int fd;  if ( ApmOK < 0 )    return -1;  if ( ( fd = open( ""/proc/apm"", O_RDONLY ) ) < 0 ) {    if ( ApmOK != 0 )      print_error( ""Cannot open file '/proc/apm'!""                   ""The kernel needs to be compiled with support""                   ""for /proc file system enabled!"" );    return -1;  }  n = read( fd, ApmBuf, APMBUFSIZE - 1 );  if ( n == APMBUFSIZE - 1 ) {    log_error( ""Internal buffer too small to read '/proc/apm'"" );    close( fd );    return -1;  }  close( fd );  ApmBuf[ n ] = '0';  Dirty = 1;  return 0;}",2,"cwe120,cweother"
"ut_init(int argc, char **argv, const char *groupName, Test allTests) {    Testtt;    chart*appName = *argv;    chart*a;    intttrunAll = 1;    ut_out = stdout;    tests = allTests;    group = groupName;    for (t = tests; t->name != 0; t++) {tt->pass = -1;tt->run = 0;    }    argc--;    argv++;    for (; 0 < argc; argc--, argv++) {ta = *argv;tif (0 == strcmp(""-o"", a)) {t    argc--;t    argv++;t    if (0 == (ut_out = fopen(*argv, ""a""))) {ttprintf(""Failed to open %s"", *argv);ttusage(appName);t    }t} else if (0 == strcmp(""-c"", a)) {t    argc--;t    argv++;t    if (0 == (ut_out = fopen(*argv, ""w""))) {ttprintf(""Failed to open %s"", *argv);ttusage(appName);t    }t} else if (0 == strcmp(""-v"", a)) {t    ut_verbose += 1;t} else {t    if (0 == (t = findTest(a))) {ttprintf(""%s does not contain test %s"", group, a);ttusage(appName);t    }t    t->run = 1;t    runAll = 0;t}    }    if (runAll) {tfor (t = tests; t->name != 0; t++) {t    t->run = 1;t}    }    ut_print(""%s tests started"", group);    for (currentTest = tests; currentTest->name != 0; currentTest++) {tif (currentTest->run) {t    if (2 <= ut_verbose) {ttprintf("">>> %s"", currentTest->name);t    }t    currentTest->func();t    if (2 <= ut_verbose) {ttprintf(""<<< %s"", currentTest->name);t    }t}    }}",2,"cwe469,cweother"
"pre_shared_encode_hash(struct message *msg){tstruct exchange *exchange = msg->exchange;tstruct ipsec_exch *ie = exchange->data;tsize_t          hashsize = ie->hash->hashsize;tchar            header[80];tint             initiator = exchange->initiator;tu_int8_t       *buf;tbuf = ipsec_add_hash_payload(msg, hashsize);tif (!buf)ttreturn -1;tif (ike_auth_hash(exchange, buf + ISAKMP_HASH_DATA_OFF) == -1)ttreturn -1;tsnprintf(header, sizeof header, ""pre_shared_encode_hash: HASH_%c"",t    initiator ? 'I' : 'R');tLOG_DBG_BUF((LOG_MISC, 80, header, buf + ISAKMP_HASH_DATA_OFF,t    hashsize));treturn 0;}",2,"cwe119,cwe120"
"parse_cmdline_args(int argc, char **argv,ttt      struct cmdline_args *args){tint opt;tconst static struct option longopts[] = {tt{""help"",                0, 0, 'H'},tt{""fet-list"",            0, 0, 'L'},tt{""fet-force-id"",        1, 0, 'F'},tt{""usb-list"",            0, 0, 'I'},tt{""version"",             0, 0, 'V'},tt{""long-password"",       0, 0, 'P'},tt{NULL, 0, 0, 0}t};twhile ((opt = getopt_long(argc, argv, ""d:jv:nU:q"",tttt  longopts, NULL)) >= 0)ttswitch (opt) {ttcase 'q':ttt{ttttconst static union opdb_value v = {ttttt.boolean = 1tttt};ttttopdb_set(""quiet"", &v);ttt}tttbreak;ttcase 'I':tttusb_init();tttusb_find_busses();tttusb_find_devices();tttusbutil_list();tttexit(0);ttcase 'd':tttargs->serial_device = optarg;tttbreak;ttcase 'U':tttargs->usb_device = optarg;tttbreak;ttcase 'L':tttexit(list_devices());ttcase 'F':tttargs->fet_force_id = optarg;tttbreak;ttcase 'H':tttusage(argv[0]);tttexit(0);ttcase 'V':tttprintc(""%s"", version_text);tttexit(0);ttcase 'v':tttargs->vcc_mv = atoi(optarg);tttbreak;ttcase 'j':tttargs->want_jtag = 1;tttbreak;ttcase 'n':tttargs->no_rc = 1;tttbreak;ttcase 'P':tttargs->long_password = 1;tttbreak;ttcase '?':tttprintc_err(""Try --help for usage information."");tttreturn -1;tt}tif (args->usb_device && args->serial_device) {ttprintc_err(""You can't simultaneously specify a serial and ""ttt""a USB device."");ttreturn -1;t}tif (optind >= argc) {ttprintc_err(""You need to specify a driver. Try --help for ""ttt""a list."");ttreturn -1;t}targs->driver_name = argv[optind];toptind++;treturn 0;}",2,"cwe120,cweother"
"""cget(){tc=getc(source);tif (c=='')ttline++;}""",2,"cwe120,cweother"
"uux(struct moduledel *p){structtctlfile ctf;unsigned *reciparray;unsigned nreceipients=p->nreceipients;structtrfc822t *hostt;unsigned i;tif ((reciparray=malloc(sizeof(unsigned)*nreceipients)) == 0)ttclog_msg_errno();tfor (i=0; i<nreceipients; i++)ttreciparray[i]=i;tif (ctlfile_openi(p->inum, &ctf, 0))ttclog_msg_errno();tctlfile_setvhost(&ctf);t thostt=rw_rewrite_tokenize(p->host);tdelhostt=hostt->tokens;tif (ctlfile_searchfirst(&ctf, COMCTLFILE_VERP) < 0 ||tt*p->sender == 0)tt ttuux2(p, &ctf, reciparray, nreceipients);telset{tconst char *save_sender=p->sender;ttfor (i=0; i<nreceipients; i++)tt{tt ttconst char *receipient=p->receipients[reciparray[i]*2+1];ttchart*recip=courier_malloc(strlen(p->host)tttt+strlen(receipient)+2);ttchart*verp_sender=0;tttstrcat(strcat(strcpy(recip, p->host), ""!""), receipient);tttverp_sender=courier_malloc(strlen(save_sender)+ttttverp_encode(recip, 0)+1);tttstrcat(strcpy(verp_sender, save_sender), ""-"");tttverp_encode(recip, verp_sender+strlen(verp_sender));tttp->sender=verp_sender;tttuux2(p, &ctf, reciparray+i, 1);tttfree(verp_sender);tt}ttp->sender=save_sender;t}tctlfile_close(&ctf);tfree(reciparray);}",2,"cwe120,cwe476"
"requeue_jobs(void){tstructtjob_savet*jp, *nxt = (struct job_save *) 0;tjobno_tttjn = REQUEUE_START;tinttfd;tunsignedthashval;tstructtspqtnewj;tstructtstattsbuf;tBLOCK_ZERO(&newj, sizeof(newj));tnewj.spq_nptimeout = newj.spq_ptimeout = 168;tnewj.spq_pri = 1;tnewj.spq_class = 0xffffffffL;tnewj.spq_end = LOTSANDLOTS;tnewj.spq_uid = Daemuid;tstrncpy(newj.spq_uname, SPUNAME, UIDSIZE);tstrncpy(newj.spq_puname, SPUNAME, UIDSIZE);tstrncpy(newj.spq_form, requeue_form, MAXFORM);tstrncpy(newj.spq_file, REBUILDTIT, MAXTITLE);tif  ((fd = open(JFILE, O_WRONLY|O_APPEND)) < 0)  {ttif  ((fd = open(JFILE, O_WRONLY|O_CREAT, 0666)) < 0)  {tttfprintf(stderr, ""Cannot output to job file"");tttreturn;tt}#ifdeftHAVE_FCHOWNttfchown(fd, Daemuid, getegid());#elsettchown(JFILE, Daemuid, getegid());#endift}tfor  (jp = dw_list;  jp;  jp = nxt)  {ttchart*npath;ttnxt = jp->next;t tt ttwhile  (find_hash(jn))tttjn++;ttnewj.spq_job = jn;ttstat(jp->job_path, &sbuf);ttnewj.spq_time = (LONG) sbuf.st_mtime;ttnewj.spq_size = (LONG) sbuf.st_size;ttnpath = my_mkspid(SPNAM, jn, existing_subds);ttif  (strcmp(npath, jp->job_path) != 0)  {  tttjob_rename(jp->job_path, npath);tttfree(jp->job_path);tttjp->job_path = stracpy(npath);tt}ttwrite(fd, (char *) &newj, sizeof(newj));ttjp->jnum = jn;ttjp->in_jfile = 1;tthashval = hashit(jn);ttjp->next = hashtab[hashval];tthashtab[hashval] = jp;ttfprintf(stderr, ""Requeued orphaned job file as job %ld"", (long) jn);ttjn++;t}tclose(fd);}",2,"cwe120,cweother"
"create_pid_file(const char *path){    char pid_buffer[12];    struct flock lock;    int rval;    int fd;    if (!path) {        path = config.pidfile;    }    if ((fd = open(path, O_CREAT | O_EXCL | O_WRONLY,                   S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1) {        if(errno == EEXIST){                         ssize_t rbyte;            pid_t pid;            char spid[6] = {0};            fd = open(path, O_RDWR);            if(fd == -1){                elog(""OPEN"");                return errno;            }            rbyte = read(fd, spid, 5);            if(rbyte != 5){                elog(""READ"");                return errno;            }            rbyte = sscanf(spid, ""%d"", &pid);            if(rbyte <= 0){                elog(""SCAN"");                return -1;            }            elog(""KILL %d"",pid);            if(kill(pid, 0) == 0){                elog(""KILL %d"",pid);                return EEXIST;            }        }    } else if ((fd = open(path, O_CREAT | O_WRONLY,                   S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1) {        return errno;    }         lock.l_type = F_WRLCK;    lock.l_start = 0;    lock.l_whence = SEEK_SET;    lock.l_len = 0;    if (fcntl(fd, F_SETLK, &lock) == -1) {        if (errno == EACCES || errno == EAGAIN) {            rval = errno;        } else {            rval = ERROR;        }        close(fd);        return rval;    }    snprintf(pid_buffer, sizeof(pid_buffer), ""%d"", (int)getpid());    if (ftruncate(fd, 0) != 0) {        return errno;    }    if (write(fd, pid_buffer, strlen(pid_buffer)) == -1) {        return errno;    }    return SUCCESS;}",3,"cwe119,cwe120,cweother"
"glusterd_handle_set_volume (rpcsvc_request_t *req){        int32_t                         ret = -1;        gf_cli_req                      cli_req = {{0,}};        dict_t                          *dict = NULL;        glusterd_op_t                   cli_op = GD_OP_SET_VOLUME;        char                            *key = NULL;        char                            *value = NULL;        char                            *volname = NULL;        GF_ASSERT (req);        if (!xdr_to_generic (req->msg[0], &cli_req, (xdrproc_t)xdr_gf_cli_req)) {                                 req->rpc_err = GARBAGE_ARGS;                goto out;        }        if (cli_req.dict.dict_len) {                                 dict  = dict_new ();                ret = dict_unserialize (cli_req.dict.dict_val,                                        cli_req.dict.dict_len,                                        &dict);                if (ret < 0) {                        gf_log (""glusterd"", GF_LOG_ERROR,                                ""failed to ""                                ""unserialize req-buffer to dictionary"");                        goto out;                } else {                        dict->extra_stdfree = cli_req.dict.dict_val;                }        }        ret = dict_get_str (dict, ""volname"", &volname);        if (ret) {                gf_log ("""", GF_LOG_WARNING, ""Unable to get volume name, while""                        ""handling volume set command"");                goto out;        }        ret = dict_get_str (dict, ""key1"", &key);        if (ret) {                if (strcmp (volname, ""help-xml"") && strcmp (volname, ""help"")) {                        gf_log ("""", GF_LOG_WARNING, ""Unable to get key, while ""                                ""handling volume set for %s"",volname);                        goto out;                }        }        ret = dict_get_str (dict, ""value1"", &value);        if (ret) {                if (strcmp (volname, ""help-xml"") && strcmp (volname, ""help"")) {                        gf_log ("""", GF_LOG_WARNING, ""Unable to get value, while""                                ""handling volume set for %s"",volname);                        goto out;                }        }        gf_cmd_log (""volume set"", ""volume-name:%s: key:%s, value:%s"",volname,                    key, value);        ret = glusterd_op_begin (req, GD_OP_SET_VOLUME, dict);        gf_cmd_log (""volume set"", ""volume-name:%s: key:%s, value:%s %s"",                    volname, key, value, (ret == 0)? ""SUCCEDED"" : ""FAILED"" );out:        glusterd_friend_sm ();        glusterd_op_sm ();        if (ret) {                if (dict)                        dict_unref (dict);                ret = glusterd_op_send_cli_response (cli_op, ret, 0, req,                                                     NULL, ""operation failed"");        }        return ret;}",2,"cwe469,cwe476"
"""rvp_read_packet( DirectStream *stream ){     unsigned char  buf[9];     int            size;     int            len;     unsigned char  id;     unsigned int   ts;          while (1) {          do {               size = recv( stream->fd, buf, 1, MSG_WAITALL );               if (size < 1)                    return DR_EOF;          } while (buf[0] != '$');               size = recv( stream->fd, buf, 7, MSG_WAITALL );          if (size < 7)               return DR_EOF;                    len = (buf[0] << 16) + (buf[1] << 8) + buf[2];           id = buf[3];          if (id != 0x40 && id != 0x42) {               if (buf[5] == 0x06) // EOS                    return DR_EOF;               size = recv( stream->fd, buf, 9, MSG_WAITALL );               if (size < 9)                    return DR_EOF;               id = buf[5];               len -= 9;          }          id = (id >> 1) & 1;                    size = recv( stream->fd, buf, 6, MSG_WAITALL );          if (size < 6)               return DR_EOF;          ts = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];                         len -= 10;          if (len > 0) {               unsigned char *dst;                              size = len + 12;                  stream->cache = D_REALLOC( stream->cache, stream->cache_size+size );               if (!stream->cache)                    return D_OOM();               dst = stream->cache+stream->cache_size;               stream->cache_size += size;                              dst += rmf_write_pheader( dst, id, len, ts );                               while (len) {                    size = recv( stream->fd, dst, len, MSG_WAITALL );                    if (size < 1)                         return DR_EOF;                    dst += size;                    len -= size;               }               break;          }     }          return DR_OK;}""",2,"cwe119,cwe120"
"run_dsa_verify (const void *data, size_t datalen,                const char *keyfile, const char *sigfile){  gpg_error_t err;  gcry_sexp_t s_data, s_key, s_sig;  char hash[20];  gcry_mpi_t tmpmpi;  gcry_md_hash_buffer (GCRY_MD_SHA1, hash, data, datalen);     err = gcry_mpi_scan (&tmpmpi, GCRYMPI_FMT_USG, hash, 20, NULL);  if (!err)    {      err = gcry_sexp_build (&s_data, NULL,                             ""(data (flags raw)(value %m))"", tmpmpi);      gcry_mpi_release (tmpmpi);    }  if (err)    die (""gcry_sexp_build failed for DSA data input: %s"",         gpg_strerror (err));  s_key = read_sexp_from_file (keyfile);  s_sig = read_sexp_from_file (sigfile);  err = gcry_pk_verify (s_sig, s_data, s_key);  if (!err)    puts (""GOOD signature"");  else if (gpg_err_code (err) == GPG_ERR_BAD_SIGNATURE)    puts (""BAD signature"");  else    printf (""ERROR (%s)"", gpg_strerror (err));  gcry_sexp_release (s_sig);  gcry_sexp_release (s_key);  gcry_sexp_release (s_data);}",3,"cwe119,cwe120,cweother"
"psmc_print_data(const psmc_par_t *pp, const psmc_data_t *pd){tint k;tFLOAT n_recomb = pp->sum_L / pd->C_sigma;tFLOAT theta0, rho0, *lambda, sum;tlambda = (FLOAT*)malloc(sizeof(FLOAT) * (pp->n + 1));ttheta0 = pd->params[0]; rho0 = pd->params[1];tfor (k = 0; k <= pp->n; ++k)ttlambda[k] = pd->params[pp->par_map[k] + PSMC_N_PARAMS];tfprintf(pp->fpout, ""LKt%lf"", pd->lk);tfprintf(pp->fpout, ""QDt%lf -> %lf"", pd->Q0, pd->Q1);t tfor (k = 0, sum = 0.0; k <= pp->n; ++k)ttsum += pd->sigma[k] * log(pd->sigma[k] / pd->post_sigma[k]);tfprintf(pp->fpout, ""RIt%.10lf"", sum);t tfprintf(pp->fpout, ""TRt%lft%lf"", pd->params[0], pd->params[1]);tfprintf(pp->fpout, ""MTt%lf"", pd->params[2]);tif (pp->flag & PSMC_F_DIVERG)ttfprintf(pp->fpout, ""DTt%lf"", pd->params[pd->n_params - 1]);t tfprintf(pp->fpout, ""MMtC_pi: %lf, n_recomb: %lf"", pd->C_pi, n_recomb);tfor (k = 0; k <= pp->n; ++k)ttfprintf(pp->fpout, ""RSt%dt%lft%lft%lft%lft%lf"", k, pd->t[k], lambda[k], n_recomb * pd->hp->a0[k],ttttpd->sigma[k], pd->post_sigma[k]);tfprintf(pp->fpout, ""PAt%s"", pp->pattern);tfor (k = 0; k != pd->n_params; ++k)ttfprintf(pp->fpout, "" %.9lf"", pd->params[k]);tif (pp->inp_ti)ttfor (k = 0; k <= pp->n; ++k)tttfprintf(pp->fpout, "" %.9lf"", pp->inp_ti[k]);tfprintf(pp->fpout, ""//"");tfflush(pp->fpout);tfree(lambda);}",3,"cwe119,cwe120,cweother"
"maketree(Tree *treex, Hashindex *gooditems, Hashindex *baditems,t      choice datacols[OUTCOME_NUMBER][DATACOLS_NUMBER][2],t      unsigned int data_number) {  Hashindex *p;  char *name, *nameend;  for (p = gooditems; p != NULL; TO_NEXT(p)) {    if (p->own != NULL) {      name = NULL;      treex->cutfn(&name, &nameend, p->name, FALSE);      (void)treefind(name, nameend, &(treex->tree), p, treex->cutfn, FALSE,tt     FALSE, TRUE, treex->space, datacols, data_number);    }  }  for (p = baditems; p != NULL; TO_NEXT(p)) {    if (p->own != NULL) {      name = NULL;      treex->cutfn(&name, &nameend, p->name, FALSE);      (void)treefind(name, nameend, &(treex->tree), p, treex->cutfn, FALSE,tt     FALSE, TRUE, treex->space, datacols, data_number);    }  }}",2,"cwe119,cwe120"
"get_password(struct passwd_ctx *ctx){    char buf[MAX_STRING_LEN + 1];    if (ctx->passwd_src == PW_STDIN) {        apr_file_t *file_stdin;        apr_size_t nread;        if (apr_file_open_stdin(&file_stdin, ctx->pool) != APR_SUCCESS) {            ctx->errstr = ""Unable to read from stdin."";            return ERR_GENERAL;        }        if (apr_file_read_full(file_stdin, buf, sizeof(buf) - 1,                               &nread) != APR_EOF            || nread == sizeof(buf) - 1) {            goto err_too_long;        }        buf[nread] = '0';        if (nread >= 1 && buf[nread-1] == '') {            buf[nread-1] = '0';            if (nread >= 2 && buf[nread-2] == 'r')                buf[nread-2] = '0';        }        apr_file_close(file_stdin);        ctx->passwd = apr_pstrdup(ctx->pool, buf);    }    else if (ctx->passwd_src == PW_PROMPT_VERIFY) {        apr_size_t bufsize = sizeof(buf);        if (apr_password_get(""Enter password: "", buf, &bufsize) != 0)            goto err_too_long;        ctx->passwd = apr_pstrdup(ctx->pool, buf);    }    else {        apr_size_t bufsize = sizeof(buf);        if (apr_password_get(""New password: "", buf, &bufsize) != 0)            goto err_too_long;        ctx->passwd = apr_pstrdup(ctx->pool, buf);        bufsize = sizeof(buf);        buf[0] = '0';        apr_password_get(""Re-type new password: "", buf, &bufsize);        if (strcmp(ctx->passwd, buf) != 0) {            ctx->errstr = ""password verification error"";            memset(ctx->passwd, '0', strlen(ctx->passwd));            memset(buf, '0', sizeof(buf));            return ERR_PWMISMATCH;        }    }    memset(buf, '0', sizeof(buf));    return 0;err_too_long:    ctx->errstr = apr_psprintf(ctx->pool,                               ""password too long (>%"" APR_SIZE_T_FMT "")"",                               ctx->out_len - 1);    return ERR_OVERFLOW;}",2,"cwe119,cwe120"
"send_http_connect(proxy_conn_rec *backend,                                      server_rec *s){    int status;    apr_size_t nbytes;    apr_size_t left;    int complete = 0;    char buffer[HUGE_STRING_LEN];    char drain_buffer[HUGE_STRING_LEN];    forward_info *forward = (forward_info *)backend->forward;    int len = 0;    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00948)                 ""CONNECT: sending the CONNECT request for %s:%d ""                 ""to the remote proxy %pI (%s)"",                 forward->target_host, forward->target_port,                 backend->addr, backend->hostname);         nbytes = apr_snprintf(buffer, sizeof(buffer),                          ""CONNECT %s:%d HTTP/1.0"" CRLF,                          forward->target_host, forward->target_port);         if (forward->proxy_auth != NULL) {        nbytes += apr_snprintf(buffer + nbytes, sizeof(buffer) - nbytes,                               ""Proxy-Authorization: %s"" CRLF,                               forward->proxy_auth);    }         nbytes += apr_snprintf(buffer + nbytes, sizeof(buffer) - nbytes,                           ""Proxy-agent: %s"" CRLF CRLF,                           ap_get_server_banner());    apr_socket_send(backend->sock, buffer, &nbytes);         left = sizeof(buffer) - 1;         do {        nbytes = left;        status = apr_socket_recv(backend->sock, buffer + len, &nbytes);        len += nbytes;        left -= nbytes;        buffer[len] = '0';        if (strstr(buffer + len - nbytes, ""rr"") != NULL) {            complete = 1;            break;        }    } while (status == APR_SUCCESS && left > 0);         if (!complete) {        nbytes = sizeof(drain_buffer) - 1;        while (status == APR_SUCCESS && nbytes) {            status = apr_socket_recv(backend->sock, drain_buffer, &nbytes);            drain_buffer[nbytes] = '0';            nbytes = sizeof(drain_buffer) - 1;            if (strstr(drain_buffer, ""rr"") != NULL) {                break;            }        }    }         if (status == APR_SUCCESS) {        int major, minor;                 char code_str[4];        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, APLOGNO(00949)                     ""send_http_connect: response from the forward proxy: %s"",                     buffer);                 if (sscanf(buffer, ""HTTP/%u.%u %3s"", &major, &minor, code_str) == 3) {            status = atoi(code_str);            if (status == HTTP_OK) {                status = APR_SUCCESS;            }            else {                ap_log_error(APLOG_MARK, APLOG_ERR, 0, s, APLOGNO(00950)                             ""send_http_connect: the forward proxy returned code is '%s'"",                             code_str);            status = APR_INCOMPLETE;            }        }    }    return(status);}",3,"cwe119,cwe120,cweother"
"read733(VolInfo* volInfo, unsigned* value){    int rc;    unsigned char both[8];        rc = readRead(volInfo, both, 8);    if(rc != 8)        return rc;        read733FromCharArray(both, value);        return rc;}",2,"cwe119,cwe120"
"decode_packet(unsigned char *buf, int len){tstruct ether_header *eh = (void *) buf;tchar src[18], dst[18];tuint16_t type;tsnprintf(dst, sizeof(dst), ""%02x:%02x:%02x:%02x:%02x:%02x"",tttteh->ether_dhost[0], eh->ether_dhost[1],tttteh->ether_dhost[2], eh->ether_dhost[3],tttteh->ether_dhost[4], eh->ether_dhost[5]);tsnprintf(src, sizeof(src), ""%02x:%02x:%02x:%02x:%02x:%02x"",tttteh->ether_shost[0], eh->ether_shost[1],tttteh->ether_shost[2], eh->ether_shost[3],tttteh->ether_shost[4], eh->ether_shost[5]);ttype = ntohs(eh->ether_type);tprintf(""> type 0x%04x src %s dst %s <"", type, src, dst);tswitch (type) {tcase ETHERTYPE_IP:ttdecode_ip(buf + 14, len - 14);ttbreak;tcase ETHERTYPE_LOOPBACK:ttdump_packet(buf, len);ttbreak;t}}",2,"cwe119,cwe120"
"""SendRLPFrame(gn_data *data, struct gn_statemachine *state){tunsigned char req[32] = {0x00, 0xd9};t/*t * Discontinuos transmission (DTX).t * See section 5.6 of GSM 04.22 version 7.0.1.t */tif (data->rlp_out_dtx) req[1] = 0x01;tmemcpy(req + 2, (unsigned char *) data->rlp_frame, 30);t/*t * It's ugly like the hell, maybe we should implement SM_SendFramet * and extend the GSM_Link structure. We should clean this up in thet * future... - bozot * return SM_SendFrame(state, 32, 0xf0, req);t */treturn fbus_tx_send_frame(32, 0xf0, req, state);}""",2,"cwe119,cwe120"
"__ecereProp_NamedStringsBox_Set_namedStrings(struct __ecereNameSpace__ecere__com__Instance * this, struct __ecereNameSpace__ecere__com__Instance * value){struct NamedStringsBox * __ecerePointer_NamedStringsBox = (struct NamedStringsBox *)(this ? (((char *)this) + __ecereClass_NamedStringsBox->offset) : 0);struct __ecereNameSpace__ecere__com__Instance * row;__ecereMethod___ecereNameSpace__ecere__gui__controls__ListBox_Clear(__ecerePointer_NamedStringsBox->list);if(value){{struct NamedString ** s;struct __ecereNameSpace__ecere__com__Instance * __internalArray = (value);for(s = (struct NamedString **)((struct __ecereNameSpace__ecere__com__Array *)(((char *)__internalArray + 24)))->array; s < (struct NamedString **)((struct __ecereNameSpace__ecere__com__Array *)(((char *)__internalArray + 24)))->array + ((struct __ecereNameSpace__ecere__com__Array *)(((char *)__internalArray + 24)))->count; s++){char temp[797];row = __ecereMethod___ecereNameSpace__ecere__gui__controls__ListBox_AddRow(__ecerePointer_NamedStringsBox->list);__ecereMethod___ecereNameSpace__ecere__gui__controls__DataRow_SetData(row, __ecerePointer_NamedStringsBox->nameField, __ecereProp_NamedString_Get_name((*s)));__ecereMethod___ecereNameSpace__ecere__gui__controls__DataRow_SetData(row, __ecerePointer_NamedStringsBox->stringField, __ecereProp_NamedString_Get_string((*s)));}}}row = __ecereMethod___ecereNameSpace__ecere__gui__controls__ListBox_AddRow(__ecerePointer_NamedStringsBox->list);__ecereProp___ecereNameSpace__ecere__gui__controls__ListBox_Set_currentRow(__ecerePointer_NamedStringsBox->list, __ecereProp___ecereNameSpace__ecere__gui__controls__ListBox_Get_firstRow(__ecerePointer_NamedStringsBox->list));__ecereProp___ecereNameSpace__ecere__gui__Window_Set_modifiedDocument(__ecerePointer_NamedStringsBox->list, 0x0);__ecereNameSpace__ecere__com__eInstance_FireSelfWatchers(this, __ecereProp_NamedStringsBox_namedStrings), __ecereNameSpace__ecere__com__eInstance_FireSelfWatchers(this, __ecerePropM_NamedStringsBox_namedStrings);}",3,"cwe119,cwe120,cwe476"
"grep_tree(struct grep_opt *opt, const char **paths,tt     struct tree_desc *tree,tt     const char *tree_name, const char *base){tint len;tint hit = 0;tstruct name_entry entry;tchar *down;tint tn_len = strlen(tree_name);tchar *path_buf = xmalloc(PATH_MAX + tn_len + 100);tif (tn_len) {tttn_len = sprintf(path_buf, ""%s:"", tree_name);ttdown = path_buf + tn_len;ttstrcat(down, base);t}telse {ttdown = path_buf;ttstrcpy(down, base);t}tlen = strlen(path_buf);twhile (tree_entry(tree, &entry)) {ttstrcpy(path_buf + len, entry.path);ttif (S_ISDIR(entry.mode))ttt tttstrcpy(path_buf + len + tree_entry_len(entry.path, entry.sha1), ""/"");ttif (!pathspec_matches(paths, down))ttt;ttelse if (S_ISREG(entry.mode))ttthit |= grep_sha1(opt, entry.sha1, path_buf, tn_len);ttelse if (S_ISDIR(entry.mode)) {tttenum object_type type;tttstruct tree_desc sub;tttvoid *data;tttunsigned long size;tttdata = read_sha1_file(entry.sha1, &type, &size);tttif (!data)ttttdie(""unable to read tree (%s)"",tttt    sha1_to_hex(entry.sha1));tttinit_tree_desc(&sub, data, size);ttthit |= grep_tree(opt, paths, &sub, tree_name, down);tttfree(data);tt}t}treturn hit;}",2,"cwe120,cwe469"
closeIngraph(ingraph_state * sp){    if (!sp->ingraphs && sp->u.Files && sp->fp)tsp->fns->closef(sp->fp);    free(sp->fns);    if (sp->heap)tfree(sp);},2,"cwe119,cwe120"
"krb5int_dk_string_to_key(const struct krb5_keytypes *ktp,                         const krb5_data *string, const krb5_data *salt,                         const krb5_data *parms, krb5_keyblock *keyblock){    krb5_error_code ret;    size_t keybytes, keylength, concatlen;    unsigned char *concat = NULL, *foldstring = NULL, *foldkeydata = NULL;    krb5_data indata;    krb5_keyblock foldkeyblock;    krb5_key foldkey = NULL;         keybytes = ktp->enc->keybytes;    keylength = ktp->enc->keylength;    concatlen = string->length + (salt ? salt->length : 0);    concat = k5alloc(concatlen, &ret);    if (ret != 0)        goto cleanup;    foldstring = k5alloc(keybytes, &ret);    if (ret != 0)        goto cleanup;    foldkeydata = k5alloc(keylength, &ret);    if (ret != 0)        goto cleanup;         if (string->length > 0)        memcpy(concat, string->data, string->length);    if (salt != NULL && salt->length > 0)        memcpy(concat + string->length, salt->data, salt->length);    krb5int_nfold(concatlen*8, concat, keybytes*8, foldstring);    indata.length = keybytes;    indata.data = (char *) foldstring;    foldkeyblock.length = keylength;    foldkeyblock.contents = foldkeydata;    foldkeyblock.enctype = ktp->etype;    ret = ktp->rand2key(&indata, &foldkeyblock);    if (ret != 0)        goto cleanup;    ret = krb5_k_create_key(NULL, &foldkeyblock, &foldkey);    if (ret != 0)        goto cleanup;         indata.length = kerberos_len;    indata.data = (char *) kerberos;    ret = krb5int_derive_keyblock(ktp->enc, foldkey, keyblock, &indata,                                  DERIVE_RFC3961);    if (ret != 0)        memset(keyblock->contents, 0, keyblock->length);cleanup:    zapfree(concat, concatlen);    zapfree(foldstring, keybytes);    zapfree(foldkeydata, keylength);    krb5_k_free_key(NULL, foldkey);    return ret;}",2,"cwe120,cweother"
"client3_1_fentrylk (call_frame_t *frame, xlator_t *this,                    void *data){        clnt_args_t       *args     = NULL;        gfs3_fentrylk_req  req      = {{0,},};        int64_t            remote_fd = -1;        clnt_conf_t       *conf     = NULL;        int                op_errno = ESTALE;        int           ret        = 0;        if (!frame || !this || !data)                goto unwind;        args = data;        conf = this->private;        CLIENT_GET_REMOTE_FD(conf, args->fd, remote_fd, unwind);        req.fd  = remote_fd;        req.cmd = args->cmd_entrylk;        req.type = args->type;        req.volume = (char *)args->volume;        req.name = """";        if (args->basename) {                req.name = (char *)args->basename;                req.namelen = 1;        }        memcpy (req.gfid, args->fd->inode->gfid, 16);        ret = client_submit_request (this, &req, frame, conf->fops,                                     GFS3_OP_FENTRYLK,                                     client3_1_fentrylk_cbk, NULL,                                     NULL, 0, NULL, 0,                                     NULL, (xdrproc_t)xdr_gfs3_fentrylk_req);        if (ret) {                op_errno = ENOTCONN;                goto unwind;        }        return 0;unwind:        gf_log (this->name, GF_LOG_WARNING, ""failed to send the fop: %s"", strerror (op_errno));        STACK_UNWIND_STRICT (fentrylk, frame, -1, op_errno);        return 0;}",2,"cwe120,cwe476"
"G3d_readIndex(G3D_Map * map){    unsigned char *tmp, *tmp2;    int dummy1, dummy2, indexLength, tileIndex;    long indexLast;    indexLast = lseek(map->data_fd, (long)0, SEEK_END);    if (indexLast == -1) {tG3d_error(""G3d_readIndex: can't position file"");treturn 0;    }    indexLength = indexLast - map->indexOffset;    if (lseek(map->data_fd, map->indexOffset, SEEK_SET) == -1) {tG3d_error(""G3d_readIndex: can't position file"");treturn 0;    }    tmp = G3d_malloc(map->indexLongNbytes * map->nTiles);    if (tmp == NULL) {tG3d_error(""G3d_readIndex: error in G3d_malloc"");treturn 0;    }    if (indexLength < map->indexLongNbytes * map->nTiles) {t tif (indexLength > sizeof(long) * map->nTiles) {tttttt      t    tmp2 = G3d_malloc(indexLength);t    if (tmp2 == NULL) {ttG3d_error(""G3d_readIndex: error in G3d_malloc"");ttreturn 0;t    }t}telsettt t    tmp2 = (unsigned char *)map->index;tif (read(map->data_fd, tmp2, indexLength) != indexLength) {t    G3d_error(""G3d_readIndex: can't read file"");t    return 0;t}tG_rle_decode(tmp2, tmp, map->indexLongNbytes * map->nTiles, 1,tt     &dummy1, &dummy2);tif (indexLength > sizeof(long) * map->nTiles)t    G3d_free(tmp2);    }    else   if (read(map->data_fd, tmp, indexLength) != indexLength) {tG3d_error(""G3d_readIndex: can't read file"");treturn 0;    }    G3d_longDecode(tmp, map->index, map->nTiles, map->indexLongNbytes);    for (tileIndex = 0; tileIndex < map->nTiles; tileIndex++)tif (map->index[tileIndex] == 0)t    map->index[tileIndex] = -1;    G3d_free(tmp);    return 1;}",2,"cwe120,cweother"
"_activate(Evas_Object *obj){   const Elm_Hoversel_Item *item;   Evas_Object *bt, *bx, *ic;   const Eina_List *l;   char buf[4096];   ELM_HOVERSEL_DATA_GET(obj, sd);   if (sd->expanded)     {        elm_hoversel_hover_end(obj);        return;     }   sd->expanded = EINA_TRUE;   if (elm_widget_disabled_get(obj)) return;   sd->hover = elm_hover_add(sd->hover_parent);   elm_widget_mirrored_automatic_set(sd->hover, EINA_FALSE);   if (sd->horizontal)     snprintf(buf, sizeof(buf), ""hoversel_horizontal/%s"",              elm_widget_style_get(obj));   else     snprintf(buf, sizeof(buf), ""hoversel_vertical/%s"",              elm_widget_style_get(obj));   elm_object_style_set(sd->hover, buf);   evas_object_smart_callback_add     (sd->hover, ""clicked"", _on_hover_clicked, obj);   elm_hover_target_set(sd->hover, obj);       bx = elm_box_add(sd->hover);   elm_widget_mirrored_automatic_set(bx, EINA_FALSE);   elm_box_homogeneous_set(bx, EINA_TRUE);   elm_box_horizontal_set(bx, sd->horizontal);   if (sd->horizontal)     snprintf(buf, sizeof(buf), ""hoversel_horizontal_entry/%s"",              elm_widget_style_get(obj));   else     snprintf(buf, sizeof(buf), ""hoversel_vertical_entry/%s"",              elm_widget_style_get(obj));   EINA_LIST_FOREACH (sd->items, l, item)     {        bt = elm_button_add(bx);        elm_widget_mirrored_automatic_set(bt, EINA_FALSE);        elm_widget_mirrored_set(bt, elm_widget_mirrored_get(obj));        elm_object_style_set(bt, buf);        elm_object_text_set(bt, item->label);        if (item->icon_file)          {             ic = elm_icon_add(obj);             elm_image_resizable_set(ic, EINA_FALSE, EINA_TRUE);             if (item->icon_type == ELM_ICON_FILE)               elm_image_file_set(ic, item->icon_file, item->icon_group);             else if (item->icon_type == ELM_ICON_STANDARD)               elm_icon_standard_set(ic, item->icon_file);             elm_object_part_content_set(bt, ""icon"", ic);          }        evas_object_size_hint_weight_set(bt, EVAS_HINT_EXPAND, 0.0);        evas_object_size_hint_align_set(bt, EVAS_HINT_FILL, EVAS_HINT_FILL);        elm_box_pack_end(bx, bt);        evas_object_smart_callback_add(bt, ""clicked"", _on_item_clicked, item);        evas_object_show(bt);     }   if (sd->horizontal)     elm_object_part_content_set(sd->hover, elm_hover_best_content_location_get                                   (sd->hover, ELM_HOVER_AXIS_HORIZONTAL), bx);   else     elm_object_part_content_set(sd->hover, elm_hover_best_content_location_get                                   (sd->hover, ELM_HOVER_AXIS_VERTICAL), bx);   evas_object_show(sd->hover);}",2,"cwe119,cwe120"
"dwarf_fde_cfa_offset(Dwarf_P_Fde fde,    Dwarf_Unsigned reg,    Dwarf_Signed offset, Dwarf_Error * error){    Dwarf_Ubyte opc, regno;    char *ptr = 0;    Dwarf_P_Frame_Pgm curinst;    int nbytes = 0;    int res = 0;    char buff1[ENCODE_SPACE_NEEDED];    Dwarf_P_Debug dbg = fde->fde_dbg;    curinst = (Dwarf_P_Frame_Pgm)        _dwarf_p_get_alloc(dbg, sizeof(struct Dwarf_P_Frame_Pgm_s));    if (curinst == NULL) {        DWARF_P_DBG_ERROR(dbg, DW_DLE_FPGM_ALLOC,            (Dwarf_P_Fde) DW_DLV_BADADDR);    }    opc = DW_CFA_offset;    regno = reg;    if (regno & 0xc0) {        DWARF_P_DBG_ERROR(dbg, DW_DLE_REGNO_OVFL,            (Dwarf_P_Fde) DW_DLV_BADADDR);    }    opc = opc | regno;               curinst->dfp_opcode = opc;    res = _dwarf_pro_encode_leb128_nm(offset, &nbytes,        buff1, sizeof(buff1));    if (res != DW_DLV_OK) {        _dwarf_p_error(dbg, error, DW_DLE_STRING_ALLOC);        return ((Dwarf_P_Fde) DW_DLV_BADADDR);    }    ptr = (char *) _dwarf_p_get_alloc(dbg, nbytes);    if (ptr == NULL) {        _dwarf_p_error(dbg, error, DW_DLE_STRING_ALLOC);        return ((Dwarf_P_Fde) DW_DLV_BADADDR);    }    memcpy(ptr, buff1, nbytes);    curinst->dfp_args = ptr;    curinst->dfp_nbytes = nbytes;    curinst->dfp_next = NULL;    _dwarf_pro_add_to_fde(fde, curinst);    return fde;}",2,"cwe119,cwe120"
"ucs2enclen(const ucs2 *s, size_t n, const char quote[128]){  size_t len = 1;  ucs2 c;    while (n-- > 0) {    c = *s++;    if (c < 0x80u)      if (quote && quote[c])tlen += 2;      else {tif (!c) break;tlen += 1;      }    else if (c < 0x800u)      len += 2;    else        len += 3;  }  return len;}",2,"cwe119,cwe120"
"crypto_aead_encrypt(ttunsigned char *c, unsigned long long *clen,ttconst unsigned char *m, unsigned long long mlen,ttconst unsigned char *ad, unsigned long long adlen,ttconst unsigned char *nsec,                           ttconst unsigned char *npub,ttconst unsigned char *ktt){         *clen = mlen + CRYPTO_ABYTES;        unsigned char tag[CRYPTO_ABYTES];    ae_cxt* cxt = ae_allocate();    if(!cxt)        return RETURN_MEMORY_FAIL;             if(ae_init(cxt, k, CRYPTO_KEYBYTES))        return RETURN_KEYSIZE_ERR;             process_ad(cxt, ad, adlen, npub, CRYPTO_NPUBBYTES);             ae_encrypt(cxt, (unsigned char*)m, mlen, c, tag, CRYPTO_ABYTES, ENC);             memcpy(c+mlen, tag, CRYPTO_ABYTES);tfree(cxt);treturn RETURN_SUCCESS;}",2,"cwe119,cwe120"
"e2_start_ext_scan(Epson_Scanner * s){tSANE_Status status;tunsigned char params[2];tunsigned char buf[14];tDBG(5, ""%s"", __func__);tparams[0] = FS;tparams[1] = 'G';tstatus = e2_txrx(s, params, 2, buf, 14);tif (status != SANE_STATUS_GOOD)ttreturn status;tif (buf[0] != STX)ttreturn SANE_STATUS_INVAL;tif (buf[1] & 0x80) {ttDBG(1, ""%s: fatal error"", __func__);ttreturn SANE_STATUS_IO_ERROR;t}ts->ext_block_len = le32atoh(&buf[2]);ts->ext_blocks = le32atoh(&buf[6]);ts->ext_last_len = le32atoh(&buf[10]);ts->ext_counter = 0;tDBG(5, "" status         : 0x%02x"", buf[1]);tDBG(5, "" block size     : %u"", (unsigned int) le32atoh(&buf[2]));tDBG(5, "" block count    : %u"", (unsigned int) le32atoh(&buf[6]));tDBG(5, "" last block size: %u"", (unsigned int) le32atoh(&buf[10]));tif (s->ext_last_len) {tts->ext_blocks++;ttDBG(1, ""adjusted block count: %d"", s->ext_blocks);t}t tif (s->ext_block_len == 0 && s->ext_last_len)tts->ext_block_len = s->ext_last_len;treturn status;}",2,"cwe119,cwe120"
"dump_entry(FILE *f, dns_adbentry_t *entry, isc_boolean_t debug,t   isc_stdtime_t now){tchar addrbuf[ISC_NETADDR_FORMATSIZE];tchar typebuf[DNS_RDATATYPE_FORMATSIZE];tisc_netaddr_t netaddr;tdns_adblameinfo_t *li;tisc_netaddr_fromsockaddr(&netaddr, &entry->sockaddr);tisc_netaddr_format(&netaddr, addrbuf, sizeof(addrbuf));tif (debug)ttfprintf(f, "";t%p: refcnt %u"", entry, entry->refcnt);tfprintf(f, "";t%s [srtt %u] [flags %08x] [edns %u/%u/%u/%u/%u] ""tt""[plain %u/%u]"", addrbuf, entry->srtt, entry->flags,ttentry->edns, entry->to4096, entry->to1432, entry->to1232,ttentry->to512, entry->plain, entry->plainto);tif (entry->udpsize != 0U)ttfprintf(f, "" [udpsize %u]"", entry->udpsize);#ifdef ISC_PLATFORM_USESITtif (entry->sit != NULL) {ttunsigned int i;ttfprintf(f, "" [sit="");ttfor (i = 0; i < entry->sitlen; i++)tttfprintf(f, ""%02x"", entry->sit[i]);ttfprintf(f, ""]"");t}#endiftif (entry->expires != 0)ttfprintf(f, "" [ttl %d]"", entry->expires - now);tfprintf(f, """");tfor (li = ISC_LIST_HEAD(entry->lameinfo);t     li != NULL;t     li = ISC_LIST_NEXT(li, plink)) {ttfprintf(f, "";tt"");ttprint_dns_name(f, &li->qname);ttdns_rdatatype_format(li->qtype, typebuf, sizeof(typebuf));ttfprintf(f, "" %s [lame TTL %d]"", typebuf,tttli->lame_timer - now);t}}",2,"cwe119,cwe120"
"xalloc(u_int i, char **arr){tchar **xrr;tu_int ac = i / DEFAULT_ALLOC;tif (i % DEFAULT_ALLOC == 0) {ttxrr = realloc(arr, sizeof(char *) * DEFAULT_ALLOC * ++ac);ttif (xrr == NULL) {tttarr[i - 1] = NULL;tttfreea(arr);tttreturn (NULL);tt}ttarr = xrr;t}treturn (arr);}",2,"cwe469,cwe476"
"save_config(config_t *c, w_data *d){    et_string_t str;    char path[1024];    FILE *f = NULL;    et_str_new(&str, 1024);    debugln(""Saving config"");    if (get_config_filename(&str) != 0) {tfprintf(stderr, ""Could not locate config file"");tet_str_end(&str);treturn -1;    }    f = fopen(str.buf, ""w"");    if (f == NULL) {tfprintf(stderr, ""Could not open config file %s for writing: %s"", path, strerror(errno));tet_str_end(&str);treturn -1;    }    fprintf(f, ""version=1"");    for (action_t ac = ac_tile_begin; ac < ac_tile_end; ac++) {tif (fprintf_sizes(f, c, ac) < 0) {t    fclose(f);t    et_str_end(&str);t    return -1;t}    }         for (int i = 0; i < d->_hk_count; i++) {tet_str_clear(&str);tw_key2str(d, &(d->_hotkeys[i].key), &str);tfprintf(f, ""hotkey_%s=%s"", action_names[d->_hotkeys[i].action].cfgname, str.buf);    }    fclose(f);    et_str_end(&str);    return 0;}",3,"cwe119,cwe120,cweother"
"dcc_wingate_proxy_traverse (GIOChannel *source, GIOCondition condition, struct DCC *dcc){tstruct proxy_state *proxy = dcc->proxy;tif (proxy->phase == 0)t{ttproxy->buffersize = snprintf ((char*) proxy->buffer, MAX_PROXY_BUFFER,tttttttttt""%s %dr"", net_ip(dcc->addr),ttttttttttdcc->port);ttproxy->bufferused = 0;ttdcc->wiotag = fe_input_add (dcc->sok, FIA_WRITE|FIA_EX,tttttttttdcc_wingate_proxy_traverse, dcc);tt++proxy->phase;t}tif (proxy->phase == 1)t{ttif (!read_proxy (dcc))tttreturn TRUE;ttfe_input_remove (dcc->wiotag);ttdcc->wiotag = 0;ttdcc_connect_finished (source, 0, dcc);t}treturn TRUE;}",2,"cwe119,cwe120"
"loadfile( const char * file,          void       * data ){    char buf[ 512 ];    char *cwd = fli_getcwd( buf, sizeof buf - 2 );    const char *s = strstr( file, cwd );    FL_OBJECT *ob;    if ( ! s )        s = file;    else        s = file + strlen( cwd ) + 1;    ob = ( data && * ( long * ) data ) ?         bt_attrib->focus_filename : bt_attrib->filename;    fl_set_input( ob, s );    fl_call_object_callback( ob );    return 1;}",2,"cwe119,cwe120"
"init_bcstate(struct IsdnCardState *cs, int bc){tstruct BCState *bcs = cs->bcs + bc;tbcs->cs = cs;tbcs->channel = bc;tINIT_WORK(&bcs->tqueue, BChannel_bh);tspin_lock_init(&bcs->aclock);tbcs->BC_SetStack = NULL;tbcs->BC_Close = NULL;tbcs->Flag = 0;}",2,"cwe119,cwe120"
"print_header_altformat( FILE       * fn,                        FL_FORM    * form,                        const char * fname){    FL_OBJECT *obj;    char name[ MAX_VAR_LEN ],         cbname[ MAX_VAR_LEN ],         argname[ MAX_VAR_LEN ];    int first = 1;    fprintf( fn, ""extern FL_FORM *%s;"", fname );    init_array_names( );    obj = form->first;    while ( ( obj = obj->next ) != NULL )    {        get_object_name( obj, name, cbname, argname );        if ( *name )        {            if ( ! check_array_name( name ) )            {                fprintf( fn, first ? ""extern FL_OBJECT"" : "","" );                first = 0;                fprintf( fn, ""        *%s"", name );            }        }    }    if ( arethere_array_names( ) )    {        fprintf( fn, first ? ""extern FL_OBJECT"" : "","" );        first = 0;        print_array_names( fn, 0 );    }    if ( ! first )        fprintf( fn, "";"" );}",3,"cwe119,cwe120,cweother"
"sock_initobj(PyObject *self, PyObject *args, PyObject *kwds){    PySocketSockObject *s = (PySocketSockObject *)self;    PyObject *fdobj = NULL;    SOCKET_T fd = INVALID_SOCKET;    int family = AF_INET, type = SOCK_STREAM, proto = 0;    static char *keywords[] = {""family"", ""type"", ""proto"", ""fileno"", 0};    if (!PyArg_ParseTupleAndKeywords(args, kwds,                                     ""|iiiO:socket"", keywords,                                     &family, &type, &proto, &fdobj))        return -1;    if (fdobj != NULL && fdobj != Py_None) {#ifdef MS_WINDOWS                 if (PyBytes_Check(fdobj)) {            WSAPROTOCOL_INFO info;            if (PyBytes_GET_SIZE(fdobj) != sizeof(info)) {                PyErr_Format(PyExc_ValueError,                    ""socket descriptor string has wrong size, ""                    ""should be %zu bytes."", sizeof(info));                return -1;            }            memcpy(&info, PyBytes_AS_STRING(fdobj), sizeof(info));            Py_BEGIN_ALLOW_THREADS            fd = WSASocket(FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO,                     FROM_PROTOCOL_INFO, &info, 0, WSA_FLAG_OVERLAPPED);            Py_END_ALLOW_THREADS            if (fd == INVALID_SOCKET) {                set_error();                return -1;            }            family = info.iAddressFamily;            type = info.iSocketType;            proto = info.iProtocol;        }        else#endif        {            fd = PyLong_AsSocket_t(fdobj);            if (fd == (SOCKET_T)(-1) && PyErr_Occurred())                return -1;            if (fd == INVALID_SOCKET) {                PyErr_SetString(PyExc_ValueError,                                ""can't use invalid socket value"");                return -1;            }        }    }    else {        Py_BEGIN_ALLOW_THREADS        fd = socket(family, type, proto);        Py_END_ALLOW_THREADS        if (fd == INVALID_SOCKET) {            set_error();            return -1;        }    }    init_sockobject(s, fd, family, type, proto);    return 0;}",2,"cwe119,cwe120"
"GetImageGeometry(const Image *image,const char *geometry,  const unsigned int size_to_fit,RectangleInfo *region_info){  char    region_geometry[MaxTextExtent];  int    flags;  region_info->width=image->columns;  region_info->height=image->rows;  region_info->x=0;  region_info->y=0;  (void) strlcpy(region_geometry,geometry,MaxTextExtent);  if (!size_to_fit)    (void) strlcat(region_geometry,""!"",MaxTextExtent);  flags=GetMagickGeometry(region_geometry,&region_info->x,&region_info->y,    &region_info->width,&region_info->height);  switch (image->gravity)  {    case ForgetGravity:    case NorthWestGravity:      break;    case NorthGravity:    {      region_info->x+=(long) (image->columns/2-region_info->width/2);      break;    }    case NorthEastGravity:    {      region_info->x=(long) (image->columns-region_info->width-region_info->x);      break;    }    case WestGravity:    {      region_info->y+=(long) (image->rows/2-region_info->height/2);      break;    }    case StaticGravity:    case CenterGravity:    default:    {      region_info->x+=(long) (image->columns/2-region_info->width/2);      region_info->y+=(long) (image->rows/2-region_info->height/2);      break;    }    case EastGravity:    {      region_info->x=(long) (image->columns-region_info->width-region_info->x);      region_info->y+=(long) (image->rows/2-region_info->height/2);      break;    }    case SouthWestGravity:    {      region_info->y=(long) (image->rows-region_info->height-region_info->y);      break;    }    case SouthGravity:    {      region_info->x+=(long) (image->columns/2-region_info->width/2);      region_info->y=(long) (image->rows-region_info->height-region_info->y);      break;    }    case SouthEastGravity:    {      region_info->x=(long) (image->columns-region_info->width-region_info->x);      region_info->y=(long) (image->rows-region_info->height-region_info->y);      break;    }  }  return(flags);}",2,"cwe119,cwe120"
"Str2Double(char *s){ double a = CF_NODOUBLE;  char remainder[CF_BUFSIZE];  char output[CF_BUFSIZE];  char c = 'X';  if (s == NULL)   {   return CF_NODOUBLE;   }remainder[0] = '0';sscanf(s,""%lf%c%s"",&a,&c,remainder);if (a == CF_NODOUBLE || !IsSpace(remainder))   {   snprintf(output,CF_BUFSIZE,""Error reading assumed real value %s (anomalous remainder %s)"",s,remainder);   ReportError(output);   }else   {   switch (c)      {      case 'k':          a = 1000 * a;          break;      case 'K':          a = 1024 * a;          break;                case 'm':          a = 1000 * 1000 * a;          break;      case 'M':          a = 1024 * 1024 * a;          break;                case 'g':          a = 1000 * 1000 * 1000 * a;          break;      case 'G':          a = 1024 * 1024 * 1024 * a;          break;                case '%':          if (a < 0 || a > 100)             {             CfOut(cf_error,"""",""Percentage out of range (%d)"",a);             return CF_NOINT;             }          else             {                           a = -a;             }          break;      case ' ':          break;                default:                    break;      }   }return a;}",3,"cwe119,cwe120,cweother"
"podcast_parse(podcast_t * podcast, GSList ** list) {txmlDocPtr doc;txmlNodePtr node;tchar filename[MAXLEN];tchar * file;tfile = podcast_file_from_url(podcast->url);tsnprintf(filename, MAXLEN-1, ""%s/.%s"", podcast->dir, file);tfree(file);tif (podcast_generic_download(podcast, podcast->url, filename, NULL, NULL) < 0) {ttreturn -1;t}tdoc = xmlParseFile(filename);tif (doc == NULL) {ttunlink(filename);ttreturn -1;t}tnode = xmlDocGetRootElement(doc);tif (node == NULL) {ttxmlFreeDoc(doc);ttunlink(filename);ttreturn -1;t}tif (!xmlStrcmp(node->name, (const xmlChar *)""rss"")) {ttparse_rss(podcast, list, doc, node);t} else if (!xmlStrcmp(node->name, (const xmlChar *)""feed"")) {ttparse_atom(podcast, list, doc, node);t} else {ttfprintf(stderr, ""unknown feed format: %s"", node->name);t}txmlFreeDoc(doc);tunlink(filename);treturn 0;}",2,"cwe119,cwe120"
"FC_GenerateRandom(CK_SESSION_HANDLE hSession,    CK_BYTE_PTRtpRandomData, CK_ULONG ulRandomLen) {    CK_RV crv;    CHECK_FORK();    SFTK_FIPSFATALCHECK();    crv = NSC_GenerateRandom(hSession,pRandomData,ulRandomLen);    if (crv != CKR_OK) {tsftk_fatalError = PR_TRUE;tif (sftk_audit_enabled) {t    char msg[128];t    PR_snprintf(msg,sizeof msg,ttt""C_GenerateRandom(hSession=0x%08lX, pRandomData=%p, ""ttt""ulRandomLen=%lu)=0x%08lX ""ttt""self-test: continuous RNG test failed"",ttt(PRUint32)hSession,pRandomData,ttt(PRUint32)ulRandomLen,(PRUint32)crv);t    sftk_LogAuditMessage(NSS_AUDIT_ERROR, NSS_AUDIT_SELF_TEST, msg);t}    }    return crv;}",2,"cwe119,cwe120"
"EscReport(u_char mode, u_short arg){    static char report[LEN_REPORT];    switch(mode) {    case 'n':tif (arg == 6) {t    int x = (con.x < con.xmax) ? con.x : con.xmax;t    int y = (con.y < con.ymax) ? con.y : con.ymax;t    snprintf(report, sizeof(report), ""x1B[%d;%dR"", y + 1, x + 1);t} else if (arg == 5)t    strcpy(report, ""x1B[0n0"");t tbreak;    case 'c':tif (arg == 0) strcpy(report, ""x1B[?6c0"");t tbreak;    }    write(masterPty, report, strlen(report));}",2,"cwe119,cwe120"
"cmd_sys(void){        int c, cnt;tulong sflag;tsflag = FALSE;        while ((c = getopt(argcnt, args, ""cp:"")) != EOF) {                switch(c)                {ttcase 'p':tttif (STREQ(optarg, ""anic""))ttttpanic_this_kernel();tttelsettttargerrs++;tttbreak;ttcase 'c':tttsflag = TRUE;tttbreak;                default:                        argerrs++;                        break;                }        }        if (argerrs)                cmd_usage(pc->curcmd, SYNOPSIS);        if (!args[optind]) {ttif (sflag)tttdump_sys_call_table(NULL, 0);ttelsetttdisplay_sys_stats();ttreturn;t}tcnt = 0;        do {                if (sflag)                        dump_sys_call_table(args[optind], cnt++);ttelse if (STREQ(args[optind], ""config""))tttread_in_kernel_config(IKCFG_READ);                else                        cmd_usage(args[optind], COMPLETE_HELP);                optind++;        } while (args[optind]);}",3,"cwe120,cwe476,cweother"
"""M_DrawOPLDev(void){    extern void I_OPL_DevMessages(char *);    char debug[1024];    char *curr, *p;    int line;    I_OPL_DevMessages(debug);    curr = debug;    line = 0;    for (;;)    {        p = strchr(curr, '');        if (p != NULL)        {            *p = '0';        }        M_WriteText(0, line * 8, curr);        ++line;        if (p == NULL)        {            break;        }        curr = p + 1;    }}""",2,"cwe119,cwe120"
"editFile(const char *fname){tconst char *editorName;tchart   *sys;tinttttresult;tpsql_assert(fname);t teditorName = getenv(""PSQL_EDITOR"");tif (!editorName)tteditorName = getenv(""EDITOR"");tif (!editorName)tteditorName = getenv(""VISUAL"");tif (!editorName)tteditorName = DEFAULT_EDITOR;t tsys = pg_malloc(strlen(editorName) + strlen(fname) + 10 + 1);#ifndef WIN32tsprintf(sys, ""exec %s '%s'"", editorName, fname);#elsetsprintf(sys, SYSTEMQUOTE """"%s"" ""%s"""" SYSTEMQUOTE, editorName, fname);#endiftresult = system(sys);tif (result == -1)ttpsql_error(""could not start editor ""%s"""", editorName);telse if (result == 127)ttpsql_error(""could not start /bin/sh"");tfree(sys);treturn result == 0;}",2,"cwe120,cweother"
"gsasl_sha1 (const char *in, size_t inlen, char *out[20]){  *out = malloc (20);  if (!*out)    return GSASL_MALLOC_ERROR;  return gc_sha1 (in, inlen, *out);}",2,"cwe119,cwe120"
"""Binary( char *nome ){tchar ch, cc;tint cont=0, nint = 1, tobin=0;tint ex, nbin;ttwhile( *nome && ( cont < 7 ) ) {ttch = *nome;ttif( !(IsBinary( ch ) ) )tttnint = 0;ttelsett{tttif( ch == '1') {ttttcc = 1;ttttex = (6 - cont);ttttnbin = cc<<ex;tttttobin = tobin + nbin;ttt}tt}ttnome++;ttcont++;t}ttif( nint == 0 )ttreturn nint;telsettreturn tobin;}""",2,"cwe119,cwe120"
"EnvisatFile_SetKeyValueAsInt( EnvisatFile *self,                                   EnvisatFile_HeaderFlag mph_or_sph,                                  const char *key,                                  int value ){    char format[32], string_value[128];    const char *prototype_value;    prototype_value = EnvisatFile_GetKeyValueAsString( self, mph_or_sph, key, NULL);    if( prototype_value == NULL )    {        charterror_buf[2048];        sprintf( error_buf,                  ""Unable to set header field ""%s"", field not found."",                  key );        SendError( error_buf );        return FAILURE;    }    sprintf( format, ""%%+0%dd"", (int) strlen(prototype_value) );    sprintf( string_value, format, value );    return EnvisatFile_SetKeyValueAsString( self, mph_or_sph, key, string_value );}",3,"cwe119,cwe120,cweother"
"v_get(size)inttsize;{   VECt*vector;      if (size < 0)     error(E_NEG,""v_get"");   if ((vector=NEW(VEC)) == (VEC *)NULL )     error(E_MEM,""v_get"");   else if (mem_info_is_on()) {      mem_bytes(TYPE_VEC,0,sizeof(VEC));      mem_numvar(TYPE_VEC,1);   }      vector->dim = vector->max_dim = size;   if ((vector->ve=NEW_A(size,Real)) == (Real *)NULL )   {      free(vector);      error(E_MEM,""v_get"");   }   else if (mem_info_is_on()) {      mem_bytes(TYPE_VEC,0,size*sizeof(Real));   }      return (vector);}",2,"cwe476,cweother"
"lock_it(unsigned char *qpath,unsigned char *bf){        unsigned char *path = dequote(qpath);tunsigned char *lock_name=dirprt(path);tunsigned char *name=namprt(path);tunsigned char buf[1024];tunsigned char *user = (unsigned char *)getenv(""USER"");tunsigned char *host = (unsigned char *)getenv(""HOSTNAME"");tint len;tif (!user) user=USTR ""me"";tif (!host) host=USTR ""here"";tlock_name=vsncpy(sv(lock_name),sc("".#""));tlock_name=vsncpy(sv(lock_name),sv(name));tjoe_snprintf_3(buf,sizeof(buf),""%s@%s.%d"",user,host,getpid());t tif (!symlink((char *)buf,(char *)lock_name) || errno != EEXIST) {ttvsrm(lock_name);ttvsrm(name);ttreturn 0;t}tif (bf) {ttlen = readlink((char *)lock_name,(char *)bf,255);ttif (len<0) len = 0;ttbf[len] = 0;t}tvsrm(lock_name);tvsrm(name);treturn -1;}",3,"cwe119,cwe120,cweother"
"ackup_argv_get( const char *name, const char *path, char ***argv ){tchar **av, arg_buf[ ARG_BUF_SIZE + 1 ];tint i, ret;tstruct tm tm;ttime_t ct;tBarg *arg;tct = time( NULL );tif( ! localtime_r( &ct, &tm ) )t{ttfprintf( stderr, ""backarg_get_argv: localtime_r error"" );ttreturn 0;t}tav = (char **) malloc( sizeof(char *) * ( barg_list.count + 1) );tif( ! av )t{ttfprintf( stderr, ""backarg_get_argv: malloc: "" tttt""could not allocate memory"" );ttreturn 0;t}targ = barg_list.start;tfor( i = 0 ; i < barg_list.count ; i++ )t{ttif( arg->type == ARG_STATIC )tttav[ i ] = arg->arg;ttelsett{tttret = backarg_expand( arg_buf, sizeof(arg_buf),tttttarg->arg, name, path, hostname, &tm );tttif( ! ret )ttt{ttttfprintf( stderr, ""backarg_get_argv: "" tttttt""could not expand back args"");ttttreturn 0;ttt}tttav[ i ] = strdup( arg_buf );tttif( ! av[ i ] )ttt{ttttfprintf( stderr, ""backarg_get_argv: strdup: "" tttttt""could not allocate memory"");ttttreturn 0;ttt}tt}ttarg = arg->next;t}tav[ barg_list.count ] = NULL;t*argv = av;treturn 1;}",3,"cwe119,cwe120,cweother"
"read_proc_info(const pid_t pid, pid_t *ppid, char *name, int max_size){tchar path[MAX_SHORTNAME], info[max_size], c;tint fd, xpid, r = 0;tsnprintf(path, sizeof(path), ""/proc/%u/stat"", pid);tif ((fd = open(path, O_RDONLY)) < 0)ttreturn 0;tif (read(fd, info, max_size) > 0 &&t    sscanf(info, ""%d %s %c %d"", &xpid, name, &c, ppid) == 4)ttr = 1;tif (!r) {tt*ppid = 0;ttname[0] = '0';t}tclose(fd);treturn r;}",3,"cwe119,cwe120,cweother"
"airEnumFmtDesc(const airEnum *enm, int val, int canon, const char *fmt) {  const char *desc;  char *buff, ident[AIR_STRLEN_SMALL];  const char *_ident;  int i;  size_t len;  if (!(enm && enm->desc && fmt)) {    return airStrdup(""(airEnumDesc: invalid args)"");  }  if (airEnumValCheck(enm, val)) {    val = airEnumUnknown(enm);  }  _ident = airEnumStr(enm, val);  if (!canon && enm->strEqv) {    len = airStrlen(_ident);    for (i=0; airStrlen(enm->strEqv[i]); i++) {      if (val != enm->valEqv[i]) {                 continue;      }      if (airStrlen(enm->strEqv[i]) < len) {                 len = airStrlen(enm->strEqv[i]);        _ident = enm->strEqv[i];      }    }  }  airStrcpy(ident, AIR_STRLEN_SMALL, _ident);  if (!enm->sense) {    airToLower(ident);  }  desc = enm->desc[_airEnumIndex(enm, val)];  buff = AIR_CALLOC(airStrlen(fmt) + airStrlen(ident) +                    airStrlen(desc) + 1, char);  if (buff) {    sprintf(buff, fmt, ident, desc);  }  return buff;}",3,"cwe119,cwe120,cweother"
"istgt_lu_create_threads(ISTGT_Ptr istgt, int new_only){#ifdef HAVE_PTHREAD_SET_NAME_NPtchar buf[MAX_TMPBUF];#endiftISTGT_LU_Ptr lu;tint rc;tint i;tISTGT_TRACELOG(ISTGT_TRACE_DEBUG, ""istgt_lu_create_threads"");tfor (i = 0; i < MAX_LOGICAL_UNIT; i++) {ttlu = istgt->logical_unit[i];ttif (lu == NULL)tttcontinue;ttif (new_only && !lu->to_add) {tttISTGT_TRACELOG(ISTGT_TRACE_DEBUG, ""skip existing LUN %d"", i);tttcontinue;tt}ttif (lu->queue_depth != 0) {ttt #ifdef ISTGT_STACKSIZEtttrc = pthread_create(&lu->thread, &istgt->attr, &luworker, (void *)lu);#elsetttrc = pthread_create(&lu->thread, NULL, &luworker, (void *)lu);#endiftttif (rc != 0) {ttttISTGT_ERRLOG(""pthread_create() failed"");ttttreturn -1;ttt}#if 0tttrc = pthread_detach(lu->thread);tttif (rc != 0) {ttttISTGT_ERRLOG(""pthread_detach() failed"");ttttreturn -1;ttt}#endif#ifdef HAVE_PTHREAD_SET_NAME_NPtttsnprintf(buf, sizeof buf, ""luthread #%d"", i);tttpthread_set_name_np(lu->thread, buf);#endiftt}t}treturn 0;}",2,"cwe119,cwe120"
"jcr_send_start_stream(void) {  extern jcr_instance jcr;  char buf[512];  char *name = xmlnode_get_data(xmlnode_get_tag(jcr->config,""name""));  char *host = xmlnode_get_data(xmlnode_get_tag(jcr->config,""host""));  gsize bytes;  GError *error = NULL;  GIOStatus rc;  memset(buf, 0, 512);  snprintf(buf, 511, ""<?xml version='1.0'?><stream:stream xmlns:stream='http://etherx.jabber.org/streams' xmlns='jabber:component:accept' to='%s' from='%s'>"", name, host);  rc = g_io_channel_write_chars(jcr->gio, buf, strlen(buf), &bytes, &error);  if (rc != G_IO_STATUS_NORMAL) {    log_warn(JDBG, ""Opening XML stream failed, rc=%d"", rc);  } else {    log_debug(JDBG, ""Opening XML stream: sent %d bytes"", bytes);  }}",2,"cwe119,cwe120"
"php_network_populate_name_from_sockaddr(tt ttstruct sockaddr *sa, socklen_t sl,tt ttchar **textaddr, long *textaddrlen,tt ttstruct sockaddr **addr,ttsocklen_t *addrlenttTSRMLS_DC){tif (addr) {tt*addr = emalloc(sl);ttmemcpy(*addr, sa, sl);tt*addrlen = sl;t}tif (textaddr) {#if HAVE_IPV6 && HAVE_INET_NTOPttchar abuf[256];#endifttchar *buf = NULL;ttswitch (sa->sa_family) {tttcase AF_INET:tttt ttttbuf = inet_ntoa(((struct sockaddr_in*)sa)->sin_addr);ttttif (buf) {ttttt*textaddrlen = spprintf(textaddr, 0, ""%s:%d"",ttttttbuf, ntohs(((struct sockaddr_in*)sa)->sin_port));tttt}ttttbreak;#if HAVE_IPV6 && HAVE_INET_NTOPtttcase AF_INET6:ttttbuf = (char*)inet_ntop(sa->sa_family, &((struct sockaddr_in6*)sa)->sin6_addr, (char *)&abuf, sizeof(abuf));ttttif (buf) {ttttt*textaddrlen = spprintf(textaddr, 0, ""%s:%d"",ttttttbuf, ntohs(((struct sockaddr_in6*)sa)->sin6_port));tttt}ttttbreak;#endif#ifdef AF_UNIXtttcase AF_UNIX:tttt{tttttstruct sockaddr_un *ua = (struct sockaddr_un*)sa;tttttif (ua->sun_path[0] == '0') {tttttt ttttttint len = strlen(ua->sun_path + 1) + 1;tttttt*textaddrlen = len;tttttt*textaddr = emalloc(len + 1);ttttttmemcpy(*textaddr, ua->sun_path, len);tttttt(*textaddr)[len] = '0';ttttt} else {tttttt*textaddrlen = strlen(ua->sun_path);tttttt*textaddr = estrndup(ua->sun_path, *textaddrlen);ttttt}tttt}ttttbreak;#endiftt}t}}",2,"cwe119,cwe120"
"_add_volinfo_dict_to_prdict (dict_t *this, char *key, data_t *value, void *data){        glusterd_voldict_ctx_t   *ctx = NULL;        char                    optkey[512] = {0,};        int                     ret = -1;        ctx = data;        snprintf (optkey, sizeof (optkey), ""volume%d.%s%d"", ctx->count,                  ctx->key_name, ctx->opt_count);        ret = dict_set_str (ctx->dict, optkey, key);        if (ret)                gf_log ("""", GF_LOG_ERROR, ""option add for %s%d %s"",                        ctx->key_name, ctx->count, key);        snprintf (optkey, sizeof (optkey), ""volume%d.%s%d"", ctx->count,                  ctx->val_name, ctx->opt_count);        ret = dict_set_str (ctx->dict, optkey, value->data);        if (ret)                gf_log ("""", GF_LOG_ERROR, ""option add for %s%d %s"",                        ctx->val_name, ctx->count, value->data);        ctx->opt_count++;        return;}",2,"cwe119,cwe120"
"PrintFancyAli(FILE *fp, struct fancyali_s *ali){  char  buffer[ALILENGTH+1];t   int   starti, endi;  int   pos;  int   i;  buffer[ALILENGTH] = '0';  endi = ali->sqfrom - 1;  for (pos = 0; pos < ali->len; pos += ALILENGTH)    {tttt       starti = endi + 1;      for (i = pos; ali->aseq[i] != '0' && i < pos + ALILENGTH; i++)tif (!isgap(ali->aseq[i])) endi++;t          if (ali->csline != NULL) {tstrncpy(buffer, ali->csline+pos, ALILENGTH);tfprintf(fp, ""  %16s %s"", ""CS"", buffer);      }      if (ali->rfline != NULL) {tstrncpy(buffer, ali->rfline+pos, ALILENGTH);tfprintf(fp, ""  %16s %s"", ""RF"", buffer);      }      if (ali->model  != NULL) {tstrncpy(buffer, ali->model+pos, ALILENGTH);tfprintf(fp, ""  %16s %s"", "" "", buffer);      }      if (ali->mline  != NULL) {tstrncpy(buffer, ali->mline+pos, ALILENGTH);tfprintf(fp, ""  %16s %s"", "" "", buffer);      }      if (ali->aseq   != NULL) { tstrncpy(buffer, ali->aseq+pos, ALILENGTH);tif (endi >= starti)t  fprintf(fp, ""  %10.10s %5d %s %-5d"", ali->target, starti, buffer, endi);telset  fprintf(fp, ""  %10.10s %5s %s %-5s"", ali->target, ""-"", buffer, ""-"");       }    }     fflush(fp);  return;}",2,"cwe119,cwe120"
"copy_out(struct archive_write *a, uint64_t offset, uint64_t length){tstruct _7zip *zip;tint r;tzip = (struct _7zip *)a->format_data;tif (zip->temp_offset > 0 &&t    lseek(zip->temp_fd, offset, SEEK_SET) < 0) {ttarchive_set_error(&(a->archive), errno, ""lseek failed"");ttreturn (ARCHIVE_FATAL);t}twhile (length) {ttsize_t rsize;ttssize_t rs;ttunsigned char *wb;ttif (length > zip->wbuff_remaining)tttrsize = zip->wbuff_remaining;ttelsetttrsize = (size_t)length;ttwb = zip->wbuff + (sizeof(zip->wbuff) - zip->wbuff_remaining);ttrs = read(zip->temp_fd, wb, rsize);ttif (rs < 0) {tttarchive_set_error(&(a->archive), errno,ttt    ""Can't read temporary file(%jd)"",ttt    (intmax_t)rs);tttreturn (ARCHIVE_FATAL);tt}ttif (rs == 0) {tttarchive_set_error(&(a->archive), 0,ttt    ""Truncated 7-Zip archive"");tttreturn (ARCHIVE_FATAL);tt}ttzip->wbuff_remaining -= rs;ttlength -= rs;ttif (zip->wbuff_remaining == 0) {tttr = flush_wbuff(a);tttif (r != ARCHIVE_OK)ttttreturn (r);tt}t}treturn (ARCHIVE_OK);}",2,"cwe120,cweother"
"read_outer_auto_keys (joiner *jr, int j, int i){    char *tfmt = jr->auto_keys->timefmt;    int numdates = jr->auto_keys->numdates;    int tcol = jr->auto_keys->keycol;    int pd = jr->l_dset->pd;    struct tm t = {0};    char sconv[32];    const char *s;    char *test;    int s_src = 0;    int err = 0;    if (tcol >= 0) {t tif (numdates) {t     t    numdate_to_string(sconv, jr->r_dset->Z[tcol][i]);t    s = sconv;t    s_src = 1;t} else {t     t    s = series_get_string_for_obs(jr->r_dset, tcol, i);t    s_src = 2;t}    } else {t ts = jr->r_dset->S[i];ts_src = 3;    }    test = strptime(s, tfmt, &t);    if (test == NULL || *test != '0') {terr = E_DATA;tif (j == 0 && test != NULL && (pd == 12 || pd == 4 || pd == 1)) {t     t    char *chk = strptime(s, ""%Y-%m-%d"", &t);t    if (chk != NULL && *chk == '0') {ttset_time_format(jr->auto_keys, ""%Y-%m-%d"");tterr = 0;  t    }t}tif (err) {t    gretl_errmsg_sprintf(""'%s' does not match the format '%s'"", s, tfmt);t    fprintf(stderr, ""time-format match error in read_outer_auto_keys:""tt    "" remainder = '%s' (source = %s)"", test ? test : ""null"", tt    s_src < 3 ? ""specified time column"" : ""first-column strings"");t}    }    if (!err) {terr = real_set_outer_auto_keys(jr, s, j, &t);    }    return err;}",2,"cwe119,cwe120"
"nautilus_file_set_integer_metadata (NautilusFile *file,tttt    const char   *key,tttt    int           default_metadata,tttt    int           metadata){tchar value_as_string[32];tchar default_as_string[32];tg_return_if_fail (NAUTILUS_IS_FILE (file));tg_return_if_fail (key != NULL);tg_return_if_fail (key[0] != '0');tg_snprintf (value_as_string, sizeof (value_as_string), ""%d"", metadata);tg_snprintf (default_as_string, sizeof (default_as_string), ""%d"", default_metadata);tnautilus_file_set_metadata (file, key,tttt    default_as_string, value_as_string);}",2,"cwe119,cwe120"
"smime_sign(FILE *ip, struct header *headp){tFILEt*sp, *fp, *bp, *hp;tchart*cp, *addr;tX509t*cert;tPKCS7t*pkcs7;tEVP_PKEYt*pkey;tBIOt*bb, *sb;tssl_init();tif ((addr = myorigin(headp)) == NULL) {ttfprintf(stderr, ""No ""from"" address for signing specified"");ttreturn NULL;t}tif ((fp = smime_sign_cert(addr, NULL, 1)) == NULL)ttreturn NULL;tif ((pkey = PEM_read_PrivateKey(fp, NULL, ssl_password_cb, NULL))ttt== NULL) {ttssl_gen_err(""Error reading private key from"");ttFclose(fp);ttreturn NULL;t}trewind(fp);tif ((cert = PEM_read_X509(fp, NULL, ssl_password_cb, NULL)) == NULL) {ttssl_gen_err(""Error reading signer certificate from"");ttFclose(fp);ttEVP_PKEY_free(pkey);ttreturn NULL;t}tFclose(fp);tif ((sp = Ftemp(&cp, ""Rs"", ""w+"", 0600, 1)) == NULL) {ttperror(""tempfile"");ttX509_free(cert);ttEVP_PKEY_free(pkey);ttreturn NULL;t}trm(cp);tFtfree(&cp);trewind(ip);tif (smime_split(ip, &hp, &bp, -1, 0) == STOP) {ttFclose(sp);ttX509_free(cert);ttEVP_PKEY_free(pkey);ttreturn NULL;t}tif ((bb = BIO_new_fp(bp, BIO_NOCLOSE)) == NULL ||ttt(sb = BIO_new_fp(sp, BIO_NOCLOSE)) == NULL) {ttssl_gen_err(""Error creating BIO signing objects"");ttFclose(sp);ttX509_free(cert);ttEVP_PKEY_free(pkey);ttreturn NULL;t}tif ((pkcs7 = PKCS7_sign(cert, pkey, NULL, bb,tttPKCS7_DETACHED)) == NULL) {ttssl_gen_err(""Error creating the PKCS#7 signing object"");ttBIO_free(bb);ttBIO_free(sb);ttFclose(sp);ttX509_free(cert);ttEVP_PKEY_free(pkey);ttreturn NULL;t}tif (PEM_write_bio_PKCS7(sb, pkcs7) == 0) {ttssl_gen_err(""Error writing signed S/MIME data"");ttBIO_free(bb);ttBIO_free(sb);ttFclose(sp);ttX509_free(cert);ttEVP_PKEY_free(pkey);ttreturn NULL;t}tBIO_free(bb);tBIO_free(sb);tX509_free(cert);tEVP_PKEY_free(pkey);trewind(bp);tfflush(sp);trewind(sp);treturn smime_sign_assemble(hp, bp, sp);}",3,"cwe119,cwe120,cweother"
"netns_pids(int argc, char **argv){tconst char *name;tchar net_path[MAXPATHLEN];tint netns;tstruct stat netst;tDIR *dir;tstruct dirent *entry;tif (argc < 1) {ttfprintf(stderr, ""No netns name specified"");ttreturn -1;t}tif (argc > 1) {ttfprintf(stderr, ""extra arguments specified"");ttreturn -1;t}tname = argv[0];tsnprintf(net_path, sizeof(net_path), ""%s/%s"", NETNS_RUN_DIR, name);tnetns = open(net_path, O_RDONLY);tif (netns < 0) {ttfprintf(stderr, ""Cannot open network namespace: %s"",tttstrerror(errno));ttreturn -1;t}tif (fstat(netns, &netst) < 0) {ttfprintf(stderr, ""Stat of netns failed: %s"",tttstrerror(errno));ttreturn -1;t}tdir = opendir(""/proc/"");tif (!dir) {ttfprintf(stderr, ""Open of /proc failed: %s"",tttstrerror(errno));ttreturn -1;t}twhile((entry = readdir(dir))) {ttchar pid_net_path[MAXPATHLEN];ttstruct stat st;ttif (!is_pid(entry->d_name))tttcontinue;ttsnprintf(pid_net_path, sizeof(pid_net_path), ""/proc/%s/ns/net"",tttentry->d_name);ttif (stat(pid_net_path, &st) != 0)tttcontinue;ttif ((st.st_dev == netst.st_dev) &&tt    (st.st_ino == netst.st_ino)) {tttprintf(""%s"", entry->d_name);tt}t}tclosedir(dir);treturn 0;t}",3,"cwe119,cwe120,cweother"
"igb_validate_nvm_checksum_generic(struct e1000_hw *hw){ts32 ret_val = E1000_SUCCESS;tu16 checksum = 0;tu16 i, nvm_data;tDEBUGFUNC(""igb_validate_nvm_checksum_generic"");tfor (i = 0; i < (NVM_CHECKSUM_REG + 1); i++) {ttret_val = hw->nvm.ops.read(hw, i, 1, &nvm_data);ttif (ret_val) {tttDEBUGOUT(""NVM Read Error"");tttgoto out;tt}ttchecksum += nvm_data;t}tif (checksum != (u16) NVM_SUM) {ttDEBUGOUT(""NVM Checksum Invalid"");ttret_val = -E1000_ERR_NVM;ttgoto out;t}out:treturn ret_val;}",2,"cwe120,cweother"
"TXT_WindowActionDrawer(TXT_UNCAST_ARG(action)){    TXT_CAST_ARG(txt_window_action_t, action);    char buf[10];    TXT_GetKeyDescription(action->key, buf);    if (TXT_HoveringOverWidget(action))    {        TXT_BGColor(TXT_COLOR_BLACK, 0);    }    TXT_DrawString("" "");    TXT_FGColor(TXT_COLOR_BRIGHT_GREEN);    TXT_DrawString(buf);    TXT_FGColor(TXT_COLOR_BRIGHT_CYAN);    TXT_DrawString(""="");    TXT_FGColor(TXT_COLOR_BRIGHT_WHITE);    TXT_DrawString(action->label);    TXT_DrawString("" "");}",2,"cwe119,cwe120"
"simulate(double *dwiSim, const double *parm, const tenExperSpec *espec) {  unsigned int ii;  double b0, diff, frac, vec[3];  b0 = parm[0];  diff = parm[1];  frac = parm[2];  vec[0] = parm[3];  vec[1] = parm[4];  vec[2] = parm[5];  for (ii=0; ii<espec->imgNum; ii++) {    double dwiBall, dwiStck, dot;    dwiBall = exp(-espec->bval[ii]*diff);    dot = ELL_3V_DOT(vec, espec->grad + 3*ii);    dwiStck = exp(-espec->bval[ii]*diff*dot*dot);    dwiSim[ii] = b0*((1-frac)*dwiBall + frac*dwiStck);  }  return;}",2,"cwe119,cwe120"
"ffcnst  (struct gafunc *pfc, struct gastat *pst) {gaint i,rc,cnt,flg;struct gagrid *pgr;struct gastn *stn;struct garpt *rpt;gadouble *val,cnst;char *ch, *uval;  if (pfc->argnum<2 || pfc->argnum>3) {    gaprnt (0,""Error from CONST:  Too many or too few args "");    gaprnt (0,""                   Two or 3 arguments expected "");    return (1);  }  if (getdbl(pfc->argpnt[1],&cnst)==NULL) {    gaprnt (0,""Error from CONST:  2nd argument must be a constant"");    return(1);  }  flg = 0;  if (pfc->argnum>2) {    ch = pfc->argpnt[2];    if      (*ch == '-' && *(ch+1) == 'u') flg = 1;    else if (*ch == '-' && *(ch+1) == 'a') flg = 2;    else gaprnt (1,""Warning from CONST: Invalid flag.  Ignored."");  }  rc = gaexpr(pfc->argpnt[0],pst);  if (rc) return (rc);  if (pst->type==1) {         pgr = pst->result.pgr;    cnt = pgr->isiz * pgr->jsiz;    val = pgr->grid;    uval = pgr->umask;    for (i=0; i<cnt; i++) {      if (flg==0) {        if (*uval!=0) {t  *val = cnst;t}      }       else if (flg==1) {        if (*uval==0) {t  *val = cnst;t  *uval = 1;       t}      }       else if (flg==2) {        *val = cnst;t*uval = 1;      }      val++; uval++;    }  }   else {         stn = pst->result.stn;    rpt = stn->rpt;    while (rpt!=NULL) {      if (flg==0) {        if (rpt->umask!=0) rpt->val = cnst;      } else if (flg==1) {        if (rpt->umask==0) rpt->val = cnst;      } else if (flg==2) {        rpt->val = cnst;      }      rpt=rpt->rpt;    }  }  return (0);}",3,"cwe119,cwe120,cweother"
"gkrellm_read_theme_event(GtkSettings  *settings)t{tThemet*theme;tgchart*s, *theme_name = NULL;tginttalt = 0;tif (settings)t ttttt tt{ttg_object_get(_GK.gtk_settings, ""gtk-theme-name"", &theme_name, NULL);ttif (theme_name)tttgkrellm_debug(DEBUG_GUI, ""notify::gtk-theme-name: %s"", theme_name);ttif (   gkrellm_dup_string(&_GK.gtk_theme_name, theme_name)ttt&& _GK.track_gtk_theme_namett   )ttt{ttttheme = find_theme_in_list(theme_name);tttif (!theme)tttt{tttttheme_name = g_strdup(_GK.default_track_theme);ttttif ((s = strrchr(theme_name, ':')) != NULL)ttttt{ttttt*s++ = '0';tttttalt = atoi(s);ttttt}tttttheme = find_theme_in_list(theme_name);ttttg_free(theme_name);tttt}tttif (   theme && theme->pathtttt&& gkrellm_dup_string(&_GK.theme_path,tttttttstrcmp(theme->path, ""Default"") ? theme->path : """")ttt   )tttt{tttt_GK.theme_alternative = alt;tttttheme_modified = TRUE;ttttgkrellm_save_theme_config();ttttgkrellm_build();tttt}ttt}tt}telsett tttt tt{ttg_free(_GK.theme_path);tt_GK.theme_path = NULL;t ttgkrellm_build();tt}t}",2,"cwe469,cweother"
"lam_ssi_base_hostmap(struct in_addr *addr, char *keyname){  int i;  int happy;  ELEM search;  ELEM *result;  char addr_ntoa[16];  char *new_hostname;  char *filename =     lam_ssi_base_param_lookup_string(lam_ssi_base_hostmap_param_index);  struct in_addr ret = *addr;  struct hostent *h;  FILE *fp;     if (filename == NULL || strlen(filename) == 0)    return ret;      if (read_hostmap == 0) {    read_hostmap = 1;         fp = fopen(filename, ""r"");    if (fp == NULL) {      lam_debug(lam_ssi_did, ""mpi: could not read hostmap: %s"", filename);      return ret;    }    fclose(fp);         happy = bhostparse(filename, &hostmap, &hostmap_len);    if (lam_ssi_verbose > 5) {      if (happy == 0)        lam_debug(lam_ssi_did, ""mpi: read hostmap: %s"", filename);      else {        lam_debug(lam_ssi_did, ""mpi: could not read hostmap: %s"", filename);        return ret;      }    }         happy = resolve_hosts(hostmap, hostmap_len);    if (happy == 0) {      if (lam_ssi_verbose > 5)        lam_debug(lam_ssi_did, ""mpi: resolved all hosts in hostmap"");    } else {      if (lam_ssi_verbose > 5)        lam_debug(lam_ssi_did, ""mpi: unable to resolve all hosts in hostmap"");      lam_deallocate_nodes(&hostmap, &hostmap_len);      hostmap = NULL;      hostmap_len = 0;    }  }     if (hostmap != NULL) {    for (i = 0; i < hostmap_len; ++i) {      if (memcmp(&(hostmap[i].lnd_addr.sin_addr.s_addr), &(addr->s_addr),                 sizeof(hostmap[i].lnd_addr.sin_addr.s_addr)) == 0) {        if (lam_ssi_verbose > 5) {                     snprintf(addr_ntoa, sizeof(addr_ntoa), ""%s"", inet_ntoa(*addr));          lam_debug(lam_ssi_did, ""mpi: found host in map: %s"", addr_ntoa);        }                 search.key = keyname;        result = al_find(hostmap[i].lnd_keyval, &search);        if (result == NULL) {          if (lam_ssi_verbose > 5)            lam_debug(lam_ssi_did, ""mpi: host does not have ""%s"" attribute"",                      keyname);        } else {          new_hostname = result->value;                     if ((h = lam_gethostbyname(new_hostname)) != NULL) {            memcpy((char *) &ret, h->h_addr_list[0], sizeof(ret));            if (lam_ssi_verbose > 5)              lam_debug(lam_ssi_did, ""mpi: remapped %s -> %s (%s)"",                         addr_ntoa, new_hostname, inet_ntoa(ret));          }        }                           break;      }    }  }     return ret;}",3,"cwe119,cwe120,cweother"
"add_kernel_modules (const char *whitelist_file, const char *modpath,                    struct writer *writer){  if (verbose)    print_timestamped_message (""adding kernel modules"");  char **whitelist = NULL;  if (whitelist_file != NULL)    whitelist = load_file (whitelist_file);  char *paths[2] = { (char *) modpath, NULL };  FTS *fts = fts_open (paths, FTS_COMFOLLOW|FTS_PHYSICAL, NULL);  if (fts == NULL)    error (EXIT_FAILURE, errno, ""add_kernel_modules: fts_open: %s"", modpath);  for (;;) {    errno = 0;    FTSENT *entry = fts_read (fts);    if (entry == NULL && errno != 0)      error (EXIT_FAILURE, errno, ""add_kernel_modules: fts_read: %s"", modpath);    if (entry == NULL)      break;         if (entry->fts_info & FTS_DP)      continue;         if (entry->fts_namelen >= 3 &&        entry->fts_name[entry->fts_namelen-3] == '.' &&        entry->fts_name[entry->fts_namelen-2] == 'k' &&        entry->fts_name[entry->fts_namelen-1] == 'o') {      if (whitelist) {                 size_t j;        for (j = 0; whitelist[j] != NULL; ++j) {          int r;          r = fnmatch (whitelist[j], entry->fts_name, 0);          if (r == 0) {                         if (verbose >= 2)              fprintf (stderr, ""including kernel module %s (matches whitelist entry %s)"",                       entry->fts_name, whitelist[j]);            writer->wr_fts_entry (entry);            break;          } else if (r != FNM_NOMATCH)            error (EXIT_FAILURE, 0, ""internal error: fnmatch ('%s', '%s', %d) returned unexpected non-zero value %d"",                   whitelist[j], entry->fts_name, 0, r);        }        } else {          if (verbose >= 2)          fprintf (stderr, ""including kernel module %s"", entry->fts_name);        writer->wr_fts_entry (entry);      }    } else             writer->wr_fts_entry (entry);  }  if (fts_close (fts) == -1)    error (EXIT_FAILURE, errno, ""add_kernel_modules: fts_close: %s"", modpath);}",3,"cwe119,cwe120,cweother"
"transop_addspec_twofish( n2n_trans_op_t * arg, const n2n_cipherspec_t * cspec ){    int retval = 1;    ssize_t pstat=-1;    transop_tf_t * priv = (transop_tf_t *)arg->priv;    uint8_t keybuf[N2N_MAX_KEYSIZE];    if ( priv->num_sa < N2N_TWOFISH_NUM_SA )    {        const char * op = (const char *)cspec->opaque;        const char * sep = index( op, '_' );        if ( sep )        {            char tmp[256];            size_t s;                        s = sep - op;            memcpy( tmp, cspec->opaque, s );            tmp[s]=0;                        s = strlen(sep+1);              priv->sa[priv->num_sa].spec = *cspec;            priv->sa[priv->num_sa].sa_id = strtoul(tmp, NULL, 10);            pstat = n2n_parse_hex( keybuf, N2N_MAX_KEYSIZE, sep+1, s );            if ( pstat > 0 )            {                priv->sa[priv->num_sa].enc_tf = TwoFishInit( keybuf, pstat);                priv->sa[priv->num_sa].dec_tf = TwoFishInit( keybuf, pstat);                                traceEvent( TRACE_DEBUG, ""transop_addspec_twofish sa_id=%u data=%s."",                            priv->sa[priv->num_sa].sa_id, sep+1);                                ++(priv->num_sa);                retval = 0;            }        }        else        {            traceEvent( TRACE_ERROR, ""transop_addspec_twofish : bad key data - missing '_'."");        }    }    else    {        traceEvent( TRACE_ERROR, ""transop_addspec_twofish : full."");    }        return retval;}",2,"cwe119,cwe120"
"test_assoc(hid_t fapl){    hid_ttfile1 = -1, file2 = -1;    H5O_info_ttoi1, oi2;    chartfilename1[1024], filename2[1024];    TESTING(""mount point open"");    h5_fixname(FILENAME[0], fapl, filename1, sizeof filename1);    h5_fixname(FILENAME[1], fapl, filename2, sizeof filename2);         if((file1 = H5Fopen(filename1, H5F_ACC_RDONLY, fapl)) < 0 ||            (file2 = H5Fopen(filename2, H5F_ACC_RDONLY, fapl)) < 0)        FAIL_STACK_ERROR         if(H5Oget_info(file2, &oi1) < 0) FAIL_STACK_ERROR         if(H5Fmount(file1, ""/mnt1"", file2, H5P_DEFAULT) < 0) FAIL_STACK_ERROR         if(H5Oget_info_by_name(file1, ""/mnt1"", &oi2, H5P_DEFAULT) < 0) FAIL_STACK_ERROR    if(oi1.fileno != oi2.fileno || H5F_addr_ne(oi1.addr, oi2.addr)) {tH5_FAILED();tputs(""    Association failed."");        TEST_ERROR    }           if(H5Funmount(file1, ""/mnt1_link"") < 0) FAIL_STACK_ERROR    if(H5Fclose(file1) < 0) FAIL_STACK_ERROR    if(H5Fclose(file2) < 0) FAIL_STACK_ERROR    PASSED();    return 0;error:    H5E_BEGIN_TRY {tH5Fclose(file2);tH5Fclose(file1);    } H5E_END_TRY;    return 1;}",2,"cwe119,cwe120"
"user_ps_add(char *s, char use){tstruct u_ps *t, *r;tint l;tif (*s == '0' || *s == '%')ttreturn;tl = strlen(s);tif (use == 'g') {ttt = malloc(sizeof *user_ps - sizeof user_ps->text + l + 6);ttsprintf(t->text, ""%%svg %s"", s);t} else {ttt = malloc(sizeof *user_ps - sizeof user_ps->text + l + 2);ttsprintf(t->text, ""%c%s"", use, s);t}tt->next = 0;tif ((r = user_ps) == 0) {ttuser_ps = t;t} else {ttwhile (r->next != 0)tttr = r->next;ttr->next = t;t}}",2,"cwe120,cweother"
"htpasswd_recheckfile (htpasswd_auth_state *htpasswd){    FILE *passwdfile;    avl_tree *new_users;    int num = 0;    struct stat file_stat;    char *sep;    char line [MAX_LINE_LEN];    if (htpasswd->filename == NULL)        return;    if (stat (htpasswd->filename, &file_stat) < 0)    {        WARN1 (""failed to check status of %s"", htpasswd->filename);                 thread_rwlock_wlock (&htpasswd->file_rwlock);        if(!htpasswd->users)            htpasswd->users = avl_tree_new(compare_users, NULL);        thread_rwlock_unlock (&htpasswd->file_rwlock);        return;    }    if (file_stat.st_mtime == htpasswd->mtime)    {                 return;    }    INFO1 (""re-reading htpasswd file ""%s"""", htpasswd->filename);    passwdfile = fopen (htpasswd->filename, ""rb"");    if (passwdfile == NULL)    {        WARN2(""Failed to open authentication database ""%s"": %s"",                 htpasswd->filename, strerror(errno));        return;    }    htpasswd->mtime = file_stat.st_mtime;    new_users = avl_tree_new (compare_users, NULL);    while (get_line(passwdfile, line, MAX_LINE_LEN))    {        int len;        htpasswd_user *entry;        num++;        if(!line[0] || line[0] == '#')            continue;        sep = strrchr (line, ':');        if (sep == NULL)        {            WARN2(""No separator on line %d (%s)"", num, htpasswd->filename);            continue;        }        entry = calloc (1, sizeof (htpasswd_user));        len = strlen (line) + 1;        entry->name = malloc (len);        *sep = 0;        memcpy (entry->name, line, len);        entry->pass = entry->name + (sep-line) + 1;        avl_insert (new_users, entry);    }    fclose (passwdfile);    thread_rwlock_wlock (&htpasswd->file_rwlock);    if (htpasswd->users)        avl_tree_free (htpasswd->users, _free_user);    htpasswd->users = new_users;    thread_rwlock_unlock (&htpasswd->file_rwlock);}",3,"cwe119,cwe120,cweother"
"add_password(const char *user, const char *realm, apr_file_t *f){    char *pw;    apr_md5_ctx_t context;    unsigned char digest[16];    char string[3 * MAX_STRING_LEN];      char pwin[MAX_STRING_LEN];    char pwv[MAX_STRING_LEN];    unsigned int i;    apr_size_t len = sizeof(pwin);    if (apr_password_get(""New password: "", pwin, &len) != APR_SUCCESS) {        apr_file_printf(errfile, ""password too long"");        cleanup_tempfile_and_exit(5);    }    len = sizeof(pwin);    apr_password_get(""Re-type new password: "", pwv, &len);    if (strcmp(pwin, pwv) != 0) {        apr_file_printf(errfile, ""They don't match, sorry."");        cleanup_tempfile_and_exit(1);    }    pw = pwin;    apr_file_printf(f, ""%s:%s:"", user, realm);         apr_snprintf(string, sizeof(string), ""%s:%s:%s"", user, realm, pw);    apr_md5_init(&context);#if APR_CHARSET_EBCDIC    apr_md5_set_xlate(&context, to_ascii);#endif    apr_md5_update(&context, (unsigned char *) string, strlen(string));    apr_md5_final(digest, &context);    for (i = 0; i < 16; i++)        apr_file_printf(f, ""%02x"", digest[i]);    apr_file_printf(f, """");}",2,"cwe119,cwe120"
"glusterd_quota_get_limit_usages (glusterd_conf_t *priv,                                 glusterd_volinfo_t *volinfo,                                 char *volname,                                 dict_t *dict,                                 char **op_errstr){        int32_t i               = 0;        int32_t ret             = 0;        int32_t count           = 0;        char    *path           = NULL;        dict_t  *ctx            = NULL;        char    cmd_str [1024]  = {0, };        char   *ret_str         = NULL;        ctx = glusterd_op_get_ctx ();        if (ctx == NULL)                return 0;        ret = dict_get_int32 (dict, ""count"", &count);        if (ret < 0)                goto out;        if (count == 0) {                ret_str = _glusterd_quota_get_limit_usages (volinfo, NULL,                                                            op_errstr);        } else {                i = 0;                while (count--) {                        snprintf (cmd_str, 1024, ""path%d"", i++);                        ret = dict_get_str (dict, cmd_str, &path);                        if (ret < 0)                                goto out;                        ret_str = _glusterd_quota_get_limit_usages (volinfo, path, op_errstr);                }        }        if (ret_str) {                ret = dict_set_dynstr (ctx, ""limit_list"", ret_str);        }out:        return ret;}",2,"cwe119,cwe120"
"calculate_tablespace_size(Oid tblspcOid){tchartttblspcPath[MAXPGPATH];tcharttpathname[MAXPGPATH];tint64tttotalsize = 0;tDIRtt   *dirdesc;tstruct dirent *direntry;tif (tblspcOid == DEFAULTTABLESPACE_OID)ttsnprintf(tblspcPath, MAXPGPATH, ""base"");telse if (tblspcOid == GLOBALTABLESPACE_OID)ttsnprintf(tblspcPath, MAXPGPATH, ""global"");telsettsnprintf(tblspcPath, MAXPGPATH, ""pg_tblspc/%u"", tblspcOid);tdirdesc = AllocateDir(tblspcPath);tif (!dirdesc)ttereport(ERROR,tttt(errcode_for_file_access(),tttt errmsg(""could not open tablespace directory ""%s"": %m"",tttttttblspcPath)));twhile ((direntry = ReadDir(dirdesc, tblspcPath)) != NULL)t{ttstruct stat fst;ttCHECK_FOR_INTERRUPTS();ttif (strcmp(direntry->d_name, ""."") == 0 ||tttstrcmp(direntry->d_name, "".."") == 0)tttcontinue;ttsnprintf(pathname, MAXPGPATH, ""%s/%s"", tblspcPath, direntry->d_name);ttif (stat(pathname, &fst) < 0)tt{tttif (errno == ENOENT)ttttcontinue;tttelsettttereport(ERROR,tttttt(errcode_for_file_access(),tttttt errmsg(""could not stat file ""%s"": %m"", pathname)));tt}ttif (S_ISDIR(fst.st_mode))ttttotalsize += db_dir_size(pathname);tttotalsize += fst.st_size;t}tFreeDir(dirdesc);treturn totalsize;}",2,"cwe119,cwe120"
"WritePNG(char * filename,struct Image * pic){ png_byte color_type;png_byte bit_depth;png_structp png_ptr;png_infop info_ptr;int number_of_passes;png_bytep * row_pointers;int width, height;  FILE *fp = fopen(filename, ""wb"");if (!fp) { abort_(""[write_png_file] File %s could not be opened for writing"", filename); return 0; } png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);if (!png_ptr) { abort_(""[write_png_file] png_create_write_struct failed""); return 0; }info_ptr = png_create_info_struct(png_ptr);if (!info_ptr) { abort_(""[write_png_file] png_create_info_struct failed""); return 0; }if (setjmp(png_jmpbuf(png_ptr))) { abort_(""[write_png_file] Error during init_io""); return 0; }png_init_io(png_ptr, fp); if (setjmp(png_jmpbuf(png_ptr))) { abort_(""[write_png_file] Error during writing header""); return 0; }png_set_IHDR(png_ptr, info_ptr, pic->width,pic->height,8,PNG_COLOR_TYPE_RGB , PNG_INTERLACE_NONE,PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);png_write_info(png_ptr, info_ptr); if (setjmp(png_jmpbuf(png_ptr))) { abort_(""[write_png_file] Error during writing bytes""); return 0; }row_pointers = (png_bytep*) malloc(sizeof(png_bytep) * pic->height);if (row_pointers==0) { abort_(""Could not allocate enough memory to hold the image ""); return 0; }char * raw_pixels=pic->pixels;unsigned int y;for (y=0; y<pic->height; y++) {   row_pointers[y] = (png_byte*) raw_pixels;   raw_pixels+=3*pic->width; } png_write_image(png_ptr,row_pointers);   if (setjmp(png_jmpbuf(png_ptr))) { abort_(""[write_png_file] Error during end of write""); return 0; } png_write_end(png_ptr, NULL);   free(row_pointers); fclose(fp);return 1;}",2,"cwe120,cweother"
"AT_SetSMSMemoryType(gn_memory_type mt, struct gn_statemachine *state){tat_driver_instance *drvinst = AT_DRVINST(state);tgn_data data;tchar req[32];tconst char *memory_name;tchar memory_name_enc[16];tint len;tgn_error ret = GN_ERR_NONE;tif (mt != drvinst->smsmemorytype) {ttmemory_name = gn_memory_type2str(mt);ttif (!memory_name)tttreturn GN_ERR_INVALIDMEMORYTYPE;ttif (drvinst->encode_memory_type) {tttgn_data_clear(&data);tttat_encode(drvinst->charset, memory_name_enc, sizeof(memory_name_enc), memory_name, strlen(memory_name));tttmemory_name = memory_name_enc;tt}ttlen = snprintf(req, sizeof(req), ""AT+CPMS=""%s""r"", memory_name);ttret = sm_message_send(len, GN_OP_Init, req, state);ttif (ret != GN_ERR_NONE)tttreturn ret;ttgn_data_clear(&data);ttret = sm_block_no_retry(GN_OP_Init, &data, state);ttif (ret != GN_ERR_NONE)tttreturn ret;ttdrvinst->smsmemorytype = mt;t}treturn ret;}",2,"cwe119,cwe120"
"get_cached_envelope(struct mail_cache_db * cache_db, MMAPString * mmapstr,    mailsession * session, uint32_t num,    struct mailimf_fields ** result){  int r;  char keyname[PATH_MAX];  struct mailpop3_msg_info * info;  struct mailimf_fields * fields;  int res;  mailpop3 * pop3;  pop3 = get_pop3_session(session);  r = mailpop3_get_msg_info(pop3, num, &info);  switch (r) {  case MAILPOP3_ERROR_BAD_STATE:    return MAIL_ERROR_BAD_STATE;  case MAILPOP3_ERROR_NO_SUCH_MESSAGE:    return MAIL_ERROR_MSG_NOT_FOUND;  case MAILPOP3_NO_ERROR:    break;  default:    return MAIL_ERROR_FETCH;  }  snprintf(keyname, PATH_MAX, ""%s-envelope"", info->msg_uidl);  r = generic_cache_fields_read(cache_db, mmapstr, keyname, &fields);  if (r != MAIL_NO_ERROR) {    res = r;    goto err;  }  * result = fields;  return MAIL_NO_ERROR; err:  return res;}",2,"cwe119,cwe120"
"make_cat_rcp(char *obj, char *catalog, double box, FILE *outf, double mag_limit) {tGList *tsl = NULL;tstruct cat_star *cats;tstruct stf *st, *stf;tchar ras[64], decs[64];tttcats = get_object_by_name(obj);tcats->flags = (cats->flags & ~CAT_STAR_TYPE_MASK) | CAT_STAR_TYPE_APSTAR;tif (cats == NULL) {tterr_printf(""make_cat_rcp: cannot find object %s"", obj);ttreturn -1;t}ttsl = query_catalog(""usnob"", cats->ra, cats->dec, box, box, progress_pr, NULL);td3_printf(""query_catalog: got %d stars"", g_list_length(tsl)); tif (cats->perr < 0.2) {ttdegrees_to_dms_pr(ras, cats->ra / 15.0, 3);ttdegrees_to_dms_pr(decs, cats->dec, 2);t} else {ttdegrees_to_dms_pr(ras, cats->ra / 15.0, 2);ttdegrees_to_dms_pr(decs, cats->dec, 1);t}tst = stf_append_string(NULL, SYM_OBJECT, cats->name);tstf_append_string(st, SYM_RA, ras);tstf_append_string(st, SYM_DEC, decs);tstf_append_double(st, SYM_EQUINOX, cats->equinox); tstf = stf_append_list(NULL, SYM_RECIPE, st); tst = stf_append_glist(stf, SYM_STARS, tsl);tstf_fprint(outf, stf, 0, 0);tcat_star_release(cats);tfflush(outf);treturn 0;}",2,"cwe119,cwe120"
"acknowledge_from_rawmessage(SMSCenter *smsc,                                       char *rawmessage, int length){    char emivars[128][1024];    char timestamp[2048], sender[2048], receiver[2048];    char emitext[2048], isotext[2048];    char *leftslash, *rightslash;    int msgnbr;    int tmpint;    int is_backup = 0;    msgnbr = -1;    memset(&sender, 0, sizeof(sender));    memset(&receiver, 0, sizeof(receiver));    memset(&emitext, 0, sizeof(emitext));    memset(&isotext, 0, sizeof(isotext));    memset(&timestamp, 0, sizeof(timestamp));    strncpy(isotext, rawmessage, length);    leftslash = isotext;    if (isotext[length - 1] == 'X')        is_backup = 1;    for (tmpint = 0; leftslash != NULL; tmpint++) {        rightslash = strchr(leftslash + 1, '/');        if (rightslash == NULL)            rightslash = strchr(leftslash + 1, '3');        if (rightslash == NULL)            break;        *rightslash = '0';        strcpy(emivars[tmpint], leftslash + 1);        leftslash = rightslash;    }         sprintf(isotext, ""A//%s:%s"", emivars[4], emivars[18]);    sprintf(isotext, ""A//%s:"", emivars[5]);    is_backup = 0;         debug(""bb.sms.emi"", 0, ""acknowledge: type = '%s'"", emivars[3]);    sprintf(emitext, ""%s/%05i/%s/%s"", emivars[0], (int) strlen(isotext) + 17,            ""R"", emivars[3]);    smsc->emi_current_msg_number = atoi(emivars[0]) + 1;         sprintf(timestamp, ""%s/%s/"", emitext, isotext);    generate_checksum((unsigned char *)timestamp, (unsigned char *)receiver);    sprintf(sender, ""%c%s/%s/%s%c"", 0x02, emitext, isotext, receiver, 0x03);    put_data(smsc, sender, strlen(sender), is_backup);    return msgnbr;}",3,"cwe119,cwe120,cweother"
"read_env_file(FILE *F, char ***env, int *assigned){    int idx = 0;    int i;    char **l;    char buf[BUFSIZ], *p, *r;    char **tmp;    int ret = 0;    *assigned = 0;    for(idx = 0; *env != NULL && (*env)[idx] != NULL; idx++);    l = *env;         while (fgets(buf, BUFSIZ, F) != NULL) {tbuf[strcspn(buf, ""#"")] = '0';tfor(p = buf; isspace((unsigned char)*p); p++);tif (*p == '0')t    continue;t tr = strchr(p, '=');tif (r == NULL)t    continue;tif((i = find_var(l, p, r - p + 1)) >= 0) {t    char *val = strdup(p);t    if(val == NULL) {ttret = ENOMEM;ttbreak;t    }t    free(l[i]);t    l[i] = val;t    (*assigned)++;t    continue;t}ttmp = realloc(l, (idx+2) * sizeof (char *));tif(tmp == NULL) {t    ret = ENOMEM;t    break;t}tl = tmp;tl[idx] = strdup(p);tif(l[idx] == NULL) {t    ret = ENOMEM;t    break;t}tl[++idx] = NULL;t(*assigned)++;    }    if(ferror(F))tret = errno;    *env = l;    return ret;}",5,"cwe119,cwe120,cwe476,cwe469,cweother"
"set_Ulong32Field(Widget w,XtPointer address,XrmQuark type,Cardinal size ) {   static char buf[BUFSIZ];   if (type != QmonQUlong32) {      XmtWarningMsg(""XmtDialogSetDialogValues"", ""Ulong32Field"",         ""Type Mismatch: Widget '%s':tCan't set widget values""         "" from a resource of type '%s'."",          XtName(w), XrmQuarkToString(type));   }t(void)sprintf(buf, ""%u"", *(unsigned int *)address);tXmtInputFieldSetString(w, buf);}",2,"cwe119,cwe120"
"main (int argc, char *argv[]){  int ch ;  printf(""*** parsing options: start"") ;  while ((ch = getopt_long(argc, argv, ""hbf:"", longopts, 0)) != -1) {    switch (ch) {    case 'h':        printf(""test_getopt_long: test VLFeat implementation of this function.""               "" --help -h      this message""               "" --buffy -b     option with no arguments""               "" --fluoride -f  option with required argument""               "" --daggerset    auto option with no arguments""               "" --daggerrunset auto option with no argument""               "" --spike        long option with optional argument"") ;        break;    case 'b':      printf(""option `b' or `buffy'"") ;      break;    case 'f':      printf(""option `f' or `flouride' with arg `%s'"", optarg) ;      break ;    case 1002 :      printf(""option `spike' with arg `%s'"", optarg) ;      break ;    case 0:      printf(""automatic longoption (daggerset=%d)"", daggerset) ;      break ;    case  '?' :      printf(""illegal option or missing argument"") ;      break ;    case ':'  :      printf(""illegal option"") ;      break ;    default:      abort() ;    }  }  printf(""*** parsing options: end"");  {    int i ;    for(i = optind ; i < argc ; ++i)ttprintf(""non-option: '%s'"", argv[i]) ;  }  return 0 ;}",2,"cwe120,cweother"
"vs_master_handle_describe(const char *address, const char *message){tchartdesc[1380] = ""DESCRIPTION"", *put = desc + 11;tif(desc_has_keyword(message, ""DE"") && server_info.desc != NULL && keyword_fits(put - desc, sizeof desc, ""DE"", server_info.desc))ttput = append_desc(put, ""DE"", server_info.desc);tif(desc_has_keyword(message, ""TA"") && server_info.tags != NULL && keyword_fits(put - desc, sizeof desc, ""TA"", server_info.tags))ttput = append_desc(put, ""TA"", server_info.tags);tverse_send_ping(address, desc);}",2,"cwe119,cwe120"
"pegasus_yes_no_info_nuf(const char *value){tswitch (mge_type & 0xFF00)t t{tcase MGE_PEGASUS:ttbreak;tcase MGE_3S:tt ttif (country_code != COUNTRY_EUROPE)tttbreak;tdefault:ttreturn 0;t}tif (!strncmp(value, ""yes"", 3))ttreturn 1;telsettreturn 0;}",2,"cwe119,cwe120"
"qrencodeStructured(const char *intext, const char *outfile){tQRcode_List *qrlist, *p;tchar filename[FILENAME_MAX];tchar *base, *q, *suffix = NULL;tint i = 1;tbase = strdup(outfile);tif(base == NULL) {ttfprintf(stderr, ""Failed to allocate memory."");ttexit(EXIT_FAILURE);t}tif(strlen(base) > 4) {ttq = base + strlen(base) - 4;ttif(strcasecmp("".png"", q) == 0) {tttsuffix = strdup(q);ttt*q = '0';tt}t}ttqrlist = encodeStructured(intext);tif(qrlist == NULL) {ttperror(""Failed to encode the input data:"");ttexit(EXIT_FAILURE);t}tfor(p = qrlist; p != NULL; p = p->next) {ttif(p->code == NULL) {tttfprintf(stderr, ""Failed to encode the input data."");tttexit(EXIT_FAILURE);tt}ttif(suffix) {tttsnprintf(filename, FILENAME_MAX, ""%s-%02d%s"", base, i, suffix);tt} else {tttsnprintf(filename, FILENAME_MAX, ""%s-%02d"", base, i);tt}ttwritePNG(p->code, filename);tti++;t}tfree(base);tif(suffix) {ttfree(suffix);t}tQRcode_List_free(qrlist);}",2,"cwe119,cwe120"
"write_attachment_to_file(MAILSTREAM *stream, long int msgno, ATTACH_S *a, int flags, char *file){    char       *l_string, sbuf[256], *err;    int         is_text, we_cancel = 0;    long        len, orig_size;    gf_io_t     pc;    STORE_S    *store;    if(!(a && a->body && a->number && a->number[0] && file && file[0]t && stream))      return 0;    is_text = (a && a->body && a->body->type == TYPETEXT);    if(flags & GER_APPEND)      orig_size = name_file_size(file);    store = so_get(FileStar, file, WRITE_ACCESS | (is_text ? WRITE_TO_LOCALE : 0));    if(store == NULL){tq_status_message2(SM_ORDER | SM_DING, 3, 5,ttt   ttt  _(""Error opening destination %s: %s""),ttt  file, error_description(errno));treturn -1;    }    snprintf(sbuf, sizeof(sbuf), ""Saving to ""%s"""", file);    sbuf[sizeof(sbuf)-1] = '0';    we_cancel = init_att_progress(sbuf, stream, a->body);    gf_set_so_writec(&pc, store);    err = detach(stream, msgno, a->number, 0L, &len, pc, NULL, 0);    gf_clear_so_writec(store);    if(we_cancel)      cancel_busy_cue(0);    if(so_give(&store))ttt       err = error_description(errno);    if(err){tif(!(flags & (GER_APPEND | GER_OVER)))t  our_unlink(file);telset  our_truncate(file, (flags & GER_APPEND) ? (off_t) orig_size : (off_t) 0);tq_status_message2(SM_ORDER | SM_DING, 3, 5,ttt   ttt  _(""%s: Error writing attachment to ""%s""""),ttt  err, file);treturn -1;    }    else{        l_string = cpystr(byte_string(len));        q_status_message8(SM_ORDER, 0, 4,t     ""Part %s, %s%s %s to ""%s""%s%s%s"",ttt  a->number, ttt  is_textttt    ? comatose(a->body->size.lines) : l_string,ttt  is_text ? "" lines"" : """",ttt  flags & GER_OVERttt      ? ""overwritten""ttt      : flags & GER_APPEND ? ""appended"" : ""written"",ttt  file,ttt  (is_text || len == a->body->size.bytes)ttt    ? """" : ""(decoded from "",                          (is_text || len == a->body->size.bytes)ttt    ? """" : byte_string(a->body->size.bytes),ttt  is_text || len == a->body->size.bytesttt    ? """" : "")"");        fs_give((void **)&l_string);treturn 1;    }}",2,"cwe119,cwe120"
"""append_entity(struct htmlfilter_info *p){tunicode_char v=0;tif (unicode_buf_len(&p->atom2) &&t    unicode_buf_ptr(&p->atom2)[0] == '#')t{ttconst unicode_char *u=unicode_buf_ptr(&p->atom2);ttsize_t n=unicode_buf_len(&p->atom2);tt++u;tt--n;ttif (n && (*u == 'x' || *u == 'X'))tt{tttwhile (--n)ttt{ttttunicode_char c=*++u;ttttconst char *cp;ttttif (c >= 'a' && c <= 'f')tttttc += 'A'-'a';ttttif (c < ' ' || c > 127)tttttbreak;ttttcp=strchr(hex, c);ttttif (!cp)tttttbreak;ttttv = v * 16 + (cp-hex);ttt}tt}ttelsett{tttwhile (n)ttt{ttttunicode_char c= *u++;tttt--n;ttttif (c < '0' || c > '9')tttttbreak;ttttv = v * 10 + (c-'0');ttt}tt}t}telset{ttchar entitybuf[32];ttsize_t i;ttif (unicode_buf_len(&p->atom2) >= sizeof(entitybuf))tttreturn;ttfor (i=0; i<unicode_buf_len(&p->atom2); ++i)tt{tttunicode_char c=unicode_buf_ptr(&p->atom2)[i];tttif ((unsigned char)c != c)ttttreturn;tttentitybuf[i]=c;tt}ttentitybuf[i]=0;ttif ((v=unicode_html40ent_lookup(entitybuf)) == 0)tttreturn;t}tunicode_buf_append(&p->value, &v, 1);}""",2,"cwe119,cwe120"
"sort_index_file (void){tif (I_index_file && strcmp (I_index_file, ""-"") != 0 &&t    atoi(I_index_file) == 0) {ttcharttcmd[512];ttfprintf (index_fp, ""##ndmjob -J"");  ttfclose (index_fp);ttindex_fp = stderr;t ttsprintf (cmd, ""LC_ALL=C sort %s -o %s"", I_index_file, I_index_file);ttndmjob_log (3, ""sort command: %s"", cmd);ttndmjob_log (1, ""sorting index"");ttif (system (cmd) < 0)tt    error_byebye (""sort index failed"");ttndmjob_log (1, ""sort index done"");t}treturn 0;}",4,"cwe119,cwe120,cwe476,cweother"
"store (const char *name, const char *mode, int unique){  FILE *fout, *din;  struct stat st;  int (*closefunc) (FILE *);  if (unique && stat (name, &st) == 0)    {      const char *name_unique = gunique (name);      if (name_unique)        name = name_unique;      else        {          LOGCMD (*mode == 'w' ? ""put"" : ""append"", name);          return;        }    }  if (restart_point)    mode = ""r+"";  fout = fopen (name, mode);  closefunc = fclose;  if (fout == NULL || fstat (fileno (fout), &st) < 0)    {      perror_reply (553, name);      LOGCMD (*mode == 'w' ? ""put"" : ""append"", name);      return;    }  byte_count = -1;  if (restart_point)    {      if (type == TYPE_A)t{t  off_t i, n;t  int c;t  n = restart_point;t  i = 0;t  while (i++ < n)t    {t      c = getc (fout);t      if (c == EOF)tt{tt   tt  reply (554,ttt ""Action not taken: invalid REST value %jd for %s."",ttt restart_point, name);tt  goto done;tt}t      if (c == '')tti++;t    }t   t  if (fseeko (fout, 0L, SEEK_CUR) < 0)t    {t      perror_reply (550, name);t      goto done;t    }t}      else if (lseek (fileno (fout), restart_point, SEEK_SET) < 0)t{t  if (errno == EINVAL)t    reply (554, ""Action not taken: invalid REST value %jd for %s."",tt   restart_point, name);t  elset    perror_reply (550, name);t  goto done;t}    }  din = dataconn (name, (off_t) - 1, ""r"");  if (din == NULL)    goto done;  if (receive_data (din, fout, st.st_blksize) == 0)    {      if (unique)treply (226, ""Transfer complete (unique file name:%s)."", name);      elsetreply (226, ""Transfer complete."");    }  fclose (din);  data = -1;  pdata = -1;done:  LOGBYTES (*mode == 'w' ? ""put"" : ""append"", name, byte_count);  (*closefunc) (fout);}",3,"cwe119,cwe120,cweother"
"Print_Char (Object port, register int c) {    char buf[1];    if (PORT(port)->flags & P_STRING) {        buf[0] = c;        Print_String (port, buf, 1);    } else {        if (putc (c, PORT(port)->file) == EOF)  {            Saved_Errno = errno;                Primitive_Error (""write error on ~s: ~E"", port);        }    }}",2,"cwe119,cwe120"
"cfgnum(char *name, float defaul){  char *s = nget(config_user,name);  int i;  float f;  if (!s)    {      fprintf(stderr,""In config file: Could not find '%s'. Using default (%f)."",name,defaul);      return defaul;    }  i = sscanf(s,""%f"",&f);  if (i != 1)    {      fprintf(stderr,""In config file: Expected number for name '%s', found '%s'. Using default (%f)."",name,s,defaul);      return defaul;    }  return f;}",2,"cwe119,cwe120"
"ring_buffer_change_overwrite(struct ring_buffer *buffer, int val){tmutex_lock(&buffer->mutex);tif (val)ttbuffer->flags |= RB_FL_OVERWRITE;telsettbuffer->flags &= ~RB_FL_OVERWRITE;tmutex_unlock(&buffer->mutex);}",2,"cwe120,cweother"
"add_listener(int port, const char *vhost_ip, unsigned int flags){  struct Listener *listener;  struct irc_ssaddr vaddr;  struct addrinfo hints, *res;  char portname[PORTNAMELEN + 1];#ifdef IPV6  static short int pass = 0;  #endif     if (!(port > 0 && port <= 0xFFFF))    return;  memset(&vaddr, 0, sizeof(vaddr));     memset(&hints, 0, sizeof(hints));  hints.ai_family = AF_UNSPEC;  hints.ai_socktype = SOCK_STREAM;     hints.ai_flags = AI_PASSIVE | AI_NUMERICHOST;#ifdef IPV6  if (ServerInfo.can_use_v6)  {    snprintf(portname, sizeof(portname), ""%d"", port);    getaddrinfo(""::"", portname, &hints, &res);    vaddr.ss.ss_family = AF_INET6;    assert(res != NULL);    memcpy((struct sockaddr*)&vaddr, res->ai_addr, res->ai_addrlen);    vaddr.ss_port = port;    vaddr.ss_len = res->ai_addrlen;    freeaddrinfo(res);  }  else#endif  {    struct sockaddr_in *v4 = (struct sockaddr_in*) &vaddr;    v4->sin_addr.s_addr = INADDR_ANY;    vaddr.ss.ss_family = AF_INET;    vaddr.ss_len = sizeof(struct sockaddr_in);    v4->sin_port = htons(port);  }  snprintf(portname, PORTNAMELEN, ""%d"", port);  if (vhost_ip)  {    if (getaddrinfo(vhost_ip, portname, &hints, &res))      return;    assert(res != NULL);    memcpy((struct sockaddr*)&vaddr, res->ai_addr, res->ai_addrlen);    vaddr.ss_port = port;    vaddr.ss_len = res->ai_addrlen;    freeaddrinfo(res);  }#ifdef IPV6  else if (pass == 0 && ServerInfo.can_use_v6)  {         pass = 1;    add_listener(port, ""0.0.0.0"", flags);  }  pass = 0;#endif  if ((listener = find_listener(port, &vaddr)))  {    listener->flags = flags;    if (listener->fd.flags.open)      return;  }  else  {    listener = make_listener(port, &vaddr);    dlinkAdd(listener, &listener->listener_node, &ListenerPollList);    listener->flags = flags;  }  if (inetport(listener))    listener->active = 1;  else    close_listener(listener);}",3,"cwe119,cwe120,cweother"
"""select_candidates(hashtable_t* candidates, matcher_t* matcher, const char* user_agent) {tfind_data_t pfx_data;tpfx_data.needle = user_agent;tpfx_data.map = hashmap_init(&string_eq, &string_hash, NULL);tif(patricia_search_foreach(matcher->prefix, user_agent, &find, &pfx_data)) {tthashtable_add(candidates, hashmap_get(pfx_data.map, user_agent), NULL, NULL);t}telse {ttfunctor_toset_data_t toset_data;tttoset_data.set = candidates;tthashmap_foreach_value(pfx_data.map, &functor_toset, &toset_data);ttchar ruser_agent[8 * 1024];ttmemset(ruser_agent, '0', 8 * 1024);ttstrrev(ruser_agent, user_agent);ttfind_data_t sfx_data;ttsfx_data.needle = ruser_agent;ttsfx_data.map = hashmap_init(&string_eq, &string_hash, NULL);ttpatricia_search_foreach(matcher->suffix, ruser_agent, &find, &sfx_data);tthashmap_foreach_value(sfx_data.map, &functor_toset, &toset_data);tthashmap_free(sfx_data.map, NULL, NULL);t}thashmap_free(pfx_data.map, NULL, NULL);}""",2,"cwe119,cwe120"
"math_memory_calculator(const char *formula, byte *res, size_t res_size, int base, char fill, int size){tbyte left[res_size];tbyte right[res_size];tchar operator;tchar text_left[res_size << 3];tchar text_right[res_size << 3];tchar text_res[res_size << 3];tconst char *formula_end;tif (res_size == 0)t{ttpr_red_info(""res_size == 0"");ttreturn -EINVAL;t}tif (res == NULL)t{ttres = alloca(res_size);ttif (res == NULL)tt{tttpr_error_info(""res == NULL"");tttreturn -ENOMEM;tt}t}tformula_end = formula + text_len(formula);tformula = math_text2memory(formula, res, res_size, -1);twhile (formula < formula_end)t{ttmath_memory_copy(left, sizeof(left), res, res_size);ttoperator = *formula;ttformula = math_text2memory(formula + 1, right, sizeof(right), -1);ttswitch (operator)tt{ttcase '+':tttmath_memory_add(left, sizeof(left), right, sizeof(right), res, res_size);tttbreak;ttcase '-':tttmath_memory_sub(left, sizeof(left), right, sizeof(right), res, res_size);tttbreak;ttcase '*':tttmath_memory_mul(left, sizeof(left), right, sizeof(right), res, res_size);tttbreak;ttcase '/':tttmath_memory_div2(left, sizeof(left), right, sizeof(right), res, res_size, base);tttbreak;ttdefault:tttpr_red_info(""invalid operator `%c'"", operator);tttreturn -EINVAL;tt}ttmath_memory2text(left, sizeof(left), text_left, sizeof(text_left), base, '0', size);ttmath_memory2text(right, sizeof(right), text_right, sizeof(text_right), base, '0', size);ttmath_memory2text(res, res_size, text_res, sizeof(text_res), base, '0', size);ttprintln(""%s %c %s = %s"", text_left, operator, text_right, text_res);t}treturn 0;}",2,"cwe119,cwe120"
"get_args_for_user_function(struct term *t,ttt       int op_code,ttt       long int *long_args,ttt       double *double_args,ttt       int *bool_args,ttt       char **string_args,ttt       struct term **term_args){  int i;  long l;  double d;  struct rel *r;  struct term *ti;  struct user_function *p;  char *s;  p = &(User_functions[op_code]);  for (r = t->farg, i=0; r; r = r->narg, i++);  if (i != p->arity) {    abend(""get_args, bad arity."");  }  for (r = t->farg, i=0; r; r = r->narg, i++) {    ti = r->argval;    switch (p->arg_types[i]) {    case LONG_TYPE:      if (ti->type != NAME)treturn(0);      else if (!str_long(sn_to_str(ti->sym_num), &l))treturn(0);      elsetlong_args[i] = l;      break;    case DOUBLE_TYPE:      if (ti->type != NAME)treturn(0);      else if (!str_double(sn_to_str(ti->sym_num), &d))treturn(0);      elsetdouble_args[i] = d;      break;    case BOOL_TYPE:      if (ti->type != NAME)treturn(0);      else {ts = sn_to_str(ti->sym_num);tif (str_ident(s,""$T""))t  bool_args[i] = 1;telse if (str_ident(s,""$F""))t  bool_args[i] = 0;telset  return(0);      }      break;    case STRING_TYPE:      if (ti->type != NAME)treturn(0);      elsetstring_args[i] = sn_to_str(ti->sym_num);      break;    case TERM_TYPE:      term_args[i] = ti;      break;    default:      abend(""get_args, bad arg type."");    }  }  return(1);}",2,"cwe119,cwe120"
"veb_tree_new(int nitems, bool clear){    int height = ilog2(2 * nitems) + 1;    int nodes = 1 << height;    struct veb *veb = malloc(sizeof(*veb));    struct tree_node *elements;    struct tree_node *scratch;    struct level_info *li;         if (!clear) {        load_veb_info(veb);        height = veb->height;        nodes = 1 << height;    }    elements = setup_mmap(sizeof(*elements) * nodes, clear);    scratch = malloc(sizeof(*scratch) * nodes);    li = malloc(sizeof(*li) * height);         veb->min_density = 0x08000;    veb->max_density = 0x10000;    compute_level_info(li, height);    veb->level_info = li;    veb->elements = elements;    veb->scratch = scratch;    veb->height = height;    veb->count = 0;    veb->iter_pos[0] = 0;    return veb;}",2,"cwe120,cweother"
"""fixnum_fill(Buf bb, int64_t num) {    chartbuf[32];    chart*end = buf + sizeof(buf) - 1;    chart*b = end;    intttneg = 0;    if (0 > num) {tneg = 1;tnum = -num;    }    *b-- = '0';    if (0 < num) {tfor (; 0 < num; num /= 10, b--) {t    *b = (num % 10) + '0';t}tif (neg) {t    *b = '-';t} else {t    b++;t}    } else {t*b = '0';    }    buf_append_string(bb, b, end - b);}""",2,"cwe119,cwe120"
"imap_select(struct mailbox *mp, off_t *size, int *count, const char *mbx){tenum okay ok = OKAY;tchart*cp;tchar o[LINESIZE];tFILEt*queuefp = NULL;tmp->mb_uidvalidity = 0;tsnprintf(o, sizeof o, ""%s SELECT %sr"", tag(1), imap_quotestr(mbx));tIMAP_OUT(o, MB_COMD, return STOP)twhile (mp->mb_active & MB_COMD) {ttok = imap_answer(mp, 1);ttif (response_status != RESPONSE_OTHER &&tttt(cp = asccasestr(responded_text,tttttt ""[UIDVALIDITY "")) != NULL)tttmp->mb_uidvalidity = atol(&cp[13]);t}t*count = had_exists > 0 ? had_exists : 0;tif (response_status != RESPONSE_OTHER &&tttascncasecmp(responded_text, ""[READ-ONLY] "", 12)ttt== 0)ttmp->mb_perm = 0;treturn ok;}",3,"cwe119,cwe120,cweother"
"main(int argc, const char *argv[]){  CdioList_t *p_entlist;  CdioListNode_t *p_entnode;  char const *psz_fname;  iso9660_t *p_iso;  const char *psz_path=""/"";  if (argc > 1)     psz_fname = argv[1];  else     psz_fname = ISO9660_IMAGE;  p_iso = iso9660_open (psz_fname);    if (NULL == p_iso) {    fprintf(stderr, ""Sorry, couldn't open %s as an ISO-9660 image"", t    psz_fname);    return 1;  }     {    char *psz_str = NULL;    print_vd_info(""Application"", iso9660_ifs_get_application_id);    print_vd_info(""Preparer   "", iso9660_ifs_get_preparer_id);    print_vd_info(""Publisher  "", iso9660_ifs_get_publisher_id);    print_vd_info(""System     "", iso9660_ifs_get_system_id);    print_vd_info(""Volume     "", iso9660_ifs_get_volume_id);    print_vd_info(""Volume Set "", iso9660_ifs_get_volumeset_id);  }      p_entlist = iso9660_ifs_readdir (p_iso, psz_path);           if (p_entlist) {    _CDIO_LIST_FOREACH (p_entnode, p_entlist)    {      char filename[4096];      iso9660_stat_t *p_statbuf = t(iso9660_stat_t *) _cdio_list_node_data (p_entnode);      iso9660_name_translate(p_statbuf->filename, filename);      printf (""%s [LSN %6d] %8u %s%s"", t      _STAT_DIR == p_statbuf->type ? ""d"" : ""-"",t      p_statbuf->lsn, p_statbuf->size, psz_path, filename);    }        _cdio_list_free (p_entlist, true);  }    iso9660_close(p_iso);  return 0;}",2,"cwe119,cwe120"
"Generate(char *OutputDir, unsigned Bpp){  FILE *Out;  unsigned RopCode;  PROPINFO RopInfo;  char *FileName;  FileName = malloc(strlen(OutputDir) + 12);  if (NULL == FileName)    {      fprintf(stderr, ""Out of memory"");      exit(1);    }  strcpy(FileName, OutputDir);  if ('/' != FileName[strlen(FileName) - 1])    {      strcat(FileName, ""/"");    }  sprintf(FileName + strlen(FileName), ""dib%ugen.c"", Bpp);  Out = fopen(FileName, ""w"");  free(FileName);  if (NULL == Out)    {      perror(""Error opening output file"");      exit(1);    }  MARK(Out);  Output(Out, ""/* This is a generated file. Please do not edit */"");  Output(Out, """");  Output(Out, ""#include <win32k.h>"");  CreateShiftTables(Out);  RopInfo = FindRopInfo(ROPCODE_GENERIC);  CreatePrimitive(Out, Bpp, RopInfo);  for (RopCode = 0; RopCode < 256; RopCode++)    {      RopInfo = FindRopInfo(RopCode);      if (NULL != RopInfo)        {          CreatePrimitive(Out, Bpp, RopInfo);        }    }  CreateTable(Out, Bpp);  CreateBitBlt(Out, Bpp);  fclose(Out);}",2,"cwe120,cweother"
"addr_debug_print(int verbose, const ioa_addr *addr, const s08bits* s){tif (verbose) {ttif (!addr) {tttTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, ""%s: EMPTY"", s);tt} else {ttts08bits addrbuf[INET6_ADDRSTRLEN];tttif (!s)tttts = """";tttif (addr->ss.sa_family == AF_INET) {ttttTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, ""IPv4. %s: %s:%d"", s, inet_ntop(AF_INET,tttttttt&addr->s4.sin_addr, addrbuf, INET6_ADDRSTRLEN),ttttttttnswap16(addr->s4.sin_port));ttt} else if (addr->ss.sa_family == AF_INET6) {ttttTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, ""IPv6. %s: %s:%d"", s, inet_ntop(AF_INET6,tttttttt&addr->s6.sin6_addr, addrbuf, INET6_ADDRSTRLEN),ttttttttnswap16(addr->s6.sin6_port));ttt} else {ttttif (addr_any_no_port(addr)) {tttttTURN_LOG_FUNC(tttttttttTURN_LOG_LEVEL_INFO,ttttttttt""IP. %s: 0.0.0.0:%d"",ttttttttts,tttttttttnswap16(addr->s4.sin_port));tttt} else {tttttTURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, ""%s: wrong IP address family: %d"", s,ttttttttt(int) (addr->ss.sa_family));tttt}ttt}tt}t}}",2,"cwe119,cwe120"
"telnet_fgets (char *s, int n, FILE *iop){  int c;  register char *cs;  cs = s;   for (c = 0; tmpline[c] != '0' && --n > 0; ++c)    {      *cs++ = tmpline[c];      if (tmpline[c] == '')t{t  *cs++ = '0';t  if (debug)t    syslog (LOG_DEBUG, ""command: %s"", s);t  tmpline[0] = '0';t  return (s);t}      if (c == 0)ttmpline[0] = '0';    }  while ((c = getc (iop)) != EOF)    {      c &= 0377;      if (c == IAC)t{t  c = getc (iop);t  if (c != EOF)t    {t      c &= 0377;t      switch (c)tt{ttcase WILL:ttcase WONT:tt  c = getc (iop);tt  printf (""%c%c%c"", IAC, DONT, 0377 & c);tt  fflush (stdout);tt  continue;ttcase DO:ttcase DONT:tt  c = getc (iop);tt  printf (""%c%c%c"", IAC, WONT, 0377 & c);tt  fflush (stdout);tt  continue;ttcase IAC:tt  break;ttdefault:tt  continue;t tt}t    }t}      *cs++ = c;      if (--n <= 0 || c == '')tbreak;    }  if (c == EOF && cs == s)    return (NULL);  *cs++ = '0';  if (debug)    {      if (!cred.guest && strncasecmp (""pass "", s, 5) == 0)t{t   t  syslog (LOG_DEBUG, ""command: %.5s ???"", s);t}      elset{t  register char *cp;t  register int len;t   t  len = strlen (s);t  cp = s + len - 1;t  while (cp >= s && (*cp == '' || *cp == 'r'))t    {t      --cp;t      --len;t    }t  syslog (LOG_DEBUG, ""command: %.*s"", len, s);t}    }  return (s);}",2,"cwe120,cweother"
"open(const char *file, int flags, ...){tint mode = 0;tif (flags & O_CREAT) {ttva_list arg;ttva_start(arg, flags);ttmode = va_arg(arg, int);ttva_end(arg);t}tif (!real_open)ttreal_open = dlsym(RTLD_NEXT, ""open"");tswitch (meminfo_state) {ttcase OVERRIDE_OFF:tttbreak;ttcase OVERRIDE_ON: {tttchar fname[PATH_MAX];tttsprintf(fname, ""%s/meminfo-hugepages"", fake_meminfo);tttfile = fname;tttbreak;tt}ttcase OVERRIDE_MISSING: {tttchar fname[PATH_MAX];tttsprintf(fname, ""%s/meminfo-none"", fake_meminfo);tttfile = fname;tttbreak;tt}ttdefault:tttreturn -1;t}treturn real_open(file, flags, mode);}",3,"cwe119,cwe120,cweother"
"deinit_tounicode(void *ptr, int *errptr){tstruct libmail_u_convert_tou *p=tt(struct libmail_u_convert_tou *)ptr;tint rc=libmail_u_convert_deinit(p->hdr.next, errptr);tstruct libmail_u_convert_buf *bufptr;tif (rc == 0 && p->nullterminate)t{ttunicode_char zero=0;ttrc=save_unicode( (const char *)&zero, sizeof(zero),tttt p->hdr.ptr);t}tif (rc == 0)t{ttif (((*p->ucptr_ret)=malloc(p->tot_size ? p->tot_size:1)) !=tt    NULL)tt{tttsize_t i=0;tttfor (bufptr=p->first; bufptr; bufptr=bufptr->next)ttt{ttttif (bufptr->fragment_size)tttttmemcpy(&(*p->ucptr_ret)[i],ttttt       bufptr->fragment,ttttt       bufptr->fragment_sizettttt       *sizeof(*bufptr->fragment));tttti += bufptr->fragment_size;ttt}ttt(*p->ucsize_ret)=i;tt}ttelsett{tttrc= -1;tt}t}tfor (bufptr=p->first; bufptr; )t{ttstruct libmail_u_convert_buf *b=bufptr;ttbufptr=bufptr->next;ttfree(b);t}tfree(p);treturn rc;}",2,"cwe120,cweother"
"main(){tint len;tttt tint max;tttt tchar line[MAXLINE];tt tchar longest[MAXLINE];t tmax = 0;twhile ((len = getline2(line, MAXLINE)) > 0)ttif (len > max) {tttmax = len;tttcopy(longest, line);tt}tif (max > 0)t ttprintf(""longest sentence: %slength: %d"", longest, max);treturn 0;}",2,"cwe119,cwe120"
"test_conv_enum_1(void){    const size_t nelmts=NTESTELEM;    inttti, val, *buf=NULL;    hid_ttt1 = -1;    hid_ttt2 = -1;    charts[80];    intttret_value = 1;    size_t      u;         if((t1 = H5Tcreate(H5T_ENUM, sizeof(int))) < 0) goto error;    if((t2 = H5Tenum_create(H5T_NATIVE_INT)) < 0) goto error;    s[1] = '0';    for(i = 0; i < 26; i++) {ts[0] = 'A' + i;tH5Tenum_insert(t1, s, &i);tH5Tenum_insert(t2, s, (val = i * 1000 + i, &val));    }           if(NULL == (buf = (int*)HDmalloc(nelmts * MAX(H5Tget_size(t1), H5Tget_size(t2)))))        goto error;    for(u = 0; u < nelmts; u++)        buf[u] = HDrand() % 26;         sprintf(s, ""Testing random enum conversion O(N)"");    printf(""%-70s"", s);    HDfflush(stdout);    if(H5Tconvert(t1, t2, nelmts, buf, NULL, H5P_DEFAULT) < 0) goto error;    PASSED();    sprintf(s, ""Testing random enum conversion O(N log N)"");    printf(""%-70s"", s);    HDfflush(stdout);    if(H5Tconvert(t2, t1, nelmts, buf, NULL, H5P_DEFAULT) < 0) goto error;    PASSED();    ret_value = 0;error:    H5E_BEGIN_TRY {        H5Tclose(t1);        H5Tclose(t2);    } H5E_END_TRY;    if(buf)        HDfree(buf);    reset_hdf5();    return ret_value;}",2,"cwe119,cwe120"
"write_automap_data_t(struct auto_string *strout, automap_data_t *data){t t t t t tint i, j;tautostr_append(savestruct_autostr, ""{"");tfor (i = 0; i < 100; i++) {ttchar line[101];ttfor (j = 0; j < 100; j++)tttline[j] = (char)((*data)[i][j] + '0');ttline[100] = '0';ttautostr_append(strout, """"%s"","", line);t}tautostr_append(strout, ""}"");}",2,"cwe119,cwe120"
"psr_put(uint16_t pskey, uint8_t *value, uint16_t size){tstruct psr_data *item;titem = malloc(sizeof(*item));tif (!item)ttreturn -ENOMEM;titem->pskey = pskey;tif (size > 0) {ttitem->value = malloc(size);ttif (!item->value) {tttfree(item);tttreturn -ENOMEM;tt}ttmemcpy(item->value, value, size);ttitem->size = size;t} else {ttitem->value = NULL;ttitem->size = 0;t}titem->next = NULL;tif (!head)tthead = item;telsetttail->next = item;ttail = item;treturn 0;}",2,"cwe120,cwe469"
"attach_sketch_hint_labels(int sketch_count, Plist hints){  Plist p;  int hint_count;  for (p = hints, hint_count = 1; p; p = p->next, hint_count++) {    Topform c = p->v;    if (!exists_attribute(c->attributes, label_att())) {      char s[100];      sprintf(s, ""S%d_H%d"", sketch_count, hint_count);      c->attributes = set_string_attribute(c->attributes, label_att(), s);    }  }}",2,"cwe119,cwe120"
"eet_mempool_init(void){   const char *choice;   unsigned int i;   choice = getenv(""EINA_MEMPOOL"");   if ((!choice) || (!choice[0]))     choice = ""chained_mempool"";   for (i = 0; i < sizeof (mempool_array) / sizeof (mempool_array[0]); ++i)     {     retry:        mempool_array[i]->mp = eina_mempool_add(choice, mempool_array[i]->name, NULL, mempool_array[i]->size, 16);        if (!mempool_array[i]->mp)          {             if (!(!strcmp(choice, ""pass_through"")))               {                  ERR(""Falling back to pass through ! Previously tried '%s' mempool."", choice);                  choice = ""pass_through"";                  goto retry;               }             else               {                  ERR(""Impossible to allocate mempool '%s' !"", choice);                  return EINA_FALSE;               }          }     }   return EINA_TRUE;}",2,"cwe469,cweother"
"String2Menu(char *s){ static char *menus[] = { ""delta"", ""full"", ""relay"", NULL };  int i; for (i = 0; menus[i] != NULL; i++)   {   if (strcmp(s,menus[i]) == 0)      {      return i;      }   }return cfd_menu_error;}",2,"cwe119,cwe120"
"readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {    redisClient *c = (redisClient*) privdata;    char buf[REDIS_IOBUF_LEN];    int nread;    REDIS_NOTUSED(el);    REDIS_NOTUSED(mask);    nread = read(fd, buf, REDIS_IOBUF_LEN);    if (nread == -1) {        if (errno == EAGAIN) {            nread = 0;        } else {            redisLog(REDIS_VERBOSE, ""Reading from client: %s"",strerror(errno));            freeClient(c);            return;        }    } else if (nread == 0) {        redisLog(REDIS_VERBOSE, ""Client closed connection"");        freeClient(c);        return;    }    if (nread) {        c->querybuf = sdscatlen(c->querybuf,buf,nread);        c->lastinteraction = time(NULL);    } else {        return;    }    if (sdslen(c->querybuf) > server.client_max_querybuf_len) {        sds ci = getClientInfoString(c), bytes = sdsempty();        bytes = sdscatrepr(bytes,c->querybuf,64);        redisLog(REDIS_WARNING,""Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)"", ci, bytes);        sdsfree(ci);        sdsfree(bytes);        freeClient(c);        return;    }    processInputBuffer(c);}",3,"cwe119,cwe120,cweother"
"derived_key_encrypt(struct encrypted_key_payload *epayload,ttt       const u8 *derived_key,ttt       unsigned int derived_keylen){tstruct scatterlist sg_in[2];tstruct scatterlist sg_out[1];tstruct blkcipher_desc desc;tunsigned int encrypted_datalen;tunsigned int padlen;tchar pad[16];tint ret;tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);tpadlen = encrypted_datalen - epayload->decrypted_datalen;tret = init_blkcipher_desc(&desc, derived_key, derived_keylen,tttt  epayload->iv, ivsize);tif (ret < 0)ttgoto out;tdump_decrypted_data(epayload);tmemset(pad, 0, sizeof pad);tsg_init_table(sg_in, 2);tsg_set_buf(&sg_in[0], epayload->decrypted_data,tt   epayload->decrypted_datalen);tsg_set_buf(&sg_in[1], pad, padlen);tsg_init_table(sg_out, 1);tsg_set_buf(sg_out, epayload->encrypted_data, encrypted_datalen);tret = crypto_blkcipher_encrypt(&desc, sg_out, sg_in, encrypted_datalen);tcrypto_free_blkcipher(desc.tfm);tif (ret < 0)ttpr_err(""encrypted_key: failed to encrypt (%d)"", ret);telsettdump_encrypted_data(epayload, encrypted_datalen);out:treturn ret;}",2,"cwe119,cwe120"
"get_client_server_context(int msgsock, char **port, char **job_dir, char **utilbin_dir, const char **host){   char *s_code = NULL;   char *data   = NULL;      DENTER(TOP_LAYER, ""get_client_server_context"");      data = read_from_qrsh_socket(msgsock);   if (data == NULL || *data == 0) {      ERROR((SGE_EVENT, MSG_QSH_ERRORREADINGCONTEXTFROMQLOGIN_STARTER_S,""qlogin_starter""));      DEXIT;      return 0;   }   DPRINTF((""qlogin_starter sent: %s"", data));     s_code = strtok(data, "":"");   if (s_code == NULL) {      ERROR((SGE_EVENT, MSG_QSH_ERRORREADINGCONTEXTFROMQLOGIN_STARTER_S,""qlogin_starter""));      DEXIT;      return 0;   }      if (strcmp(s_code, ""0"") == 0) {         if ((*port = strtok(NULL, "":"")) != NULL) {         if ((*utilbin_dir = strtok(NULL, "":"")) != NULL) {            if ((*job_dir = strtok(NULL, "":"")) != NULL) {               if ((*host = strtok(NULL, "":"")) != NULL) {                  return 1;               }            }         }      }      ERROR((SGE_EVENT, MSG_QSH_ERRORREADINGCONTEXTFROMQLOGIN_STARTER_S,""qlogin_starter""));      DEXIT;      return 0;   } else {                               char *message = strtok(NULL, """");      ERROR((SGE_EVENT, ""%s: %s"", s_code, message == NULL ? """" : message));   }   DEXIT;   return 0;}",4,"cwe119,cwe120,cwe476,cweother"
"ast_yyerror (const char *s,  yyltype *loc, struct parse_io *parseio ){tstruct yyguts_t * yyg = (struct yyguts_t*)(parseio->scanner);tchar spacebuf[8000];  tint i=0;tchar *s2 = expr2_token_subst(s);tspacebuf[0] = 0;tfor (i = 0; i < (int)(yytext - YY_CURRENT_BUFFER_LVALUE->yy_ch_buf); i++) {ttspacebuf[i] = ' ';t}t tspacebuf[i++] = '^';tspacebuf[i] = 0;#ifdef STANDALONE3t tprintf(""ast_yyerror(): %s syntax error: %s; Input:%s%s"",ttt(extra_error_message_supplied ? extra_error_message : """"), s2, parseio->string, spacebuf);#elsetast_log(LOG_WARNING,""ast_yyerror(): %s syntax error: %s; Input:%s%s"",ttt(extra_error_message_supplied ? extra_error_message : """"), s2, parseio->string, spacebuf);#endif#ifndef STANDALONEtast_log(LOG_WARNING,""If you have questions, please refer to https://wiki.asterisk.org/wiki/display/AST/Channel+Variables"");#endiftfree(s2);treturn(0);}",2,"cwe119,cwe120"
"set_special_pids(struct pid *pid){tstruct task_struct *curr = current->group_leader;tif (task_session(curr) != pid)ttchange_pid(curr, PIDTYPE_SID, pid);tif (task_pgrp(curr) != pid)ttchange_pid(curr, PIDTYPE_PGID, pid);}",2,"cwe119,cwe120"
"gerbv_process_tools_file(const char *tf){    FILE *f;    char buf[80];        have_tools_file = 0;    memset(tools, 0, sizeof(tools));        if (tf == NULL)        return 0;        f = fopen(tf, ""r"");    if (f == NULL) {        fprintf(stderr, ""*** ERROR: Failed to open file ""%s"" to read."", tf);        return 0;    }    while (!feof(f)) {        memset(buf, 0, sizeof(buf));        if (NULL == fgets(buf, sizeof(buf)-1, f))            break;        ProcessToolLine(buf);    }    fclose(f);    have_tools_file = 1;    return 1;}",3,"cwe119,cwe120,cweother"
"httpc_mime_next(httpc_conn_t * conn,                const char *content_id,                const char *content_type, const char *transfer_encoding){  herror_t status;  char buffer[512];  char boundary[75];     _httpc_mime_get_boundary(conn, boundary);  sprintf(buffer, ""r--%sr"", boundary);     status = http_output_stream_write(conn->out,                                    (const byte_t *) buffer, strlen(buffer));  if (status != H_OK)    return status;     sprintf(buffer, ""%s: %sr%s: %sr%s: %srr"",          HEADER_CONTENT_TYPE, content_type,          HEADER_CONTENT_TRANSFER_ENCODING, transfer_encoding,          HEADER_CONTENT_ID, content_id);  return http_output_stream_write(conn->out,                                    (const byte_t *) buffer, strlen(buffer));}",2,"cwe119,cwe120"
"do_vg_activate (int activate, char *const *volgroups){  int r, i, argc;  CLEANUP_FREE char *err = NULL;  CLEANUP_FREE const char **argv = NULL;  argc = count_strings (volgroups) + 4;  argv = malloc (sizeof (char *) * (argc+1));  if (argv == NULL) {    reply_with_perror (""malloc"");    return -1;  }  argv[0] = str_lvm;  argv[1] = ""vgchange"";  argv[2] = ""-a"";  argv[3] = activate ? ""y"" : ""n"";  for (i = 4; i <= argc; ++i)    argv[i] = volgroups[i-4];  r = commandv (NULL, &err, (const char * const*) argv);  if (r == -1) {    reply_with_error (""vgchange: %s"", err);    return -1;  }  udev_settle ();  return 0;}",2,"cwe120,cweother"
"isc_httpd_addheaderuint(isc_httpd_t *httpd, const char *name, int val) {tisc_result_t result;tunsigned int needlen;tchar buf[sizeof ""18446744073709551616""];tsprintf(buf, ""%d"", val);tneedlen = strlen(name);  tneedlen += 2 + strlen(buf);  tneedlen += 2;  twhile (isc_buffer_availablelength(&httpd->headerbuffer) < needlen) {ttresult = grow_headerspace(httpd);ttif (result != ISC_R_SUCCESS)tttreturn (result);t}tsprintf(isc_buffer_used(&httpd->headerbuffer),tt""%s: %sr"", name, buf);tisc_buffer_add(&httpd->headerbuffer, needlen);treturn (ISC_R_SUCCESS);}",2,"cwe119,cwe120"
"read_command(HSCPRJ * hp) {    STRPTR command;    do        command = infgetw(hp->inpf);    while (command && !strcmp(command, """"));    if (command) {                 infskip_ws(hp->inpf);        DP(fprintf(stderr, DHP ""command `%s'"", command));    } else        DP(fprintf(stderr, DHP ""command EOF""));    return (command);}",2,"cwe469,cweother"
"AT_DialVoice(gn_data *data, struct gn_statemachine *state){tunsigned char req[32];tif (!data->call_info)ttreturn GN_ERR_INTERNALERROR;tsnprintf(req, sizeof(req), ""ATD%s;r"", data->call_info->number);tif (sm_message_send(strlen(req), GN_OP_MakeCall, req, state))ttreturn GN_ERR_NOTREADY;treturn sm_block_no_retry(GN_OP_MakeCall, data, state);}",2,"cwe119,cwe120"
"inWriteF77Block(int fileID, int byteswap, size_t blocksize){  static union {unsigned long l; unsigned char c[sizeof(long)];} u_byteorder = {1};  unsigned char f77block[4];  if ( IsBigendian() )    {      if ( byteswap )t{t  f77block[0] = (unsigned char) (blocksize);t  f77block[1] = (unsigned char) (blocksize >>  8);t  f77block[2] = (unsigned char) (blocksize >> 16);t  f77block[3] = (unsigned char) (blocksize >> 24);t}      elset{t  f77block[3] = (unsigned char) (blocksize);t  f77block[2] = (unsigned char) (blocksize >>  8);t  f77block[1] = (unsigned char) (blocksize >> 16);t  f77block[0] = (unsigned char) (blocksize >> 24);t}    }  else    {      if ( byteswap )t{t  f77block[3] = (unsigned char) (blocksize);t  f77block[2] = (unsigned char) (blocksize >>  8);t  f77block[1] = (unsigned char) (blocksize >> 16);t  f77block[0] = (unsigned char) (blocksize >> 24);t}      elset{t  f77block[0] = (unsigned char) (blocksize);t  f77block[1] = (unsigned char) (blocksize >>  8);t  f77block[2] = (unsigned char) (blocksize >> 16);t  f77block[3] = (unsigned char) (blocksize >> 24);t}    }  if ( fileWrite(fileID, f77block, 4) != 4 )    Error(""write failed on %s"", fileInqName(fileID));}",2,"cwe119,cwe120"
"gdm_address_get_numeric_info (GdmAddress *address,                              char      **hostp,                              char      **servp){        char     host [NI_MAXHOST];        char     serv [NI_MAXSERV];        int      res;        gboolean ret;        g_return_val_if_fail (address != NULL, FALSE);        g_return_val_if_fail (address->ss != NULL, FALSE);        ret = FALSE;        host [0] = '0';        serv [0] = '0';        res = getnameinfo ((const struct sockaddr *)address->ss,                           (int) gdm_sockaddr_len (address->ss),                           host, sizeof (host),                           serv, sizeof (serv),                           NI_NUMERICHOST | NI_NUMERICSERV);        if (res != 0) {                const char *err_msg;                err_msg = gai_strerror (res);                g_warning (""Unable to lookup numeric info: %s"",                        err_msg ? err_msg : ""(null)"");                _gdm_address_debug (address, NULL, NULL, NULL);        } else {                ret = TRUE;        }        if (servp != NULL) {                if (g_str_has_prefix (serv, ""::ffff:"")) {                        *servp = g_strdup (serv + 7);                } else {                        *servp = g_strdup (serv);                }        }        if (hostp != NULL) {                if (g_str_has_prefix (host, ""::ffff:"")) {                        *hostp = g_strdup (host + 7);                } else {                        *hostp = g_strdup (host);                }        }        return ret;}",2,"cwe119,cwe120"
"outputClusters(t_Params *ptParams, int nK, int *anZ, int nN, int nM, int* anT, t_Flows *ptFlows, char **aszLabels, int* anCentroids, t_Unique *ptUnique, char** aszIDs){  FILE *ofp = NULL;  char *szOutFile = (char *) malloc(sizeof(char)*MAX_LINE_LENGTH);  int  s = 0, i = 0, j = 0, index = 0;  mkdir(ptParams->szOutFileStub, S_IRWXU);    if(!szOutFile)    goto memoryError;  for(i = 0; i < nK; i++){    if(anT[i] > 0){      sprintf(szOutFile, ""%s/i_%d%s"",ptParams->szOutFileStub,index, FASTA_SUFFIX);      ofp = fopen(szOutFile, ""w"");      if(ofp){tint nUI = anCentroids[i];tfprintf(ofp, "">%s_%d_%d"",ptParams->szOutFileStub,index, anT[i]);tfor(j = nOffSet; j < nM; j++){t  char   cBase = szFlows[j % 4];t  for(s = 0; s < ptUnique->asU[nUI*nM + j]; s++){t    fprintf(ofp, ""%c"", cBase);t  }t}      tfprintf(ofp,"""");tfor(j = 0; j < nN; j++){t  if(anZ[j] == i){t    int  nLen     = 0;t    char *szSeq   = flowToSeq(&nLen, &(ptFlows->adData[j*nM]), ptFlows->anLengths[j]);t    writeSequenceUnaligned(ofp, aszLabels[j], szSeq, nLen);t    free(szSeq);t  }t}ttfclose(ofp);      }      else{tfprintf(stderr,""Can't open file %s for writing"",szOutFile);      }      index++;    }  }tttt        free(szOutFile);  return; memoryError:  fprintf(stderr, ""Failed allocating memory in outputClusters"");  fflush(stderr);  exit(EXIT_FAILURE);}",2,"cwe120,cweother"
"kpropd_com_err_proc(const char *whoami,                    long code,                    const char *fmt,                    va_list args){    char    error_buf[8096];    error_buf[0] = '0';    if (fmt)        vsnprintf(error_buf, sizeof(error_buf), fmt, args);    syslog(LOG_ERR, ""%s%s%s%s%s"", whoami ? whoami : """", whoami ? "": "" : """",           code ? error_message(code) : """", code ? "" "" : """", error_buf);}",3,"cwe119,cwe120,cweother"
"glusterd_op_ac_commit_op (glusterd_op_sm_event_t *event, void *ctx){        int                       ret        = 0;        glusterd_req_ctx_t       *req_ctx = NULL;        int32_t                   status     = 0;        char                     *op_errstr  = NULL;        dict_t                   *dict       = NULL;        dict_t                   *rsp_dict = NULL;        GF_ASSERT (ctx);        req_ctx = ctx;        dict = req_ctx->dict;        rsp_dict = glusterd_op_init_commit_rsp_dict (req_ctx->op);        if (NULL == rsp_dict)                return -1;        status = glusterd_op_commit_perform (req_ctx->op, dict, &op_errstr,                                             rsp_dict);        if (status) {                gf_log ("""", GF_LOG_ERROR, ""Commit failed: %d"", status);        }        ret = glusterd_op_commit_send_resp (req_ctx->req, req_ctx->op,                                            status, op_errstr, rsp_dict);        glusterd_op_fini_ctx ();        if (op_errstr && (strcmp (op_errstr, """")))                GF_FREE (op_errstr);        if (rsp_dict)                dict_unref (rsp_dict);        gf_log ("""", GF_LOG_DEBUG, ""Returning with %d"", ret);        return ret;}",2,"cwe469,cwe476"
want_subj(SUBJECT *subj){    intttvisible    = False;    inttthas_unread = !only_unread;    ARTICLEt*thr       = subj->thread;    do {tif (subj->disp >= 0) {t    visible = True;t    if (has_unread)ttreturn True;t}tif (subj->no_unread > 0) {t    has_unread = True;t    if (visible)ttreturn True;t}tsubj = subj->next;    } while (subj && subj->thread == thr);    return False;},2,"cwe120,cweother"
"snd_opl3_seq_probe(struct device *_dev){tstruct snd_seq_device *dev = to_seq_dev(_dev);tstruct snd_opl3 *opl3;tint client, err;tchar name[32];tint opl_ver;topl3 = *(struct snd_opl3 **)SNDRV_SEQ_DEVICE_ARGPTR(dev);tif (opl3 == NULL)ttreturn -EINVAL;tspin_lock_init(&opl3->voice_lock);topl3->seq_client = -1;t topl_ver = (opl3->hardware & OPL3_HW_MASK) >> 8;tsprintf(name, ""OPL%i FM synth"", opl_ver);tclient = opl3->seq_client =ttsnd_seq_create_kernel_client(opl3->card, opl3->seq_dev_num,ttttt     name);tif (client < 0)ttreturn client;tif ((err = snd_opl3_synth_create_port(opl3)) < 0) {ttsnd_seq_delete_kernel_client(client);ttopl3->seq_client = -1;ttreturn err;t}t tsetup_timer(&opl3->tlist, snd_opl3_timer_func, (unsigned long) opl3);tspin_lock_init(&opl3->sys_timer_lock);topl3->sys_timer_status = 0;#ifdef CONFIG_SND_SEQUENCER_OSStsnd_opl3_init_seq_oss(opl3, name);#endiftreturn 0;}",2,"cwe119,cwe120"
"vti_print_opt(struct link_util *lu, FILE *f, struct rtattr *tb[]){tchar s1[1024];tchar s2[64];tconst char *local = ""any"";tconst char *remote = ""any"";tif (!tb)ttreturn;tif (tb[IFLA_VTI_REMOTE]) {ttunsigned addr = *(__u32 *)RTA_DATA(tb[IFLA_VTI_REMOTE]);ttif (addr)tttremote = format_host(AF_INET, 4, &addr, s1, sizeof(s1));t}tfprintf(f, ""remote %s "", remote);tif (tb[IFLA_VTI_LOCAL]) {ttunsigned addr = *(__u32 *)RTA_DATA(tb[IFLA_VTI_LOCAL]);ttif (addr)tttlocal = format_host(AF_INET, 4, &addr, s1, sizeof(s1));t}tfprintf(f, ""local %s "", local);tif (tb[IFLA_VTI_LINK] && *(__u32 *)RTA_DATA(tb[IFLA_VTI_LINK])) {ttunsigned link = *(__u32 *)RTA_DATA(tb[IFLA_VTI_LINK]);ttconst char *n = if_indextoname(link, s2);ttif (n)tttfprintf(f, ""dev %s "", n);ttelsetttfprintf(f, ""dev %u "", link);t}tif (tb[IFLA_VTI_IKEY]) {ttinet_ntop(AF_INET, RTA_DATA(tb[IFLA_VTI_IKEY]), s2, sizeof(s2));ttfprintf(f, ""ikey %s "", s2);t}tif (tb[IFLA_VTI_OKEY]) {ttinet_ntop(AF_INET, RTA_DATA(tb[IFLA_VTI_OKEY]), s2, sizeof(s2));ttfprintf(f, ""okey %s "", s2);t}}",2,"cwe119,cwe120"
"cmd_window_size(const char *data){        char sizestr[MAX_INT_STRLEN];tint size;tif (!is_numeric(data, 0)) return;tsize = atoi(data);tsize -= WINDOW_MAIN(active_win)->height -ttWINDOW_MAIN(active_win)->statusbar_lines;tif (size == 0) return;tltoa(sizestr, size < 0 ? -size : size);tif (size < 0)ttcmd_window_shrink(sizestr);telsettcmd_window_grow(sizestr);}",3,"cwe119,cwe120,cweother"
"slurm_sprint_job_step_info ( job_step_info_t * job_step_ptr,ttt    int one_liner ){tchar time_str[32];tchar limit_str[32];tchar tmp_line[128];tchar *out = NULL;tuint32_t cluster_flags = slurmdb_setup_cluster_flags();t tslurm_make_time_str ((time_t *)&job_step_ptr->start_time, time_str,ttsizeof(time_str));tif (job_step_ptr->time_limit == INFINITE)ttsprintf(limit_str, ""UNLIMITED"");telsettsecs2time_str ((time_t)job_step_ptr->time_limit * 60,ttttlimit_str, sizeof(limit_str));tsnprintf(tmp_line, sizeof(tmp_line),tt""StepId=%u.%u UserId=%u StartTime=%s TimeLimit=%s"",ttjob_step_ptr->job_id, job_step_ptr->step_id,ttjob_step_ptr->user_id, time_str, limit_str);tout = xstrdup(tmp_line);tif (one_liner)ttxstrcat(out, "" "");telsettxstrcat(out, ""   "");t tif (cluster_flags & CLUSTER_FLAG_BG) {ttchar *io_nodes;ttselect_g_select_jobinfo_get(job_step_ptr->select_jobinfo,ttttt    SELECT_JOBDATA_IONODES,ttttt    &io_nodes);ttsnprintf(tmp_line, sizeof(tmp_line),ttt""Partition=%s MidplaneList=%s[%s] Gres=%s"",tttjob_step_ptr->partition,tttjob_step_ptr->nodes, io_nodes,tttjob_step_ptr->gres);ttxfree(io_nodes);t} else {ttsnprintf(tmp_line, sizeof(tmp_line),ttt""Partition=%s Nodes=%s Gres=%s"",tttjob_step_ptr->partition, job_step_ptr->nodes,tttjob_step_ptr->gres);t}txstrcat(out, tmp_line);tif (one_liner)ttxstrcat(out, "" "");telsettxstrcat(out, ""   "");t tsnprintf(tmp_line, sizeof(tmp_line),tt""Tasks=%u Name=%s Network=%s"",ttjob_step_ptr->num_tasks, job_step_ptr->name,ttjob_step_ptr->network);txstrcat(out, tmp_line);tif (one_liner)ttxstrcat(out, "" "");telsettxstrcat(out, ""   "");t tsnprintf(tmp_line, sizeof(tmp_line),tt""ResvPorts=%s Checkpoint=%u CheckpointDir=%s"",tt job_step_ptr->resv_ports,tt job_step_ptr->ckpt_interval, job_step_ptr->ckpt_dir);txstrcat(out, tmp_line);tif (one_liner)ttxstrcat(out, "" "");telsettxstrcat(out, ""   "");t tif (job_step_ptr->cpu_freq == NO_VAL)ttsnprintf(tmp_line, sizeof(tmp_line), ttt ""CPUFreqReq=Default"");telse if (job_step_ptr->cpu_freq & CPU_FREQ_RANGE_FLAG) {ttswitch (job_step_ptr->cpu_freq) tt{ttcase CPU_FREQ_LOW :tttsnprintf(tmp_line, sizeof(tmp_line),tttt ""CPUFreqReq=Low"");tttbreak;ttcase CPU_FREQ_MEDIUM :tttsnprintf(tmp_line, sizeof(tmp_line),tttt ""CPUFreqReq=Medium"");tttbreak;ttcase CPU_FREQ_HIGH :tttsnprintf(tmp_line, sizeof(tmp_line),tttt ""CPUFreqReq=High"");tttbreak;ttdefault :tttsnprintf(tmp_line, sizeof(tmp_line),tttt ""CPUFreqReq=Unknown"");tt}t}telse ttsnprintf(tmp_line, sizeof(tmp_line),ttt ""CPUFreqReq=%u"", job_step_ptr->cpu_freq);txstrcat(out, tmp_line);treturn out;}",2,"cwe119,cwe120"
"read_words (const char *filename, char ***ret_w){    unsigned n, alloc;    FILE *f;    char buf[256];    char **w = NULL;    char *wbuf = NULL, *wptr = NULL, *wend = NULL;    f = fopen (filename, ""r"");    if (f == NULL)terr (1, ""cannot open %s"", filename);    alloc = n = 0;    while (fgets (buf, sizeof(buf), f) != NULL) {tsize_t len;tbuf[strcspn(buf, ""r"")] = '0';tif (n >= alloc) {t    alloc = max(alloc + 16, alloc * 2);t    w = erealloc (w, alloc * sizeof(char **));t}tlen = strlen(buf);tif (wptr + len + 1 >= wend) {t    wptr = wbuf = emalloc (WORDBUF_SIZE);t    wend = wbuf + WORDBUF_SIZE;t}tmemmove (wptr, buf, len + 1);tw[n++] = wptr;twptr += len + 1;    }    if (n == 0)terrx(1, ""%s is an empty file, no words to try"", filename);    *ret_w = w;    fclose(f);    return n;}",4,"cwe119,cwe120,cwe476,cweother"
"sb1000_get_frequency(const int ioaddr[], const char* name, int* frequency){tstatic const unsigned char Command0[6] = {0x80, 0x44, 0x00, 0x00, 0x00, 0x00};tunsigned char st[7];tint status;tudelay(1000);tif ((status = sb1000_start_get_set_command(ioaddr, name)))ttreturn status;tif ((status = card_send_command(ioaddr, name, Command0, st)))ttreturn status;t*frequency = ((st[1] << 8 | st[2]) << 8 | st[3]) << 8 | st[4];treturn sb1000_end_get_set_command(ioaddr, name);}",2,"cwe119,cwe120"
"lfopen(const char *name, const char *mode, int flags){    int fd;    FILE *file;    fd = open(name, flags, 0600);    if (fd < 0) {treturn NULL;    }    file = fdopen(fd, mode);    if (!file) {tclose(fd);    }         return file;}",3,"cwe119,cwe120,cweother"
"tibetan_shape_syllable(HB_Bool openType, HB_ShaperItem *item, HB_Bool invalid){    hb_uint32 i;    const HB_UChar16 *str = item->string + item->item.pos;    int len = item->item.length;#ifndef NO_OPENTYPE    const int availableGlyphs = item->num_glyphs;#endif    HB_Bool haveGlyphs;    HB_STACKARRAY(HB_UChar16, reordered, len + 4);    if (item->num_glyphs < item->item.length + 4) {        item->num_glyphs = item->item.length + 4;        return FALSE;    }    if (invalid) {        *reordered = 0x25cc;        memcpy(reordered+1, str, len*sizeof(HB_UChar16));        len++;        str = reordered;    }    haveGlyphs = item->font->klass->convertStringToGlyphIndices(item->font,                                                                str, len,                                                                item->glyphs, &item->num_glyphs,                                                                item->item.bidiLevel % 2);    HB_FREE_STACKARRAY(reordered);    if (!haveGlyphs)        return FALSE;    for (i = 0; i < item->item.length; i++) {        item->attributes[i].mark = FALSE;        item->attributes[i].clusterStart = FALSE;        item->attributes[i].justification = 0;        item->attributes[i].zeroWidth = FALSE;     }     #ifndef NO_OPENTYPE    if (openType) {        HB_OpenTypeShape(item,  0);        if (!HB_OpenTypePosition(item, availableGlyphs,  FALSE))            return FALSE;    } else {        HB_HeuristicPosition(item);    }#endif    item->attributes[0].clusterStart = TRUE;    return TRUE;}",2,"cwe120,cweother"
get_empty_artifactlist(void) {    artifactlist *tl = (artifactlist *)malloc(sizeof(artifactlist));    if (tl == NULL)        fatal(OUT_OF_MEMORY);    tl->next = NULL;    tl->items = NULL;    tl->total_chance = 0;    return tl;},2,"cwe469,cwe476"
"get_stmt(FILE * fd, dbString * stmt){    char buf[1024];    int n;    static int first = 1;    db_zero_string(stmt);         if (!first)treturn 0;    first = 0;    while ((n = fread(buf, 1, sizeof(buf) - 1, fd)) > 0) {tbuf[n] = 0;tdb_append_string(stmt, buf);    }    return 1;}",2,"cwe119,cwe120"
"setup_collation(void){#if defined(HAVE_LOCALE_T) && !defined(WIN32)tintttti;tFILEt   *locale_a_handle;tcharttlocalebuf[NAMEDATALEN];  tinttttcount = 0;tPG_CMD_DECL;#endiftfputs(_(""creating collations ... ""), stdout);tfflush(stdout);#if defined(HAVE_LOCALE_T) && !defined(WIN32)tsnprintf(cmd, sizeof(cmd),ttt """"%s"" %s template1 >%s"",ttt backend_exec, backend_options,ttt DEVNULL);tlocale_a_handle = popen_check(""locale -a"", ""r"");tif (!locale_a_handle)ttreturn;ttttt tPG_CMD_OPEN;tPG_CMD_PUTS(""CREATE TEMP TABLE tmp_pg_collation ( ""tttt""tcollname name, ""tttt""tlocale name, ""tttt""tencoding int) WITHOUT OIDS;"");twhile (fgets(localebuf, sizeof(localebuf), locale_a_handle))t{ttsize_tttlen;ttinttttenc;ttboolttskip;ttchart   *quoted_locale;ttcharttalias[NAMEDATALEN];ttlen = strlen(localebuf);ttif (len == 0 || localebuf[len - 1] != '')tt{tttif (debug)ttttfprintf(stderr, _(""%s: locale name too long, skipped: ""%s""""),ttttttprogname, localebuf);tttcontinue;tt}ttlocalebuf[len - 1] = '0';tt ttskip = false;ttfor (i = 0; i < len; i++)tt{tttif (IS_HIGHBIT_SET(localebuf[i]))ttt{ttttskip = true;ttttbreak;ttt}tt}ttif (skip)tt{tttif (debug)ttttfprintf(stderr, _(""%s: locale name has non-ASCII characters, skipped: ""%s""""),ttttttprogname, localebuf);tttcontinue;tt}ttenc = pg_get_encoding_from_locale(localebuf, debug);ttif (enc < 0)tt{ttt tttcontinue;tt}ttif (!PG_VALID_BE_ENCODING(enc))tttcontinue;ttt ttif (enc == PG_SQL_ASCII)tttcontinue;ttt ttcount++;ttquoted_locale = escape_quotes(localebuf);ttPG_CMD_PRINTF3(""INSERT INTO tmp_pg_collation VALUES (E'%s', E'%s', %d);"",ttttt   quoted_locale, quoted_locale, enc);tt ttif (normalize_locale_name(alias, localebuf))tt{tttchart   *quoted_alias = escape_quotes(alias);tttPG_CMD_PRINTF3(""INSERT INTO tmp_pg_collation VALUES (E'%s', E'%s', %d);"",tttttt   quoted_alias, quoted_locale, enc);tttfree(quoted_alias);tt}ttfree(quoted_locale);t}t tPG_CMD_PRINTF1(""INSERT INTO tmp_pg_collation VALUES ('ucs_basic', 'C', %d);"", PG_UTF8);t tPG_CMD_PUTS(""INSERT INTO pg_collation (collname, collnamespace, collowner, collencoding, collcollate, collctype) ""tttt"" SELECT DISTINCT ON (collname, encoding)""tttt""   collname, ""tttt""   (SELECT oid FROM pg_namespace WHERE nspname = 'pg_catalog') AS collnamespace, ""tttt""   (SELECT relowner FROM pg_class WHERE relname = 'pg_collation') AS collowner, ""tttt""   encoding, locale, locale ""tttt""  FROM tmp_pg_collation""tttt""  WHERE NOT EXISTS (SELECT 1 FROM pg_collation WHERE collname = tmp_pg_collation.collname)""t   ""  ORDER BY collname, encoding, (collname = locale) DESC, locale;"");tpclose(locale_a_handle);tPG_CMD_CLOSE;tcheck_ok();tif (count == 0 && !debug)t{ttprintf(_(""No usable system locales were found.""));ttprintf(_(""Use the option ""--debug"" to see details.""));t}#elsettttttt tprintf(_(""not supported on this platform""));tfflush(stdout);#endif    }",2,"cwe119,cwe120"
"gli_set_zcolors(stream_t *str, glui32 fg, glui32 bg)r{r    if (!str || !str->writable)r        return;rr    if (!gli_conf_stylehint)r        return;rr    unsigned char fore[3];r    fore[0] = (fg >> 16) & 0xff;r    fore[1] = (fg >> 8) & 0xff;r    fore[2] = (fg) & 0xff;rr    unsigned char back[3];r    back[0] = (bg >> 16) & 0xff;r    back[1] = (bg >> 8) & 0xff;r    back[2] = (bg) & 0xff;rr    switch (str->type)r    {r        case strtype_Window:r            if (fg != zcolor_Transparent && fg != zcolor_Cursor)r            {r                if (fg == zcolor_Default)r                {r                    str->win->attr.fgset = 0;r                    str->win->attr.fgcolor = 0;r                    gli_override_fg_set = 0;r                    gli_override_fg_val = 0;r                    memcpy(gli_more_color, gli_more_save, 3);r                    memcpy(gli_caret_color, gli_caret_save, 3);r                    memcpy(gli_link_color, gli_link_save, 3);r                }r                else if (fg != zcolor_Current)r                {r                    str->win->attr.fgset = 1;r                    str->win->attr.fgcolor = fg;r                    gli_override_fg_set = 1;r                    gli_override_fg_val = fg;r                    memcpy(gli_more_color, fore, 3);r                    memcpy(gli_caret_color, fore, 3);r                    memcpy(gli_link_color, fore, 3);r                }r            }rr            if (bg != zcolor_Transparent && bg != zcolor_Cursor)r            {r                if (bg == zcolor_Default)r                {r                    str->win->attr.bgset = 0;r                    str->win->attr.bgcolor = 0;r                    gli_override_bg_set = 0;r                    gli_override_bg_val = 0;r                    memcpy(gli_window_color, gli_window_save, 3);r                    memcpy(gli_border_color, gli_border_save, 3);r                }r                else if (bg != zcolor_Current)r                {r                    str->win->attr.bgset = 1;r                    str->win->attr.bgcolor = bg;r                    gli_override_bg_set = 1;r                    gli_override_bg_val = bg;r                    memcpy(gli_window_color, back, 3);r                    memcpy(gli_border_color, back, 3);r                }r            }rr            if (fg == zcolor_Default && bg == zcolor_Default)r                gli_override_reverse = 0;r            elser                gli_override_reverse = 1;rr            if (str->win->echostr)r                gli_set_zcolors(str->win->echostr, fg, bg);r            break;r    }rr    gli_force_redraw = 1;r}",2,"cwe119,cwe120"
"mtip_dump_identify(struct mtip_port *port){tsector_t sectors;tunsigned short revid;tchar cbuf[42];tif (!port->identify_valid)ttreturn;tstrlcpy(cbuf, (char *)(port->identify+10), 21);tdev_info(&port->dd->pdev->dev,tt""Serial No.: %s"", cbuf);tstrlcpy(cbuf, (char *)(port->identify+23), 9);tdev_info(&port->dd->pdev->dev,tt""Firmware Ver.: %s"", cbuf);tstrlcpy(cbuf, (char *)(port->identify+27), 41);tdev_info(&port->dd->pdev->dev, ""Model: %s"", cbuf);tdev_info(&port->dd->pdev->dev, ""Security: %04x %s"",ttport->identify[128],ttport->identify[128] & 0x4 ? ""(LOCKED)"" : """");tif (mtip_hw_get_capacity(port->dd, &sectors))ttdev_info(&port->dd->pdev->dev,ttt""Capacity: %llu sectors (%llu MB)"",ttt (u64)sectors,ttt ((u64)sectors) * ATA_SECT_SIZE >> 20);tpci_read_config_word(port->dd->pdev, PCI_REVISION_ID, &revid);tswitch (revid & 0xFF) {tcase 0x1:ttstrlcpy(cbuf, ""A0"", 3);ttbreak;tcase 0x3:ttstrlcpy(cbuf, ""A2"", 3);ttbreak;tdefault:ttstrlcpy(cbuf, ""?"", 2);ttbreak;t}tdev_info(&port->dd->pdev->dev,tt""Card Type: %s"", cbuf);}",2,"cwe119,cwe120"
"pgtypes_fmt_replace(union un_fmt_comb replace_val, int replace_type, char **output, int *pstr_len){t tintttti = 0;tswitch (replace_type)t{ttcase PGTYPES_TYPE_NOTHING:tttbreak;ttcase PGTYPES_TYPE_STRING_CONSTANT:ttcase PGTYPES_TYPE_STRING_MALLOCED:ttti = strlen(replace_val.str_val);tttif (i + 1 <= *pstr_len)ttt{tttt ttttstrncpy(*output, replace_val.str_val, i + 1);tttt*pstr_len -= i;tttt*output += i;ttttif (replace_type == PGTYPES_TYPE_STRING_MALLOCED)tttttfree(replace_val.str_val);ttttreturn 0;ttt}tttelsettttreturn -1;tttbreak;ttcase PGTYPES_TYPE_CHAR:tttif (*pstr_len >= 2)ttt{tttt(*output)[0] = replace_val.char_val;tttt(*output)[1] = '0';tttt(*pstr_len)--;tttt(*output)++;ttttreturn 0;ttt}tttelsettttreturn -1;tttbreak;ttcase PGTYPES_TYPE_DOUBLE_NF:ttcase PGTYPES_TYPE_INT64:ttcase PGTYPES_TYPE_UINT:ttcase PGTYPES_TYPE_UINT_2_LZ:ttcase PGTYPES_TYPE_UINT_2_LS:ttcase PGTYPES_TYPE_UINT_3_LZ:ttcase PGTYPES_TYPE_UINT_4_LZ:ttt{ttttchart   *t = pgtypes_alloc(PGTYPES_FMT_NUM_MAX_DIGITS);ttttif (!t)tttttreturn ENOMEM;ttttswitch (replace_type)tttt{tttttcase PGTYPES_TYPE_DOUBLE_NF:tttttti = snprintf(t, PGTYPES_FMT_NUM_MAX_DIGITS,ttttttttt ""%0.0g"", replace_val.double_val);ttttttbreak;tttttcase PGTYPES_TYPE_INT64:tttttti = snprintf(t, PGTYPES_FMT_NUM_MAX_DIGITS,ttttttttt INT64_FORMAT, replace_val.int64_val);ttttttbreak;tttttcase PGTYPES_TYPE_UINT:tttttti = snprintf(t, PGTYPES_FMT_NUM_MAX_DIGITS,ttttttttt ""%u"", replace_val.uint_val);ttttttbreak;tttttcase PGTYPES_TYPE_UINT_2_LZ:tttttti = snprintf(t, PGTYPES_FMT_NUM_MAX_DIGITS,ttttttttt ""%02u"", replace_val.uint_val);ttttttbreak;tttttcase PGTYPES_TYPE_UINT_2_LS:tttttti = snprintf(t, PGTYPES_FMT_NUM_MAX_DIGITS,ttttttttt ""%2u"", replace_val.uint_val);ttttttbreak;tttttcase PGTYPES_TYPE_UINT_3_LZ:tttttti = snprintf(t, PGTYPES_FMT_NUM_MAX_DIGITS,ttttttttt ""%03u"", replace_val.uint_val);ttttttbreak;tttttcase PGTYPES_TYPE_UINT_4_LZ:tttttti = snprintf(t, PGTYPES_FMT_NUM_MAX_DIGITS,ttttttttt ""%04u"", replace_val.uint_val);ttttttbreak;tttt}ttttif (i < 0)tttt{tttttfree(t);tttttreturn -1;tttt}tttti = strlen(t);tttt*pstr_len -= i;tttt ttttif (*pstr_len <= 0)tttt{tttttfree(t);tttttreturn -1;tttt}ttttstrcpy(*output, t);tttt*output += i;ttttfree(t);ttt}tttbreak;ttdefault:tttbreak;t}treturn 0;}",2,"cwe120,cweother"
"restore(void){#ifdef HAVE_GLK  frefid_t saveFileRef;  strid_t saveFile;  saveFileRef = glk_fileref_create_by_prompt(fileusage_SavedGame, filemode_Read, 0);  if (saveFileRef == NULL) return;  saveFile = glk_stream_open_file(saveFileRef, filemode_Read, 0);  if (saveFile == NULL) return;#else  char str[1000];  FILE *saveFile;  current.location = where(HERO, TRUE);     if (saveFileName[0] == '0') {    strcpy(saveFileName, adventureName);    strcat(saveFileName, "".sav"");  }  printMessage(M_RESTOREFROM);  sprintf(str, ""(%s) : "", saveFileName);  output(str);#ifdef USE_READLINE  readline(str);#else  gets(str);#endif  col = 1;  if (str[0] == '0') {    strcpy(str, saveFileName);  }  if ((saveFile = fopen(str, READ_MODE)) == NULL)    error(M_SAVEMISSING);  strcpy(saveFileName, str);           #endif  restoreGame(saveFile);  fclose(saveFile);}",3,"cwe119,cwe120,cweother"
"sge_execv(char *path,     char *argv[],char *expath,   int close_stdin  ) {   const char *value;    char *taskname = NULL;   lListElem *task = NULL;   int i = 0;   int narg_resreq = 0;   int narg_argv = 0;   int newargv_size = 0;   char **argv_iter = NULL;   char **newargv = NULL;       char qrsh_path[2048];       if (!strchr(expath, '/')) {      taskname = expath;   }   if (mode_verbose) {      fprintf(stderr, ""sge_execv(path = %s, taskname = %s, expath = %s, close_stdin = %d)"",          path, taskname?taskname:""<no remote execution>"", expath, close_stdin);   }   if (!mode_remote ||          !taskname ||         !(task=lGetElemStr(task_config, CF_name, taskname))) {      if (mode_verbose)         fprintf(stderr, ""local execution of ""SFQ"""", expath);      return execv(path, argv);   }     if ((value = lGetString(task, CF_value))) {      narg_resreq = sge_quick_count_num_args (value);   }   for (argv_iter=argv; argv_iter[0] != NULL; argv_iter++) {      narg_argv++;    }      newargv_size =      1 +                                       (close_stdin?1:0) +                       (mode_verbose?1:0) +                      2 +                                       narg_resreq +                             narg_argv +                               1;                                     newargv = (char **)malloc(sizeof(char *) * newargv_size);   memset(newargv, 0, newargv_size);       i = 0;   newargv[i++] = strdup(""qrsh"");   if (close_stdin)       newargv[i++] = strdup(""-nostdin"");   if (mode_verbose)       newargv[i++] = strdup(""-verbose"");   if (mode_immediate) {      newargv[i++] = strdup(""-now"");      newargv[i++] = strdup(""y"");   } else {      newargv[i++] = strdup(""-now"");      newargv[i++] = strdup(""n"");   }       if (value) {      sge_parse_args (value, &newargv[i]);      i += narg_resreq;   }t        for (argv_iter=argv; argv_iter[0] != NULL; argv_iter++) {      newargv[i++] = argv_iter[0];   }   newargv[i] = NULL;         sprintf(qrsh_path, ""%s/bin/%s/qrsh"", sge_get_root_dir(1, NULL, 0, 1), sge_get_arch());   return execvp(qrsh_path, newargv);}",4,"cwe119,cwe120,cwe476,cweother"
"file_close(struct archive *a, void *client_data){tstruct read_file_data *mine = (struct read_file_data *)client_data;t(void)a;  t tif (mine->fd >= 0) {tt ttif (!S_ISREG(mine->st_mode)tt    && !S_ISCHR(mine->st_mode)tt    && !S_ISBLK(mine->st_mode)) {tttssize_t bytesRead;tttdo {ttttbytesRead = read(mine->fd, mine->buffer,tttt    mine->block_size);ttt} while (bytesRead > 0);tt}tt ttif (mine->filename_type != FNT_STDIN)tttclose(mine->fd);t}tfree(mine->buffer);tfree(mine);treturn (ARCHIVE_OK);}",2,"cwe120,cweother"
"FC_Login(CK_SESSION_HANDLE hSession, CK_USER_TYPE userType,tttt    CK_CHAR_PTR pPin, CK_ULONG usPinLen) {    CK_RV rv;    PRBool successful;    if (sftk_fatalError) return CKR_DEVICE_ERROR;    rv = NSC_Login(hSession,userType,pPin,usPinLen);    successful = (rv == CKR_OK) || (rv == CKR_USER_ALREADY_LOGGED_IN);    if (successful)tisLoggedIn = PR_TRUE;    if (sftk_audit_enabled) {tchar msg[128];tNSSAuditSeverity severity;tseverity = successful ? NSS_AUDIT_INFO : NSS_AUDIT_ERROR;tPR_snprintf(msg,sizeof msg,tt    ""C_Login(hSession=0x%08lX, userType=%lu)=0x%08lX"",tt    (PRUint32)hSession,(PRUint32)userType,(PRUint32)rv);tsftk_LogAuditMessage(severity, NSS_AUDIT_LOGIN, msg);    }    return rv;}",2,"cwe119,cwe120"
"ip6_sa2str(const struct sockaddr_in6 *sa6, char *buf,t   size_t bufsiz, int flags){#ifdef USE_IFNAMELINKIDtunsigned int ifindex = (unsigned int)sa6->sin6_scope_id;tconst struct in6_addr *a6 = &sa6->sin6_addr;#endiftchar tmp[64];#ifdef NI_NUMERICSCOPEtif (flags & NI_NUMERICSCOPE) {ttsprintf(tmp, ""%u"", sa6->sin6_scope_id);ttif (bufsiz != 0U) {tttstrncpy(buf, tmp, bufsiz - 1);tttbuf[bufsiz - 1] = '0';tt}ttreturn(strlen(tmp));t}#endif#ifdef USE_IFNAMELINKIDt t tif ((IN6_IS_ADDR_LINKLOCAL(a6) || IN6_IS_ADDR_MC_LINKLOCAL(a6)) &&t    bufsiz >= IF_NAMESIZE) {ttchar *p = if_indextoname(ifindex, buf);ttif (p) {tttreturn(strlen(p));tt}t}#endift tsprintf(tmp, ""%u"", sa6->sin6_scope_id);tif (bufsiz != 0U) {ttstrncpy(buf, tmp, bufsiz - 1);ttbuf[bufsiz - 1] = '0';t}treturn(strlen(tmp));}",2,"cwe119,cwe120"
"make_challenge_path(char *path){tint result;twhile(1) {ttsprintf(path, ""%s/challenge.%d.%d"", challenge_dir, (int) getpid(), rand());ttresult = unlink(path);ttif(result == 0) {tttbreak;tt} else {tttif(errno == ENOENT) {ttttbreak;ttt} else {ttttdebug(D_AUTH, ""unix: %s is in use, still trying..."");ttttcontinue;ttt}tt}t}tdebug(D_AUTH, ""unix: challenge path is %s"", path);}",3,"cwe119,cwe120,cweother"
"dumpit(ap_filter_t *f, apr_bucket *b, dumpio_conf_t *ptr){    conn_rec *c = f->c;    ap_log_cerror(APLOG_MARK, APLOG_TRACE7, 0, c,                  ""mod_dumpio:  %s (%s-%s): %"" APR_SIZE_T_FMT "" bytes"",                  f->frec->name,                  (APR_BUCKET_IS_METADATA(b)) ? ""metadata"" : ""data"",                  b->type->name,                  b->length) ;    if (!(APR_BUCKET_IS_METADATA(b)))    {#if APR_CHARSET_EBCDIC        char xlatebuf[dumpio_MAX_STRING_LEN + 1];#endif        const char *buf;        apr_size_t nbytes;        apr_status_t rv = apr_bucket_read(b, &buf, &nbytes, APR_BLOCK_READ);        if (rv == APR_SUCCESS)        {            while (nbytes)            {                apr_size_t logbytes = nbytes;                if (logbytes > dumpio_MAX_STRING_LEN)                    logbytes = dumpio_MAX_STRING_LEN;                nbytes -= logbytes;#if APR_CHARSET_EBCDIC                memcpy(xlatebuf, buf, logbytes);                ap_xlate_proto_from_ascii(xlatebuf, logbytes);                xlatebuf[logbytes] = '0';                ap_log_cerror(APLOG_MARK, APLOG_TRACE7, 0, c,                              ""mod_dumpio:  %s (%s-%s): %s"", f->frec->name,                              (APR_BUCKET_IS_METADATA(b)) ? ""metadata"" : ""data"",                              b->type->name, xlatebuf);#else                                 ap_log_cerror(APLOG_MARK, APLOG_TRACE7, 0, c,                              ""mod_dumpio:  %s (%s-%s): %.*s"", f->frec->name,                              (APR_BUCKET_IS_METADATA(b)) ? ""metadata"" : ""data"",                              b->type->name, (int)logbytes, buf);#endif                buf += logbytes;            }        }        else {            ap_log_cerror(APLOG_MARK, APLOG_TRACE7, rv, c,                          ""mod_dumpio:  %s (%s-%s): %s"", f->frec->name,                          (APR_BUCKET_IS_METADATA(b)) ? ""metadata"" : ""data"",                          b->type->name, ""error reading data"");        }    }}",2,"cwe119,cwe120"
"match_explicit(struct ref *src, struct ref *dst,ttt  struct ref ***dst_tail,ttt  struct refspec *rs,ttt  int errs){tstruct ref *matched_src, *matched_dst;tconst char *dst_value = rs->dst;tchar *dst_guess;tif (rs->pattern)ttreturn errs;tmatched_src = matched_dst = NULL;tswitch (count_refspec_match(rs->src, src, &matched_src)) {tcase 1:ttbreak;tcase 0:tt ttmatched_src = try_explicit_object_name(rs->src);ttif (!matched_src)ttterror(""src refspec %s does not match any."", rs->src);ttbreak;tdefault:ttmatched_src = NULL;tterror(""src refspec %s matches more than one."", rs->src);ttbreak;t}tif (!matched_src)tterrs = 1;tif (!dst_value) {ttunsigned char sha1[20];ttint flag;ttif (!matched_src)tttreturn errs;ttdst_value = resolve_ref(matched_src->name, sha1, 1, &flag);ttif (!dst_value ||tt    ((flag & REF_ISSYMREF) &&tt     prefixcmp(dst_value, ""refs/heads/"")))tttdie(""%s cannot be resolved to branch."",ttt    matched_src->name);t}tswitch (count_refspec_match(dst_value, dst, &matched_dst)) {tcase 1:ttbreak;tcase 0:ttif (!memcmp(dst_value, ""refs/"", 5))tttmatched_dst = make_linked_ref(dst_value, dst_tail);ttelse if((dst_guess = guess_ref(dst_value, matched_src)))tttmatched_dst = make_linked_ref(dst_guess, dst_tail);ttelsettterror(""unable to push to unqualified destination: %s""ttt      ""The destination refspec neither matches an ""ttt      ""existing ref on the remote nor""ttt      ""begins with refs/, and we are unable to ""ttt      ""guess a prefix based on the source ref."",ttt      dst_value);ttbreak;tdefault:ttmatched_dst = NULL;tterror(""dst refspec %s matches more than one."",tt      dst_value);ttbreak;t}tif (errs || !matched_dst)ttreturn 1;tif (matched_dst->peer_ref) {tterrs = 1;tterror(""dst ref %s receives from more than one src."",tt      matched_dst->name);t}telse {ttmatched_dst->peer_ref = matched_src;ttmatched_dst->force = rs->force;t}treturn errs;}",2,"cwe119,cwe120"
"_Com_DPrintf (const char *fmt, ...){tva_listttargptr;tcharttmsg[MAXPRINTMSG];tttif (!developer->integer)ttreturn;ttt tva_start (argptr,fmt);tvsnprintf(msg, MAXPRINTMSG, fmt, argptr);tva_end (argptr);ttCom_Printf (""%s"", msg);}",3,"cwe119,cwe120,cweother"
"am_aux_append(bam1_t *b, const char tag[2], char type, int len, uint8_t *data){tint ori_len = b->data_len;tb->data_len += 3 + len;tb->l_aux += 3 + len;tif (b->m_data < b->data_len) {ttb->m_data = b->data_len;ttkroundup32(b->m_data);ttb->data = (uint8_t*)realloc(b->data, b->m_data);t}tb->data[ori_len] = tag[0]; b->data[ori_len + 1] = tag[1];tb->data[ori_len + 2] = type;tmemcpy(b->data + ori_len + 3, data, len);}",2,"cwe119,cwe120"
"transmit_header(int sockfd, char *printer_name){t tchar buffer[64];tsprintf(buffer, ""%c%s"", 2, printer_name);talarm(TIME_OUT_LENGTH);tif  (send(sockfd, buffer, (unsigned int)strlen(buffer), 0) < 0)ttreturn -TCP_SEND_ERROR;t talarm(TIME_OUT_LENGTH);tif  (recv(sockfd, buffer, sizeof(buffer), 0) < 0)ttreturn -TCP_RECV_ERROR;talarm(0);t tif  (buffer[0])ttreturn buffer[0];treturn 0;}",2,"cwe119,cwe120"
"fusion_arena_exit (FusionArena   *arena,                   ArenaExitFunc  shutdown,                   ArenaExitFunc  leave,                   void          *ctx,                   bool           emergency,                   int           *ret_error){     int error = 0;     D_ASSERT( shutdown != NULL );           error = shutdown( arena, ctx, emergency );           if (ret_error)          *ret_error = error;     return DR_OK;}",2,"cwe119,cwe120"
"rule_matches(const char *fname, filter_rule *ex, int name_is_dir){tint slash_handling, str_cnt = 0, anchored_match = 0;tint ret_match = ex->rflags & FILTRULE_NEGATE ? 0 : 1;tchar *p, *pattern = ex->pattern;tconst char *strings[16];  tconst char *name = fname + (*fname == '/');tif (!*name)ttreturn 0;tif (!ex->u.slash_cnt && !(ex->rflags & FILTRULE_WILD2)) {tt ttif ((p = strrchr(name,'/')) != NULL)tttname = p+1;t} else if (ex->rflags & FILTRULE_ABS_PATH && *fname != '/'t    && curr_dir_len > module_dirlen + 1) {tt ttstrings[str_cnt++] = curr_dir + module_dirlen + 1;ttstrings[str_cnt++] = ""/"";t} else if (ex->rflags & FILTRULE_WILD2_PREFIX && *fname != '/') {tt ttstrings[str_cnt++] = ""/"";t}tstrings[str_cnt++] = name;tif (name_is_dir) {tt ttif (ex->rflags & FILTRULE_WILD3_SUFFIX)tttstrings[str_cnt++] = ""/"";t} else if (ex->rflags & FILTRULE_DIRECTORY)ttreturn !ret_match;tstrings[str_cnt] = NULL;tif (*pattern == '/') {ttanchored_match = 1;ttpattern++;t}tif (!anchored_match && ex->u.slash_cntt    && !(ex->rflags & FILTRULE_WILD2)) {tt ttslash_handling = ex->u.slash_cnt + 1;t} else if (!anchored_match && !(ex->rflags & FILTRULE_WILD2_PREFIX)tttt   && ex->rflags & FILTRULE_WILD2) {tt ttslash_handling = -1;t} else {tt ttslash_handling = 0;t}tif (ex->rflags & FILTRULE_WILD) {ttif (wildmatch_array(pattern, strings, slash_handling))tttreturn ret_match;t} else if (str_cnt > 1) {ttif (litmatch_array(pattern, strings, slash_handling))tttreturn ret_match;t} else if (anchored_match) {ttif (strcmp(name, pattern) == 0)tttreturn ret_match;t} else {ttint l1 = strlen(name);ttint l2 = strlen(pattern);ttif (l2 <= l1 &&tt    strcmp(name+(l1-l2),pattern) == 0 &&tt    (l1==l2 || name[l1-(l2+1)] == '/')) {tttreturn ret_match;tt}t}treturn !ret_match;}",2,"cwe119,cwe120"
"odbc_release_obj2(struct odbc_obj *obj, struct odbc_txn_frame *tx){tSQLINTEGER nativeerror=0, numfields=0;tSQLSMALLINT diagbytes=0, i;tunsigned char state[10], diagnostic[256];tast_debug(2, ""odbc_release_obj2(%p) called (obj->txf = %p)"", obj, obj->txf);tif (tx) {ttast_debug(1, ""called on a transactional handle with %s"", tx->forcecommit ? ""COMMIT"" : ""ROLLBACK"");ttif (SQLEndTran(SQL_HANDLE_DBC, obj->con, tx->forcecommit ? SQL_COMMIT : SQL_ROLLBACK) == SQL_ERROR) {ttt tttSQLGetDiagField(SQL_HANDLE_DBC, obj->con, 1, SQL_DIAG_NUMBER, &numfields, SQL_IS_INTEGER, &diagbytes);tttfor (i = 0; i < numfields; i++) {ttttSQLGetDiagRec(SQL_HANDLE_DBC, obj->con, i + 1, state, &nativeerror, diagnostic, sizeof(diagnostic), &diagbytes);ttttast_log(LOG_WARNING, ""SQLEndTran returned an error: %s: %s"", state, diagnostic);ttttif (!strcmp((char *)state, ""25S02"") || !strcmp((char *)state, ""08007"")) {ttttt tttttSQLEndTran(SQL_HANDLE_DBC, obj->con, SQL_ROLLBACK);tttt}ttttif (i > 10) {tttttast_log(LOG_WARNING, ""Oh, that was good.  There are really %d diagnostics?"", (int)numfields);tttttbreak;tttt}ttt}tt}tt ttif (SQLSetConnectAttr(obj->con, SQL_ATTR_AUTOCOMMIT, (void *)SQL_AUTOCOMMIT_ON, 0) == SQL_ERROR) {tttSQLGetDiagField(SQL_HANDLE_DBC, obj->con, 1, SQL_DIAG_NUMBER, &numfields, SQL_IS_INTEGER, &diagbytes);tttfor (i = 0; i < numfields; i++) {ttttSQLGetDiagRec(SQL_HANDLE_DBC, obj->con, i + 1, state, &nativeerror, diagnostic, sizeof(diagnostic), &diagbytes);ttttast_log(LOG_WARNING, ""SetConnectAttr (Autocommit) returned an error: %s: %s"", state, diagnostic);ttttif (i > 10) {tttttast_log(LOG_WARNING, ""Oh, that was good.  There are really %d diagnostics?"", (int)numfields);tttttbreak;tttt}ttt}tt}t}#ifdef DEBUG_THREADStobj->file[0] = '0';tobj->function[0] = '0';tobj->lineno = 0;#endift tobj->used = 0;tif (obj->txf) {tt ttobj->txf->obj = NULL;ttobj->txf = release_transaction(obj->txf);t}tao2_ref(obj, -1);}",3,"cwe119,cwe120,cwe469"
"string_to_uuid(const char *source, pg_uuid_t *uuid){tconst char *src = source;tboolttbraces = false;tintttti;tif (src[0] == '{')t{ttsrc++;ttbraces = true;t}tfor (i = 0; i < UUID_LEN; i++)t{ttcharttstr_buf[3];ttif (src[0] == '0' || src[1] == '0')tttgoto syntax_error;ttmemcpy(str_buf, src, 2);ttif (!isxdigit((unsigned char) str_buf[0]) ||ttt!isxdigit((unsigned char) str_buf[1]))tttgoto syntax_error;ttstr_buf[2] = '0';ttuuid->data[i] = (unsigned char) strtoul(str_buf, NULL, 16);ttsrc += 2;ttif (src[0] == '-' && (i % 2) == 1 && i < UUID_LEN - 1)tttsrc++;t}tif (braces)t{ttif (*src != '}')tttgoto syntax_error;ttsrc++;t}tif (*src != '0')ttgoto syntax_error;treturn;syntax_error:tereport(ERROR,ttt(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),ttt errmsg(""invalid input syntax for uuid: ""%s"""",tttttsource)));}",2,"cwe119,cwe120"
"_ecore_exe_data_generic_handler(void             *data,                                Ecore_Fd_Handler *fd_handler,                                Ecore_Exe_Flags   flags){   Ecore_Exe *exe;   int child_fd;   int event_type;   exe = data;       if (flags & ECORE_EXE_PIPE_READ)   {      flags = ECORE_EXE_PIPE_READ;      event_type = ECORE_EXE_EVENT_DATA;      child_fd = exe->child_fd_read;   }   else   {      flags = ECORE_EXE_PIPE_ERROR;      event_type = ECORE_EXE_EVENT_ERROR;      child_fd = exe->child_fd_error;   }   if ((fd_handler)       && (ecore_main_fd_handler_active_get(fd_handler, ECORE_FD_READ)))   {      unsigned char *inbuf;      int inbuf_num;             if (flags & ECORE_EXE_PIPE_READ)      {         inbuf = exe->read_data_buf;         inbuf_num = exe->read_data_size;         exe->read_data_buf = NULL;         exe->read_data_size = 0;      }      else      {         inbuf = exe->error_data_buf;         inbuf_num = exe->error_data_size;         exe->error_data_buf = NULL;         exe->error_data_size = 0;      }      for (;; )      {         int num, lost_exe;         char buf[READBUFSIZ];         lost_exe = 0;         errno = 0;         if ((num = read(child_fd, buf, READBUFSIZ)) < 1)         {                           lost_exe = ((errno == EIO) ||                          (errno == EBADF) ||                          (errno == EPIPE) ||                          (errno == EINVAL) || (errno == ENOSPC));              if ((errno != EAGAIN) && (errno != EINTR))                perror(""_ecore_exe_generic_handler() read problem "");         }         if (num > 0)           {            inbuf = realloc(inbuf, inbuf_num + num);            memcpy(inbuf + inbuf_num, buf, num);            inbuf_num += num;         }         else         {              if (inbuf)            {               Ecore_Exe_Event_Data *e;                               if (flags & ECORE_EXE_PIPE_READ)               {                  exe->read_data_buf = inbuf;                  exe->read_data_size = inbuf_num;               }               else               {                  exe->error_data_buf = inbuf;                  exe->error_data_size = inbuf_num;               }               if (!(exe->flags & ECORE_EXE_PIPE_AUTO))               {                  e = ecore_exe_event_data_get(exe, flags);                  if (e)                      ecore_event_add(event_type, e,                                    _ecore_exe_event_exe_data_free,                                    NULL);               }            }            if (lost_exe)            {               if (flags & ECORE_EXE_PIPE_READ)               {                  if (exe->read_data_size)                    INF(""There are %d bytes left unsent from the dead exe %s."",                        exe->read_data_size, exe->cmd);               }               else               {                  if (exe->error_data_size)                    INF(""There are %d bytes left unsent from the dead exe %s."",                        exe->error_data_size, exe->cmd);               }                               ecore_exe_terminate(exe);            }            break;         }      }   }   return ECORE_CALLBACK_RENEW;}",3,"cwe119,cwe120,cweother"
"cgi_interpose_input( httpd_conn* hc, int wfd )    {    size_t c;    ssize_t r;    char buf[1024];    c = hc->read_idx - hc->checked_idx;    if ( c > 0 )t{tif ( httpd_write_fully( wfd, &(hc->read_buf[hc->checked_idx]), c ) != c )t    return;t}    while ( c < hc->contentlength )t{tr = read( hc->conn_fd, buf, MIN( sizeof(buf), hc->contentlength - c ) );tif ( r < 0 && ( errno == EINTR || errno == EAGAIN ) )t    {t    sleep( 1 );t    continue;t    }tif ( r <= 0 )t    return;tif ( httpd_write_fully( wfd, buf, r ) != r )t    return;tc += r;t}    post_post_garbage_hack( hc );    }",3,"cwe119,cwe120,cweother"
"xlator_option_validate_addr_list (xlator_t *xl, const char *key,                                  const char *value, volume_option_t *opt,                                  char **op_errstr){        int          ret = -1;        char         *dup_val = NULL;        char         *addr_tok = NULL;        char         *save_ptr = NULL;        char         errstr[4096] = {0,};        dup_val = gf_strdup (value);        if (!dup_val)                goto out;        addr_tok = strtok_r (dup_val, "","", &save_ptr);        if (addr_tok == NULL)                goto out;        while (addr_tok) {                if (!valid_internet_address (addr_tok, _gf_true))                        goto out;                addr_tok = strtok_r (NULL, "","", &save_ptr);        }        ret = 0;out:        if (ret) {                snprintf (errstr, sizeof (errstr), ""option %s %s: '%s' is not ""                ""a valid internet-address-list"", key, value, value);                gf_log (xl->name, GF_LOG_ERROR, ""%s"", errstr);                if (op_errstr)                        *op_errstr = gf_strdup (errstr);        }        GF_FREE (dup_val);        return ret;}",2,"cwe119,cwe120"
"write_short (FILE *file, short s){    unsigned char   file_short[2];    file_short[0] = (s & (unsigned)0xff00) >> 8;    file_short[1] = s & 0xff;    if (fwrite ((char *) file_short, (int) sizeof (file_short), 1, file) != 1)treturn 0;    return 1;}",2,"cwe119,cwe120"
"pop_iostack(void){  Iostack n;  fflush(IOSTREAM);  if (pipe) {    if (pclose(IOSTREAM)) {           }  } else {    fclose(IOSTREAM);  }  n = last(stack);  if (n->stream == NULL) {    n->stream = fopen(n->filename, ""r"");    if (n->stream == NULL) {      fprintf(stderr, ""Error: cannot open file ""%s"""", n->filename);      exit(1);    }  }  IOSTREAM = n->stream;  strcpy(FILENAME, n->filename);  free(n->filename);  pipe = n->pipe;  line = n->line;  oldchar = n->oldchar;  oldcharvalid = n->oldcharvalid;  delete_item((List)n);  free_node((List)n, (List)stack);}",2,"cwe469,cweother"
"IPString2KeyDigest(char *ipv4,char *result){ CF_DB *dbp;  CF_DBC *dbcp;  char *key;  char name[CF_BUFSIZE];  void *value;  struct CfKeyHostSeen entry;  int ksize,vsize;  unsigned char digest[EVP_MAX_MD_SIZE+1];result[0] = '0';if (strcmp(ipv4,""127.0.0.1"") == 0 || strcmp(ipv4,""::1"") == 0 || strcmp(ipv4,VIPADDRESS) == 0)   {   if (PUBKEY)      {      HashPubKey(PUBKEY,digest,CF_DEFAULT_DIGEST);      snprintf(result,CF_MAXVARSIZE,""%s"",HashPrint(CF_DEFAULT_DIGEST,digest));      }   return;   }snprintf(name,CF_BUFSIZE-1,""%s/%s"",CFWORKDIR,CF_LASTDB_FILE);MapName(name);if (!OpenDB(name,&dbp))   {   return;   }if (!NewDBCursor(dbp,&dbcp))   {   CfOut(cf_inform,"""","" !! Unable to scan last-seen database"");   CloseDB(dbp);   return;   }  memset(&entry, 0, sizeof(entry));  while(NextDB(dbp,dbcp,&key,&ksize,&value,&vsize))   {   if (value != NULL)      {      memcpy(&entry,value,sizeof(entry));                   if (strcmp(ipv4,MapAddress((char *)entry.address)) == 0)         {         CfOut(cf_verbose,"""","" -> Matched IP %s to key %s"",ipv4,key+1);         strncpy(result,key+1,CF_MAXVARSIZE-1);         break;         }      }   }DeleteDBCursor(dbp,dbcp);CloseDB(dbp);if(EMPTY(result))   {   CfOut(cf_verbose, """", ""!! Unable to find a key for ip %s"", ipv4);   }}",2,"cwe119,cwe120"
"leaf_dump(ScmPort *out, Leaf *self, int indent,                      void (*dumper)(ScmPort*, Leaf*, int, void*), void *data){    char keybuf[BUF_SIZE];    Scm_Printf(out, ""LEAF(%s,%x) "", key_dump(LEAF_KEY(self), keybuf),               LEAF_KEY(self));    if (dumper) dumper(out, self, indent, data);    Scm_Printf(out, """");}",2,"cwe119,cwe120"
"""readtonl(FILE *fp){    int input_buffer;    while (1) {tif ((input_buffer = fgetc(fp)) == EOF) return EOF;tif (input_buffer == '') {t    return FALSE;t}    }    return TRUE;}""",2,"cwe120,cweother"
"pfnexpand(char *fn, size_t fnlen){    register char *x, *y, *z;    char *home = NULL;#ifndef _WINDOWS    struct passwd *pw;    char name[50];    if(*fn == '~'){        for(x = fn+1, y = name;t    *x != '/' && *x != '0' && y-name < sizeof(name)-1;t    *y++ = *x++)t  ;        *y = '0';        if(x == fn + 1){ttt t    if (!(home = (char *) getenv(""HOME"")))t      if ((pw = getpwuid(geteuid())) != NULL)tthome = pw->pw_dir;t}telse if(*name){tttt t    if((pw = getpwnam(name)) != NULL)t      home = pw->pw_dir;t}        if(!home || (strlen(home) + strlen(fn) >= fnlen))t  return(NULL);#else      char name[_MAX_PATH];    if(*fn == '~' && *(x = fn + 1) == '') {tif(!(home = (char *) getenv(""HOME""))t   && getenv(""HOMEDRIVE"") && getenv(""HOMEPATH""))t  snprintf(home = name, sizeof(name), ""%s%s"",tt  (char *) getenv(""HOMEDRIVE""), (char *) getenv(""HOMEPATH""));#endif  thome = fname_to_utf8(home);t tfor(z = x + strlen(x), y = fn + strlen(x) + strlen(home);t    z >= x;t    *y-- = *z--)t  ;t tfor(x = fn, y = home; *y != '0' && x-fn < fnlen; *x++ = *y++)t  ;    }    fn[fnlen-1] = '0';    return(fn);}",3,"cwe119,cwe120,cweother"
"msp_reset(struct i2c_client *client){t tstatic u8 reset_off[3] = { I2C_MSP_CONTROL, 0x80, 0x00 };tstatic u8 reset_on[3]  = { I2C_MSP_CONTROL, 0x00, 0x00 };tstatic u8 write[3]     = { I2C_MSP_DSP + 1, 0x00, 0x1e };tu8 read[2];tstruct i2c_msg reset[2] = {tt{ttt.addr = client->addr,ttt.flags = I2C_M_IGNORE_NAK,ttt.len = 3,ttt.buf = reset_offtt},tt{ttt.addr = client->addr,ttt.flags = I2C_M_IGNORE_NAK,ttt.len = 3,ttt.buf = reset_ontt},t};tstruct i2c_msg test[2] = {tt{ttt.addr = client->addr,ttt.len = 3,ttt.buf = writett},tt{ttt.addr = client->addr,ttt.flags = I2C_M_RD,ttt.len = 2,ttt.buf = readtt},t};tv4l_dbg(3, msp_debug, client, ""msp_reset"");tif (i2c_transfer(client->adapter, &reset[0], 1) != 1 ||t    i2c_transfer(client->adapter, &reset[1], 1) != 1 ||t    i2c_transfer(client->adapter, test, 2) != 2) {ttv4l_err(client, ""chip reset failed"");ttreturn -1;t}treturn 0;}",2,"cwe120,cweother"
"pycann_load_file(const char *path, unsigned int num_threads) {  pycann_t *net;  FILE *fd;  unsigned int i;  unsigned int *mod_neurons;  struct pycann_file_header header;     fd = fopen(path, ""rb"");  if (fd==NULL) {    pycann_set_error(""Can't open file (for reading): %s"", path);    return NULL;  }     fread(&header, sizeof(header), 1, fd);  if (memcmp(header.magic, PYCANN_FILE_MAGIC, PYCANN_FILE_MAGIC_LENGTH)!=0) {    pycann_set_error(""Invalid file signature: %s"", path);    fclose(fd);    return NULL;  }     net = pycann_new(header.size, header.num_inputs, header.num_outputs, num_threads);  if (net==NULL) {    fclose(fd);    return NULL;  }  net->learning_rate = header.learning_rate;     fread(net->gammas, 4*sizeof(pycann_float_t), header.size, fd);  fread(net->weights, sizeof(pycann_float_t), header.size*header.size, fd);  fread(net->thresholds, sizeof(pycann_float_t), header.size, fd);  fread(net->activations, sizeof(pycann_float_t), header.size, fd);  fread(net->mod_weights, sizeof(pycann_float_t), header.size, fd);  fread(net->inputs, sizeof(pycann_float_t), header.num_inputs, fd);  fread(net->activation_functions, sizeof(pycann_activation_function_t), net->size, fd);     mod_neurons = malloc(sizeof(unsigned int)*header.size);  fread(mod_neurons, sizeof(unsigned int), header.size, fd);  for (i=0; i<header.size; i++) {    net->mod_neurons[i] = net->activations+mod_neurons[i];  }  free(mod_neurons);     fclose(fd);  return net;}",2,"cwe120,cweother"
"splitToLines(char *buffer, int* lineCount){tint allocatedLineCount = getLineCount(buffer);tchar** lines = (char**)malloc(allocatedLineCount * sizeof(char*));tif(lines == NULL)t{ttfree(lines);ttreturn NULL;t}ttlines[0] = buffer;t*lineCount = 1;tchar* lastTokenFound = strpbrk(buffer, """");twhile(lastTokenFound != NULL && (*lineCount) < allocatedLineCount)t{ttlines[*lineCount] = lastTokenFound + 1;tttt ) with 0tt*(lines[*lineCount] - 1) = '0';ttttlastTokenFound = strpbrk(lines[*lineCount], """");tttt(*lineCount)++;t}tt t(*lineCount)--;ttreturn lines;}",2,"cwe120,cweother"
"jtagmkI_set_devdescr(PROGRAMMER * pgm, AVRPART * p){  unsigned char resp[2];  LNODEID ln;  AVRMEM * m;  struct {    unsigned char cmd;    struct device_descriptor dd;  } sendbuf;  memset(&sendbuf, 0, sizeof sendbuf);  sendbuf.cmd = CMD_SET_DEVICE_DESCRIPTOR;  sendbuf.dd.ucSPMCRAddress = p->spmcr;  sendbuf.dd.ucRAMPZAddress = p->rampz;  sendbuf.dd.ucIDRAddress = p->idr;  for (ln = lfirst(p->mem); ln; ln = lnext(ln)) {    m = ldata(ln);    if (strcmp(m->desc, ""flash"") == 0) {      PDATA(pgm)->flash_pagesize = m->page_size;      u16_to_b2(sendbuf.dd.uiFlashPageSize, PDATA(pgm)->flash_pagesize);    } else if (strcmp(m->desc, ""eeprom"") == 0) {      sendbuf.dd.ucEepromPageSize = PDATA(pgm)->eeprom_pagesize = m->page_size;    }  }  if (verbose >= 2)    fprintf(stderr, ""%s: jtagmkI_set_devdescr(): ""t    ""Sending set device descriptor command: "",t    progname);  jtagmkI_send(pgm, (unsigned char *)&sendbuf, sizeof(sendbuf));  jtagmkI_recv(pgm, resp, 2);  if (resp[0] != RESP_OK) {    if (verbose >= 2)      putc('', stderr);    fprintf(stderr,t    ""%s: jtagmkI_set_devdescr(): ""t    ""timeout/error communicating with programmer (resp %c)"",t    progname, resp[0]);  } else {    if (verbose == 2)      fprintf(stderr, ""OK"");  }}",2,"cwe119,cwe120"
"adsi_login(struct ast_channel *chan){tunsigned char buf[256];tint bytes = 0;tunsigned char keys[8];tint x;tif (!ast_adsi_available(chan))ttreturn;tfor (x = 0; x < 8; x++)ttkeys[x] = 0;t tkeys[3] = ADSI_KEY_APPS + 3;tbytes += adsi_logo(buf + bytes);tbytes += ast_adsi_display(buf + bytes, ADSI_COMM_PAGE, 3, ADSI_JUST_CENT, 0, "" "", """");tbytes += ast_adsi_display(buf + bytes, ADSI_COMM_PAGE, 4, ADSI_JUST_CENT, 0, "" "", """");tbytes += ast_adsi_set_line(buf + bytes, ADSI_COMM_PAGE, 1);tbytes += ast_adsi_input_format(buf + bytes, 1, ADSI_DIR_FROM_LEFT, 0, ""Mailbox: ******"", """");tbytes += ast_adsi_input_control(buf + bytes, ADSI_COMM_PAGE, 4, 1, 1, ADSI_JUST_LEFT);tbytes += ast_adsi_load_soft_key(buf + bytes, ADSI_KEY_APPS + 3, ""Enter"", ""Enter"", ""#"", 1);tbytes += ast_adsi_set_keys(buf + bytes, keys);tbytes += ast_adsi_voice_mode(buf + bytes, 0);tast_adsi_transmit_message(chan, buf, bytes, ADSI_MSG_DISPLAY);}",2,"cwe119,cwe120"
"gf_store_read_and_tokenize (FILE *file, char *str, char **iter_key,                            char **iter_val, gf_store_op_errno_t *store_errno){        int32_t     ret = -1;        char        *savetok = NULL;        char        *key = NULL;        char        *value = NULL;        GF_ASSERT (file);        GF_ASSERT (str);        GF_ASSERT (iter_key);        GF_ASSERT (iter_val);        GF_ASSERT (store_errno);        ret = fscanf (file, ""%s"", str);        if (ret <= 0 || feof (file)) {                ret = -1;                *store_errno = GD_STORE_EOF;                goto out;        }        key = strtok_r (str, ""="", &savetok);        if (!key) {                ret = -1;                *store_errno = GD_STORE_KEY_NULL;                goto out;        }        value = strtok_r (NULL, ""="", &savetok);        if (!value) {                ret = -1;                *store_errno = GD_STORE_VALUE_NULL;                goto out;        }        *iter_key = key;        *iter_val = value;        *store_errno = GD_STORE_SUCCESS;        ret = 0;out:        return ret;}",3,"cwe476,cwe469,cweother"
"write_vacmGroupName(int action,                    u_char * var_val,                    u_char var_val_type,                    size_t var_val_len,                    u_char * statP, oid * name, size_t name_len){    static unsigned char string[VACMSTRINGLEN];    struct vacm_groupEntry *geptr;    static int      resetOnFail;    if (action == RESERVE1) {        resetOnFail = 0;        if (var_val_type != ASN_OCTET_STR) {            return SNMP_ERR_WRONGTYPE;        }        if (var_val_len < 1 || var_val_len > 32) {            return SNMP_ERR_WRONGLENGTH;        }    } else if (action == RESERVE2) {        if ((geptr = sec2group_parse_groupEntry(name, name_len)) == NULL) {            return SNMP_ERR_INCONSISTENTNAME;        } else {            resetOnFail = 1;            memcpy(string, geptr->groupName, VACMSTRINGLEN);            memcpy(geptr->groupName, var_val, var_val_len);            geptr->groupName[var_val_len] = 0;            if (geptr->status == RS_NOTREADY) {                geptr->status = RS_NOTINSERVICE;            }        }    } else if (action == FREE) {                 if ((geptr = sec2group_parse_groupEntry(name, name_len)) != NULL &&            resetOnFail) {            memcpy(geptr->groupName, string, VACMSTRINGLEN);        }    }    return SNMP_ERR_NOERROR;}",2,"cwe119,cwe120"
"utf8_wc_to_mbstr(const unsigned *wordbuf, size_t wordlen, char **sptr){    size_t i;    size_t wbc;    char *s;    wbc = 0;    for (i = 0; i < wordlen; i++) {tchar r[4];tint rc = utf8_wctomb(r, wordbuf[i]);tif (rc <= 0)t    return rc;twbc += rc;    }    s = malloc(wbc + 1);    if (!s) {terrno = ENOMEM;treturn -1;    }    wbc = 0;    for (i = 0; i < wordlen; i++) {tchar r[4];tint rc = utf8_wctomb(r, wordbuf[i]);tif (rc <= 0)t    return rc;tmemcpy(s + wbc, r, rc);twbc += rc;    }    s[wbc] = 0;    *sptr = s;    return 0;}",3,"cwe119,cwe120,cweother"
"remove_directory(char *d){#ifdeftS_IFLNKtstructtstattsbuf;tif  (lstat(d, &sbuf) >= 0  &&  (sbuf.st_mode & S_IFMT) == S_IFLNK)ttreturn  unlink(d) >= 0;#endif#ifdeftHAVE_RMDIRtreturn  rmdir(d) >= 0;#elsetchartbuf[80];tsprintf(buf, ""rmdir %s"", d);treturn  system(buf) == 0;#endif}",3,"cwe119,cwe120,cweother"
"caseFoldReadRaw (FILE *in, CaseFoldRaw *raw){    char    line[MAX_LINE];    for (;;)    {tif (!fgets (line, sizeof (line) - 1, in))t    return 0;tif (parseRaw (line, raw))t    return 1;    }}",2,"cwe119,cwe120"
"rodlandj_gfx_unmangle(int region)r{rtdata8_t *rom = memory_region(REGION_GFX1+region);rtint size = memory_region_length(REGION_GFX1+region);rtdata8_t *buffer;rtint i;rrt rtfor (i = 0;i < size;i++)rttrom[i] =   (rom[i] & 0x27)rtttt| ((rom[i] & 0x80) >> 4)rtttt| ((rom[i] & 0x48) << 1)rtttt| ((rom[i] & 0x10) << 2);rrtbuffer = malloc(size);rtif (!buffer) return;rrtmemcpy(buffer,rom,size);rrt rtfor (i = 0;i < size;i++)rt{rttint a =    (i &~0x2508)rtttt| ((i & 0x2000) >> 10)rtttt| ((i & 0x0400) << 3)rtttt| ((i & 0x0100) << 2)rtttt| ((i & 0x0008) << 5);rttrom[i] = buffer[a];rt}rrtfree(buffer);r}",2,"cwe120,cweother"
Devices_ReadBasicFile(void){tif (BINLOAD_bin_file != NULL) {ttint ch = fgetc(BINLOAD_bin_file);ttif (ch == EOF) {tttCPU_regY = 136;tttCPU_SetN;tttreturn;tt}ttswitch (BINLOAD_loading_basic) {ttcase BINLOAD_LOADING_BASIC_LISTED:tttswitch (ch) {tttcase 0x9b:ttttBINLOAD_loading_basic = BINLOAD_LOADING_BASIC_LISTED_ATARI;ttttbreak;tttcase 0x0a:ttttBINLOAD_loading_basic = BINLOAD_LOADING_BASIC_LISTED_LF;ttttch = 0x9b;ttttbreak;tttcase 0x0d:ttttBINLOAD_loading_basic = BINLOAD_LOADING_BASIC_LISTED_CR_OR_CRLF;ttttch = 0x9b;ttttbreak;tttdefault:ttttbreak;ttt}tttbreak;ttcase BINLOAD_LOADING_BASIC_LISTED_CR:tttif (ch == 0x0d)ttttch = 0x9b;tttbreak;ttcase BINLOAD_LOADING_BASIC_LISTED_LF:tttif (ch == 0x0a)ttttch = 0x9b;tttbreak;ttcase BINLOAD_LOADING_BASIC_LISTED_CRLF:tttif (ch == 0x0a) {ttttch = fgetc(BINLOAD_bin_file);ttttif (ch == EOF) {tttttCPU_regY = 136;tttttCPU_SetN;tttttreturn;tttt}ttt}tttif (ch == 0x0d)ttttch = 0x9b;tttbreak;ttcase BINLOAD_LOADING_BASIC_LISTED_CR_OR_CRLF:tttif (ch == 0x0a) {ttttBINLOAD_loading_basic = BINLOAD_LOADING_BASIC_LISTED_CRLF;ttttch = fgetc(BINLOAD_bin_file);ttttif (ch == EOF) {tttttCPU_regY = 136;tttttCPU_SetN;tttttreturn;tttt}ttt}tttelsettttBINLOAD_loading_basic = BINLOAD_LOADING_BASIC_LISTED_CR;tttif (ch == 0x0d)ttttch = 0x9b;tttbreak;ttcase BINLOAD_LOADING_BASIC_SAVED:ttcase BINLOAD_LOADING_BASIC_LISTED_ATARI:ttdefault:tttbreak;tt}ttCPU_regA = (UBYTE) ch;ttCPU_regY = 1;ttCPU_ClrN;t}},2,"cwe120,cweother"
"poll_read( int fd, char *buf, int sz ){tint r, n;tstruct pollfd pf;tpf.fd = fd;tpf.events = POLLIN;twhile( sz )t{ttr = poll( &pf, 1, 1000 );ttif( r == -1 && errno != EINTR )tt{tttmsglog( MSG_ERR|LOG_ERRNO, ""poll_read: poll"" );tttreturn -1;tt}ttif( r == 0 && self.shutdown )tttreturn 0;ttif( r <= 0 ) continue;  ttwhile( ( n = read( fd, buf, sz ) ) == -1 &&tttterrno == EINTR );ttif( n > 0 )tt{tttsz -= n;tttbuf += n;tt}ttelse if( ! n )tt{tttmsglog( MSG_ALERT, ""poll_read: kernel pipe closed"" );tttreturn -1;tt}ttelse if( n == -1 )tt{tttif( errno == EAGAIN )ttt{ttttsleep( 1 );ttttcontinue;ttt}tttmsglog( MSG_ERR|LOG_ERRNO, ""poll_read: read"" );tttreturn -1;tt}t}treturn 1;}",2,"cwe120,cweother"
"ldmp_xdump(char *saddr, int count){#define LINESZ     60#define ASCIISTRT  40#define HEXEND     36tint i, j, k, hexdigit;tint c;tchar *hexchar;tchar linebuf[LINESZ + 1];tchar prevbuf[LINESZ + 1];tchar *linestart;tint asciistart;tchar asterisk = ' ';thexchar = ""0123456789ABCDEF"";tprevbuf[0] = '0';ti = (int) saddr % 4;tif (i != 0)ttsaddr = saddr - i;tfor (i = 0; i < count;) {ttfor (j = 0; j < LINESZ; j++)tttlinebuf[j] = ' ';ttlinestart = saddr;ttasciistart = ASCIISTRT;ttfor (j = 0; j < HEXEND;) {tttfor (k = 0; k < 4; k++) {ttttc = *(saddr++) & 0xFF;ttttif ((c >= 0x20) && (c <= 0x7e))tttttlinebuf[asciistart++] = (char) c;ttttelsetttttlinebuf[asciistart++] = '.';tttthexdigit = c >> 4;ttttlinebuf[j++] = hexchar[hexdigit];tttthexdigit = c & 0x0f;ttttlinebuf[j++] = hexchar[hexdigit];tttti++;ttt}tttif (i >= count)ttttbreak;tttlinebuf[j++] = ' ';tt}ttlinebuf[LINESZ] = '0';ttif (((j = ldmp_x_scmp(linebuf, prevbuf)) == 0) && (i < count)) {tttif (asterisk == ' ') {ttttasterisk = '*';ttttfprintf(outfp, ""    *"");ttt}tt} else {tttfprintf(outfp, ""    %p  %s"", linestart, linebuf);tttasterisk = ' ';tttldmp_x_scpy(prevbuf, linebuf);tt}t}treturn;}",2,"cwe119,cwe120"
"_rpc_health_check(slurm_msg_t *msg){tint        rc = SLURM_SUCCESS;tuid_t req_uid = g_slurm_auth_get_uid(msg->auth_cred, NULL);tif (!_slurm_authorized_user(req_uid)) {tterror(""Security violation, health check RPC from uid %d"",tt      req_uid);ttrc = ESLURM_USER_ID_MISSING;t t}t tif (slurm_send_rc_msg(msg, rc) < 0) {tterror(""Error responding to ping: %m"");ttsend_registration_msg(SLURM_SUCCESS, false);t}tif ((rc == SLURM_SUCCESS) && (conf->health_check_program)) {ttchar *env[1] = { NULL };ttrc = run_script(""health_check"", conf->health_check_program,tttt0, 60, env, 0);t}t t_enforce_job_mem_limit();treturn rc;}",2,"cwe119,cwe120"
"ath6kl_fetch_testmode_file(struct ath6kl *ar){tchar filename[100];tint ret;tif (ar->testmode == 0)ttreturn 0;tath6kl_dbg(ATH6KL_DBG_BOOT, ""testmode %d"", ar->testmode);tif (ar->testmode == 2) {ttif (ar->hw.fw.utf == NULL) {tttath6kl_warn(""testmode 2 not supported"");tttreturn -EOPNOTSUPP;tt}ttsnprintf(filename, sizeof(filename), ""%s/%s"",ttt ar->hw.fw.dir, ar->hw.fw.utf);t} else {ttif (ar->hw.fw.tcmd == NULL) {tttath6kl_warn(""testmode 1 not supported"");tttreturn -EOPNOTSUPP;tt}ttsnprintf(filename, sizeof(filename), ""%s/%s"",ttt ar->hw.fw.dir, ar->hw.fw.tcmd);t}tset_bit(TESTMODE, &ar->flag);tret = ath6kl_get_fw(ar, filename, &ar->fw, &ar->fw_len);tif (ret) {ttath6kl_err(""Failed to get testmode %d firmware file %s: %d"",ttt   ar->testmode, filename, ret);ttreturn ret;t}treturn 0;}",2,"cwe119,cwe120"
"gfarm_hash_key_equal_casefold(const void *key1, int key1len,ttt      const void *key2, int key2len){tint i;tif (key1len != key2len)ttreturn (0);tfor (i = 0; i < key1len; i++) {ttif (tolower(((unsigned char *)key1)[i]) !=tt    tolower(((unsigned char *)key2)[i]))tttreturn (0);t}treturn (1);}",2,"cwe119,cwe120"
"_StartBlob(ArchiveHandle *AH, TocEntry *te, Oid oid){tlclContext *ctx = (lclContext *) AH->formatData;tlclTocEntry *tctx = (lclTocEntry *) te->formatData;tcharttfname[255];tchart   *sfx;tif (oid == 0)ttdie_horribly(AH, modulename, ""invalid OID for large object (%u)"", oid);tif (AH->compression != 0)ttsfx = "".gz"";telsettsfx = """";tsprintf(fname, ""blob_%u.dat%s"", oid, sfx);ttarPrintf(AH, ctx->blobToc, ""%u %s"", oid, fname);ttctx->TH = tarOpen(AH, fname, 'w');}",2,"cwe119,cwe120"
"_view_init(Evas_Object *obj){   Widget_Data *wd = elm_widget_data_get(obj);   if (!wd) return;   if (!wd->box)     {        wd->box = elm_box_add(obj);        if (!wd->box) return;        elm_widget_sub_object_add(obj, wd->box);        elm_box_layout_set(wd->box, _box_layout_cb, NULL, NULL);        elm_box_homogeneous_set(wd->box, EINA_FALSE);        edje_object_part_swallow(wd->base, ""box.swallow"", wd->box);     }   if (!wd->label)     {        wd->label = edje_object_add(evas_object_evas_get(obj));        if (!wd->label) return;        _elm_theme_object_set(obj, wd->label, ""multibuttonentry"", ""label"", elm_widget_style_get(obj));        _set_label(obj, """");        elm_widget_sub_object_add(obj, wd->label);     }   if (!wd->entry)     {        wd->entry = elm_entry_add(obj);        if (!wd->entry) return;        elm_entry_single_line_set(wd->entry, EINA_TRUE);        elm_object_text_set(wd->entry, """");        elm_entry_input_panel_enabled_set(wd->entry, EINA_FALSE);        evas_object_size_hint_min_set(wd->entry, MIN_W_ENTRY, 0);        evas_object_size_hint_weight_set(wd->entry, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);        evas_object_size_hint_align_set(wd->entry, EVAS_HINT_FILL, EVAS_HINT_FILL);        if (wd->box) elm_box_pack_end(wd->box, wd->entry);        evas_object_show(wd->entry);        wd->view_state = MULTIBUTTONENTRY_VIEW_ENTRY;     }   if (!wd->end)     {        const char *end_type;        end_type = edje_object_data_get(wd->base, ""closed_button_type"");        if (!end_type || !strcmp(end_type, ""label""))          {             wd->end = elm_label_add(obj);             if (!wd->end) return;             elm_object_style_set(wd->end, ""extended/multibuttonentry_default"");             wd->end_type = MULTIBUTTONENTRY_CLOSED_LABEL;          }        else          {             const char *size_str;             wd->end = edje_object_add(evas_object_evas_get(obj));             if (!wd->end) return;             _elm_theme_object_set(obj, wd->end, ""multibuttonentry"", ""closedbutton"", elm_widget_style_get(obj));             Evas_Coord button_min_width = 0;             Evas_Coord button_min_height = 0;             size_str = edje_object_data_get(wd->end, ""closed_button_width"");             if (size_str) button_min_width = (Evas_Coord)atoi(size_str);             size_str = edje_object_data_get(wd->end, ""closed_button_height"");             if (size_str) button_min_height = (Evas_Coord)atoi(size_str);             wd->end_type = MULTIBUTTONENTRY_CLOSED_IMAGE;             evas_object_size_hint_min_set(wd->end,                                           button_min_width * _elm_config->scale,                                           button_min_height * _elm_config->scale);             elm_widget_sub_object_add(obj, wd->end);          }     }}",2,"cwe469,cweother"
"sdb_engine_extract_type_qualifier (const gchar *string, const gchar *expr){t tregex_t re;tregmatch_t pm[8];  tmemset (&pm, -1, sizeof(pm));t tgchar *res = NULL;tstatic char pattern[512] =tt""("" RX_IDENT "">)"" t tt""(::"" RX_IDENT "")*""t tt""("" RX_WS ""<[^>;]*>)?""t tt tt""("" RX_WS RX_PTR RX_WS RX_IDENT RX_WS ""("" RX_ARRAY "")*"" ""("" RX_INITIALIZER "")?,"" RX_WS "")*"" tt""[ t*&]*"";tt t tgchar regexp[512];tg_snprintf (regexp, sizeof (regexp), ""%s<%s>"", pattern, expr);t tint error = regcomp (&re, regexp, REG_EXTENDED) ;tif (error)ttreturn NULL;t terror = regexec (&re, string, 8, &pm[0], 0) ;t twhile (error == 0) t{   tt tt ttint len = (pm[2].rm_so != -1 ? pm[2].rm_eo : pm[1].rm_eo) - pm[1].rm_so;ttif (res)tttfree (res);ttres = (gchar*) g_malloc0 (len + 1);ttif (!res)tt{tttregfree (&re);tttreturn NULL;tt}ttstrncpy (res, string + pm[1].rm_so, len); ttres[len] = '0';tt tterror = regexec (&re, string + pm[0].rm_eo, 8, &pm[0], 0) ;ttbreak;t}tregfree(&re);treturn res;}",2,"cwe119,cwe120"
"_ecore_fb_vt_setup(void){   char buf[64];     struct vt_mode new_vtmode;   if (_ecore_fb_vt_current_vt != _ecore_fb_vt_prev_vt)     {        snprintf(buf, sizeof(buf), ""/dev/tty%i"", _ecore_fb_vt_current_vt);        if ((_ecore_fb_vt_tty_fd = open(buf, O_RDWR)) < 0)          {             printf(""[ecore_fb:vt_setup] can't open tty %d"", _ecore_fb_vt_current_vt);             return 0;          }        close(_ecore_fb_vt_tty0_fd);        _ecore_fb_vt_tty0_fd = -1;              }   else      _ecore_fb_vt_tty_fd = _ecore_fb_vt_tty0_fd;       tcgetattr(_ecore_fb_vt_tty_fd, &_ecore_fb_tty_prev_tio_mode);   ioctl(_ecore_fb_vt_tty_fd, KDGETMODE, &_ecore_fb_tty_prev_kd_mode);   ioctl(_ecore_fb_vt_tty_fd, VT_GETMODE, &_ecore_fb_vt_prev_mode);   if (ioctl(_ecore_fb_vt_tty_fd, KDSETMODE, KD_GRAPHICS) < 0)     {        perror(""[ecore_fb:vt_setup] can't set the mode to KD_GRAPHICS"");        close(_ecore_fb_vt_tty_fd);        _ecore_fb_vt_tty_fd = -1;        return 0;     }   ioctl(_ecore_fb_vt_tty_fd, KDGKBMODE, &_ecore_fb_tty_prev_mode);       new_vtmode.mode = VT_PROCESS;   new_vtmode.waitv = 0;   new_vtmode.relsig = SIGUSR1;   new_vtmode.acqsig = SIGUSR2;   if (ioctl(_ecore_fb_vt_tty_fd, VT_SETMODE, &new_vtmode) < 0)     {        perror(""[ecore_fb:vt_setup] can't set the tty mode"");        close(_ecore_fb_vt_tty_fd);        _ecore_fb_vt_tty_fd = -1;        return 0;     }       _ecore_fb_user_handler = ecore_event_handler_add(ECORE_EVENT_SIGNAL_USER,                                                    _ecore_fb_signal_usr_handler,                                                    NULL);           usleep(40000);   if (ioctl(_ecore_fb_vt_tty_fd, VT_ACTIVATE, _ecore_fb_vt_current_vt) < 0)     {        perror(""[ecore_fb:vt_setup] error on VT_ACTIVATE"");        close(_ecore_fb_vt_tty_fd);        _ecore_fb_vt_tty_fd = -1;        return 0;     }   if(ioctl(_ecore_fb_vt_tty_fd, VT_WAITACTIVE, _ecore_fb_vt_current_vt) < 0)     {        perror(""[ecore_fb:vt_setup] error on VT_WAITACTIVE"");        close(_ecore_fb_vt_tty_fd);        _ecore_fb_vt_tty_fd = -1;        return 0;     }       return 1;}",3,"cwe119,cwe120,cweother"
"hdhomerun_device_get_tuner_status(struct hdhomerun_device_t *hd, char **pstatus_str, struct hdhomerun_tuner_status_t *status){tif (!hd->cs) {tthdhomerun_debug_printf(hd->dbg, ""hdhomerun_device_get_tuner_status: device not set"");ttreturn -1;t}tmemset(status, 0, sizeof(struct hdhomerun_tuner_status_t));tchar name[32];thdhomerun_sprintf(name, name + sizeof(name), ""/tuner%u/status"", hd->tuner);tchar *status_str;tint ret = hdhomerun_control_get(hd->cs, name, &status_str, NULL);tif (ret <= 0) {ttreturn ret;t}tif (pstatus_str) {tt*pstatus_str = status_str;t}tif (status) {ttchar *channel = strstr(status_str, ""ch="");ttif (channel) {tttsscanf(channel + 3, ""%31s"", status->channel);tt}ttchar *lock = strstr(status_str, ""lock="");ttif (lock) {tttsscanf(lock + 5, ""%31s"", status->lock_str);tt}ttstatus->signal_strength = (unsigned int)hdhomerun_device_get_status_parse(status_str, ""ss="");ttstatus->signal_to_noise_quality = (unsigned int)hdhomerun_device_get_status_parse(status_str, ""snq="");ttstatus->symbol_error_quality = (unsigned int)hdhomerun_device_get_status_parse(status_str, ""seq="");ttstatus->raw_bits_per_second = hdhomerun_device_get_status_parse(status_str, ""bps="");ttstatus->packets_per_second = hdhomerun_device_get_status_parse(status_str, ""pps="");ttstatus->signal_present = status->signal_strength >= 45;ttif (strcmp(status->lock_str, ""none"") != 0) {tttif (status->lock_str[0] == '(') {ttttstatus->lock_unsupported = TRUE;ttt} else {ttttstatus->lock_supported = TRUE;ttt}tt}t}treturn 1;}",3,"cwe119,cwe120,cwe469"
"verify_clean_subdirectory(struct cache_entry *ce,tttt      enum unpack_trees_error_types error_type,tttt      struct unpack_trees_options *o){t tint namelen;tint i;tstruct dir_struct d;tchar *pathbuf;tint cnt = 0;tunsigned char sha1[20];tif (S_ISGITLINK(ce->ce_mode) &&t    resolve_gitlink_ref(ce->name, ""HEAD"", sha1) == 0) {tt ttif (!hashcmp(sha1, ce->sha1))tttreturn 0;ttreturn verify_clean_submodule(ce, error_type, o);t}t tnamelen = strlen(ce->name);tfor (i = locate_in_src_index(ce, o);t     i < o->src_index->cache_nr;t     i++) {ttstruct cache_entry *ce2 = o->src_index->cache[i];ttint len = ce_namelen(ce2);ttif (len < namelen ||tt    strncmp(ce->name, ce2->name, namelen) ||tt    ce2->name[namelen] != '/')tttbreak;tt ttif (!ce_stage(ce2)) {tttif (verify_uptodate(ce2, o))ttttreturn -1;tttadd_entry(o, ce2, CE_REMOVE, 0);tttmark_ce_used(ce2, o);tt}ttcnt++;t}t tpathbuf = xmalloc(namelen + 2);tmemcpy(pathbuf, ce->name, namelen);tstrcpy(pathbuf+namelen, ""/"");tmemset(&d, 0, sizeof(d));tif (o->dir)ttd.exclude_per_dir = o->dir->exclude_per_dir;ti = read_directory(&d, pathbuf, namelen+1, NULL);tif (i)ttreturn o->gently ? -1 :tttadd_rejected_path(o, ERROR_NOT_UPTODATE_DIR, ce->name);tfree(pathbuf);treturn cnt;}",2,"cwe119,cwe120"
"""show_iline_prefix(struct Client *sptr, struct AccessItem *aconf, const char *name){  static char prefix_of_host[USERLEN + 14];  char *prefix_ptr;  prefix_ptr = prefix_of_host;  if (IsNoTilde(aconf))    *prefix_ptr++ = '-';  if (IsLimitIp(aconf))    *prefix_ptr++ = '!';  if (IsNeedIdentd(aconf))    *prefix_ptr++ = '+';  if (!IsNeedPassword(aconf))    *prefix_ptr++ = '&';  if (IsConfExemptResv(aconf))    *prefix_ptr++ = '$';  if (IsNoMatchIp(aconf))    *prefix_ptr++ = '%';  if (IsConfDoSpoofIp(aconf))    *prefix_ptr++ = '=';  if (MyOper(sptr) && IsConfExemptKline(aconf))    *prefix_ptr++ = '^';  if (MyOper(sptr) && IsConfExemptGline(aconf))    *prefix_ptr++ = '_';  if (MyOper(sptr) && IsConfExemptLimits(aconf))    *prefix_ptr++ = '>';  if (MyOper(sptr) && IsConfIdlelined(aconf))    *prefix_ptr++ = '<';  if (IsConfCanFlood(aconf))    *prefix_ptr++ = '|';  strlcpy(prefix_ptr, name, USERLEN+1);  return(prefix_of_host);}""",2,"cwe119,cwe120"
"varAddRecord(int recID, int param, int gridID, int zaxistype, int lbounds,tt  int level1, int level2, int level_sf, int level_unit, int prec,tt  int *pvarID, int *plevelID, int tsteptype, int numavg, int ltype,tt  const char *name, const char *longname, const char *units){  int varID = UNDEFID;  int levelID = -1;  if ( ! (cdiSplitLtype105 == 1 && zaxistype == ZAXIS_HEIGHT) )    varID = varGetEntry(param, zaxistype, ltype, name);  if ( varID == UNDEFID )    {      nvars++;      varID = paramNewEntry(param);      vartable[varID].gridID    = gridID;      vartable[varID].zaxistype = zaxistype;      vartable[varID].ltype     = ltype;      vartable[varID].lbounds   = lbounds;      vartable[varID].level_sf  = level_sf;      vartable[varID].level_unit = level_unit;      if ( tsteptype != UNDEFID ) vartable[varID].tsteptype = tsteptype;      if ( numavg ) vartable[varID].timave = 1;      if ( name )     if ( name[0] )     vartable[varID].name     = strdup(name);      if ( longname ) if ( longname[0] ) vartable[varID].longname = strdup(longname);      if ( units )    if ( units[0] )    vartable[varID].units    = strdup(units);    }  else    {      char paramstr[32];      cdiParamToString(param, paramstr, sizeof(paramstr));      if ( vartable[varID].gridID != gridID )t{t  Message(""param = %s gridID = %d"", paramstr, gridID);t  Error(""horizontal grid must not change for same param!"");t}      if ( vartable[varID].zaxistype != zaxistype )t{t  Message(""param = %s zaxistype = %d"", paramstr, zaxistype);t  Error(""zaxistype must not change for same param!"");t}    }  if ( prec > vartable[varID].prec ) vartable[varID].prec = prec;  levelID = levelNewEntry(varID, level1, level2);  vartable[varID].levelTable[levelID].recID = recID;  if ( CDI_Debug )    Message(""varID = %d  levelID = %d"", varID, levelID);  *pvarID   = varID;  *plevelID = levelID;}",2,"cwe119,cwe120"
"read_line(char *s){  int i;  int c;       if (mlevel(6))    fprintf(stderr, ""Reading line: %s"", s);     for (i = 0; i < LINEBUF_LEN-1; i++)  {    c = fgetc(in_file);         if (c == EOF || c == '')      break;    buffer[i] = c;  }     buffer[i] = 0;     if (mlevel(6))    fprintf(stderr, ""# %s"", buffer);}",2,"cwe120,cweother"
"iax2_transfer(struct ast_channel *c, const char *dest){tunsigned short callno = PTR_TO_CALLNO(ast_channel_tech_pvt(c));tstruct iax_ie_data ied = { """", };tchar tmp[256], *context;tenum ast_control_transfer message = AST_TRANSFER_SUCCESS;tast_copy_string(tmp, dest, sizeof(tmp));tcontext = strchr(tmp, '@');tif (context) {tt*context = '0';ttcontext++;t}tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, tmp);tif (context)ttiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, context);tast_debug(1, ""Transferring '%s' to '%s'"", ast_channel_name(c), dest);tast_queue_control_data(c, AST_CONTROL_TRANSFER, &message, sizeof(message));treturn send_command_locked(callno, AST_FRAME_IAX, IAX_COMMAND_TRANSFER, 0, ied.buf, ied.pos, -1);}",2,"cwe119,cwe120"
"add_stdrules(){  register int i = 0, j = 0, k = 0;  register struct cmds *comm;  while(strcmp(stdrules[i],""0"") != 0)      {tif (is_pattern (stdrules[i]))t  {t    if((stdruletab[k] = tt(struct rules *) malloc( sizeof(struct rules))) == t       (struct rules *) NIL)t      errexit(10,""malloc"");t    memset ((char *)stdruletab[k], 0, sizeof (struct rules));t    stdruletab[k]->name = stdrules[i];t    stdruletab[k]->next = (struct rules *)NIL;t    i++;t  }tif(stdrules[i][0] != 't')t  {t    while ((stdrules[i][0] != 't') &&tt   (stdrules[i][0] != '+') &&tt   (strcmp(stdrules[i],""0"") != 0))t      {ttstdruletab[k]->deplist = stdrules[i];ttstdruletab[k]->firstdep = stdrules[i];tti++;t      }t  }tif (stdrules[i][0] == '+')t  {t    j = 0;t    while (stdrules[i][0] == '+')t      {ttstdruletab[k]->heritage[j] = stdrules[i];tti++;ttj++;t      }t    stdruletab[k]->heritage[j] = NIL;t  }telset  stdruletab[k]->heritage[0] = NIL;tif (stdrules[i][0] == 't')t  {t    comm = stdruletab[k]->cmdlist = newcmds();t    if (stdrules[i][0] == 't')t      dott{ttcomm->command = stdrules[i];ttcomm->nextcmd = newcmds(); ttcomm = comm->nextcmd;tti++;t      }  while (stdrules[i][0] == 't');t    stdruletab[k]->targetlist[0] = stdruletab[k]->name;t    stdruletab[k]->targetlist[1] = NIL;t  }tk++;      }  stdruletab[k] = (struct rules *) NIL;  lastrule = k - 1;}",3,"cwe119,cwe120,cwe469"
"icalparameter_new_clone(icalparameter* param){    struct icalparameter_impl *old;    struct icalparameter_impl *new;    old = (struct icalparameter_impl *)param;    new = icalparameter_new_impl(old->kind);    icalerror_check_arg_rz((param!=0),""param"");    if (new == 0){treturn 0;    }    memcpy(new,old,sizeof(struct icalparameter_impl));    if (old->string != 0){tnew->string = icalmemory_strdup(old->string);tif (new->string == 0){t    icalparameter_free(new);t    return 0;t}    }    if (old->x_name != 0){tnew->x_name = icalmemory_strdup(old->x_name);tif (new->x_name == 0){t    icalparameter_free(new);t    return 0;t}    }    return new;}",2,"cwe120,cweother"
"float8_numeric(PG_FUNCTION_ARGS){tfloat8ttval = PG_GETARG_FLOAT8(0);tNumericttres;tNumericVartresult;tcharttbuf[DBL_DIG + 100];tif (isnan(val))ttPG_RETURN_NUMERIC(make_result(&const_nan));tsprintf(buf, ""%.*g"", DBL_DIG, val);tinit_var(&result);tset_var_from_str(buf, &result);tres = make_result(&result);tfree_var(&result);tPG_RETURN_NUMERIC(res);}",2,"cwe119,cwe120"
"change_handle(struct userrec *u, char *newh){  int i;  char s[HANDLEN + 1];  if (!u)    return 0;     if (!newh[1] && strchr(BADHANDCHARS, newh[0]))    return 0;  check_tcl_nkch(u->handle, newh);     if (!noshare && !(u->flags & USER_UNSHARED))    shareout(NULL, ""h %s %s"", u->handle, newh);  strncpyz(s, u->handle, sizeof s);  strncpyz(u->handle, newh, sizeof u->handle);  for (i = 0; i < dcc_total; i++)    if (dcc[i].type != &DCC_BOT && !egg_strcasecmp(dcc[i].nick, s)) {      strncpyz(dcc[i].nick, newh, sizeof dcc[i].nick);      if (dcc[i].type == &DCC_CHAT && dcc[i].u.chat->channel >= 0) {        chanout_but(-1, dcc[i].u.chat->channel,                    ""*** Handle change: %s -> %s"", s, newh);        if (dcc[i].u.chat->channel < GLOBAL_CHANS)          botnet_send_nkch(i, s);      }    }  return 1;}",2,"cwe119,cwe120"
"S_InitScript(void){    int i;    SC_OpenLump(""sndinfo"");    while (SC_GetString())    {        if (*sc_String == '$')        {            if (!strcasecmp(sc_String, ""$ARCHIVEPATH""))            {                SC_MustGetString();            }            else if (!strcasecmp(sc_String, ""$MAP""))            {                SC_MustGetNumber();                SC_MustGetString();                if (sc_Number)                {                    P_PutMapSongLump(sc_Number, sc_String);                }            }            continue;        }        else        {            for (i = 0; i < NUMSFX; i++)            {                if (!strcmp(S_sfx[i].tagname, sc_String))                {                    SC_MustGetString();                    if (*sc_String != '?')                    {                        strcpy(S_sfx[i].name, sc_String);                    }                    else                    {                        strcpy(S_sfx[i].name, ""default"");                    }                    break;                }            }            if (i == NUMSFX)            {                SC_MustGetString();            }        }    }    SC_Close();    for (i = 0; i < NUMSFX; i++)    {        if (!strcmp(S_sfx[i].name, """"))        {            strcpy(S_sfx[i].name, ""default"");        }    }}",2,"cwe120,cwe469"
"printBinaryTree(FILE *fp, NodeT *np){  char buf[128];  if(LEAF(np)) {    sprintf(buf, ""%s:%f"", np->name, np->rho);    wrapPrint(fp, buf);  }  else {    wrapPrint(fp, ""("");    printBinaryTree(fp, np->child_l);    wrapPrint(fp, "","");    printBinaryTree(fp, np->child_r);    sprintf(buf, ""):%f"", np->rho);    wrapPrint(fp, buf);  }}",2,"cwe119,cwe120"
"fetch_pack(const unsigned char *sha1){tstruct packed_git *target;tchar filename[PATH_MAX];tif (setup_indices())ttreturn -1;ttarget = find_sha1_pack(sha1, packs);tif (!target)ttreturn error(""Couldn't find %s: not separate or in any pack"",ttt     sha1_to_hex(sha1));tif (get_verbosely) {ttfprintf(stderr, ""Getting pack %s"",tttsha1_to_hex(target->sha1));ttfprintf(stderr, "" which contains %s"",tttsha1_to_hex(sha1));t}tsprintf(filename, ""%s/objects/pack/pack-%s.pack"",ttpath, sha1_to_hex(target->sha1));tcopy_file(filename, sha1_pack_name(target->sha1),tt  sha1_to_hex(target->sha1), 1);tsprintf(filename, ""%s/objects/pack/pack-%s.idx"",ttpath, sha1_to_hex(target->sha1));tcopy_file(filename, sha1_pack_index_name(target->sha1),tt  sha1_to_hex(target->sha1), 1);tinstall_packed_git(target);treturn 0;}",2,"cwe119,cwe120"
"test_util_datadir(void){  char buf[1024];  char *f = NULL;  char *temp_dir = NULL;  temp_dir = get_datadir_fname(NULL);  f = get_datadir_fname(""state"");  tor_snprintf(buf, sizeof(buf), ""%s""PATH_SEPARATOR""state"", temp_dir);  test_streq(f, buf);  tor_free(f);  f = get_datadir_fname2(""cache"", ""thingy"");  tor_snprintf(buf, sizeof(buf),               ""%s""PATH_SEPARATOR""cache""PATH_SEPARATOR""thingy"", temp_dir);  test_streq(f, buf);  tor_free(f);  f = get_datadir_fname2_suffix(""cache"", ""thingy"", "".foo"");  tor_snprintf(buf, sizeof(buf),               ""%s""PATH_SEPARATOR""cache""PATH_SEPARATOR""thingy.foo"", temp_dir);  test_streq(f, buf);  tor_free(f);  f = get_datadir_fname_suffix(""cache"", "".foo"");  tor_snprintf(buf, sizeof(buf), ""%s""PATH_SEPARATOR""cache.foo"",               temp_dir);  test_streq(f, buf); done:  tor_free(f);  tor_free(temp_dir);}",2,"cwe119,cwe120"
"r_locate (void *symbol){tchar line[5000];tFILE *f;tchar *path;tbr_return_val_if_fail (symbol != NULL, NULL);tf = fopen (""/proc/self/maps"", ""r"");tif (!f) {ttif (fallback_func)tttreturn fallback_func(symbol, fallback_data);ttelsetttreturn NULL;t}twhile (!feof (f))t{ttunsigned long start, end;ttif (!fgets (line, sizeof (line), f))tttcontinue;ttif (!strstr (line, "" r-xp "") || !strchr (line, '/'))tttcontinue;ttsscanf (line, ""%lx-%lx "", &start, &end);ttif (symbol >= (void *) start && symbol < (void *) end)tt{tttchar *tmp;tttsize_t len;ttt tttpath = strchr (line, '/');ttt ttttmp = strrchr (path, '');tttif (tmp) *tmp = 0;ttt tttlen = strlen (path);tttif (len > 10 && strcmp (path + len - 10, "" (deleted)"") == 0)ttt{tttttmp = path + len - 10;tttt*tmp = 0;ttt}tttfclose(f);tttreturn strdup (path);tt}t}tfclose (f);treturn NULL;}",4,"cwe119,cwe120,cwe476,cweother"
"main(int ac, char **av){        int fd;        if (ac > 1)                dev = av[1];        if ((fd = open(dev, O_RDWR)) < 0) {                fprintf(stderr, ""can't open %s:  %s"", dev,                        strerror(errno));                exit(1);        }                         my_data.csr.control_reg_value = MY_CTRL_VAMPIRE;        sprintf(my_data.message, ""I vant your blood"");        if (ioctl(fd, MY_CMD_CONFIG, &my_data) < 0) {                fprintf(stderr, ""CONFIG ioctl failed:  %s"",                        strerror(errno));                exit(1);        }        printf(""after CONFIG, status register is 0x%x.  Bitwise AND with ""               ""control:  0x%x"",               my_data.csr.status_reg_value,               my_data.csr.status_reg_value & MY_CTRL_VAMPIRE);        fflush(stdout);        if (ioctl(fd, MY_CMD_START) < 0) {                fprintf(stderr, ""START ioctl failed:  %s"",                        strerror(errno));                exit(1);        }        printf(""successfully started the device"");        fflush(stdout);                        if (ioctl(fd, MY_CMD_STOP) < 0) {                fprintf(stderr, ""STOP ioctl failed:  %s"",                        strerror(errno));                exit(1);        }        printf(""successfully stopped the device"");        fflush(stdout);        close(fd);        printf(""sizeof(uint32_t) is %d"", sizeof(uint32_t));        return 0;   }",2,"cwe120,cweother"
"rdwr_gridatb(){    FILE *fp;    int fd, i, j, retval;    float idx;    fp = fopen(file, ""r"");    buf[0] = 0;    fscanf(fp, ""%[^]"", buf);    if (!buf[0])tgetc(fp);    fscanf(fp, ""%d %d %lf"", &cellhd.cols, &cellhd.rows, &cellhd.ns_res);    cellhd.ew_res = cellhd.ns_res;    cellhd.south = 0;    cellhd.north = cellhd.south + cellhd.ns_res * cellhd.rows;    cellhd.west = 0;    cellhd.east = cellhd.west + cellhd.ew_res * cellhd.cols;    cellhd.format = -1;    cellhd.compressed = 1;    if (retval = adjcellhd(&cellhd)) {tfclose(fp);tswitch (retval) {tcase 1:t    G_fatal_error(_(""Setting window header failed""));t    break;tcase 2:t    G_fatal_error(_(""Rows changed""));t    break;tcase 3:t    G_fatal_error(_(""Cols changed""));t    break;t}    }    fd = G_open_raster_new(oname, FCELL_TYPE);    cell = (FCELL *) G_malloc(sizeof(FCELL) * cellhd.cols);    for (i = 0; i < cellhd.rows; i++) {tG_percent(i, cellhd.rows, 2);tfor (j = 0; j < cellhd.cols; j++) {t    idx = 9999.0;t    fscanf(fp, ""%f"", &idx);t    if (idx >= 9999.0) {ttG_set_f_null_value(&(cell[j]), 1);t    }t    else {ttcell[j] = idx;t    }t}tG_put_f_raster_row(fd, cell);    }    G_percent(i, cellhd.rows, 2);    if(fp)tfclose(fp);    G_close_cell(fd);    G_put_cell_title(oname, buf);    G_put_cellhd(oname, &cellhd);    return;}",2,"cwe120,cweother"
"command_opendir(char * token, Channel * c) {    char path[FILE_PATH_SIZE];    DIR * dir = NULL;    int err = 0;    OpenFileInfo * handle = NULL;    read_path(&c->inp, path, sizeof(path));    if (read_stream(&c->inp) != 0) exception(ERR_JSON_SYNTAX);    if (read_stream(&c->inp) != MARKER_EOM) exception(ERR_JSON_SYNTAX);    dir = opendir(path);    if (dir == NULL) {        err = errno;    }    else {        handle = create_open_file_info(c, path, -1, dir);    }    write_stringz(&c->out, ""R"");    write_stringz(&c->out, token);    write_fs_errno(&c->out, err);    write_file_handle(&c->out, handle);    write_stream(&c->out, MARKER_EOM);}",2,"cwe119,cwe120"
"DXGetNextHashElement( HashTable hashtab ){    PageTable * pagetab;    HashElement element, nextelt;    HashElement *pages;    int pageNum, eltNum;    int eltSize, eltsInPage;    int nPages;    if ( ! hashtab )        return ERROR;    pagetab = &hashtab->pageTable;    if ( ( pageNum = hashtab->getNextPage ) >= ( nPages = pagetab->nPages ) )        return NULL;    eltNum = hashtab->getNextElement;    pages = pagetab->pagePtrs;    eltSize = pagetab->eltSize;    if ( pageNum == nPages - 1 )        eltsInPage = pagetab->nextEltNum;    else        eltsInPage = ELTS_PER_PAGE;    nextelt = ( HashElement ) ( ( ( char * ) pages[ pageNum ] ) + eltNum * eltSize );    while ( pageNum < nPages ) {        element = nextelt;        eltNum ++;        if ( eltNum >= eltsInPage ) {            eltNum = 0;            if ( ++pageNum < nPages ) {                if ( pageNum == nPages - 1 )                    eltsInPage = pagetab->nextEltNum;                else                    eltsInPage = ELTS_PER_PAGE;                nextelt = pages[ pageNum ];            }        } else            nextelt = ( HashElement ) ( ( char * ) element + eltSize );        if ( element->u.pseudoKey ) {            hashtab->getNextPage = pageNum;            hashtab->getNextElement = eltNum;            return DATA_PTR( element );        }    }    return NULL;}",2,"cwe119,cwe120"
"get_jobs(char *cmd_ptr, int *err_code, char **err_msg){tchar *arg_ptr = NULL, *tmp_char = NULL, *tmp_buf = NULL, *buf = NULL;ttime_t update_time;t tslurmctld_lock_t job_read_lock = {ttNO_LOCK, READ_LOCK, NO_LOCK, READ_LOCK };tint job_rec_cnt = 0, buf_size = 0;tif (cr_test == 0) {ttselect_g_get_info_from_plugin(SELECT_CR_PLUGIN, NULL,ttttt      &cr_enabled);ttcr_test = 1;t}targ_ptr = strstr(cmd_ptr, ""ARG="");tif (arg_ptr == NULL) {tt*err_code = -300;tt*err_msg = ""GETJOBS lacks ARG"";tterror(""wiki: GETJOBS lacks ARG"");ttreturn -1;t}tupdate_time = (time_t) strtoul(arg_ptr+4, &tmp_char, 10);tif (tmp_char[0] != ':') {tt*err_code = -300;tt*err_msg = ""Invalid ARG value"";tterror(""wiki: GETJOBS has invalid ARG value"");ttreturn -1;t}tif (job_list == NULL) {tt*err_code = -140;tt*err_msg = ""Still performing initialization"";tterror(""wiki: job_list not yet initilized"");ttreturn -1;t}ttmp_char++;tlock_slurmctld(job_read_lock);tif (strncmp(tmp_char, ""ALL"", 3) == 0) {tt ttbuf = _dump_all_jobs(&job_rec_cnt, update_time);t} else {ttstruct job_record *job_ptr = NULL;ttchar *job_name = NULL, *tmp2_char = NULL;ttuint32_t job_id;ttjob_name = strtok_r(tmp_char, "":"", &tmp2_char);ttwhile (job_name) {tttjob_id = (uint32_t) strtoul(job_name, NULL, 10);tttjob_ptr = find_job_record(job_id);ttttmp_buf = _dump_job(job_ptr, update_time);tttif (job_rec_cnt > 0)ttttxstrcat(buf, ""#"");tttxstrcat(buf, tmp_buf);tttxfree(tmp_buf);tttjob_rec_cnt++;tttjob_name = strtok_r(NULL, "":"", &tmp2_char);tt}t}tunlock_slurmctld(job_read_lock);t tif (buf)ttbuf_size = strlen(buf);ttmp_buf = xmalloc(buf_size + 32);tif (job_rec_cnt)ttsprintf(tmp_buf, ""SC=0 ARG=%d#%s"", job_rec_cnt, buf);telsettsprintf(tmp_buf, ""SC=0 ARG=0#"");txfree(buf);t*err_code = 0;t*err_msg = tmp_buf;treturn 0;}",2,"cwe120,cwe469"
"submit_cancel_async(){chartbuf[256];tkill(submit_pid, SIGTERM);talarmflag=0;tsignal(SIGALRM, sigtrap);talarm(10);twhile (read(fileno(fromsubmit), buf, sizeof(buf)) > 0)tt;talarm(0);tsignal(SIGALRM, SIG_DFL);tif (alarmflag)tkill(submit_pid, SIGKILL);t(void)submit_wait_noreset();}",3,"cwe119,cwe120,cweother"
"test_locale (const char *langstr){#ifndef ENABLE_NLS    return 1;#else    const char *lcode;    char *orig, ocpy[64];    int langid, err = 0;    langid = lang_id_from_name(langstr);    lcode = get_setlocale_string(langid);    orig = setlocale(LC_ALL, NULL);    gretl_error_clear();    *ocpy = '0';    strncat(ocpy, orig, 63);    err = set_locale_with_workaround(langid, lcode);    if (err) {tgretl_errmsg_sprintf(_(""%s: locale is not supported ""ttt       ""on this system""), lcode);    } else {tsetlocale(LC_ALL, ocpy);      }     return err;#endif}",2,"cwe119,cwe120"
"growl_tcp_parse_hostname( const char *const server , int default_port , struct sockaddr_in *const sockaddr ){tchar *hostname = strdup(server);tchar *port = strchr( hostname, ':' );tstruct hostent* host_ent;tif( port != NULL )t{tt*port = '0';ttport++;ttdefault_port = atoi(port);t}tthost_ent = gethostbyname(hostname);tif( host_ent == NULL )t{ttperror(""gethostbyname"");ttfree(hostname);ttreturn -1;t}ttmemset( sockaddr , 0 , sizeof(sockaddr) );tsockaddr->sin_family = AF_INET;tmemcpy( &sockaddr->sin_addr , host_ent->h_addr , host_ent->h_length );tsockaddr->sin_port = htons(default_port);t tfree(hostname);treturn 0;}",2,"cwe120,cweother"
"readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {    redisClient *c = (redisClient*) privdata;    int nread, readlen;    size_t qblen;    REDIS_NOTUSED(el);    REDIS_NOTUSED(mask);    server.current_client = c;    readlen = REDIS_IOBUF_LEN;         if (c->reqtype == REDIS_REQ_MULTIBULK && c->multibulklen && c->bulklen != -1        && c->bulklen >= REDIS_MBULK_BIG_ARG)    {        int remaining = (unsigned)(c->bulklen+2)-sdslen(c->querybuf);        if (remaining < readlen) readlen = remaining;    }    qblen = sdslen(c->querybuf);    if (c->querybuf_peak < qblen) c->querybuf_peak = qblen;    c->querybuf = sdsMakeRoomFor(c->querybuf, readlen);    nread = read(fd, c->querybuf+qblen, readlen);    if (nread == -1) {        if (errno == EAGAIN) {            nread = 0;        } else {            redisLog(REDIS_VERBOSE, ""Reading from client: %s"",strerror(errno));            freeClient(c);            return;        }    } else if (nread == 0) {        redisLog(REDIS_VERBOSE, ""Client closed connection"");        freeClient(c);        return;    }    if (nread) {        sdsIncrLen(c->querybuf,nread);        c->lastinteraction = server.unixtime;        if (c->flags & REDIS_MASTER) c->reploff += nread;        server.stat_net_input_bytes += nread;    } else {        server.current_client = NULL;        return;    }    if (sdslen(c->querybuf) > server.client_max_querybuf_len) {        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();        bytes = sdscatrepr(bytes,c->querybuf,64);        redisLog(REDIS_WARNING,""Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)"", ci, bytes);        sdsfree(ci);        sdsfree(bytes);        freeClient(c);        return;    }    processInputBuffer(c);    server.current_client = NULL;}",2,"cwe120,cweother"
"QRinput_appendECIheader(QRinput *input, unsigned int ecinum){tunsigned char data[4];tif(ecinum > 999999) {tterrno = EINVAL;ttreturn -1;t}t tdata[0] = ecinum & 0xff;tdata[1] = (ecinum >>  8) & 0xff;tdata[2] = (ecinum >> 16) & 0xff;tdata[3] = (ecinum >> 24) & 0xff;treturn QRinput_append(input, QR_MODE_ECI, 4, data);}",2,"cwe119,cwe120"
mapimg_count(void){  if (!mapimg_initialised()) {    return 0;  }  return mapdef_list_size(mapimg.mapdef);},2,"cwe119,cwe120"
"simfs_find(const char * name) {tchar name_buff[MAX_LINE];tsimfs_absolute_name(name, name_buff, MAX_LINE); ttrie_node_t * node = trie_find(fs, name_buff);tsimfs_t * simfs;tif (!node) {ttreturn NULL;t} else {ttsimfs = trie_get_instance(node, simfs_t, node);ttreturn simfs;t}}",2,"cwe119,cwe120"
"generate_random_salt(char *salt, int length){tchar *buf;tint fd, i;tif((fd = open(""/dev/random"", O_RDONLY)) < 0)t{ttreturn (generate_poor_salt(salt, length));t}tbuf = calloc(1, length);tif(read(fd, buf, length) != length)t{ttfree(buf);ttreturn (generate_poor_salt(salt, length));t}tfor(i = 0; i < length; i++)t{ttsalt[i] = saltChars[abs(buf[i]) % 64];t}tfree(buf);treturn (salt);}",2,"cwe120,cweother"
"""gnc_entry_ledger_get_taxable_value (VirtualLocation virt_loc,                                    gboolean translate,                                    gboolean *conditionally_changed,                                    gpointer user_data){    GncEntryLedger *ledger = user_data;    gboolean is_current;    is_current = virt_cell_loc_equal(ledger->table->current_cursor_loc.vcell_loc,                                     virt_loc.vcell_loc);    if (is_current)        return gnc_entry_ledger_get_checkmark (ledger, ENTRY_TAXABLE_CELL);    else    {        const char *valstr =            get_taxable_entry (virt_loc, translate, conditionally_changed,                               user_data);        if (valstr && *valstr == 'X')            return TRUE;    }    return FALSE;}""",2,"cwe119,cwe120"
"setup_pager(void){tconst char *pager = getenv(""GIT_PAGER"");tif (!isatty(1))ttreturn;tif (!pager) {ttif (!pager_program)tttgit_config(git_default_config, NULL);ttpager = pager_program;t}tif (!pager)ttpager = getenv(""PAGER"");tif (!pager)ttpager = ""less"";telse if (!*pager || !strcmp(pager, ""cat""))ttreturn;tspawned_pager = 1;  t tpager_argv[2] = pager;tpager_process.argv = pager_argv;tpager_process.in = -1;#ifndef __MINGW32__tpager_process.preexec_cb = pager_preexec;#endiftif (start_command(&pager_process))ttreturn;t tdup2(pager_process.in, 1);tdup2(pager_process.in, 2);tclose(pager_process.in);t tatexit(wait_for_pager);}",2,"cwe469,cweother"
"check_magic(FILE *f){  char buf[MAGIC_LENGTH];  int r;  r = fread(&buf, 1, MAGIC_LENGTH, f);  return (r == MAGIC_LENGTH &&t  memcmp(buf, magic_str, MAGIC_LENGTH) == 0);}",3,"cwe119,cwe120,cweother"
"""explain_buffer_pid_t(explain_string_buffer_t *sb, pid_t pid){    char            path[PATH_MAX + 1];    explain_buffer_long(sb, pid);    if (explain_fileinfo_pid_exe(pid, path, sizeof(path)))    {        const char      *cp;        cp = strrchr(path, '/');        if (cp)            ++cp;        else            cp = path;        explain_string_buffer_putc(sb, ' ');        explain_string_buffer_puts_quoted(sb, cp);    }}""",2,"cwe119,cwe120"
"dag_prepare_nested_jobs(struct dag *d){t tint dag_nested_width = dag_width(d, 1);tint update_dag_nests = 1;tchar *s = getenv(""MAKEFLOW_UPDATE_NESTED_JOBS"");tif(s)ttupdate_dag_nests = atoi(s);tif(dag_nested_width > 0 && update_dag_nests) {ttdag_nested_width = MIN(dag_nested_width, d->local_jobs_max);ttstruct dag_node *n;ttfor(n = d->nodes; n; n = n->next) {tttif(n->nested_job && (n->local_job || batch_queue_type == BATCH_QUEUE_TYPE_LOCAL)) {ttttchar *command = xxmalloc(strlen(n->command) + 20);ttttsprintf(command, ""%s -j %d"", n->command, d->local_jobs_max / dag_nested_width);ttttfree((char *) n->command);ttttn->command = command;ttt}tt}t}}",2,"cwe120,cweother"
"zxid_load_cot_cache(zxid_conf* cf){  zxid_entity* ent;  struct dirent* de;  DIR* dir;  char buf[4096];  if (cf->path_len + sizeof(ZXID_COT_DIR) > sizeof(buf)) {   ERR(""Too long path(%.*s) for config dir. Has %d chars. Max allowed %d. (config problem)"",tcf->path_len, cf->path, cf->path_len, ((int)(sizeof(buf) - sizeof(ZXID_COT_DIR))));    return 0;  }  memcpy(buf, cf->path, cf->path_len);  memcpy(buf + cf->path_len, ZXID_COT_DIR, sizeof(ZXID_COT_DIR));  zxid_load_cot_cache_from_file(cf);    dir = opendir(buf);  if (!dir) {    perror(""opendir for /var/zxid/cot (or other if configured) for loading cot cache"");    ERR(""opendir failed path(%s) uid=%d gid=%d"", buf, geteuid(), getegid());    return 0;  }    while (de = readdir(dir))    if (de->d_name[0] != '.' && de->d_name[strlen(de->d_name)-1] != '~')      zxid_get_ent_by_sha1_name(cf, de->d_name);    DD(""HERE %p"", cf);  closedir(dir);  LOCK(cf->mx, ""return cot"");  ent = cf->cot;  UNLOCK(cf->mx, ""return cot"");  return ent;}",2,"cwe119,cwe120"
"load_config(int reload){tstruct ast_config *cfg = NULL;tstruct ast_flags config_flags = { reload ? CONFIG_FLAG_FILEUNCHANGED : 0 };tstruct cli_alias *alias;tstruct ast_variable *v, *v1;tif (!(cfg = ast_config_load(config_file, config_flags)) || cfg == CONFIG_STATUS_FILEINVALID) {ttast_log(LOG_ERROR, ""res_clialiases configuration file '%s' not found"", config_file);ttreturn;t} else if (cfg == CONFIG_STATUS_FILEUNCHANGED) {ttreturn;t}t tif (reload) {ttao2_callback(cli_aliases, OBJ_UNLINK | OBJ_NODATA | OBJ_MULTIPLE, NULL, NULL);t}tfor (v = ast_variable_browse(cfg, ""general""); v; v = v->next) {ttif (strcmp(v->name, ""template"")) {tttast_log(LOG_WARNING, ""%s is not a correct option in [%s]"", v->name, ""general"");tttcontinue;tt}tt ttfor (v1 = ast_variable_browse(cfg, v->value); v1; v1 = v1->next) {tttif (!(alias = ao2_alloc((sizeof(*alias) + strlen(v1->name) + strlen(v1->value) + 2), alias_destroy))) {ttttcontinue;ttt}tttalias->alias = ((char *) alias) + sizeof(*alias);tttalias->real_cmd = ((char *) alias->alias) + strlen(v1->name) + 1;tttstrcpy(alias->alias, v1->name);tttstrcpy(alias->real_cmd, v1->value);tttalias->cli_entry.handler = cli_alias_passthrough;tttalias->cli_entry.command = alias->alias;tttalias->cli_entry.usage = ""Aliased CLI Command"";tttif (ast_cli_register(&alias->cli_entry)) {ttttao2_ref(alias, -1);ttttcontinue;ttt}tttao2_link(cli_aliases, alias);tttast_verb(2, ""Aliased CLI command '%s' to '%s'"", v1->name, v1->value);tttao2_ref(alias, -1);tt}t}tast_config_destroy(cfg);treturn;}",2,"cwe120,cwe469"
"OpFilePut(){   cid_fileput_it out ;   cid_fileput_ot in ;   char path[PATH_LEN] ;   struct stat buff ;   FILE *fp ;   char *data ;   int toread ;   status=system(""clear"") ;   printf(""CID_OP_PUT_FILE"") ;   printf(""---------------"") ;tttt    printf(""Enter login : "") ;   status=scanf(""%s"", out.login) ;   getchar() ;   printf(""Enter rlogin : "") ;   status=scanf(""%s"", out.rlogin) ;   getchar() ;   printf(""Enter remote path : "") ;   status=scanf(""%s"", out.path) ;   getchar() ;   printf(""Enter local path : "") ;   status=scanf(""%s"", path) ;tttt    if (stat(path, &buff) == -1)    {       printf(""OpPutFile::stat"") ;       getchar() ; getchar() ;       return ;    }   out.len = htonl(buff.st_size) ;tttt    if ((fp = fopen(path, ""r"")) == NULL)    {       printf(""OpPutFile::fopen"") ;       getchar() ; getchar() ;       return ;    }tttt    printf(""To CID :"") ;   printf(""login : %s"", out.login) ;   printf(""rlogin : %s"", out.rlogin) ;   printf(""path : %s"", out.path) ;   printf(""len : %ud"", ntohl(out.len)) ;tttt    if (!writen(cidsock, (char *)&out, sizeof(out)))    {       printf(""OpPutFile::writen"") ;       getchar() ; getchar() ;       return ;    }tttt    data = (char *) malloc(SEGMENT) ;   while (buff.st_size > 0)    {       toread = (buff.st_size >= SEGMENT) ? SEGMENT : buff.st_size ;       if (fread(data, 1, toread, fp) == toread)t  if (writen(cidsock, (char *)data, toread))t   {t      buff.st_size -= toread ;t      continue ;t   }       free(data) ;       printf(""OpPutFile::fread/writen"") ;       getchar() ; getchar() ;       return ;    }   free(data) ;tttt    if (!readn(cidsock, (char *)&in, sizeof(in)))    {       printf(""OpPutFile::readn"") ;       getchar() ; getchar() ;       return ;    }tttt    printf(""From CID :"") ;   printf(""status : %d"", ntohs(in.status)) ;   printf(""error : %d"", ntohs(in.error)) ;   getchar() ;  getchar() ;}",3,"cwe119,cwe120,cweother"
"sym_get_row_activity(sym_environment *env, double *rowact){   double * colsol;     int i, j;   int * matbeg;   double * matval;   int * matind;   if (!env->mip || !env->mip->n){      if(env->par.verbosity >= 1){t printf(""sym_get_row_activity():There is no loaded mip description or"");t printf(""no column description!"");      }      return(FUNCTION_TERMINATED_ABNORMALLY);   }   colsol = (double *)malloc(DSIZE*env->mip->n);   sym_get_col_solution(env, colsol);      matbeg = env->mip->matbeg;   matval = env->mip->matval;   matind = env->mip->matind;   memset(rowact, 0, DSIZE*env->mip->m);      for(i = 0; i<env->mip->n; i++){      for(j = matbeg[i]; j<matbeg[i+1]; j++){t rowact[matind[j]] += matval[j] * colsol[i];      }   }   return (FUNCTION_TERMINATED_NORMALLY);}",2,"cwe120,cweother"
"evhttp_append_to_last_header(struct evkeyvalq *headers, const char *line){tstruct evkeyval *header = TAILQ_LAST(headers, evkeyvalq);tchar *newval;tsize_t old_len, line_len;tif (header == NULL)ttreturn (-1);told_len = strlen(header->value);tline_len = strlen(line);tnewval = realloc(header->value, old_len + line_len + 1);tif (newval == NULL)ttreturn (-1);tmemcpy(newval + old_len, line, line_len + 1);theader->value = newval;treturn (0);}",2,"cwe120,cwe469"
"P3110_IncomingSMSHeader(int messagetype, unsigned char *message, int length, gn_data *data, struct gn_statemachine *state){tint smsc_length, remote_length, l;tgn_gsm_number_type smsc_number_type, remote_number_type;tunsigned char smsc[256], remote[256];t tswitch (message[0]) {  tcase 0x2c:ttbreak;tcase 0x2d:ttif (message[2] == 0x74)tttreturn GN_ERR_INVALIDLOCATION;ttelsetttreturn GN_ERR_EMPTYLOCATION;tdefault:ttreturn GN_ERR_INTERNALERROR;t}tif (!data->raw_sms) {ttdprintf(""Unrequested SMS header received. Ignoring."");ttreturn GN_ERR_INTERNALERROR;t}tdata->raw_sms->status = message[4];t tif (message[5] & 0x40)t ttdata->raw_sms->udh_indicator = 1;telsettdata->raw_sms->udh_indicator = 0;tdata->raw_sms->dcs = message[7];t tdata->raw_sms->dcs = 0xf4;t tdata->raw_sms->length = message[15];t tif (message[5] != 0x01) {ttmemcpy(data->raw_sms->smsc_time, message + 8, 7);tt ttsmsc_length = message[16];ttremote_length = message[17 + smsc_length];ttremote_number_type = message[17 + smsc_length + 1 + remote_length];tt ttstrncpy(smsc, message + 17, smsc_length);ttsmsc[smsc_length] = '0';ttsmsc_number_type = (smsc[0] == '+') ? GN_GSM_NUMBER_International : GN_GSM_NUMBER_Unknown;ttl = char_semi_octet_pack(smsc, data->raw_sms->message_center + 1, smsc_number_type);tt ttdata->raw_sms->message_center[0] = (l + 1) / 2 + 1;ttstrncpy(remote, message + 17 + smsc_length + 1, remote_length);ttremote[remote_length] = '0';ttl = char_semi_octet_pack(remote, data->raw_sms->remote_number + 1, remote_number_type);ttdata->raw_sms->remote_number[0] = l;t} else {ttremote[0] = '0';ttsmsc[0] = '0';t}tdprintf(""PID:%02x DCS:%02x Timezone:%02x Stat1:%02x Stat2:%02x"",ttmessage[6], message[7], message[14], message[4], message[5]);tdprintf(""Message Read:"");tdprintf(""  Location: %d. Type: %d Status: %d"", data->raw_sms->number, data->raw_sms->type, data->raw_sms->status);tdprintf(""  Sender: %s"", remote);tdprintf(""  Message Center: %s"", smsc);treturn GN_ERR_NONE;}",2,"cwe119,cwe120"
"photoset_created_cb                     (GObject      *object,                                         GAsyncResult *res,                                         gpointer      user_data){  FspSession *session = FSP_SESSION (object);  GError *error = NULL;  created_photoset_id =    fsp_session_create_photoset_finish (session, res, &error);  if (error != NULL)    {      g_print (""Error creating photoset: %s"", error->message);      g_error_free (error);    }  else    {      g_print (""[photosets_created_cb]::Success! Photo set Id: %s"",               created_photoset_id);      getchar ();             g_print (""Uploading a new picture to be added to the photoset..."");      fsp_session_upload (session,                          test_photo_path,                          ""Yet another title"",                          ""Yet another description "",                          ""yet some other tags"",                          FSP_VISIBILITY_NO,                          FSP_VISIBILITY_YES,                          FSP_VISIBILITY_NONE,                          FSP_SAFETY_LEVEL_NONE,                          FSP_CONTENT_TYPE_PHOTO,                          FSP_SEARCH_SCOPE_NONE,                          NULL, upload_cb,                          (gpointer) photoset_created_cb);    }}",2,"cwe120,cweother"
"rand_object(object_type *o_ptr, int brand_type){tint i, j;tego_item_type *e_ptr;tbool ok = FALSE;t t tif (o_ptr->kind && !cursed_p(o_ptr->flags) && o_ptr->kind->cost &&t    !o_ptr->artifact && !o_ptr->ego)t{ttchar o_name[80];ttbitflag f[OF_SIZE];ttconst char *brand[SL_MAX];ttobject_desc(o_name, sizeof(o_name), o_ptr, ODESC_BASE);ttof_wipe(f);ttof_on(f, brand_type);tti = list_slays(f, f, NULL, brand, NULL, FALSE);tttt ttmsg(""The %s %s surrounded with an aura of %s."", o_name,tttt(o_ptr->number > 1) ? ""are"" : ""is"", brand[0]);tt ttfor (i = 0; i < z_info->e_max; i++) {ttte_ptr = &e_info[i];tttif (of_has(e_ptr->flags, brand_type)) {ttttfor (j = 0; j < EGO_TVALS_MAX; j++)tttttif ((o_ptr->tval == e_ptr->tval[j]) &&tttttt(o_ptr->sval >= e_ptr->min_sval[j]) &&tttttt(o_ptr->sval <= e_ptr->max_sval[j]))ttttttok = TRUE;ttt}tttif (ok) break;tt}tto_ptr->ego = &e_info[i];ttego_apply_magic(o_ptr, 0);ttobject_notice_ego(o_ptr);tt ttp_ptr->notice |= (PN_COMBINE | PN_REORDER | PN_SORT_QUIVER);tt ttp_ptr->redraw |= (PR_INVEN | PR_EQUIP);tt ttenchant(o_ptr, randint0(3) + 4, ENCH_TOHIT | ENCH_TODAM);t}telset{ttflush();ttmsg(""The branding failed."");t}}",2,"cwe119,cwe120"
"read_and_compare(int fd, char *read_buf, char *mmap_buf, unsigned long len){t tif (read(fd, read_buf, len) != len) {ttfprintf(stderr, ""read problem:  %s"", strerror(errno));ttexit(1);t}tif (memcmp(read_buf, mmap_buf, len) != 0) {ttfprintf(stderr, ""buffer miscompare"");ttexit(1);t}}",2,"cwe120,cweother"
"SAF_ConnectService(GF_InputService *plug, GF_ClientService *serv, const char *url){tchar szURL[2048];tchar *ext;tSAFIn *read = (SAFIn *)plug->priv;tread->service = serv;tif (read->dnload) gf_term_download_del(read->dnload);tread->dnload = NULL;tstrcpy(szURL, url);text = strrchr(szURL, '#');tif (ext) ext[0] = 0;tread->needs_connection = 1;tread->duration = 0;tread->saf_type = SAF_FILE_LOCAL;t tif (strnicmp(url, ""file://"", 7) && strstr(url, ""://"")) {ttread->saf_type = SAF_FILE_REMOTE;ttSAF_DownloadFile(plug, (char *) szURL);ttreturn GF_OK;t}tread->stream = gf_f64_open(szURL, ""rb"");tif (!read->stream) {ttgf_term_on_connect(serv, NULL, GF_URL_ERROR);ttreturn GF_OK;t}tSAF_CheckFile(read);tread->th = gf_th_new(""SAFDemux"");t tgf_th_run(read->th, SAF_Run, read);treturn GF_OK;}",3,"cwe119,cwe120,cweother"
"ase64_encode_alloc (const char *in, size_t inlen, char **out){  size_t outlen = 1 + BASE64_LENGTH (inlen);     if (inlen > outlen)    {      *out = NULL;      return 0;    }  *out = malloc (outlen);  if (!*out)    return outlen;  base64_encode (in, inlen, *out, outlen);  return outlen - 1;}",2,"cwe119,cwe120"
"diffdir(char *f, char *t, int level){tchar  **df, **dt, **dirf, **dirt;tchar *from, *to;tint res;tchar fb[MAXPATHLEN+1], tb[MAXPATHLEN+1];tdf = scandir(f);tdt = scandir(t);tdirf = df;tdirt = dt;tif(df == nil || dt == nil)ttgoto Out;twhile (*df || *dt) {ttfrom = *df;ttto = *dt;ttif (from && isdotordotdot(from)) {tttdf++;tttcontinue;tt}ttif (to && isdotordotdot(to)) {tttdt++;tttcontinue;tt}ttif (!from)tttres = 1;ttelse if (!to)tttres = -1;ttelsetttres = strcmp(from, to);ttif (res < 0) {tttif (mode == 0 || mode == 'n')ttttBprint(&stdout, ""Only in %s: %s"", f, from);tttdf++;tttcontinue;tt}ttif (res > 0) {tttif (mode == 0 || mode == 'n')ttttBprint(&stdout, ""Only in %s: %s"", t, to);tttdt++;tttcontinue;tt}ttif (mkpathname(fb, f, from))tttcontinue;ttif (mkpathname(tb, t, to))tttcontinue;ttdiff(fb, tb, level+1);ttdf++; dt++;t}Out:tfor (df = dirf; df && *df; df++)ttFREE(*df);tfor (dt = dirt; dt && *dt; dt++)ttFREE(*dt);tFREE(dirf);tFREE(dirt);}",2,"cwe119,cwe120"
"changeSize(But *but)  {  CliMatch  *m = but_packet(but);  char  sizeStr[3];  assert(MAGIC(m));  if (newSize(m->sizeIn, butTextin_get(m->sizeIn)) & BUTOUT_ERR)    return(BUTOUT_ERR);  if (but == m->sizeUp)  {    if (m->size < 13)      m->size = 13;    else      m->size = 19;  } else  {    assert(but == m->sizeDown);    if (m->size > 13)      m->size = 13;    else      m->size = 9;  }  sprintf(sizeStr, ""%d"", m->size);  butTextin_set(m->sizeIn, sizeStr, TRUE);  return(0);}",2,"cwe119,cwe120"
"FormatNumber(int formatting, int n){    char label[20];    switch (formatting) {            case ALPHA_NUMBERING:            snprintf(label, 20, ""%c"", (char) (n + (int) 'A' - 1) );            break;            case ARABIC_NUMBERING:            snprintf(label, 20, ""%d"", n);            break;                    case ROMAN_NUMBERING:            return roman_item(n, TRUE);    }        return strdup(label);}",2,"cwe469,cweother"
"zxid_parse_vurl(zxid_conf* cf, char* vurl){  char newurl[PATH_MAX];  zxid_expand_percent(vurl, newurl, newurl + sizeof(newurl), 1);  if (--zxid_suppress_vpath_warning > 0)    INFO(""VURL(%s) alters URL(%s) to new URL(%s)"", vurl, cf->url, newurl);  cf->url = zx_dup_cstr(cf->ctx, newurl);  return 1;}",2,"cwe119,cwe120"
"mob_spawn_dataset(struct mob_data *md,const char *mobname,int class_){tnullpo_retr(0, md);tmd->bl.type = BL_MOB;tmd->bl.prev = NULL;tmd->bl.next = NULL;tif(strcmp(mobname,""--en--"") == 0) {ttmemcpy(md->name,mob_db[class_].name,24);t} else if(strcmp(mobname,""--ja--"") == 0) {ttmemcpy(md->name,mob_db[class_].jname,24);t} else {ttstrncpy(md->name,mobname,24);ttmd->name[23] = '0';t t}tmd->n          = 0;tmd->base_class = class_;tmd->class_     = class_;tmd->bl.id      = npc_get_new_npc_id();tmemset(&md->state,0,sizeof(md->state));tmd->target_id   = 0;tmd->attacked_id = 0;tmd->guild_id    = 0;tmd->speed       = mob_db[class_].speed;tunit_dataset( &md->bl );treturn 0;}",2,"cwe120,cwe469"
"ShowDebriefing( Player &player, bool restart ) {  GUI_Status rc = GUI_OK;  if ( player.IsInteractive() ) {    Player *winner = NULL;    bool draw = false;    const char *msg;    Player &p1 = mission->GetPlayer(PLAYER_ONE);    Player &p2 = mission->GetPlayer(PLAYER_TWO);    if ( p1.Success( 0 ) >= 100 ) winner = &p1;    if ( p2.Success( 0 ) >= 100 ) {      if ( winner ) draw = true;      else winner = &p2;    }    if ( draw ) msg = MSG(MSG_RESULT_DRAW);    else if ( &player == winner ) msg = MSG(MSG_RESULT_VICTORY);    else msg = MSG(MSG_RESULT_DEFEAT);    NoteWindow *note = new NoteWindow( MSG(MSG_DEBRIEFING), msg, WIN_CENTER, view );    if ( restart ) {      const char *next_map = NULL;      if ( mission->GetFlags() & GI_CAMPAIGN ) next_map = mission->GetSequel();      if ( !next_map || draw || !winner->IsHuman() ) {        note->SetButtonID( 0, G_BUTTON_SHUTDOWN );        note->SetButtonHook( 0, this );      } else {        note->EventLoop();        view->CloseWindow( note );        CFOptions.Unlock( next_map );        int err = SwitchMap( next_map );        if ( err == -1 ) {          note = new NoteWindow( MSG(MSG_ERROR), MSG(MSG_ERR_MAP_NOT_FOUND), 0, view );          note->SetButtonID( 0, G_BUTTON_SHUTDOWN );          note->SetButtonHook( 0, this );        } else {          InitWindows();          rc = StartTurn();        }      }    } else {      note->EventLoop();      view->CloseWindow( note );    }  } else if ( restart ) rc = GUI_RESTART;  return rc;}",2,"cwe476,cweother"
"cbf_get_bits (cbf_file *file, int *bitslist, int bitcount){  int bitcode, count, m, maxbits;       maxbits = sizeof (int) * CHAR_BIT;       while (bitcount > maxbits)  {    cbf_failnez (cbf_get_bits (file, bitslist, maxbits))    bitslist++;    bitcount -= maxbits;  }       count = file->bits [0];  bitcode = file->bits [1] & 0x0ff;  while (count < bitcount)  {    if (file->temporary) {            if (file->characters_used) {              file->bits [1] = *((file->characters)++);                  file->bits [1] &= 0xFF;                  file->characters_used--;                  file->characters_size--;              } else {                file->bits [1] = EOF;        t      }      t    } else {      if (file->characters_used) {              file->bits [1] = *((file->characters)++);                  file->bits [1] &= 0xFF;                  file->characters_used--;                  file->characters_size--;              } else {      t        file->bits [1] = getc (file->stream);      }     }    if (file->bits [1] == EOF)      return CBF_FILEREAD;    file->bits [0] = 8;    bitcode |= (file->bits [1] << count) & -(1 << count);    count += 8;  }  file->bits [1] = (file->bits [1] >> (file->bits [0] - (count - bitcount)));  file->bits [0] = count - bitcount;       m = 1 << (bitcount - 1);  if (bitcode & m)    *bitslist = bitcode | -m;  else    *bitslist = bitcode & ~-m;       return 0;}",2,"cwe120,cweother"
"print_disk (int announce, char* format){tchar string[bsize] = {0,};#if 0tif (*word == '0')t{ttif (xs_parse_df (NULL, string))tt{ttthexchat_printf (ph, ""ERROR in parse_df"");tttreturn HEXCHAT_EAT_ALL;tt}t}telset{ttif (xs_parse_df (*word, string))tt{ttthexchat_printf (ph, ""ERROR in parse_df"");tttreturn HEXCHAT_EAT_ALL;tt}t}#endiftif (xs_parse_df (NULL, string))t{tthexchat_printf (ph, ""%stERROR in parse_df"", name);ttreturn HEXCHAT_EAT_ALL;t}tformat_output (""Disk"", string, format);tif (announce)t{tthexchat_commandf (ph, ""SAY %s"", string);t}telset{tthexchat_printf (ph, ""%s"", string);t}treturn HEXCHAT_EAT_ALL;}",2,"cwe119,cwe120"
"parse_ns_labels(packet_t *pkt, char *name){  u_int8_t count;  u_int16_t offset;  int read_a_label = 0;  char label[MAX_LABEL_SIZE];  int first_offset = 0;  while(1)    {      if (get_packet_bytes((u_int8_t *) &count, pkt, 1) == 0)treturn;             if (count == 0) tbreak;             if (count > MAX_LABEL_SIZE && count < 192)tcount = MAX_LABEL_SIZE;             if (read_a_label)tset_nslabel_next();      new_nslabel();      if (!first_offset)t{t  first_offset = get_packet_markdistance(pkt)-1;t}      set_nslabel_offset(get_packet_markdistance(pkt)-1);             if (count >= 192)t{t   t  t  offset = count - 192;t  offset = offset << 8;t  if (get_packet_bytes((u_int8_t *) &count, pkt, 1) == 0)t    return;t  offset = offset + count;t  get_nslabel(offset, name);t  set_nslabel_label(name);t  return;t}             if (get_packet_bytes((u_int8_t *) &label, pkt, count ) == 0)treturn;      label[count] = '0';      set_nslabel_label(label);      read_a_label = 1;    }    get_nslabel(first_offset, name);    return;}",3,"cwe119,cwe120,cweother"
"Dir_FindHereOrAbove(char *here, char *search_path, char *result, int rlen){tstruct stat st;tchar dirbase[MAXPATHLEN + 1], *db_end;tchar try[MAXPATHLEN + 1], *try_end;t tsnprintf(dirbase, sizeof(dirbase), ""%s"", here);tdb_end = dirbase + strlen(dirbase);t twhile (1) {tt ttsnprintf(try, sizeof(try), ""%s/%s"", dirbase, search_path);ttif (stat(try, &st) != -1) {ttt tttif ((st.st_mode & S_IFMT) != S_IFDIR) {tttttry_end = try + strlen(try);ttttwhile (try_end > try && *try_end != '/')ttttttry_end--;ttttif (try_end > try)ttttt*try_end = 0;t ttt}ttt tttsnprintf(result, rlen, ""%s"", try);tttreturn(1);tt}tt ttif (db_end == dirbase)tttbreak;tt tt ttwhile (db_end > dirbase && *db_end != '/')tttdb_end--;tt*db_end = 0;tt t}  t treturn(0);}",2,"cwe119,cwe120"
"_dxf_MakeXImage(int width, int height, int depth, char *where){    Field i = NULL;    Array a = NULL;    translationPttranslation;    Private w_obj = NULL;    struct window *w;    char *s, copy[201], *host = NULL, *window = NULL;    int directMap = 0;    strcpy(copy, where);    for (s = copy; *s && !window; s++)tif (*s == ',')t{t    if (host == NULL) tthost = s+1;t    elset        window = s+1;t    t    *s = '0';t}         i = DXNewField();    if (!i) goto error;         a = DXMakeGridPositions(2, height,width,ttt    0.0,0.0,ttt    0.0,1.0, 1.0,0.0);    if (!a) goto error;    DXSetComponentValue(i, POSITIONS, (Object)a);    a = NULL;         a = DXMakeGridConnections(2, height,width);    if (!a) goto error;    DXSetConnections(i, ""quads"", a);    a = NULL;    XSetErrorHandler(error_handler);    if (! getWindowStructure(host, depth, window, &directMap, &w, &w_obj, 0))tgoto error;    translation = w->translation;    if (!translation)tgoto error;    if (_dxf_GetXBytesPerPixel(translation) == 4)    {      a = DXNewArray(TYPE_UINT, CATEGORY_REAL, 0);    }    else if (_dxf_GetXBytesPerPixel(translation) == 3)    {      a = DXNewArray(TYPE_UBYTE, CATEGORY_REAL, 1, 3);    }    else if (_dxf_GetXBytesPerPixel(translation) == 2)    {      a = DXNewArray(TYPE_USHORT, CATEGORY_REAL, 0);    }    else    {      a = DXNewArray(TYPE_UBYTE, CATEGORY_REAL, 0);    }    if (!a)tgoto error;    if (!DXAddArrayData(a, 0, width*height, NULL))    {tDXAddMessage(""can't make %dx%d image"", width, height);tgoto error;    }    DXSetAttribute((Object)a, IMAGE_TYPE, O_X_IMAGE);    DXSetAttribute((Object)a, X_SERVER, w->translation_owner);    DXSetComponentValue(i, IMAGE, (Object)a);    a = NULL;    DXDelete((Object)w_obj);         return DXEndField(i);error:    DXDelete((Object)w_obj);    DXDelete((Object)a);    DXDelete((Object)i);    return NULL;}",2,"cwe119,cwe120"
"intel_dp_print_rates(struct intel_dp *intel_dp){tstruct drm_device *dev = intel_dp_to_dev(intel_dp);tconst int *source_rates, *sink_rates;tint source_len, sink_len, common_len;tint common_rates[DP_MAX_SUPPORTED_RATES];tchar str[128];  tif ((drm_debug & DRM_UT_KMS) == 0)ttreturn;tsource_len = intel_dp_source_rates(dev, &source_rates);tsnprintf_int_array(str, sizeof(str), source_rates, source_len);tDRM_DEBUG_KMS(""source rates: %s"", str);tsink_len = intel_dp_sink_rates(intel_dp, &sink_rates);tsnprintf_int_array(str, sizeof(str), sink_rates, sink_len);tDRM_DEBUG_KMS(""sink rates: %s"", str);tcommon_len = intel_dp_common_rates(intel_dp, common_rates);tsnprintf_int_array(str, sizeof(str), common_rates, common_len);tDRM_DEBUG_KMS(""common rates: %s"", str);}",2,"cwe119,cwe120"
"client_connect(void){    ssize_t r;    size_t p = 0;    char *path;#ifdef HAVE_UNIX_DOMAIN_SOCKETS    struct sockaddr_un sa;#else    struct sockaddr_in sa;#endif    char banner[sizeof(OVDB_SERVER_BANNER)];    fd_set fds;    struct timeval timeout;#ifdef HAVE_UNIX_DOMAIN_SOCKETS    clientfd = socket(AF_UNIX, SOCK_STREAM, 0);#else    clientfd = socket(AF_INET, SOCK_STREAM, 0);#endif    if(clientfd < 0) {        syswarn(""OVDB: socket"");treturn -1;    }    memset(&sa, 0, sizeof sa);#ifdef HAVE_UNIX_DOMAIN_SOCKETS    sa.sun_family = AF_UNIX;    path = concatpath(innconf->pathrun, OVDB_SERVER_SOCKET);    strlcpy(sa.sun_path, path, sizeof(sa.sun_path));    free(path);    r = connect(clientfd, (struct sockaddr *) &sa, SUN_LEN(&sa));#else    sa.sin_family = AF_INET;    sa.sin_port = 0;    sa.sin_addr.s_addr = htonl(0x7f000001UL);    bind(clientfd, (struct sockaddr *) &sa, sizeof sa);    sa.sin_port = htons(OVDB_SERVER_PORT);    r = connect(clientfd, (struct sockaddr *) &sa, sizeof sa);#endif    if(r != 0) {        syswarn(""OVDB: rc: cant connect to server"");tclose(clientfd);tclientfd = -1;treturn -1;    }    while(p < sizeof(OVDB_SERVER_BANNER)) {tFD_ZERO(&fds);tFD_SET(clientfd, &fds);ttimeout.tv_sec = 30;ttimeout.tv_usec = 0;tr = select(clientfd+1, &fds, NULL, NULL, &timeout);tif(r < 0) {t    if(errno == EINTR)t    tcontinue;            syswarn(""OVDB: select"");t    close(clientfd);t    clientfd = -1;t    return -1;t}tif(r == 0) {            warn(""OVDB: rc: timeout waiting for server"");t    close(clientfd);t    clientfd = -1;t    return -1;    t}tr = read(clientfd, banner + p, sizeof(OVDB_SERVER_BANNER) - p);tif(r <= 0) {t    if(r < 0 && errno == EINTR)ttcontinue;            syswarn(""OVDB: rc: cant read"");t    close(clientfd);t    clientfd = -1;t    return -1;t}tp+= r;    }    if(memcmp(banner, OVDB_SERVER_BANNER, sizeof(OVDB_SERVER_BANNER))) {        warn(""OVDB: rc: unknown reply from server"");tclose(clientfd);tclientfd = -1;treturn -1;    }    return 0;}",3,"cwe119,cwe120,cweother"
"putf(char *cp, char *where){#ifdef HAVE_UNAME    struct utsname name;#endif    char *slash;    time_t t;    char db[100];         char *sysname = ""Unix"",t*machine = """",t*release = """",t*version = """";#ifdef HAVE_UNAME    uname(&name);    sysname=name.sysname;    machine=name.machine;    release=name.release;    version=name.version;#endif    putlocation = where;    while (*cp) {tif (*cp != '%') {t    putchr(*cp++);t    continue;t}tswitch (*++cp) {tcase 't':t    slash = strchr(line+1, '/');t    if (slash == (char *) 0)ttputstr(line);t    elsettputstr(&slash[1]);t    break;tcase 'h':t    putstr(editedhost);t    break;tcase 's':t    putstr(sysname);t    break;tcase 'm':t    putstr(machine);t    break;tcase 'r':t    putstr(release);t    break;tcase 'v':t    putstr(version);t    break;tcase 'd':t    time(&t);t    strftime(db, sizeof(db), fmtstr, localtime(&t));t    putstr(db);t    break;tcase '%':t    putchr('%');t    break;t}tcp++;    }}",2,"cwe119,cwe120"
"sp2_write_i2c(struct sp2 *s, u8 reg, u8 *buf, int len){tint ret;tu8 buffer[35];tstruct i2c_client *client = s->client;tstruct i2c_adapter *adap = client->adapter;tstruct i2c_msg msg = {tt.addr = client->addr,tt.flags = 0,tt.buf = &buffer[0],tt.len = len + 1t};tif ((len + 1) > sizeof(buffer)) {ttdev_err(&client->dev, ""i2c wr reg=%02x: len=%d is too big!"",ttttreg, len);ttreturn -EINVAL;t}tbuffer[0] = reg;tmemcpy(&buffer[1], buf, len);tret = i2c_transfer(adap, &msg, 1);tif (ret != 1) {ttdev_err(&client->dev, ""i2c write error, reg = 0x%02x, status = %d"",ttttreg, ret);ttif (ret < 0)tttreturn ret;ttelsetttreturn -EIO;t}tdev_dbg(&s->client->dev, ""addr=0x%04x, reg = 0x%02x, data = %*ph"",ttttclient->addr, reg, len, buf);treturn 0;}",2,"cwe120,cweother"
"ldns_init_random(FILE *fd, unsigned int size){t tFILE *rand_f;tuint8_t *seed;tsize_t read = 0;tunsigned int seed_i;tstruct timeval tv;t tif (size < (unsigned int) sizeof(seed_i)){ttsize = (unsigned int) sizeof(seed_i);t}tseed = LDNS_XMALLOC(uint8_t, size);        if(!seed) {ttreturn 1;        }tif (!fd) {ttif ((rand_f = fopen(""/dev/urandom"", ""r"")) == NULL) {ttt tttif ((rand_f = fopen(""/dev/random"", ""r"")) == NULL) {tttt ttttfor (read = 0; read < size; read++) {tttttgettimeofday(&tv, NULL);tttttseed[read] = (uint8_t) (tv.tv_usec % 256);tttt}ttt} else {ttttread = fread(seed, 1, size, rand_f);ttt}tt} else {tttread = fread(seed, 1, size, rand_f);tt}t} else {ttrand_f = fd;ttread = fread(seed, 1, size, rand_f);t}tif (read < size) {ttLDNS_FREE(seed);ttif (!fd) fclose(rand_f);ttreturn 1;t} else {#ifdef HAVE_SSLtt ttRAND_seed(seed, (int) size);#elsett ttmemcpy(&seed_i, seed, sizeof(seed_i));ttsrandom(seed_i);#endifttLDNS_FREE(seed);t}tif (!fd) {                if (rand_f) fclose(rand_f);t}treturn 0;}",2,"cwe120,cweother"
"cmp_salt (const krb5_salt *salt, const krb5_key_data *k){    if (salt->salttype != (size_t)k->key_data_type[1])treturn 1;    if (salt->saltvalue.length != (size_t)k->key_data_length[1])treturn 1;    return memcmp (salt->saltvalue.data, k->key_data_contents[1],tt   salt->saltvalue.length);}",2,"cwe119,cwe120"
"""get_tag(int emptyOk){    register int c;    register int i;    register char *s;    int t_lineno = lineno;    char *t_line = dup_line();    char *t_cptr = t_line + (cptr - line);    ++cptr;    c = nextc();    if (c == EOF) unexpected_EOF();    if (emptyOk && c == '>') {      ++cptr; return 0;t// 0 indicates empty tag if emptyOk    }    if (!isalpha(c) && c != '_' && c != '$')tillegal_tag(t_lineno, t_line, t_cptr);    cinc = 0;    do { cachec(c); c = *++cptr; } while (IS_IDENT(c));    cachec(NUL);    c = nextc();    if (c == EOF) unexpected_EOF();    if (c != '>')tillegal_tag(t_lineno, t_line, t_cptr);    ++cptr;    for (i = 0; i < ntags; ++i)    {tif (strcmp(cache, tag_table[i]) == 0)t    return (tag_table[i]);    }    if (ntags >= tagmax)    {ttagmax += 16;ttag_table = (char **)ttt(tag_table ? REALLOC(tag_table, tagmax*sizeof(char *))tttt   : MALLOC(tagmax*sizeof(char *)));tif (tag_table == 0) no_space();    }    s = MALLOC(cinc);    if  (s == 0) no_space();    strcpy(s, cache);    tag_table[ntags] = s;    ++ntags;    FREE(t_line);    return (s);}""",3,"cwe119,cwe120,cweother"
"httpd_mime_next(httpd_conn_t * conn, const char *content_id,                const char *content_type, const char *transfer_encoding){  herror_t status;  char buffer[512];  char boundary[75];     _httpd_mime_get_boundary(conn, boundary);  sprintf(buffer, ""r--%sr"", boundary);     status =    http_output_stream_write(conn->out, (const byte_t *) buffer,                             strlen(buffer));  if (status != H_OK)    return status;     sprintf(buffer, ""%s: %sr%s: %sr%s: %srr"",          HEADER_CONTENT_TYPE, content_type ? content_type : ""text/plain"",          HEADER_CONTENT_TRANSFER_ENCODING,          transfer_encoding ? transfer_encoding : ""binary"",          HEADER_CONTENT_ID,          content_id ? content_id : ""<content-id-not-set>"");  status =    http_output_stream_write(conn->out, (const byte_t *) buffer,                             strlen(buffer));  return status;}",2,"cwe119,cwe120"
"umoven(struct tcb *tcp, long addr, int len, char *laddr){#ifdef LINUXtint pid = tcp->pid;tint n, m;tint started = 0;tunion {ttlong val;ttchar x[sizeof(long)];t} u;tif (addr & (sizeof(long) - 1)) {tt ttn = addr - (addr & -sizeof(long));  ttaddr &= -sizeof(long);  tterrno = 0;ttu.val = ptrace(PTRACE_PEEKDATA, pid, (char *) addr, 0);ttif (errno) {tttif (started && (errno==EPERM || errno==EIO)) {tttt ttttreturn 0;ttt}ttt tttif (addr != 0 && errno != EIO && errno != ESRCH)ttttperror(""ptrace: umoven"");tttreturn -1;tt}ttstarted = 1;ttmemcpy(laddr, &u.x[n], m = MIN(sizeof(long) - n, len));ttaddr += sizeof(long), laddr += m, len -= m;t}twhile (len) {tterrno = 0;ttu.val = ptrace(PTRACE_PEEKDATA, pid, (char *) addr, 0);ttif (errno) {tttif (started && (errno==EPERM || errno==EIO)) {tttt ttttreturn 0;ttt}tttif (addr != 0 && errno != EIO && errno != ESRCH)ttttperror(""ptrace: umoven"");tttreturn -1;tt}ttstarted = 1;ttmemcpy(laddr, u.x, m = MIN(sizeof(long), len));ttaddr += sizeof(long), laddr += m, len -= m;t}#endif  #ifdef SUNOS4tint pid = tcp->pid;tint n;twhile (len) {ttn = MIN(len, PAGSIZ);ttn = MIN(n, ((addr + PAGSIZ) & PAGMASK) - addr);ttif (ptrace(PTRACE_READDATA, pid,ttt   (char *) addr, len, laddr) < 0) {tttif (errno != ESRCH) {ttttperror(""umoven: ptrace(PTRACE_READDATA, ...)"");ttttabort();ttt}tttreturn -1;tt}ttlen -= n;ttaddr += n;ttladdr += n;t}#endif  #ifdef USE_PROCFS#ifdef HAVE_MP_PROCFStint fd = tcp->pfd_as;#elsetint fd = tcp->pfd;#endiftlseek(fd, addr, SEEK_SET);tif (read(fd, laddr, len) == -1)ttreturn -1;#endif  treturn 0;}",3,"cwe119,cwe120,cweother"
"push_token(PDFSCAN *ps){    ref r;    int len = ps->end - ps->begin;    const char *p = ps->buf + ps->begin;    r.type = ps->token_type;    r.rsize = 0;    r.value.voidval = NULL;    switch(r.type) {      case invalidtype:tbreak;      case marktype:tbreak;      case nulltype:tbreak;      case booltype:tif ((len == 4) && (memcmp(p, ""true"", 4)==0))t    r.value.boolval = TRUE;telse if ((len == 5) && (memcmp(p, ""true"", 5)==0))t    r.value.boolval = FALSE;telset    r = invalidref;tbreak;      case integertype:t{   char buf[64];t    if (len > (int)sizeof(buf)-1)ttr = invalidref;t    else {ttmemcpy(buf, p, len);ttbuf[len] = '0';ttr.value.intval = atoi(buf);t    }t}tbreak;      case realtype:t{   char buf[64];t    if (len > (int)sizeof(buf)-1)ttr = invalidref;t    else {ttmemcpy(buf, p, len);ttbuf[len] = '0';ttr.value.realval = (float)atof(buf);t    }t}tbreak;      case nametype:tr = make_name(ps, p+1, len-1);tbreak;      case stringtype:tr = make_string(ps, p, len);tbreak;      case streamtype:      case commenttype:      case objtype:      case optype:      case arraytype:      case dicttype:t t treturn invalidref;      default:tr.type = invalidtype;tbreak;    }    push_stack(ps, r);    return r;}",3,"cwe119,cwe120,cweother"
"add_logxtics( FL_OBJECT * ob ){    FLI_XYPLOT_SPEC *sp = ob->spec;    float tic = sp->xtic,          xw;    int xr,        ticl = 6,        i,        yi,        yf;    char label[ 80 ];    if ( tic < 0 )        return;    yi = sp->yf + 1;    yf = yi + ticl / 2;    for ( i = 0; i < sp->num_xminor; i++ )    {        xr = sp->xtic_minor[ i ];        fl_line( xr, yi, xr, yf, ob->col2 );    }    yi = sp->yf;    yf = yi + ticl;    for ( i = 0; i < sp->num_xmajor; i++ )    {        xr = sp->xtic_major[ i ];        fl_line( xr, yi, xr, yf, ob->col2 );        xw = sp->xmajor_val[ i ];        if ( sp->xbase == 10.0 )        {            sprintf( label, ""%g"", pow( sp->xbase, xw ) );            fl_drw_text( FL_ALIGN_TOP, xr, sp->yf + ticl - 2, 0, 0,                         ob->col2, sp->lstyle, sp->lsize, label );        }        else        {            int len1,                len2,                ll;            ll = sprintf( label, ""%g"", sp->xbase );            fl_drw_text( FL_ALIGN_TOP, xr - 3, yf - 2, 0, 0,                         ob->col2, sp->lstyle, sp->lsize, label );            len1 = fl_get_string_width( sp->lstyle, sp->lsize, label, ll );            ll = sprintf( label, ""%d"", ( int ) ceil( xw ) );            len2 = fl_get_string_width( sp->lstyle, sp->lsize, label, ll );            fl_drw_text( FL_ALIGN_TOP, xr - 3 + len1 / 2 + 1 + len2 / 2,                         yf - 6, 0, 0, ob->col2, sp->lstyle, sp->lsize, label );        }    }}",2,"cwe119,cwe120"
"make_work_pssm(length)int length;{  struct work_pssm *pssm;  int pos, aa;  double* double_pointer;  CheckMem(           pssm = (struct work_pssm *) malloc(sizeof(struct work_pssm))           );        double_pointer = (double*) calloc (length * AASALL, sizeof (double));        pssm->value = (double **) calloc (length, sizeof (double*));        pssm->sum = (double *) calloc (length, sizeof (double));  for (pos = 0; pos < length; pos++) {        pssm->value[pos] = &(double_pointer[pos * AASALL]);  }  for (pos = 0; pos < length; pos++) {    pssm->sum[pos] = 0.0;    for (aa=0; aa < AASALL; aa++) {      pssm->value[pos][aa] = 0.0;    }  }    return pssm;}",2,"cwe476,cweother"
"make_arglist (char *program, char *arg1, char *arg2, char *arg3, int procs_n,t      int *procs){  int i;  char **args = NULL;  char buf[10];  args = malloc ((5 + procs_n) * sizeof (char *));  args[0] = malloc ((strlen (program) + 1) * sizeof (char));  args[1] = malloc ((strlen (arg1) + 1) * sizeof (char));  args[2] = malloc ((strlen (arg2) + 1) * sizeof (char));     args[3] = malloc ((strlen (program) + 1) * sizeof (char));  args[4] = malloc ((strlen (arg3) + 1) * sizeof (char));  for (i = 5; i < procs_n + 5; i++) {    int i_procs = i - 5;    int blacklisted = 0;    int j;    for (j = 0; j < blacklist_c; j++) {      if (blacklist[j] == procs[i_procs]) {tblacklisted = 1;tbreak;      }    }    if (blacklisted)      break;    sprintf (buf, ""%d"", procs[i_procs]);    args[i] = malloc ((strlen (buf) + 1) * sizeof (char));    strcpy (args[i], buf);  }  strcpy (args[0], program);  strcpy (args[1], arg1);  strcpy (args[2], arg2);  strcpy (args[3], program);  strcpy (args[4], arg3);  args[procs_n + 5] = NULL;  return args;}",2,"cwe120,cweother"
"SendTransaction(int sd,char *buffer,int len,char status){ char work[CF_BUFSIZE];  int wlen;memset(work, 0, sizeof(work)); if (len == 0)    {   wlen = strlen(buffer);   }else   {   wlen = len;   }    if (wlen > CF_BUFSIZE-CF_INBAND_OFFSET)   {   CfOut(cf_error, """", ""SenTransaction: wlen (%d) > %d - %d"", wlen, CF_BUFSIZE, CF_INBAND_OFFSET);   FatalError(""SendTransaction software failure"");   } snprintf(work,CF_INBAND_OFFSET,""%c %d"",status,wlen);memcpy(work+CF_INBAND_OFFSET,buffer,wlen);Debug(""Transaction Send[%s][Packed text]"",work);  if (SendSocketStream(sd,work,wlen+CF_INBAND_OFFSET,0) == -1)   {   return -1;   }return 0; }",2,"cwe119,cwe120"
"CLUSTERIP_check(unsigned int flags){tif (flags == 0)ttreturn;tif ((flags & (PARAM_NEW|PARAM_HMODE|PARAM_MAC|PARAM_TOTALNODE|PARAM_LOCALNODE))tt== (PARAM_NEW|PARAM_HMODE|PARAM_MAC|PARAM_TOTALNODE|PARAM_LOCALNODE))ttreturn;txtables_error(PARAMETER_PROBLEM, ""CLUSTERIP target: Invalid parameter combination"");}",2,"cwe119,cwe120"
"from_uio_find_associated_eth_device(nic_t *nic,ttttt       int uio_minor,ttttt       char *name, size_t name_size){tchar *path;tint rc;tint count;tstruct dirent **files;tchar *parsed_name;tint i;tint path_iterator;tchar *search_paths[] = { ""/sys/class/uio/uio%i/device/"",tt""/sys/class/uio/uio%i/device/net""t};tint path_to[] = { 5, 1 };tint (*search_filters[]) (const struct dirent *) = {tfilter_net_name, filter_dot_out,};tchar *(*extract_name[]) (struct dirent **files) = {textract_net_name, extract_none,};tint extract_name_offset[] = { 1, 0 };tpath = malloc(PATH_MAX);tif (path == NULL) {ttLOG_ERR(PFX ""Could not allocate memory for path"");ttrc = -ENOMEM;ttgoto error;t}tfor (path_iterator = 0;t     path_iterator < sizeof(search_paths) / sizeof(search_paths[0]);t     path_iterator++) {tt ttrc = sprintf(path, search_paths[path_iterator], uio_minor);ttwait_for_file_node_timed(nic, path, path_to[path_iterator]);ttcount = scandir(path, &files,ttttsearch_filters[path_iterator], alphasort);ttswitch (count) {ttcase 1:tttparsed_name = (*extract_name[path_iterator]) (files);tttif (parsed_name == NULL) {ttttLOG_WARN(PFX ""Couldn't find delimiter in: %s"",ttttt files[0]->d_name);ttttbreak;ttt}tttstrncpy(name,ttttparsed_name +ttttextract_name_offset[path_iterator], name_size);tttfree(files[0]);tttfree(files);tttrc = 0;tttbreak;ttcase 0:tttrc = -EINVAL;tttbreak;ttcase -1:tttLOG_WARN(PFX ""Error when scanning path: %s[%s]"",tttt path, strerror(errno));tttrc = -EINVAL;tttbreak;ttdefault:tttLOG_WARN(PFXtttt ""Too many entries when looking for device: %s"",tttt path);ttt tttfor (i = 0; i < count; i++)ttttfree(files[i]);tttfree(files);tttrc = -EINVAL;tttbreak;tt}ttif (rc == 0)tttbreak;t}error:tfree(path);treturn rc;}",2,"cwe120,cweother"
"git_path_find_dir(git_buf *dir, const char *path, const char *base){tint error = git_path_join_unrooted(dir, path, base, NULL);tif (!error) {ttchar buf[GIT_PATH_MAX];ttif (p_realpath(dir->ptr, buf) != NULL)ttterror = git_buf_sets(dir, buf);t}t tif (!error && git_path_isdir(dir->ptr) == false)tterror = git_path_dirname_r(dir, dir->ptr);tif (!error)tterror = git_path_to_dir(dir);treturn error;}",2,"cwe119,cwe120"
"command_get_environment(char * token, Channel * c) {    char id[256];    pid_t pid = 0;    pid_t parent = 0;    int err = 0;    char dir[FILE_PATH_SIZE];    int f = -1;    json_read_string(&c->inp, id, sizeof(id));    if (read_stream(&c->inp) != 0) exception(ERR_JSON_SYNTAX);    if (read_stream(&c->inp) != MARKER_EOM) exception(ERR_JSON_SYNTAX);    write_stringz(&c->out, ""R"");    write_stringz(&c->out, token);    pid = id2pid(id, &parent);    if (pid != 0 && parent == 0) {        struct stat st;        snprintf(dir, sizeof(dir), ""/proc/%d"", pid);        if (lstat(dir, &st) < 0) err = errno;        else if (!S_ISDIR(st.st_mode)) err = ERR_INV_CONTEXT;    }    else {        err = ERR_INV_CONTEXT;    }    if (err == 0 && chdir(dir) < 0) err = errno;    if (err == 0 && (f = open(""environ"", O_RDONLY)) < 0) err = errno;    write_errno(&c->out, err);    if (err == 0) {        write_string_array(&c->out, f);        close(f);        write_stream(&c->out, 0);    }    else {        write_stringz(&c->out, ""null"");    }    write_stream(&c->out, MARKER_EOM);}",3,"cwe119,cwe120,cweother"
"search_by_title(void){tunsigned long i;tchar title[256];tprintf(""Title of Book to (linearly) search for? "");tclear_stream();tscanf(""%[0-9a-zA-Z.:!'?,)( ]"", title);tfor (i = 0; i < db.numberOfBooks; i++) {ttif (strcmp(db.arr[i].title, title) == 0) {tttprintf(""ID    : %ld"",   db.arr[i].id);tttprintf(""Author: %s %s"", db.arr[i].authors[0].first, db.arr[i].authors[0].last);tttprintf(""Year  : %d"",    db.arr[i].yearPublished);tttreturn;tt}t}tprintf(""No Book with that title"");treturn;}",2,"cwe119,cwe120"
"do_read (int dev, unsigned char * buffer, int try, int block_size,tt    blk_t current_block){tlong got;tstruct timeval tv1, tv2;#define NANOSEC (1000000000L)#define MILISEC (1000L)tset_o_direct(dev, buffer, try * block_size, current_block);tif (v_flag > 1)ttprint_status();t tif (ext2fs_llseek (dev, (ext2_loff_t) current_block * block_size,ttt SEEK_SET) != (ext2_loff_t) current_block * block_size)ttcom_err (program_name, errno, _(""during seek""));t tif (d_flag)ttgettimeofday(&tv1, NULL);tgot = read (dev, buffer, try * block_size);tif (d_flag)ttgettimeofday(&tv2, NULL);tif (got < 0)ttgot = 0;tif (got & 511)ttfprintf(stderr, _(""Weird value (%ld) in do_read""), got);tgot /= block_size;tif (d_flag && got == try) {#ifdef HAVE_NANOSLEEPttstruct timespec ts;ttts.tv_sec = tv2.tv_sec - tv1.tv_sec;ttts.tv_nsec = (tv2.tv_usec - tv1.tv_usec) * MILISEC;ttif (ts.tv_nsec < 0) {tttts.tv_nsec += NANOSEC;tttts.tv_sec -= 1;tt}tt ttts.tv_sec = ts.tv_sec * d_flag / 100;ttts.tv_nsec = ts.tv_nsec * d_flag / 100;ttif (ts.tv_nsec > NANOSEC) {tttts.tv_sec += ts.tv_nsec / NANOSEC;tttts.tv_nsec %= NANOSEC;tt}ttif (ts.tv_sec || ts.tv_nsec)tttnanosleep(&ts, NULL);#else#ifdef HAVE_USLEEPttstruct timeval tv;tttv.tv_sec = tv2.tv_sec - tv1.tv_sec;tttv.tv_usec = tv2.tv_usec - tv1.tv_usec;tttv.tv_sec = tv.tv_sec * d_flag / 100;tttv.tv_usec = tv.tv_usec * d_flag / 100;ttif (tv.tv_usec > 1000000) {ttttv.tv_sec += tv.tv_usec / 1000000;ttttv.tv_usec %= 1000000;tt}ttif (tv.tv_sec)tttsleep(tv.tv_sec);ttif (tv.tv_usec)tttusleep(tv.tv_usec);#endif#endift}treturn got;}",2,"cwe120,cweother"
"on_spell_treeview_row_activated(GtkTreeView       *treeview,                                     GtkTreePath       *path,                                     GtkTreeViewColumn *column,                                     gpointer           user_data){    int tag;    char command[MAX_BUF];    const char *options=NULL;    GtkTreeIter iter;    GtkTreeModel *model;    model = gtk_tree_view_get_model(treeview);    if (gtk_tree_model_get_iter(model, &iter, path)) {        gtk_tree_model_get(model, &iter, LIST_TAG, &tag, -1);        if (!tag) {            LOG(LOG_ERROR, ""spells.c::on_spell_cast_clicked"",                ""Unable to get spell tag"");            return;        }        snprintf(command, MAX_BUF-1, ""cast %d %s"", tag, options);        send_command(command, -1, 1);    }}",2,"cwe119,cwe120"
"send_probe(int ifindex, __u32 addr){tstruct ifreq ifr;tstruct sockaddr_in dst;tsocklen_t len;tunsigned char buf[256];tstruct arphdr *ah = (struct arphdr*)buf;tunsigned char *p = (unsigned char *)(ah+1);tstruct sockaddr_ll sll;tmemset(&ifr, 0, sizeof(ifr));tifr.ifr_ifindex = ifindex;tif (ioctl(udp_sock, SIOCGIFNAME, &ifr))ttreturn -1;tif (ioctl(udp_sock, SIOCGIFHWADDR, &ifr))ttreturn -1;tif (ifr.ifr_hwaddr.sa_family != ARPHRD_ETHER)ttreturn -1;tif (setsockopt(udp_sock, SOL_SOCKET, SO_BINDTODEVICE, ifr.ifr_name, strlen(ifr.ifr_name)+1) < 0)ttreturn -1;tdst.sin_family = AF_INET;tdst.sin_port = htons(1025);tdst.sin_addr.s_addr = addr;tif (connect(udp_sock, (struct sockaddr*)&dst, sizeof(dst)) < 0)ttreturn -1;tlen = sizeof(dst);tif (getsockname(udp_sock, (struct sockaddr*)&dst, &len) < 0)ttreturn -1;tah->ar_hrd = htons(ifr.ifr_hwaddr.sa_family);tah->ar_pro = htons(ETH_P_IP);tah->ar_hln = 6;tah->ar_pln = 4;tah->ar_op  = htons(ARPOP_REQUEST);tmemcpy(p, ifr.ifr_hwaddr.sa_data, ah->ar_hln);tp += ah->ar_hln;tmemcpy(p, &dst.sin_addr, 4);tp+=4;tsll.sll_family = AF_PACKET;tmemset(sll.sll_addr, 0xFF, sizeof(sll.sll_addr));tsll.sll_ifindex = ifindex;tsll.sll_protocol = htons(ETH_P_ARP);tmemcpy(p, &sll.sll_addr, ah->ar_hln);tp+=ah->ar_hln;tmemcpy(p, &addr, 4);tp+=4;tif (sendto(pset[0].fd, buf, p-buf, 0, (struct sockaddr*)&sll, sizeof(sll)) < 0)ttreturn -1;tstats.probes_sent++;treturn 0;}",2,"cwe119,cwe120"
"OTF_Reader_open( const char* namestub, OTF_FileManager* manager ) {tOTF_Reader* ret;tint read;tret = (OTF_Reader*) malloc( sizeof( OTF_Reader ) );tif( NULL == ret ) {tttOTF_Error( ""ERROR in function %s, file: %s, line: %i: ""tttt""no memory left."",tttt__FUNCTION__, __FILE__, __LINE__ );ttreturn NULL;t}tOTF_Reader_init( ret );tret->namestub = OTF_stripFilename( namestub );tif( NULL == manager ) {tttOTF_Error( ""ERROR in function %s, file: %s, line: %i: ""tttt""manager has not been specified."",tttt__FUNCTION__, __FILE__, __LINE__ );ttOTF_Reader_finish(ret);ttfree( ret );ttret= NULL;ttreturn NULL;t}tret->manager=manager;tret->mc= OTF_MasterControl_new( manager );tif( NULL == ret->mc ) {tttOTF_Error( ""ERROR in function %s, file: %s, line: %i: ""tttt""OTF_MasterControl_new() failed."",tttt__FUNCTION__, __FILE__, __LINE__ );ttOTF_Reader_finish(ret);ttfree( ret );ttret= NULL;ttreturn NULL;t}tttread= OTF_MasterControl_read( ret->mc, ret->namestub );tif( 0 == read ) {tttOTF_Error( ""ERROR in function %s, file: %s, line: %i: ""tttt""OTF_MasterControl_read() failed."",tttt__FUNCTION__, __FILE__, __LINE__ );ttOTF_Reader_finish(ret);ttfree( ret );ttret= NULL;ttreturn NULL;t}tret->processList= (OTF_ProcessList*) malloc( sizeof(OTF_ProcessList) );tif( NULL == ret->processList ) {tttOTF_Error( ""ERROR in function %s, file: %s, line: %i: ""tttt""no memory left."",tttt__FUNCTION__, __FILE__, __LINE__ );ttOTF_Reader_finish(ret);ttfree( ret );ttret= NULL;ttttreturn NULL;t}tret->processList->status = NULL;tret->processList->processes = NULL;ttif( 0 == OTF_ProcessList_init( ret->processList, ret->mc ) ) {tttOTF_Error( ""ERROR in function %s, file: %s, line: %i: ""tttt""OTF_ProcessList_init() failed."",tttt__FUNCTION__, __FILE__, __LINE__ );ttttOTF_Reader_finish(ret);ttfree( ret );ttret= NULL;tttreturn NULL;t}treturn ret;}",2,"cwe120,cweother"
"_razf_read(RAZF* rz, void *data, size_t size){tint ret, tin;tif(rz->z_eof || rz->z_err) return 0;tif (rz->file_type == FILE_TYPE_PLAIN) {ttssize_t fileret;#ifdef _USE_KNETFILEttfileret = knet_read(rz->x.fpr, data, size);#elsettfileret = read(rz->filedes, data, size);#endif        ttif (fileret == 0) rz->z_eof = 1;ttreturn fileret;t}trz->stream->avail_out = size;trz->stream->next_out  = (Bytef*) data;twhile(rz->stream->avail_out){ttif(rz->stream->avail_in == 0){tttif(rz->in >= rz->end){ rz->z_eof = 1; break; }tttif(rz->end - rz->in < RZ_BUFFER_SIZE){#ifdef _USE_KNETFILEttttrz->stream->avail_in = knet_read(rz->x.fpr, rz->inbuf, rz->end -rz->in);#elsettttrz->stream->avail_in = read(rz->filedes, rz->inbuf, rz->end -rz->in);#endif        ttt} else {#ifdef _USE_KNETFILEttttrz->stream->avail_in = knet_read(rz->x.fpr, rz->inbuf, RZ_BUFFER_SIZE);#elsettttrz->stream->avail_in = read(rz->filedes, rz->inbuf, RZ_BUFFER_SIZE);#endif        ttt}tttif(rz->stream->avail_in == 0){ttttrz->z_eof = 1;ttttbreak;ttt}tttrz->stream->next_in = (Bytef*)rz->inbuf;tt}tttin = rz->stream->avail_in;ttret = inflate(rz->stream, Z_BLOCK);ttrz->in += tin - rz->stream->avail_in;ttif(ret == Z_NEED_DICT || ret == Z_MEM_ERROR || ret == Z_DATA_ERROR){tttfprintf(stderr, ""[_razf_read] inflate error: %d %s (at %s:%d)"", ret, rz->stream->msg ? rz->stream->msg : """", __FILE__, __LINE__);tttrz->z_err = 1;tttbreak;tt}ttif(ret == Z_STREAM_END){tttrz->z_eof = 1;tttbreak;tt}ttif ((rz->stream->data_type&128) && !(rz->stream->data_type&64)){tttrz->buf_flush = 1;tttrz->next_block_pos = rz->in;tttbreak;tt}t}treturn size - rz->stream->avail_out;}",2,"cwe120,cweother"
"gui_clear_theme(void){  theme_free(theme);  if (!load_theme(gui_sdl_default_theme_name)) {         log_fatal(_(""No gui-sdl theme was found. For instructions on how to ""                ""get one, please visit %s""), WIKI_URL);    exit(EXIT_FAILURE);  }}",2,"cwe119,cwe120"
"writequeuef(struct qitem *it){tint error;tint queuefd;tqueuefd = open_locked(it->queuefn, O_CREAT|O_EXCL|O_RDWR, 0660);tif (queuefd == -1)ttreturn (-1);tif (fchmod(queuefd, 0660) < 0)ttreturn (-1);tit->queuef = fdopen(queuefd, ""w+"");tif (it->queuef == NULL)ttreturn (-1);terror = fprintf(it->queuef,ttt""ID: %s""ttt""Sender: %s""ttt""Recipient: %s"",ttt it->queueid,ttt it->sender,ttt it->addr);tif (error <= 0)ttreturn (-1);tif (fflush(it->queuef) != 0 || fsync(fileno(it->queuef)) != 0)ttreturn (-1);treturn (0);}",3,"cwe119,cwe120,cweother"
"_extFromU(UConverter *cnv, const UConverterSharedData *sharedData,          UChar32 cp,          const UChar **source, const UChar *sourceLimit,          uint8_t **target, const uint8_t *targetLimit,          int32_t **offsets, int32_t sourceIndex,          UBool flush,          UErrorCode *pErrorCode) {    const int32_t *cx;    cnv->useSubChar1=FALSE;    if( (cx=sharedData->mbcs.extIndexes)!=NULL &&        ucnv_extInitialMatchFromU(            cnv, cx,            cp, source, sourceLimit,            (char **)target, (char *)targetLimit,            offsets, sourceIndex,            flush,            pErrorCode)    ) {        return 0;      }         if((cnv->options&_MBCS_OPTION_GB18030)!=0) {        const uint32_t *range;        int32_t i;        range=gb18030Ranges[0];        for(i=0; i<sizeof(gb18030Ranges)/sizeof(gb18030Ranges[0]); range+=4, ++i) {            if(range[0]<=(uint32_t)cp && (uint32_t)cp<=range[1]) {                                 uint32_t linear;                char bytes[4];                                 linear=range[2]-LINEAR_18030_BASE;                                 linear+=((uint32_t)cp-range[0]);                                 bytes[3]=(char)(0x30+linear%10); linear/=10;                bytes[2]=(char)(0x81+linear%126); linear/=126;                bytes[1]=(char)(0x30+linear%10); linear/=10;                bytes[0]=(char)(0x81+linear);                                 ucnv_fromUWriteBytes(cnv,                                     bytes, 4, (char **)target, (char *)targetLimit,                                     offsets, sourceIndex, pErrorCode);                return 0;            }        }    }         *pErrorCode=U_INVALID_CHAR_FOUND;    return cp;}",3,"cwe119,cwe120,cweother"
"add_file(DOS_FS * fs, DOS_FILE *** chain, DOS_FILE * parent,tt     loff_t offset, FDSC ** cp){    DOS_FILE *new;    DIR_ENT de;    FD_TYPE type;    if (offset)tfs_read(offset, sizeof(DIR_ENT), &de);    else {t tmemcpy(de.name, ""           "", MSDOS_NAME);tde.attr = ATTR_DIR;tde.size = de.time = de.date = 0;tde.start = CT_LE_W(fs->root_cluster & 0xffff);tde.starthi = CT_LE_W((fs->root_cluster >> 16) & 0xffff);    }    if ((type = file_type(cp, (char *)de.name)) != fdt_none) {tif (type == fdt_undelete && (de.attr & ATTR_DIR))t    die(""Can't undelete directories."");tfile_modify(cp, (char *)de.name);tfs_write(offset, 1, &de);    }    if (IS_FREE(de.name)) {tlfn_check_orphaned();treturn;    }    if (de.attr == VFAT_LN_ATTR) {tlfn_add_slot(&de, offset);treturn;    }    new = qalloc(&mem_queue, sizeof(DOS_FILE));    new->lfn = lfn_get(&de, &new->lfn_offset);    new->offset = offset;    memcpy(&new->dir_ent, &de, sizeof(de));    new->next = new->first = NULL;    new->parent = parent;    if (type == fdt_undelete)tundelete(fs, new);    **chain = new;    *chain = &new->next;    if (list) {tprintf(""Checking file %s"", path_name(new));tif (new->lfn)t    printf("" (%s)"", file_name(new->dir_ent.name));t tprintf("""");    }         if (offset &&tstrncmp((const char *)de.name, MSDOS_DOT, MSDOS_NAME) != 0 &&tstrncmp((const char *)de.name, MSDOS_DOTDOT, MSDOS_NAME) != 0)t++n_files;    test_file(fs, new, test);t }",2,"cwe120,cweother"
"folder_lister_addmanually(SCROLL_S *sparms){    int        rc, flags = OE_APPEND_CURRENT, cnt = 0, rv = 0;    char       addname[MAXFOLDER+1];    HelpType   help;    CONTEXT_S *cntxt = (sparms->text.handles)ttt ? sparms->text.handles->h.f.contextttt : FPROC(sparms)->fs->context;         addname[0] = '0';    help = NO_HELP;    while(1){trc = optionally_enter(addname, -FOOTER_ROWS(ps_global), 0,ttt      sizeof(addname), _(""Name of new folder : ""),ttt      NULL, help, &flags);tremoving_leading_and_trailing_white_space(addname);tif(rc == 3)t  help = (help == NO_HELP) ? h_save_addman : NO_HELP;telse if(rc == 1)t  return(rv);telse if(rc == 0){t    if(F_OFF(F_ENABLE_DOT_FOLDERS,ps_global) && *addname == '.'){ttif(cnt++ <= 0)                  q_status_message(SM_ORDER,3,3,tt    _(""Folder name can't begin with dot""));ttelsett  q_status_message1(SM_ORDER,3,3,tt   _(""Config feature ""%s"" enables names beginning with dot""),tt   pretty_feature_name(feature_list_name(F_ENABLE_DOT_FOLDERS), -1));                display_message(NO_OP_COMMAND);                continue;t    }t    else if(!strucmp(addname, ps_global->inbox_name)){ttq_status_message1(SM_ORDER, 3, 3,tttt  _(""Can't add folder named %s""),tttt  ps_global->inbox_name);ttcontinue;t    }t    break;t}    }    if(*addname){tFPROC(sparms)->fs->context = cntxt;tFPROC(sparms)->rv = new_strlist(NULL);tFPROC(sparms)->rv->name = folder_lister_fullname(FPROC(sparms)->fs,ttttttt addname);tFPROC(sparms)->done = rv = 1;    }    return(rv);}",2,"cwe119,cwe120"
"pes_to_ts2( int fdin, int fdout, uint16_t pida, uint16_t pidv){tp2p p;tint count = 1;tuint8_t buf[SIZE];tuint64_t length = 0;tuint64_t l = 0;tint verb = 0;ttinit_p2p(&p, NULL, 2048);tp.fd1 = fdout;tp.pida = pida;tp.pidv = pidv;tp.acounter = 0;tp.vcounter = 0;tp.count1 = 0;tp.count0 = 0;tp.func = write_out;tttif (fdin != STDIN_FILENO) verb = 1; tif (verb) {ttlength = lseek(fdin, 0, SEEK_END);ttlseek(fdin,0,SEEK_SET);t}twhile (count > 0){ttcount = read(fdin,buf,SIZE);ttl += count;ttif (verb)tttfprintf(stderr,""Writing TS  %2.2f %%r"",tttt100.*l/length);ttget_pes(buf,count,&p,pes_in_ts);t}tt}",2,"cwe120,cweother"
"dostandard(flames_frame *ScienceFrame,            orderpos *Order,            allflats *Shifted_FF,            frame_mask **mask,            double ***pfibrecentre,            double phalfwinsize,            int32_t realfirstorder,            int32_t reallastorder){  int32_t ordsta=0, ordend=0;  char output[100];  int actvals=0;  char drs_verbosity[10];  int status=0;  memset(drs_verbosity, 0, 10);  if ((status=SCKGETC(DRS_VERBOSITY, 1, 3, &actvals, drs_verbosity))      != 0) {         return(MAREMMA);  }  for (ordsta=ordend=realfirstorder; ordsta<=reallastorder;        ordsta=++ordend) {              if (ordselect(Order, ScienceFrame, Shifted_FF, &ordend)!=NOERR) {      SCTPUT(""Error selecting an order subset to estract"");      return flames_midas_error(MAREMMA);    }         sprintf(output, ""Extracting orders from nr. %d to nr. %d...."",         ordsta, ordend);    SCTPUT(output);    memset(output, '0', 70);           if (standard(ScienceFrame, Shifted_FF, Order, ordsta, ordend,           mask, pfibrecentre, phalfwinsize)==NOERR) {    if ( strcmp(drs_verbosity,""LOW"") == 0 ){    } else {      sprintf(output,           ""Standard extraction for orders from nr. %d to %d completed"",          ordsta, ordend);      SCTPUT(output);     }      memset(output, 0, 70);    }    else {      sprintf(output, ""Error in standard extraction"");      SCTPUT(output);      return flames_midas_error(MAREMMA);    }  }  return NOERR;}",3,"cwe119,cwe120,cwe469"
"_elm_module_load(Elm_Module *m){   const char *home;   char buf[PATH_MAX];   if (m->module) return EINA_TRUE;   home = getenv(""HOME"");   if (home)     {        snprintf(buf, sizeof(buf), ""%s/""ELEMENTARY_BASE_DIR""/modules/%s/%s/module"" EFL_SHARED_EXTENSION, home, m->name, MODULE_ARCH);        m->module = eina_module_new(buf);        if (m->module && eina_module_load (m->module) == EINA_TRUE)          {             m->init_func = eina_module_symbol_get(m->module, ""elm_modapi_init"");             if (m->init_func)               {                  m->shutdown_func = eina_module_symbol_get(m->module, ""elm_modapi_shutdown"");                  m->so_path = eina_stringshare_add(buf);                  snprintf(buf, sizeof(buf), ""%s/""ELEMENTARY_BASE_DIR""/modules/%s/%s"", home, m->name, MODULE_ARCH);                  m->bin_dir = eina_stringshare_add(buf);                  snprintf(buf, sizeof(buf), ""%s/""ELEMENTARY_BASE_DIR""/modules/%s"", home, m->name);                  m->data_dir = eina_stringshare_add(buf);               }             else               {                  if (m->module)                    {                       eina_module_unload(m->module);                       eina_module_free(m->module);                       m->module = NULL;                    }                  return EINA_FALSE;               }          }        else if (m->module)          {            eina_module_free(m->module);            m->module = NULL;          }     }   if (!m->module)     {        snprintf(buf, sizeof(buf), ""%s/elementary/modules/%s/%s/module"" EFL_SHARED_EXTENSION, _elm_lib_dir, m->name, MODULE_ARCH);        m->module = eina_module_new(buf);        if (m->module && eina_module_load (m->module) == EINA_TRUE)          {             m->init_func = eina_module_symbol_get(m->module, ""elm_modapi_init"");             if (m->init_func)               {                  m->shutdown_func = eina_module_symbol_get(m->module, ""elm_modapi_shutdown"");                  m->so_path = eina_stringshare_add(buf);                  snprintf(buf, sizeof(buf), ""%s/elementary/modules/%s/%s"", _elm_lib_dir, m->name, MODULE_ARCH);                  m->bin_dir = eina_stringshare_add(buf);                  snprintf(buf, sizeof(buf), ""%s/elementary/modules/%s"", _elm_lib_dir, m->name);                  m->data_dir = eina_stringshare_add(buf);               }             else               {                  if (m->module)                    {                       eina_module_unload(m->module);                       eina_module_free(m->module);                       m->module = NULL;                    }                  return EINA_FALSE;               }          }     }   else if (m->module)     {       eina_module_free(m->module);       m->module = NULL;     }   if (!m->module) return EINA_FALSE;   return EINA_TRUE;}",3,"cwe119,cwe120,cweother"
"""dispatch_arc4stir(arc4ctx_t *actx) {tint i;tunion {ttunsigned char rnd[128];ttisc_uint32_t rnd32[32];t} rnd;tisc_result_t result;tif (actx->entropy != NULL) {tt/*tt * We accept any quality of random data to avoid blocking.tt */ttresult = isc_entropy_getdata(actx->entropy, rnd.rnd,ttttt     sizeof(rnd), NULL, 0);ttRUNTIME_CHECK(result == ISC_R_SUCCESS);t} else {ttfor (i = 0; i < 32; i++)tttisc_random_get(&rnd.rnd32[i]);t}tdispatch_arc4addrandom(actx, rnd.rnd, sizeof(rnd.rnd));t/*t * Discard early keystream, as per recommendations in:t * http://www.wisdom.weizmann.ac.il/~itsik/RC4/Papers/Rc4_ksa.pst */tfor (i = 0; i < 256; i++)tt(void)dispatch_arc4get8(actx);t/*t * Derived from OpenBSD's implementation.  The rationale is not clear,t * but should be conservative enough in safety, and reasonably larget * for efficiency.t */tactx->count = 1600000;}""",2,"cwe119,cwe120"
"parse_next(FILE *fd, struct blkid_config *conf){tchar buf[BUFSIZ];tchar *s;t tdo {ttif (fgets (buf, sizeof(buf), fd) == NULL)tttreturn feof(fd) ? 0 : -1;tts = strchr (buf, '');ttif (!s) {ttt ttt tttif (feof(fd))tttts = strchr (buf, '0');tttelse {ttttDBG(CONFIG, ul_debug(ttttt""config file: missing newline at line '%s'."",tttttbuf));ttttreturn -1;ttt}tt}tt*s = '0';ttif (--s >= buf && *s == 'r')ttt*s = '0';tts = buf;ttwhile (*s == ' ' || *s == 't')tt ttts++;t} while (*s == '0' || *s == '#');tif (!strncmp(s, ""SEND_UEVENT="", 12)) {tts += 13;ttif (*s && !strcasecmp(s, ""yes""))tttconf->uevent = TRUE;ttelse if (*s)tttconf->uevent = FALSE;t} else if (!strncmp(s, ""CACHE_FILE="", 11)) {tts += 11;ttif (*s)tttconf->cachefile = strdup(s);t} else if (!strncmp(s, ""EVALUATE="", 9)) {tts += 9;ttif (*s && parse_evaluate(conf, s) == -1)tttreturn -1;t} else {ttDBG(CONFIG, ul_debug(ttt""config file: unknown option '%s'."", s));ttreturn -1;t}treturn 0;}",3,"cwe119,cwe120,cweother"
"AT_DeletePhonebook(gn_data *data, struct gn_statemachine *state){tat_driver_instance *drvinst = AT_DRVINST(state);tint len;tchar req[64];tgn_error ret;tif (!data->phonebook_entry)ttreturn GN_ERR_INTERNALERROR;tret = at_memory_type_set(data->phonebook_entry->memory_type, state);tif (ret)ttreturn ret;tlen = snprintf(req, sizeof(req), ""AT+CPBW=%dr"", data->phonebook_entry->location+drvinst->memoryoffset);tif (sm_message_send(len, GN_OP_DeletePhonebook, req, state))ttreturn GN_ERR_NOTREADY;treturn sm_block_no_retry(GN_OP_DeletePhonebook, data, state);}",2,"cwe119,cwe120"
"chapms2_verify_response(int id, char *name,tttunsigned char *secret, int secret_len,tttunsigned char *challenge, unsigned char *response,tttchar *message, int message_space){tunsigned char md[MS_CHAP2_RESPONSE_LEN];tchar saresponse[MS_AUTH_RESPONSE_LENGTH+1];tint challenge_len, response_len;tchallenge_len = *challenge++;t tresponse_len = *response++;tif (response_len != MS_CHAP2_RESPONSE_LEN)ttgoto bad;t t tChapMS2(challenge, &response[MS_CHAP2_PEER_CHALLENGE], name,tt(char *)secret, secret_len, md,tt(unsigned char *)saresponse, MS_CHAP2_AUTHENTICATOR);t t tif (memcmp(&md[MS_CHAP2_NTRESP], &response[MS_CHAP2_NTRESP],tt   MS_CHAP2_NTRESP_LEN) == 0) {ttif (response[MS_CHAP2_FLAGS])tttslprintf(message, message_space, ""S=%s"", saresponse);ttelsetttslprintf(message, message_space, ""S=%s M=%s"",tttt saresponse, ""Access granted"");ttreturn 1;t} bad:t tslprintf(message, message_space, ""E=691 R=1 C=%0.*B V=0 M=%s"",tt challenge_len, challenge, ""Access denied"");treturn 0;}",2,"cwe119,cwe120"
"gt_timer_show_progress_va(GtTimer *t, FILE *fp, const char *desc,                               va_list ap){  char buf[BUFSIZ];  struct timeval elapsed_tv, elapsed_user_tv, elapsed_sys_tv;  gt_assert(t && desc);  gettimeofday(&t->stop_tv, NULL);  gt_xgetrusage(RUSAGE_SELF, &t->stop_ru);  timeval_subtract(&elapsed_tv, &t->stop_tv, &t->start_tv);  timeval_subtract(&elapsed_user_tv, &t->stop_ru.ru_utime,    &t->start_ru.ru_utime);  timeval_subtract(&elapsed_sys_tv, &t->stop_ru.ru_stime,    &t->start_ru.ru_stime);  gt_timer_print_progress_report(t, &elapsed_tv, &elapsed_user_tv,    &elapsed_sys_tv, t->statedesc, fp);  if (t->statedesc)    gt_free(t->statedesc);  (void) vsnprintf(buf, BUFSIZ, desc, ap);  t->statedesc = gt_cstr_dup(buf);  gettimeofday(&t->start_tv, NULL);  gt_xgetrusage(RUSAGE_SELF, &t->start_ru);}",3,"cwe119,cwe120,cweother"
"atch_job_submit_condor(struct batch_queue *q, const char *cmd, const char *args, const char *infile, const char *outfile, const char *errfile, const char *extra_input_files, const char *extra_output_files){tFILE *file;tint njobs;tint jobid;tfile = fopen(""condor.submit"", ""w"");tif(!file) {ttdebug(D_BATCH, ""could not create condor.submit: %s"", strerror(errno));ttreturn -1;t}tfprintf(file, ""universe = vanilla"");tfprintf(file, ""executable = %s"", cmd);tfprintf(file, ""getenv = true"");tif(args)ttfprintf(file, ""arguments = %s"", args);tif(infile)ttfprintf(file, ""input = %s"", infile);tif(outfile)ttfprintf(file, ""output = %s"", outfile);tif(errfile)ttfprintf(file, ""error = %s"", errfile);tif(extra_input_files)ttfprintf(file, ""transfer_input_files = %s"", extra_input_files);t t tfprintf(file, ""should_transfer_files = yes"");tfprintf(file, ""when_to_transfer_output = on_exit"");tfprintf(file, ""notification = never"");tfprintf(file, ""copy_to_spool = true"");tfprintf(file, ""transfer_executable = true"");tfprintf(file, ""log = %s"", q->logfile);tif(q->options_text)ttfprintf(file, ""%s"", q->options_text);tfprintf(file, ""queue"");tfclose(file);tfile = popen(""condor_submit condor.submit"", ""r"");tif(!file)ttreturn -1;tchar line[BATCH_JOB_LINE_MAX];twhile(fgets(line, sizeof(line), file)) {ttif(sscanf(line, ""%d job(s) submitted to cluster %d"", &njobs, &jobid) == 2) {tttpclose(file);tttdebug(D_BATCH, ""job %d submitted to condor"", jobid);tttstruct batch_job_info *info;tttinfo = malloc(sizeof(*info));tttmemset(info, 0, sizeof(*info));tttinfo->submitted = time(0);tttitable_insert(q->job_table, jobid, info);tttreturn jobid;tt}t}tpclose(file);tdebug(D_BATCH, ""failed to submit job to condor!"");treturn -1;}",3,"cwe119,cwe120,cweother"
"read_sbn_header(route_head *track){  char header[QRY_INFORMATION_LEN];  size_t len;  int type = 0;  len = read_packet(&type, header, sizeof(header));  if (len == 0 || type != PID_QRY_INFORMATION ||      !locosys_decode_file_id(header, len)) {    fatal(MYNAME "": Format error: Couldn't read SBN header.""          ""This probably isn't a SBN file."");  }}",2,"cwe119,cwe120"
"uip_neighbor_add(struct uip_stack *ustack,tt      struct in6_addr *addr6, struct uip_eth_addr *addr){tint i, oldest;tu8_t oldest_time;tchar buf[INET6_ADDRSTRLEN];tinet_ntop(AF_INET6, addr6, buf, sizeof(buf));tpthread_mutex_lock(&ustack->lock);t toldest_time = 0;toldest = 0;tfor (i = 0; i < UIP_NEIGHBOR_ENTRIES; ++i) {ttif (ustack->neighbor_entries[i].time == MAX_TIME) {tttoldest = i;tttbreak;tt}ttif (uip_ip6addr_cmptt    (ustack->neighbor_entries[i].ipaddr.s6_addr, addr6)) {tttoldest = i;tttbreak;tt}ttif (ustack->neighbor_entries[i].time > oldest_time) {tttoldest = i;tttoldest_time = ustack->neighbor_entries[i].time;tt}t}t tustack->neighbor_entries[oldest].time = 0;tuip_ip6addr_copy(ustack->neighbor_entries[oldest].ipaddr.s6_addr,ttt addr6);tmemcpy(&ustack->neighbor_entries[oldest].mac_addr, addr,t       sizeof(struct uip_eth_addr));tLOG_DEBUG(""Adding neighbor %s with ""tt  ""mac address %02x:%02x:%02x:%02x:%02x:%02x at %d"",tt  buf, addr->addr[0], addr->addr[1], addr->addr[2],tt  addr->addr[3], addr->addr[4], addr->addr[5], oldest);tpthread_mutex_unlock(&ustack->lock);}",2,"cwe119,cwe120"
"xml_parse_version(struct playlist* pl, ezxml_t xml, ...){    va_list ap;    ezxml_t r;    va_start(ap, xml);    r = ezxml_vget(xml, ap);    va_end(ap);    if (r) {        char ver[64];        strncpy(ver, r->txt, sizeof ver);        ver[sizeof ver-1] = 0;        int collab;        if (sscanf(ver, ""%u,%u,%u,%u"", &pl->revision, &pl->num_tracks,                    &pl->checksum, &collab) != 4) {            DSFYDEBUG(""!!! List version parsing failed (%s)"", ver);        }        pl->is_collaborative = collab;    }}",2,"cwe119,cwe120"
"Csec_server_lookup_protocols(struct sockaddr *client_address,                                 socklen_t alen,tttt Csec_protocol **protocols,tttt int *nbprotocols) {  const char *p;  char *q, *tokctx;  char *buf;  int entry = 0;  Csec_protocol *prots;  char *func = ""Csec_server_lookup_protocols"";     if (client_address == NULL)    p = ""(no address specified)"";  else    p = Cgetnetaddress(-1, client_address, alen, &na_key, NULL, NULL, NI_NUMERICHOST, 0);  Csec_trace(func, ""Looking for allowed security protocols for [%s]"", (p) ? p : ""unknown"");t          if (!((p = Cthread_getenv (CSEC_AUTH_MECH))t|| (p = (char *)getconfent (CSEC_CONF_SECTION, CSEC_CONF_ENTRY_AUTHMECH, 0)))) {    p = CSEC_DEFAULT_MECHS;    serrno = 0;  }  buf = (char *)malloc(strlen(p)+1);  if (NULL == buf) {    serrno = ENOMEM;    Csec_errmsg(func, ""Error allocating buffer of size %d"",ttstrlen(p)+1);    return -1;  }     strcpy(buf, p);  q = strtok_r(buf, "" t"", &tokctx);  while (q  != NULL) {    if (strlen(q) > 0) entry++;    q = strtok_r(NULL, "" t"", &tokctx);  }     prots = (Csec_protocol *)malloc(entry * sizeof(Csec_protocol));  if (NULL == prots) {    serrno = ENOMEM;    Csec_errmsg(func, ""Error allocating buffer of size %d"",ttentry * sizeof(Csec_protocol));    free(buf);    return -1;  }       entry = 0;  strcpy(buf, p);  q = strtok_r(buf, "" t"", &tokctx);  while (q != NULL) {    if (strlen(q) > 0) {      if (_is_proto_compat_with_addr(q, client_address)) {        strncpy(prots[entry].id, q, CA_MAXCSECPROTOLEN);        entry++;      }      q = strtok_r(NULL, "" t"", &tokctx);    }  }  *nbprotocols = entry;  free(buf);  *protocols = prots;  return 0;}",3,"cwe120,cwe476,cweother"
"gf_rdma_listen (rpc_transport_t *this){        union gf_sock_union  sock_union   = {{0, }, };        socklen_t            sockaddr_len = 0;        gf_rdma_private_t   *priv         = NULL;        int                  opt          = 1, ret = 0;        char                 service[NI_MAXSERV], host[NI_MAXHOST];        priv = this->private;        memset (&sock_union, 0, sizeof (sock_union));        ret = gf_rdma_server_get_local_sockaddr (this,                                                 &sock_union.sa,                                                 &sockaddr_len);        if (ret != 0) {                gf_log (this->name, GF_LOG_DEBUG,                        ""cannot find network address of server to bind to"");                goto err;        }        priv->sock = socket (sock_union.sa.sa_family, SOCK_STREAM, 0);        if (priv->sock == -1) {                gf_log (""rdma/server"", GF_LOG_CRITICAL,                        ""init: failed to create socket, error: %s"",                        strerror (errno));                GF_FREE (this->private);                ret = -1;                goto err;        }        memcpy (&this->myinfo.sockaddr, &sock_union.storage, sockaddr_len);        this->myinfo.sockaddr_len = sockaddr_len;        ret = getnameinfo ((struct sockaddr *)&this->myinfo.sockaddr,                           this->myinfo.sockaddr_len,                           host, sizeof (host),                           service, sizeof (service),                           NI_NUMERICHOST);        if (ret != 0) {                gf_log (this->name, GF_LOG_ERROR,                        ""getnameinfo failed (%s)"", gai_strerror (ret));                goto err;        }        sprintf (this->myinfo.identifier, ""%s:%s"", host, service);        setsockopt (priv->sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof (opt));        if (bind (priv->sock, &sock_union.sa, sockaddr_len) != 0) {                ret = -1;                gf_log (""rdma/server"", GF_LOG_ERROR,                        ""init: failed to bind to socket for %s (%s)"",                        this->myinfo.identifier, strerror (errno));                goto err;        }        if (listen (priv->sock, 10) != 0) {                gf_log (""rdma/server"", GF_LOG_ERROR,                        ""init: listen () failed on socket for %s (%s)"",                        this->myinfo.identifier, strerror (errno));                ret = -1;                goto err;        }                 priv->idx = event_register (this->ctx->event_pool, priv->sock,                                    gf_rdma_server_event_handler,                                    rpc_transport_ref (this), 1, 0);err:        return ret;}",2,"cwe119,cwe120"
"timeperiod(time_t period){  int hours, minutes, seconds;  static char timeper[41];  memset(timeper, 0, 41);  hours = period/3600;  minutes = (period/60)%60;  seconds = period%60;  if (hours) {    sprintf(timeper, ""%d:%02d:%02d"", hours, minutes, seconds);  }  else {    sprintf(timeper, ""%d:%02d"", minutes, seconds);  }  return timeper;}",2,"cwe119,cwe120"
"establish_proxy_connection(int fd, char *host, int port,tttt      char *proxy_user, char *proxy_pass){tchar *cp, buffer[1024];tchar *authhdr, authbuf[1024];tint len;tif (proxy_user && proxy_pass) {ttstringjoin(buffer, sizeof buffer,ttt proxy_user, "":"", proxy_pass, NULL);ttlen = strlen(buffer);ttif ((len*8 + 5) / 6 >= (int)sizeof authbuf - 3) {tttrprintf(FERROR,tttt""authentication information is too long"");tttreturn -1;tt}ttbase64_encode(buffer, len, authbuf, 1);ttauthhdr = ""rProxy-Authorization: Basic "";t} else {tt*authbuf = '0';ttauthhdr = """";t}tsnprintf(buffer, sizeof buffer, ""CONNECT %s:%d HTTP/1.0%s%srr"",tt host, port, authhdr, authbuf);tlen = strlen(buffer);tif (write(fd, buffer, len) != len) {ttrsyserr(FERROR, errno, ""failed to write to proxy"");ttreturn -1;t}tfor (cp = buffer; cp < &buffer[sizeof buffer - 1]; cp++) {ttif (read(fd, cp, 1) != 1) {tttrsyserr(FERROR, errno, ""failed to read from proxy"");tttreturn -1;tt}ttif (*cp == '')tttbreak;t}tif (*cp != '')ttcp++;t*cp-- = '0';tif (*cp == 'r')tt*cp = '0';tif (strncmp(buffer, ""HTTP/"", 5) != 0) {ttrprintf(FERROR, ""bad response from proxy -- %s"",tttbuffer);ttreturn -1;t}tfor (cp = &buffer[5]; isDigit(cp) || *cp == '.'; cp++) {}twhile (*cp == ' ')ttcp++;tif (*cp != '2') {ttrprintf(FERROR, ""bad response from proxy -- %s"",tttbuffer);ttreturn -1;t}t twhile (1) {ttfor (cp = buffer; cp < &buffer[sizeof buffer - 1]; cp++) {tttif (read(fd, cp, 1) != 1) {ttttrsyserr(FERROR, errno,ttttt""failed to read from proxy"");ttttreturn -1;ttt}tttif (*cp == '')ttttbreak;tt}ttif (cp > buffer && *cp == '')tttcp--;ttif (cp == buffer && (*cp == '' || *cp == 'r'))tttbreak;t}treturn 0;}",3,"cwe119,cwe120,cweother"
"MXHeloOK(char const *sockname,t char *msg,t char const *ip,t char const *name,t char const *helo,t unsigned int port,t char const *myip,t unsigned int daemon_port){    char cmd[SMALLBUF];    char ans[SMALLBUF];    char port_string[65];    char daemon_port_string[65];    snprintf(port_string, sizeof(port_string), ""%u"", port);    snprintf(daemon_port_string, sizeof(daemon_port_string), ""%u"", daemon_port);    *msg = 0;    if (!ip || !*ip) {tip = ""UNKNOWN"";    }    if (!name || !*name) {tname = ip;    }    if (!helo) {thelo = ""UNKNOWN"";    }    if (!myip || !*myip) {tmyip = ""UNKNOWN"";    }    if (percent_encode_command(1, cmd, sizeof(cmd), ""helook"", ip, name, helo, port_string, myip, daemon_port_string, NULL) < 0) {treturn MD_TEMPFAIL;    }    if (MXCommand(sockname, cmd, ans, SMALLBUF-1) < 0) return MD_TEMPFAIL;    return munch_mx_return(ans, msg);}",2,"cwe119,cwe120"
"main(){tint len;tttt tchar line[MAXLINE];tt twhile ((len = getline2(line, MAXLINE)) > 0)ttif (len > 80) {tttprintf(""%s"", line);tt}treturn 0;}",2,"cwe119,cwe120"
"put_truth_table(int exoid, int varid, int *table, const char *label){  int  iresult = 0;  char errmsg[MAX_ERR_LENGTH];    iresult = nc_put_var_int(exoid, varid, table);      if (iresult != NC_NOERR) {    exerrval = iresult;    sprintf(errmsg,            ""Error: failed to store %s variable truth table in file id %d"",            label, exoid);    ex_err(""ex_put_all_var_param_ext"",errmsg,exerrval);   }  return iresult;}",2,"cwe119,cwe120"
"AlterDatabaseOwner(const char *dbname, Oid newOwnerId){tHeapTuplettuple;tRelationtrel;tScanKeyData scankey;tSysScanDesc scan;tForm_pg_database datForm;t trel = heap_open(DatabaseRelationId, RowExclusiveLock);tScanKeyInit(&scankey,ttttAnum_pg_database_datname,ttttBTEqualStrategyNumber, F_NAMEEQ,ttttNameGetDatum(dbname));tscan = systable_beginscan(rel, DatabaseNameIndexId, true,ttttttt  SnapshotNow, 1, &scankey);ttuple = systable_getnext(scan);tif (!HeapTupleIsValid(tuple))ttereport(ERROR,tttt(errcode(ERRCODE_UNDEFINED_DATABASE),tttt errmsg(""database ""%s"" does not exist"", dbname)));tdatForm = (Form_pg_database) GETSTRUCT(tuple);t tif (datForm->datdba != newOwnerId)t{ttDatumttrepl_val[Natts_pg_database];ttboolttrepl_null[Natts_pg_database];ttboolttrepl_repl[Natts_pg_database];ttAcltt   *newAcl;ttDatumttaclDatum;ttboolttisNull;ttHeapTupletnewtuple;tt ttif (!pg_database_ownercheck(HeapTupleGetOid(tuple), GetUserId()))tttaclcheck_error(ACLCHECK_NOT_OWNER, ACL_KIND_DATABASE,tttttt   dbname);tt ttcheck_is_member_of_role(GetUserId(), newOwnerId);tt ttif (!have_createdb_privilege())tttereport(ERROR,ttttt(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),tttt   errmsg(""permission denied to change owner of database"")));ttmemset(repl_null, false, sizeof(repl_null));ttmemset(repl_repl, false, sizeof(repl_repl));ttrepl_repl[Anum_pg_database_datdba - 1] = true;ttrepl_val[Anum_pg_database_datdba - 1] = ObjectIdGetDatum(newOwnerId);tt ttaclDatum = heap_getattr(tuple,ttttttttAnum_pg_database_datacl,ttttttttRelationGetDescr(rel),tttttttt&isNull);ttif (!isNull)tt{tttnewAcl = aclnewowner(DatumGetAclP(aclDatum),tttttttt datForm->datdba, newOwnerId);tttrepl_repl[Anum_pg_database_datacl - 1] = true;tttrepl_val[Anum_pg_database_datacl - 1] = PointerGetDatum(newAcl);tt}ttnewtuple = heap_modify_tuple(tuple, RelationGetDescr(rel), repl_val, repl_null, repl_repl);ttsimple_heap_update(rel, &newtuple->t_self, newtuple);ttCatalogUpdateIndexes(rel, newtuple);ttheap_freetuple(newtuple);tt ttchangeDependencyOnOwner(DatabaseRelationId, HeapTupleGetOid(tuple),ttttttttnewOwnerId);t}tsystable_endscan(scan);t theap_close(rel, NoLock);}",2,"cwe476,cweother"
"parse_opts(int argc, char **argv){tstatic struct option longopts[] = {tt{""help"", 0, NULL, 'h'},tt{""foreground"", 0, NULL, 'f'},tt{""verbose"", 0, NULL, 'v'},tt{""user"", 2, NULL, 'U'},tt{""udev"", 0, NULL, 'u'},tt{""exit"", 0, NULL, 'x'},tt{""force-exit"", 0, NULL, 'X'},tt{NULL, 0, NULL, 0}t};tint c;twhile (1) {ttc = getopt_long(argc, argv, ""hfvuU::xX"", longopts, (int *) 0);ttif (c == -1) {tttbreak;tt}ttswitch (c) {ttcase 'h':tttusage();tttexit(0);ttcase 'f':tttforeground = 1;tttbreak;ttcase 'v':ttt++verbose;tttbreak;ttcase 'U':tttdrop_privileges = 1;tttif(optarg)ttttdrop_user = optarg;tttbreak;ttcase 'u':tttopt_udev = 1;tttbreak;ttcase 'x':tttopt_exit = 1;tttexit_signal = SIGUSR1;tttbreak;ttcase 'X':tttopt_exit = 1;tttexit_signal = SIGTERM;tttbreak;ttdefault:tttusage();tttexit(2);tt}t}}",2,"cwe120,cweother"
"xml_read(void){  int len;  char buf[MY_CBUF];  while ((len = gbfread(buf, 1, sizeof(buf), ifd))) {    char *str = buf;    if (ifd->unicode) {      str = cet_str_uni_to_utf8((short *)&buf, len >> 1);      len = strlen(str);    }    if (!XML_Parse(psr, str, len, gbfeof(ifd))) {      fatal(MYNAME "":Parse error at %d: %s"",            (int) XML_GetCurrentLineNumber(psr),            XML_ErrorString(XML_GetErrorCode(psr)));    }    if (str != buf) {      xfree(str);    }  }  XML_ParserFree(psr);}",2,"cwe119,cwe120"
"queue_file_write(const char *filename){tstruct direntry *cur;t tAST_LIST_TRAVERSE_SAFE_BEGIN(&openlist, cur, list) {ttif (!strcmp(cur->name, filename)) {tttAST_LIST_REMOVE_CURRENT(list);tttast_free(cur);tttqueue_file(filename, 0);tttbreak;tt}t}tAST_LIST_TRAVERSE_SAFE_END}",3,"cwe119,cwe120,cweother"
"do_nfs4_super_data_conv(void *raw_data){tint version = *(compat_uint_t *) raw_data;tif (version == 1) {ttstruct compat_nfs4_mount_data_v1 *raw = raw_data;ttstruct nfs4_mount_data *real = raw_data;tt ttreal->auth_flavours = compat_ptr(raw->auth_flavours);ttreal->auth_flavourlen = raw->auth_flavourlen;ttreal->proto = raw->proto;ttreal->host_addr = compat_ptr(raw->host_addr);ttreal->host_addrlen = raw->host_addrlen;ttcompat_nfs_string(&real->hostname, &raw->hostname);ttcompat_nfs_string(&real->mnt_path, &raw->mnt_path);ttcompat_nfs_string(&real->client_addr, &raw->client_addr);ttreal->acdirmax = raw->acdirmax;ttreal->acdirmin = raw->acdirmin;ttreal->acregmax = raw->acregmax;ttreal->acregmin = raw->acregmin;ttreal->retrans = raw->retrans;ttreal->timeo = raw->timeo;ttreal->wsize = raw->wsize;ttreal->rsize = raw->rsize;ttreal->flags = raw->flags;ttreal->version = raw->version;t}treturn 0;}",2,"cwe119,cwe120"
"""fskip_string (FILE *fp){  int ch;  while ((ch = fgetc (fp)) != EOF)    {      if (ch == '0')tbreak;    }}""",2,"cwe120,cweother"
"unpack6(char *packet, int sz,   int hoplimit){tstruct icmp6_hdr *icmppkt;tchar buf[INET6_ADDRSTRLEN];t tif (sz < (datalen + sizeof(struct icmp6_hdr)))ttreturn;ticmppkt = (struct icmp6_hdr *) packet;tif (icmppkt->icmp6_id != myid)ttreturn;tttt tif (icmppkt->icmp6_type == ICMP6_ECHO_REPLY) {ttuint16_t recv_seq = ntohs(icmppkt->icmp6_seq);ttuint32_t *tp = NULL;ttif (sz >= sizeof(struct icmp6_hdr) + sizeof(uint32_t))ttttp = (uint32_t *) &icmppkt->icmp6_data8[4];ttunpack_tail(sz, tp,tttinet_ntop(AF_INET6, &pingaddr.sin6.sin6_addr,tttttbuf, sizeof(buf)),tttrecv_seq, hoplimit);t} else if (icmppkt->icmp6_type != ICMP6_ECHO_REQUEST) {ttbb_error_msg(""warning: got ICMP %d (%s)"",tttticmppkt->icmp6_type,tttticmp6_type_name(icmppkt->icmp6_type));t}}",2,"cwe119,cwe120"
"FlamePasteData(struct state *st,               unsigned char *d, int xx, int yy, int w, int h){  unsigned char *ptr1,*ptr2;  ptr2 = d;  if (xx < 0) xx = 0;  if (yy < 0) yy = 0;  if ((xx >= 0) &&      (yy >= 0) &&      (xx + w <= st->fwidth) &&      (yy + h <= st->fheight))    {      int x, y;      for (y = 0; y < h; y++)        {          ptr1 = st->flame + 1 + xx + ((yy + y) * (st->fwidth + 2));          for (x = 0; x < w; x++)            {              if (*ptr2 / 24)                *ptr1 += random() % (*ptr2 / 24);              ptr1++;              ptr2++;            }        }    }  else    {      static Bool warned = False;      if (!warned)        {          fprintf (stderr, ""%s: st->window is %dx%d; image must be ""                   ""smaller than %dx%d (not %dx%d)."",                   progname, st->width, st->height, st->fwidth, st->fheight, w, h);          warned = True;        }    }}",2,"cwe120,cweother"
"received(int bytes, isc_sockaddr_t *from, dig_query_t *query) {tisc_uint64_t diff;ttime_t tnow;tstruct tm tmnow;tchar time_str[100];tchar fromtext[ISC_SOCKADDR_FORMATSIZE];tisc_sockaddr_format(from, fromtext, sizeof(fromtext));tif (query->lookup->stats && !short_form) {ttdiff = isc_time_microdiff(&query->time_recv, &query->time_sent);ttif (use_usec)tttprintf("";; Query time: %ld usec"", (long) diff);ttelsetttprintf("";; Query time: %ld msec"", (long) diff / 1000);ttprintf("";; SERVER: %s(%s)"", fromtext, query->servname);tttime(&tnow);tttmnow  = *localtime(&tnow);ttif (strftime(time_str, sizeof(time_str),ttt     ""%a %b %d %H:%M:%S %Z %Y"", &tmnow) > 0U)tttprintf("";; WHEN: %s"", time_str);ttif (query->lookup->doing_xfr) {tttprintf("";; XFR size: %u records (messages %u, ""ttt       ""bytes %"" ISC_PRINT_QUADFORMAT ""u)"",ttt       query->rr_count, query->msg_count,ttt       query->byte_count);tt} else {tttprintf("";; MSG SIZE  rcvd: %u"", bytes);tt}ttif (key != NULL) {tttif (!validated)ttttputs("";; WARNING -- Some TSIG could not ""tttt     ""be validated"");tt}ttif ((key == NULL) && (keysecret[0] != 0)) {tttputs("";; WARNING -- TSIG key was not used."");tt}ttputs("""");t} else if (query->lookup->identify && !short_form) {ttdiff = isc_time_microdiff(&query->time_recv, &query->time_sent);ttif (use_usec)tttprintf("";; Received %"" ISC_PRINT_QUADFORMAT ""u bytes ""ttt       ""from %s(%s) in %ld us"",ttt       query->lookup->doing_xfrtttt ? query->byte_counttttt : (isc_uint64_t)bytes,ttt       fromtext, query->userarg, (long) diff);ttelsetttprintf("";; Received %"" ISC_PRINT_QUADFORMAT ""u bytes ""ttt       ""from %s(%s) in %ld ms"",ttt       query->lookup->doing_xfrtttt ?  query->byte_counttttt : (isc_uint64_t)bytes,ttt       fromtext, query->userarg, (long) diff / 1000);t}}",2,"cwe119,cwe120"
"syck_parser_read( SyckParser *p ){    long len = 0;    long skip = 0;    ASSERT( p != NULL );    switch ( p->io_type )    {        case syck_io_str:            skip = syck_move_tokens( p );            len = (p->io.str->read)( p->buffer, p->io.str, SYCK_BUFFERSIZE - 1, skip );            break;        case syck_io_file:            skip = syck_move_tokens( p );            len = (p->io.file->read)( p->buffer, p->io.file, SYCK_BUFFERSIZE - 1, skip );            break;    }    syck_check_limit( p, len );    return len;}",2,"cwe120,cweother"
